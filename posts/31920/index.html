<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"evestorm.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="JS 类型string，number，boolean，undefined，null，symbol，object 值类型和引用类型的区别两种类型的区别是：存储位置不同；  值类型存储在栈（stack）中，占空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用类型存储在堆（heap）中,占据空间大、大小不固定。如果存在栈中，影响程序运行性能；引用类型在栈中存储了指针，该指针指向堆中该实体的起">
<meta property="og:type" content="article">
<meta property="og:title" content="JS知识点（面试系列）">
<meta property="og:url" content="https://evestorm.github.io/posts/31920/index.html">
<meta property="og:site_name" content="EVE | 暴风雨前夕">
<meta property="og:description" content="JS 类型string，number，boolean，undefined，null，symbol，object 值类型和引用类型的区别两种类型的区别是：存储位置不同；  值类型存储在栈（stack）中，占空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用类型存储在堆（heap）中,占据空间大、大小不固定。如果存在栈中，影响程序运行性能；引用类型在栈中存储了指针，该指针指向堆中该实体的起">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://evestorm.github.io/posts/31920/1549856966458-39b2f008-64fc-4753-936b-e513a5de46d2.png">
<meta property="og:image" content="https://evestorm.github.io/posts/31920/%E8%99%9A%E6%8B%9Fdom1.webp">
<meta property="og:image" content="https://evestorm.github.io/posts/31920/%E8%99%9A%E6%8B%9Fdom2.webp">
<meta property="og:image" content="https://evestorm.github.io/posts/31920/%E8%99%9A%E6%8B%9Fdom3.webp">
<meta property="og:image" content="https://evestorm.github.io/posts/31920/1549791418436-78a38fa1-d824-45c0-8caa-7a6314637140.png">
<meta property="og:image" content="https://evestorm.github.io/posts/31920/1549711479179-356c282c-60db-41ea-82df-5ebfb9550785.png">
<meta property="og:image" content="https://evestorm.github.io/posts/31920/1549711526339-9b043225-9ad9-4f88-b1b5-95da79cc4bf8.png">
<meta property="og:image" content="https://evestorm.github.io/posts/31920/1550160415749-0297296f-0559-485f-bfe4-05859bdc757a.jpeg">
<meta property="og:image" content="https://evestorm.github.io/posts/31920/JS%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%EF%BC%89/bVWhRl.png">
<meta property="article:published_time" content="2019-06-09T15:15:17.000Z">
<meta property="article:modified_time" content="2020-12-15T15:55:53.584Z">
<meta property="article:author" content="Lance">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://evestorm.github.io/posts/31920/1549856966458-39b2f008-64fc-4753-936b-e513a5de46d2.png">


<link rel="canonical" href="https://evestorm.github.io/posts/31920/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>JS知识点（面试系列） | EVE | 暴风雨前夕</title>
  


  <script>
    !function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.growingio.com/2.1/gio.js","gio");
    gio('init', 'cc683d67407a283ba8d0382c43e8ca28', {});
    gio('send');
  </script>

  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">EVE | 暴风雨前夕</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Lance的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JS-%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">JS 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.</span> <span class="nav-text">值类型和引用类型的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS-%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B"><span class="nav-number">1.2.</span> <span class="nav-text">JS 的类型检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.</span> <span class="nav-text">&#x3D;&#x3D;&#x3D; 和 &#x3D;&#x3D; 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E9%9D%9E-boolean-%E5%80%BC%E8%A2%AB%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%80%E4%B8%AA-boolean-%E6%97%B6%EF%BC%8C%E5%AE%83%E6%98%AF-false-%EF%BC%9F"><span class="nav-number">1.4.</span> <span class="nav-text">哪些非 boolean 值被强制转换为一个 boolean 时，它是 false ？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null%EF%BC%8Cundefined-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.5.</span> <span class="nav-text">null，undefined 的区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM"><span class="nav-number">2.</span> <span class="nav-text">DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM-%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E6%80%8E%E6%A0%B7%E6%B7%BB%E5%8A%A0%E3%80%81%E7%A7%BB%E9%99%A4%E3%80%81%E7%A7%BB%E5%8A%A8%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM-%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.</span> <span class="nav-text">DOM 数操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#offsetWidth-offsetHeight%EF%BC%8CclientWidth-clientHeight-%E4%B8%8E-scrollWidth-scrollHeight-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.3.</span> <span class="nav-text">offsetWidth&#x2F;offsetHeight，clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Virtual-DOM%EF%BC%8C%E4%B8%BA%E4%BD%95%E8%A6%81%E7%94%A8-Virtual-DOM%EF%BC%9F"><span class="nav-number">2.4.</span> <span class="nav-text">什么是 Virtual DOM，为何要用 Virtual DOM？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">对象的原生方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-assign"><span class="nav-number">3.1.</span> <span class="nav-text">Object.assign()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-create"><span class="nav-number">3.2.</span> <span class="nav-text">Object.create()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-is"><span class="nav-number">3.3.</span> <span class="nav-text">Object.is()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-keys-Object-values"><span class="nav-number">3.4.</span> <span class="nav-text">Object.keys &#x2F; Object.values</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-entries"><span class="nav-number">3.5.</span> <span class="nav-text">Object.entries()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">4.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">数组的遍历方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ES5"><span class="nav-number">4.1.1.</span> <span class="nav-text">ES5</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6"><span class="nav-number">4.1.2.</span> <span class="nav-text">ES6</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for-in-%E5%92%8C-for-of-%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.3.</span> <span class="nav-text">for in 和 for of 区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS-%E6%95%B0%E7%BB%84%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">JS 数组有哪些方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%889-%E4%B8%AA%EF%BC%89"><span class="nav-number">4.2.1.</span> <span class="nav-text">改变原数组的方法（9 个）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#splice-%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">splice() 添加 &#x2F; 删除数组元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sort-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">sort() 数组排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pop-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%90%8E%E7%9A%84%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-number">4.2.1.3.</span> <span class="nav-text">pop() 删除一个数组中的最后的一个元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#shift-%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-number">4.2.1.4.</span> <span class="nav-text">shift() 删除数组的第一个元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#push-%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-number">4.2.1.5.</span> <span class="nav-text">push() 向数组的末尾添加元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unshift"><span class="nav-number">4.2.1.6.</span> <span class="nav-text">unshift()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reverse-%E9%A2%A0%E5%80%92%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">4.2.1.7.</span> <span class="nav-text">reverse() 颠倒数组中元素的顺序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%888-%E4%B8%AA%EF%BC%89"><span class="nav-number">4.2.2.</span> <span class="nav-text">不改变原数组的方法（8 个）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#slice-%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">slice() 浅拷贝数组的元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#join-%E6%95%B0%E7%BB%84%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">join() 数组转字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#toLocaleString-%E6%95%B0%E7%BB%84%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">toLocaleString() 数组转字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#concat-%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84"><span class="nav-number">4.2.2.4.</span> <span class="nav-text">concat 合并数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ES6-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84"><span class="nav-number">4.2.2.5.</span> <span class="nav-text">ES6 扩展运算符 ... 合并数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#indexOf-%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%8B%E6%A0%87"><span class="nav-number">4.2.2.6.</span> <span class="nav-text">indexOf() 查找数组是否存在某个元素，返回下标</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lastIndexOf-%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-number">4.2.2.7.</span> <span class="nav-text">lastIndexOf() 查找指定元素在数组中的最后一个位置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ES7-includes-%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0-%E8%BF%94%E5%9B%9E%E5%B8%83%E5%B0%94"><span class="nav-number">4.2.2.8.</span> <span class="nav-text">ES7 includes() 查找数组是否包含某个元素 返回布尔</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">字符串的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#charAt-%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E7%AC%A6"><span class="nav-number">5.1.1.</span> <span class="nav-text">charAt 返回字符串字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#substring-%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%90%E9%9B%86"><span class="nav-number">5.1.2.</span> <span class="nav-text">substring 返回字符串子集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#replace-%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.1.3.</span> <span class="nav-text">replace 替换字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#toLowerCase-toUpperCase-%E8%BD%AC%E6%8D%A2%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="nav-number">5.1.4.</span> <span class="nav-text">toLowerCase &#x2F; toUpperCase 转换字母大小写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#includes"><span class="nav-number">5.1.5.</span> <span class="nav-text">includes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#repeat"><span class="nav-number">5.1.6.</span> <span class="nav-text">repeat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#startsWith"><span class="nav-number">5.1.7.</span> <span class="nav-text">startsWith</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#endsWith"><span class="nav-number">5.1.8.</span> <span class="nav-text">endsWith</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-JavaScript-%E4%BD%9C%E7%94%A8%E9%93%BE%E5%9F%9F%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">什么是 JavaScript 作用链域？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">7.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85-%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">7.1.</span> <span class="nav-text">什么是闭包&#x2F;对闭包的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-number">7.2.</span> <span class="nav-text">闭包的用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85"><span class="nav-number">7.3.</span> <span class="nav-text">如何使用闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">7.4.</span> <span class="nav-text">闭包应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#li-%E8%8A%82%E7%82%B9%E7%9A%84-onclick-%E4%BA%8B%E4%BB%B6%E9%83%BD%E8%83%BD%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BC%B9%E5%87%BA%E5%BD%93%E5%89%8D%E8%A2%AB%E7%82%B9%E5%87%BB%E7%9A%84-li-%E7%B4%A2%E5%BC%95"><span class="nav-number">7.4.1.</span> <span class="nav-text">li 节点的 onclick 事件都能正确的弹出当前被点击的 li 索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E9%97%AD%E5%8C%85%E6%A8%A1%E6%8B%9F%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="nav-number">7.4.2.</span> <span class="nav-text">用闭包模拟私有方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3-%E5%BE%AA%E7%8E%AF-%E9%97%AD%E5%8C%85-%E9%97%AE%E9%A2%98"><span class="nav-number">7.5.</span> <span class="nav-text">解决 循环+闭包 问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this"><span class="nav-number">8.</span> <span class="nav-text">this</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9-this-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">8.1.</span> <span class="nav-text">对 this 的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E5%AE%9A-this"><span class="nav-number">8.2.</span> <span class="nav-text">判定 this</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#apply-call-bind-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.</span> <span class="nav-text">apply, call, bind 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">9.1.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-%E5%8E%9F%E5%9E%8B"><span class="nav-number">10.</span> <span class="nav-text">JavaScript 原型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B"><span class="nav-number">10.1.</span> <span class="nav-text">什么是原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">10.2.</span> <span class="nav-text">作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">11.</span> <span class="nav-text">原型链</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">11.1.</span> <span class="nav-text">什么是原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%88%AB%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C-class-%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="nav-number">11.2.</span> <span class="nav-text">分别使用原型链和 class 的方式实现继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%93%BE-%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%89%E3%80%90%E4%B8%8D%E6%8E%A8%E8%8D%90%E3%80%91"><span class="nav-number">11.2.1.</span> <span class="nav-text">1. 组合继承（原型链 + 借用构造函数）【不推荐】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD-Student-prototype-Person-prototype"><span class="nav-number">11.2.1.1.</span> <span class="nav-text">为什么不能 Student.prototype &#x3D; Person.prototype</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E7%BA%AF%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7"><span class="nav-number">11.2.1.2.</span> <span class="nav-text">单纯的原型链继承有什么缺陷</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E7%BA%AF%E7%9A%84%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7"><span class="nav-number">11.2.1.3.</span> <span class="nav-text">单纯的借用构造函数继承有什么缺陷</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">11.2.1.4.</span> <span class="nav-text">组合继承的缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E3%80%90%E6%8E%A8%E8%8D%90%E3%80%91"><span class="nav-number">11.2.2.</span> <span class="nav-text">2. 寄生组合继承【推荐】</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-class-%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="nav-number">11.2.3.</span> <span class="nav-text">3. class 实现继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%8Cproto-%E5%92%8C-prototype-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">11.3.</span> <span class="nav-text">原型链，proto 和 prototype 的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number">12.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">12.1.</span> <span class="nav-text">创建对象的三种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">12.1.1.</span> <span class="nav-text">字面量的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">12.1.2.</span> <span class="nav-text">调用系统的构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">12.1.3.</span> <span class="nav-text">自定义构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="nav-number">12.1.4.</span> <span class="nav-text">new 操作符具体干了什么呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-new-%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%80%9A%E8%BF%87%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9B%E5%BB%BA%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">12.1.5.</span> <span class="nav-text">通过 new 的方式创建对象和通过字面量创建有什么区别？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">13.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%EF%BC%8CIE-%E4%B8%8E%E7%81%AB%E7%8B%90%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%EF%BC%9F"><span class="nav-number">13.1.</span> <span class="nav-text">什么是事件，IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="nav-number">13.2.</span> <span class="nav-text">事件流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-DOM-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="nav-number">13.3.</span> <span class="nav-text">什么是 DOM 事件模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">13.4.</span> <span class="nav-text">事件绑定的三种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM2-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="nav-number">13.5.</span> <span class="nav-text">DOM2 事件传播机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">13.6.</span> <span class="nav-text">事件的执行顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E7%BB%99%E4%B8%80%E4%B8%AA-dom-%E5%90%8C%E6%97%B6%E7%BB%91%E5%AE%9A%E4%B8%A4%E4%B8%AA%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%EF%BC%8C%E4%B8%80%E4%B8%AA%E7%94%A8%E6%8D%95%E8%8E%B7%EF%BC%8C%E4%B8%80%E4%B8%AA%E7%94%A8%E5%86%92%E6%B3%A1%E3%80%82%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%87%A0%E6%AC%A1%E4%BA%8B%E4%BB%B6%EF%BC%8C%E4%BC%9A%E5%85%88%E6%89%A7%E8%A1%8C%E5%86%92%E6%B3%A1%E8%BF%98%E6%98%AF%E6%8D%95%E8%8E%B7%EF%BC%9F"><span class="nav-number">13.6.1.</span> <span class="nav-text">我们给一个 dom 同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="nav-number">13.7.</span> <span class="nav-text">事件委托</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="nav-number">13.7.1.</span> <span class="nav-text">实现一个事件委托</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%BB%A5%E4%B8%8B%E6%A6%82%E5%BF%B5%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%E3%80%81%E9%98%BB%E6%AD%A2%E4%BC%A0%E6%92%AD%E3%80%81%E5%8F%96%E6%B6%88%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6%E3%80%81%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="nav-number">13.8.</span> <span class="nav-text">解释以下概念：事件传播机制、阻止传播、取消默认事件、事件代理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96"><span class="nav-number">13.9.</span> <span class="nav-text">什么是节流和防抖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">13.9.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96%E4%BD%9C%E7%94%A8"><span class="nav-number">13.9.2.</span> <span class="nav-text">节流防抖作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mouseover-%E5%92%8C-mouseenter-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">13.10.</span> <span class="nav-text">mouseover 和 mouseenter 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#window-onload-%E5%92%8C-document-onDOMContentLoaded-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">13.11.</span> <span class="nav-text">window.onload 和 document.onDOMContentLoaded 有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-%E7%9B%B8%E5%85%B3"><span class="nav-number">14.</span> <span class="nav-text">ES6 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6-%E7%94%A8%E5%88%B0%E8%BF%87%E5%90%97%EF%BC%8C%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E4%B8%9C%E8%A5%BF%EF%BC%8C%E4%BD%A0%E7%94%A8%E5%88%B0%E8%BF%87%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">14.1.</span> <span class="nav-text">ES6 用到过吗，新增了哪些东西，你用到过什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E5%92%8C-let-%E5%8C%BA%E5%88%AB"><span class="nav-number">14.2.</span> <span class="nav-text">const 和 let 区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">14.2.1.</span> <span class="nav-text">共同点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#let-var-%E5%8C%BA%E5%88%AB"><span class="nav-number">14.2.2.</span> <span class="nav-text">let var 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98-const-%E5%AE%9A%E4%B9%89%E7%9A%84%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%97"><span class="nav-number">14.2.3.</span> <span class="nav-text">可以改变 const 定义的某个对象的属性吗</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%EF%BC%88-this-%E6%8C%87%E5%90%91%EF%BC%89"><span class="nav-number">14.3.</span> <span class="nav-text">箭头函数（ this 指向）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">14.3.1.</span> <span class="nav-text">箭头函数与普通函数的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-%E5%92%8C-Map"><span class="nav-number">14.4.</span> <span class="nav-text">Set 和 Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">14.4.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="nav-number">14.4.2.</span> <span class="nav-text">相同点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%B3%95"><span class="nav-number">14.4.3.</span> <span class="nav-text">用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise"><span class="nav-number">14.5.</span> <span class="nav-text">Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#promise-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">14.5.1.</span> <span class="nav-text">promise 是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%9E%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">14.5.2.</span> <span class="nav-text">诞生的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#promise-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">14.5.3.</span> <span class="nav-text">promise 使用场景有哪些</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">14.5.4.</span> <span class="nav-text">三种状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">14.5.5.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">14.5.6.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#promise-%E7%89%B9%E6%80%A7"><span class="nav-number">14.5.7.</span> <span class="nav-text">promise 特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#promise-%E9%87%8C%E9%9D%A2-return-%E4%B8%80%E4%B8%AA-string%EF%BC%8C%E5%92%8C%E5%9C%A8-resolve-%E4%B8%80%E4%B8%AA-string-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">14.5.8.</span> <span class="nav-text">promise 里面 return 一个 string，和在 resolve 一个 string 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8-then-%E9%87%8C%E9%9D%A2-throw-%E4%B8%80%E4%B8%AA-error%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8D%95%E6%8D%89"><span class="nav-number">14.5.9.</span> <span class="nav-text">在 then 里面 throw 一个 error，怎么捕捉</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Promise-%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA-url"><span class="nav-number">14.5.10.</span> <span class="nav-text">使用 Promise 封装一个 url</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8-Promise-%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%AD%EF%BC%8C%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%8A%E4%B8%80%E4%B8%AA-promise-%E5%87%BA%E7%8E%B0%E6%8A%A5%E9%94%99%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%88%B0%E5%90%8E%E7%BB%AD-then-%E7%9A%84%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C"><span class="nav-number">14.5.11.</span> <span class="nav-text">在 Promise 链式调用中，怎样才能保证上一个 promise 出现报错不会影响到后续 .then 的正常执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%EF%BC%8C%E9%82%A3%E4%B9%88-then-%E6%96%B9%E6%B3%95%E5%91%A2%EF%BC%9F"><span class="nav-number">14.5.12.</span> <span class="nav-text">Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Async-Await"><span class="nav-number">14.6.</span> <span class="nav-text">Async &#x2F; Await</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">14.6.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Async"><span class="nav-number">14.6.2.</span> <span class="nav-text">Async</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Await"><span class="nav-number">14.6.3.</span> <span class="nav-text">Await</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF"><span class="nav-number">14.6.4.</span> <span class="nav-text">优势</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">14.7.</span> <span class="nav-text">解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%94%A8%E6%B3%95"><span class="nav-number">14.7.1.</span> <span class="nav-text">数组用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%94%A8%E6%B3%95"><span class="nav-number">14.7.2.</span> <span class="nav-text">对象用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%A6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">14.7.3.</span> <span class="nav-text">…运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84-rest%EF%BC%88%E5%89%A9%E4%BD%99%EF%BC%89%E5%8F%82%E6%95%B0"><span class="nav-number">14.8.</span> <span class="nav-text">函数中的 rest（剩余）参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E5%92%8C-arguments-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">14.8.1.</span> <span class="nav-text">剩余参数和 arguments 对象的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CommonJS-%E8%A7%84%E8%8C%83%EF%BC%88NodeJS%EF%BC%89"><span class="nav-number">14.8.2.</span> <span class="nav-text">CommonJS 规范（NodeJS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AMD-%E8%A7%84%E8%8C%83%EF%BC%88RequireJS%EF%BC%89"><span class="nav-number">14.8.3.</span> <span class="nav-text">AMD 规范（RequireJS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMD%EF%BC%88SeaJS%EF%BC%89"><span class="nav-number">14.8.4.</span> <span class="nav-text">CMD（SeaJS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6-%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">14.8.5.</span> <span class="nav-text">ES6 模块化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="nav-number">14.8.6.</span> <span class="nav-text">模块化开发怎么做？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5"><span class="nav-number">15.</span> <span class="nav-text">异步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Ajax"><span class="nav-number">15.1.</span> <span class="nav-text">Ajax</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Ajax-%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-Ajax%EF%BC%9F"><span class="nav-number">15.1.1.</span> <span class="nav-text">Ajax 是什么? 如何创建一个 Ajax？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ajax-%E5%8E%9F%E7%90%86"><span class="nav-number">15.1.2.</span> <span class="nav-text">Ajax 原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ajax-%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">15.1.3.</span> <span class="nav-text">Ajax 解决浏览器缓存问题？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="nav-number">15.2.</span> <span class="nav-text">什么是同源策略？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-number">15.3.</span> <span class="nav-text">如何解决跨域问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#jsonp"><span class="nav-number">15.3.1.</span> <span class="nav-text">jsonp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB"><span class="nav-number">15.3.2.</span> <span class="nav-text">CORS 跨域资源共享</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%90%86"><span class="nav-number">15.3.3.</span> <span class="nav-text">代理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON-%E5%92%8C-JSONP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">15.4.</span> <span class="nav-text">JSON 和 JSONP 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer-%E5%92%8C-async-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">15.5.</span> <span class="nav-text">defer 和 async 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#preload-%E5%92%8C-prefetch-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">15.6.</span> <span class="nav-text">preload 和 prefetch 的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setTimeout%E3%80%81setInterval%E3%80%81requestAnimationFrame-%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-number">15.7.</span> <span class="nav-text">setTimeout、setInterval、requestAnimationFrame 各有什么特点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setTimeout-%E5%80%92%E8%AE%A1%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%AF%AF%E5%B7%AE%EF%BC%9F"><span class="nav-number">15.8.</span> <span class="nav-text">setTimeout 倒计时为什么会出现误差？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A%E5%8D%95%E7%BA%BF%E7%A8%8B%E3%80%81%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="nav-number">15.9.</span> <span class="nav-text">简单解释单线程、任务队列的概念？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-number">16.</span> <span class="nav-text">其它</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON-%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">16.1.</span> <span class="nav-text">JSON 的了解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON-%E6%96%B9%E6%B3%95%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">16.1.1.</span> <span class="nav-text">JSON 方法的缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">17.</span> <span class="nav-text">概念性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">17.1.</span> <span class="nav-text">你理解的面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E5%8F%AB%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E5%92%8C%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%EF%BC%9F"><span class="nav-number">17.2.</span> <span class="nav-text">什么叫优雅降级和渐进增强？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#compose-%E5%87%BD%E6%95%B0-%E2%9D%8C"><span class="nav-number">17.3.</span> <span class="nav-text">compose 函数 ❌</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96-%E2%9D%8C"><span class="nav-number">17.4.</span> <span class="nav-text">函数柯里化 ❌</span></a></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lance"
      src="/uploads/avatar_lance.jpeg">
  <p class="site-author-name" itemprop="name">Lance</p>
  <div class="site-description" itemprop="description">Front-end developer and iOS developer</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">194</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/evestorm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;evestorm" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1572534835@qq.com" title="E-Mail → mailto:1572534835@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://evestorm.github.io/posts/31920/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar_lance.jpeg">
      <meta itemprop="name" content="Lance">
      <meta itemprop="description" content="Front-end developer and iOS developer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EVE | 暴风雨前夕">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JS知识点（面试系列）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-09 23:15:17" itemprop="dateCreated datePublished" datetime="2019-06-09T23:15:17+08:00">2019-06-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-15 23:55:53" itemprop="dateModified" datetime="2020-12-15T23:55:53+08:00">2020-12-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    
      <a title="changyan" href="/posts/31920/#SOHUCS" itemprop="discussionUrl">
        <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="posts/31920/" itemprop="commentCount"></span>
      </a>
    
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="JS-类型"><a href="#JS-类型" class="headerlink" title="JS 类型"></a>JS 类型</h2><p>string，number，boolean，undefined，null，symbol，object</p>
<h3 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h3><p>两种类型的区别是：存储位置不同；</p>
<ul>
<li>值类型存储在栈（stack）中，占空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>
<li>引用类型存储在堆（heap）中,占据空间大、大小不固定。如果存在栈中，影响程序运行性能；引用类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li>
</ul>
<img src="/posts/31920/1549856966458-39b2f008-64fc-4753-936b-e513a5de46d2.png" class="" title="js类型堆栈图">

<a id="more"></a>

<h3 id="JS-的类型检测"><a href="#JS-的类型检测" class="headerlink" title="JS 的类型检测"></a>JS 的类型检测</h3><ul>
<li><p>typeof （判断一个变量是什么类型）undefined object function boolean string number symbol</p>
</li>
<li><p>instanceof （判断当前对象是不是某个类型）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 要检测的对象 <span class="keyword">instanceof</span> 某个构造函数 --&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.make = make;</span><br><span class="line">    <span class="built_in">this</span>.model = model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> auto = <span class="keyword">new</span> Car(<span class="string">&#x27;Honda&#x27;</span>, <span class="string">&#x27;Accord&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(auto <span class="keyword">instanceof</span> Car);</span><br><span class="line"><span class="comment">// expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(auto <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="comment">// expected output: true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.prototype.toString.call()（检测一个对象的类型）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;Lance&#x27;</span>)); <span class="comment">//[object String]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="=== 和 == 的区别"></a>=== 和 == 的区别</h3><p><code>==</code> 在允许强制转换的条件下检查值的等价性，而 <code>===</code> 是在不允许强制转换的条件下检查值的等价性；</p>
<p>因此 <code>===</code> 常被称为「严格等价」。（”55” == 55 true, “55” === 55 false。p.s. 把字符串转为数值）</p>
<h3 id="哪些非-boolean-值被强制转换为一个-boolean-时，它是-false-？"><a href="#哪些非-boolean-值被强制转换为一个-boolean-时，它是-false-？" class="headerlink" title="哪些非 boolean 值被强制转换为一个 boolean 时，它是 false ？"></a>哪些非 boolean 值被强制转换为一个 boolean 时，它是 false ？</h3><ul>
<li><code>&quot;&quot;</code>（空字符串）</li>
<li><code>0</code>, <code>-0</code>, <code>NaN</code> （非法的 <code>number</code> ）</li>
<li><code>null</code>, <code>undefined</code></li>
</ul>
<h3 id="null，undefined-的区别？"><a href="#null，undefined-的区别？" class="headerlink" title="null，undefined 的区别？"></a>null，undefined 的区别？</h3><ul>
<li>null 表示一个对象是「没有值」的值，也就是值为 “空”；</li>
<li>undefined 表示一个变量声明了没有初始化(赋值)；</li>
<li>undefined 的类型（typeof）是 undefined ；</li>
<li>null 的类型（typeof）是 object ；</li>
<li>JavaScript 将未赋值的变量默认值设为 undefined；</li>
<li>JavaScript 从来不会将变量设为 null 。它是用来让程序员表明某个用 var 声明的变量时没有值的。</li>
</ul>
<p>在验证 null 时，一定要使用　=== ，因为 == 无法分别 null 和 undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">copy（1）创建新节点</span><br><span class="line">    createDocumentFragment()    &#x2F;&#x2F;创建一个DOM片段</span><br><span class="line">    createElement()   &#x2F;&#x2F;创建一个具体的元素</span><br><span class="line">    createTextNode()   &#x2F;&#x2F;创建一个文本节点</span><br><span class="line">（2）添加、移除、替换、插入</span><br><span class="line">    appendChild()</span><br><span class="line">    removeChild()</span><br><span class="line">    replaceChild()</span><br><span class="line">    insertBefore() &#x2F;&#x2F;在已有的子节点前插入一个新的子节点</span><br><span class="line">（3）查找</span><br><span class="line">    querySelector(&quot;ul&quot;) &#x2F; querySelectorAll(&quot;ul li&quot;) &#x2F;&#x2F; 查找单个元素 &#x2F; 多个元素</span><br><span class="line">    getElementsByTagName(&quot;div&quot;)</span><br><span class="line">    getElementsByClassName()</span><br><span class="line">    getElementById()</span><br></pre></td></tr></table></figure>

<h3 id="DOM-数操作"><a href="#DOM-数操作" class="headerlink" title="DOM 数操作"></a>DOM 数操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加新节点</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">p1.innerHTML = <span class="string">&#x27;this is p1&#x27;</span>;</span><br><span class="line">div1.appendChild(p1); <span class="comment">// 添加新创建的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动已有节点。注意，这里是“移动”，并不是拷贝</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p2&#x27;</span>);</span><br><span class="line">div1.appendChild(p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父元素</span></span><br><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> parent = div1.parentElement;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取子元素</span></span><br><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> child = div1.childNodes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> child = div1.childNodes;</span><br><span class="line">div1.removeChild(child[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="offsetWidth-offsetHeight，clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别"><a href="#offsetWidth-offsetHeight，clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别" class="headerlink" title="offsetWidth/offsetHeight，clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别"></a>offsetWidth/offsetHeight，clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别</h3><ul>
<li><strong>offsetWidth/offsetHeight</strong> 返回值包含 content + padding + border，效果与 e.getBoundingClientRect() 相同；</li>
<li><strong>clientWidth/clientHeight</strong> 返回值只包含 content + padding，如果有滚动条，也不包含滚动条；</li>
<li><strong>scrollWidth/scrollHeight</strong> 返回值包含 content + padding + 溢出内容的尺寸。</li>
</ul>
<h3 id="什么是-Virtual-DOM，为何要用-Virtual-DOM？"><a href="#什么是-Virtual-DOM，为何要用-Virtual-DOM？" class="headerlink" title="什么是 Virtual DOM，为何要用 Virtual DOM？"></a>什么是 Virtual DOM，为何要用 Virtual DOM？</h3><p>Virtual DOM 的概念有很多解释，分别是：一个对象，两个前提，三个步骤。</p>
<p><strong>一个对象</strong>指的是 Virtual DOM 是一个基本的 JavaScript 对象，也是整个 Virtual DOM 树的基本。</p>
<p><strong>两个前提</strong>分别是 JavaScript 很快和直接操作 DOM 很慢，这是 Virtual DOM 得以实现的两个基本前提。</p>
<p>得益于 V8 引擎的出现，让 JavaScript 可以高效地运行，在性能上有了极大的提高。</p>
<p>直接操作 DOM 的低效和 JavaScript 的高效相对比，为 Virtual DOM 的产生提供了大前提。</p>
<p><strong>三个步骤</strong>指的是 Virtual DOM 的三个重要步骤，分别是：生成 Virtual DOM 树、对比两棵树的差异、更新视图。</p>
<p>1.生成 Virtual DOM 树：</p>
<p>DOM 是前端工程师最常接触的内容之一，一个 DOM 节点包含了很多的内容，但是抽象出一个 DOM 节点却只需要三部分：<strong>节点类型，节点属性、子节点</strong>。所以围绕这三个部分，我们可以使用 JavaScript 简单地实现一棵 DOM 树，然后给节点实现渲染方法，就可以实现虚拟节点到真实 DOM 的转化。</p>
<img src="/posts/31920/%E8%99%9A%E6%8B%9Fdom1.webp" class="" title="虚拟dom1">

<p>2.对比两棵树的差异：</p>
<p>比较两棵 DOM 树的差异是 Virtual DOM 算法最核心的部分，这也是我们常说的的 Virtual DOM 的 diff 算法。在比较的过程中，我们只比较同级的节点，非同级的节点不在我们的比较范围内，这样既可以满足我们的需求，又可以简化算法实现。</p>
<img src="/posts/31920/%E8%99%9A%E6%8B%9Fdom2.webp" class="" title="虚拟dom2">

<p>比较“树”的差异，首先是要对树进行遍历，常用的有两种遍历算法，分别是深度优先遍历和广度优先遍历，一般的 diff 算法中都采用的是深度优先遍历。对新旧两棵树进行一次深度优先的遍历，这样每个节点都会有一个唯一的标记。在遍历的时候，每遍历到一个节点就把该节点和新的树的同一个位置的节点进行对比，如果有差异的话就记录到一个对象里面。</p>
<p>例如，上面的 div 和新的 div 有差异，当前的标记是 0，那么：patches[0] = [{difference}, {difference}, …]。同理 p 是 patches[1]，ul 是 patches[3]，以此类推。这样当遍历完整棵树的时候，就可以获得一个完整的差异对象。</p>
<img src="/posts/31920/%E8%99%9A%E6%8B%9Fdom3.webp" class="" title="虚拟dom3">

<p>在这个差异对象中记录了有改变的节点，每一个发生改变的内容也不尽相同，但也是有迹可循，常见的差异包括四种，分别是：</p>
<ul>
<li>替换节点</li>
<li>增加/删除子节点</li>
<li>修改节点属性</li>
<li>改变文本内容</li>
</ul>
<h2 id="对象的原生方法"><a href="#对象的原生方法" class="headerlink" title="对象的原生方法"></a>对象的原生方法</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>copy 对象的可枚举属性</p>
<blockquote>
<p>语法：Object.assign(target, …sources)</p>
<p>参数：目标对象, …源对象</p>
<p>返回值：目标对象</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>创建新对象</p>
<blockquote>
<p>语法：Object.create(proto, [ propertiesObject ])</p>
<p>参数：新创建对象的原型对象, 用于指定创建对象的一些属性，（eg：是否可读、是否可写，是否可以枚举 etc）</p>
</blockquote>
<h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>用来判断两个值是否是同一个值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="string">&#x27;haorooms&#x27;</span>, <span class="string">&#x27;haorooms&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="built_in">window</span>, <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is([], []); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.is(test, test); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特例</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">0</span>, -<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(-<span class="number">0</span>, -<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="number">0</span> / <span class="number">0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-keys-Object-values"><a href="#Object-keys-Object-values" class="headerlink" title="Object.keys / Object.values"></a>Object.keys / Object.values</h3><p>返回给定对象的自身可枚举属性 / 值 的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple array</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(arr)); <span class="comment">// console: [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// console: [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)); <span class="comment">// [&#x27;bar&#x27;, 42]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p><code>**Object.entries()**</code> 方法返回对象自身可枚举属性的键值对数组，其排列与使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in"><code>for...in</code></a> 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// [ [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, 42] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// iterate through key-value gracefully</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">5</span>, <span class="attr">b</span>: <span class="number">7</span>, <span class="attr">c</span>: <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的遍历方法"><a href="#数组的遍历方法" class="headerlink" title="数组的遍历方法"></a>数组的遍历方法</h3><ul>
<li><p>标准 for 循环</p>
</li>
<li><p>forEach((当前值, 当前索引,当前数组)=&gt;{})</p>
<ul>
<li>无法中途退出循环，只能用 <code>return</code> 退出本次回调，进行下一次回调。</li>
<li>它总是返回 undefined 值,即使你 return 了一个值。</li>
</ul>
</li>
<li><p>for-in（不推荐）会把继承链的对象属性都会遍历一遍，而且数组遍历不一定按次序</p>
<ul>
<li>for-in 循环返回的是所有能通过对象访问的、可枚举的属性。</li>
</ul>
</li>
<li><p>for (variable of iterable)（ES6）可迭代</p>
<p>Array</p>
<p>，</p>
<p>Map</p>
<p>，</p>
<p>Set</p>
<p>，</p>
<p>String</p>
<p>等（迭代的是值 value ）</p>
<ul>
<li>在 <code>for-of</code> 中如果遍历中途要退出，可以使用 <code>break</code> 退出循环。</li>
</ul>
</li>
</ul>
<h4 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h4><ul>
<li><p>map (不改变原数组) 会给原数组中的每个元素都按顺序调用一次 callback 函数</p>
</li>
<li><p>reduce (不改变原数组) 数组中的前项和后项做某种计算,并累计最终值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr.reduce(function(total, currentValue, currentIndex, arr), initialValue)</span></span><br><span class="line"><span class="comment">// callback 参数</span></span><br><span class="line"><span class="comment">// (累积器, 当前元素, 当前元素索引, 当前数组)</span></span><br><span class="line"><span class="comment">// initialValue:指定第一次回调 的第一个参数</span></span><br><span class="line"><span class="keyword">var</span> wallets = [<span class="number">4</span>, <span class="number">7.8</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> totalMoney = wallets.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">countedMoney, curMoney</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> countedMoney + curMoney;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>filter（不改变原数组）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> morearr = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number &gt; <span class="number">3</span>;</span><br><span class="line">&#125;); <span class="comment">// [4,5,6]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>every（不改变原数组）测试数组的所有元素是否都通过了指定函数的测试</p>
<ul>
<li><p>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</p>
</li>
<li><p>如果所有元素都满足条件，则返回 true 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> result = arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>some（不改变原数组）测试是否至少有一个元素通过 callback 中的条件.对于放在空数组上的任何条件，此方法返回 false 。</p>
<ul>
<li><p>如果有一个元素满足条件，则表达式返回 true , 剩余的元素不会再执行检测。</p>
</li>
<li><p>如果没有满足条件的元素，则返回 false 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some(callback, thisArg)</span></span><br><span class="line"><span class="comment">// callback:</span></span><br><span class="line"><span class="comment">//    (当前元素, 当前索引, 调用some的数组)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> result = arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">3</span>;</span><br><span class="line">&#125;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><ul>
<li><p>find() &amp; findIndex() 根据条件找到数组成员</p>
<ul>
<li><p>find() 定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回 undefined 。</p>
</li>
<li><p>findIndex() 定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 -1 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 语法 --&gt;</span><br><span class="line"><span class="keyword">let</span> new_array = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisArg</span>)</span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">new_array</span> = <span class="title">arr</span>.<span class="title">findIndex</span>(<span class="params"><span class="keyword">function</span>(currentValue, index, arr), thisArg</span>)</span></span><br><span class="line"><span class="function">&lt;!-- 这两个方法都可以识别<span class="title">NaN</span>,弥补了<span class="title">indexOf</span>的不足 --&gt;</span></span><br><span class="line"><span class="function">&lt;!-- <span class="title">find</span> --&gt;</span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">a</span> = [1, 4, -5, 10].<span class="title">find</span>(<span class="params">(n) =&gt; n &lt; <span class="number">0</span></span>)</span>;</span><br><span class="line">&lt;!-- 返回元素-<span class="number">5</span> --&gt;</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>,<span class="literal">NaN</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, n));</span><br><span class="line">&lt;!-- 返回元素<span class="literal">NaN</span> --&gt;</span><br><span class="line">&lt;!-- findIndex --&gt;</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].findIndex(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>);</span><br><span class="line">&lt;!-- 返回索引<span class="number">2</span> --&gt;</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>,<span class="literal">NaN</span>].findIndex(<span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, n));</span><br><span class="line">&lt;!-- 返回索引<span class="number">4</span> --&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>keys() &amp; values() &amp; entries() 遍历键名、遍历键值、遍历键名+键值</p>
<ul>
<li><p>三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">array.keys()   array.values()   array.entries()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="for-in-和-for-of-区别"><a href="#for-in-和-for-of-区别" class="headerlink" title="for in 和 for of 区别"></a>for in 和 for of 区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">iterable.foo = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;  <span class="xml">&lt;-- 循环的是索引</span></span><br><span class="line"><span class="xml">  console.log(i); // 打印 0, 1, 2, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">for (let i in iterable) &#123;</span></span><br><span class="line"><span class="xml">  if (iterable.hasOwnProperty(i)) &#123;</span></span><br><span class="line"><span class="xml">    console.log(i); // 打印 0, 1, 2, &quot;foo&quot;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line">for (let i of iterable) &#123;  &lt;-- 迭代的是值</span><br><span class="line">  console.log(i); // 打印 3, 5, 7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://juejin.im/post/5a3a59e7518825698e72376b">JavaScript 数组遍历方法的对比</a></p>
<h3 id="JS-数组有哪些方法"><a href="#JS-数组有哪些方法" class="headerlink" title="JS 数组有哪些方法"></a>JS 数组有哪些方法</h3><h4 id="改变原数组的方法（9-个）"><a href="#改变原数组的方法（9-个）" class="headerlink" title="改变原数组的方法（9 个）"></a>改变原数组的方法（9 个）</h4><h5 id="splice-添加-删除数组元素"><a href="#splice-添加-删除数组元素" class="headerlink" title="splice() 添加 / 删除数组元素"></a>splice() 添加 / 删除数组元素</h5><blockquote>
<p>splice() 方法<strong>向/从数组中添加/删除</strong>项目，然后返回被删除的项目</p>
<p>array.splice(index,howmany,item1,…..,itemX)</p>
<ol>
<li>index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</li>
<li>howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。</li>
<li>item1, …, itemX： 可选。向数组添加的新项目。</li>
</ol>
<p>返回值: 如果有元素被删除,返回包含被删除项目的新数组。</p>
</blockquote>
<p><strong>删除元素</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从数组下标0开始，删除3个元素</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7</span></span><br><span class="line"><span class="keyword">let</span> item = a.splice(-<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// [7]</span></span><br></pre></td></tr></table></figure>

<p><strong>删除并添加</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从数组下标0开始，删除3个元素，并添加元素&#x27;添加&#x27;</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&#x27;添加&#x27;</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [&#x27;添加&#x27;,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组最后第二个元素开始，删除3个元素，并添加两个元素&#x27;添加1&#x27;、&#x27;添加2&#x27;</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = b.splice(-<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;添加1&#x27;</span>, <span class="string">&#x27;添加2&#x27;</span>); <span class="comment">// [6,7]</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [1,2,3,4,5,&#x27;添加1&#x27;,&#x27;添加2&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>不删除只添加</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;添加1&#x27;</span>, <span class="string">&#x27;添加2&#x27;</span>); <span class="comment">// [] 没有删除元素，返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [&#x27;添加1&#x27;,&#x27;添加2&#x27;,1,2,3,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = b.splice(-<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;添加1&#x27;</span>, <span class="string">&#x27;添加2&#x27;</span>); <span class="comment">// [] 没有删除元素，返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [1,2,3,4,5,6,&#x27;添加1&#x27;,&#x27;添加2&#x27;,7] 在最后一个元素的前面添加两个元素</span></span><br></pre></td></tr></table></figure>

<h5 id="sort-数组排序"><a href="#sort-数组排序" class="headerlink" title="sort() 数组排序"></a>sort() 数组排序</h5><blockquote>
<p>定义: sort() 方法对数组元素进行排序，并返回这个数组。</p>
<p>参数可选: 规定排序顺序的比较函数。</p>
<p>默认情况下 sort() 方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用 <code>toString()</code> 方法将元素转化为字符串的 Unicode (万国码)位点，然后再比较字符。</p>
</blockquote>
<p><strong>不传参</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串排列 看起来很正常</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Mango&#x27;</span>];</span><br><span class="line">a.sort(); <span class="comment">// [&quot;Apple&quot;,&quot;Banana&quot;,&quot;Mango&quot;,&quot;Orange&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">8</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a.sort()); <span class="comment">// [1,10,20,25,3,8];</span></span><br></pre></td></tr></table></figure>

<p><em>比较函数的两个参数：</em></p>
<p>sort 的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：</p>
<ul>
<li>若比较函数返回值 &lt;0 ，那么 a 将排到 b 的前面;</li>
<li>若比较函数返回值 =0 ，那么 a 和 b 相对位置不变；</li>
<li>若比较函数返回值 &gt;0 ，那么 b 排在 a 将的前面；</li>
</ul>
<p><strong>数字升降序</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">4</span>, <span class="number">25</span>, <span class="number">8</span>];</span><br><span class="line">array.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [1,3,4,4,8,10,20,25];</span></span><br><span class="line"></span><br><span class="line">array.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b - a;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [25,20,10,8,4,4,3,1];</span></span><br></pre></td></tr></table></figure>

<h5 id="pop-删除一个数组中的最后的一个元素"><a href="#pop-删除一个数组中的最后的一个元素" class="headerlink" title="pop() 删除一个数组中的最后的一个元素"></a>pop() 删除一个数组中的最后的一个元素</h5><blockquote>
<p>定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.pop(); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure>

<h5 id="shift-删除数组的第一个元素"><a href="#shift-删除数组的第一个元素" class="headerlink" title="shift() 删除数组的第一个元素"></a>shift() 删除数组的第一个元素</h5><blockquote>
<p>定义: shift()方法删除数组的第一个元素，并返回这个元素。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.shift(); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [2,3]</span></span><br></pre></td></tr></table></figure>

<h5 id="push-向数组的末尾添加元素"><a href="#push-向数组的末尾添加元素" class="headerlink" title="push() 向数组的末尾添加元素"></a>push() 向数组的末尾添加元素</h5><blockquote>
<p>定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p>
<p>参数: item1, item2, …, itemX ,要添加到数组末尾的元素</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.push(<span class="string">&#x27;末尾&#x27;</span>, <span class="string">&#x27;233&#x27;</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [1,2,3,&#x27;末尾&#x27;, &#x27;233&#x27;]</span></span><br></pre></td></tr></table></figure>

<h5 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h5><blockquote>
<p>定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</p>
<p>参数: item1, item2, …, itemX ,要添加到数组开头的元素</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.unshift(<span class="string">&#x27;开头&#x27;</span>, <span class="string">&#x27;开头2&#x27;</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [ &#x27;开头&#x27;, &#x27;开头2&#x27;, 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<h5 id="reverse-颠倒数组中元素的顺序"><a href="#reverse-颠倒数组中元素的顺序" class="headerlink" title="reverse() 颠倒数组中元素的顺序"></a>reverse() 颠倒数组中元素的顺序</h5><blockquote>
<p>定义: reverse() 方法用于颠倒数组中元素的顺序。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [3,2,1]</span></span><br></pre></td></tr></table></figure>

<h4 id="不改变原数组的方法（8-个）"><a href="#不改变原数组的方法（8-个）" class="headerlink" title="不改变原数组的方法（8 个）"></a>不改变原数组的方法（8 个）</h4><h5 id="slice-浅拷贝数组的元素"><a href="#slice-浅拷贝数组的元素" class="headerlink" title="slice() 浅拷贝数组的元素"></a>slice() 浅拷贝数组的元素</h5><blockquote>
<p>定义： 方法返回一个从开始到结束（<strong>不包括结束</strong>）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。</p>
<p>语法：array.slice(begin, end);</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> b = a.slice(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// [&#x27;hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。</span></span><br><span class="line"><span class="comment">// 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&#x27;改变原数组&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// [&#x27;改变原数组&#x27;,&#x27;world&#x27;] [&#x27;hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [&#123; <span class="attr">name</span>: <span class="string">&#x27;OBKoro1&#x27;</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> b = a.slice();</span><br><span class="line"><span class="built_in">console</span>.log(b, a); <span class="comment">// [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;]  [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;]</span></span><br><span class="line"><span class="comment">// a[0].name=&#x27;改变原数组&#x27;</span></span><br><span class="line"><span class="comment">// console.log(b,a) // [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;] [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;]</span></span><br></pre></td></tr></table></figure>

<h5 id="join-数组转字符串"><a href="#join-数组转字符串" class="headerlink" title="join() 数组转字符串"></a>join() 数组转字符串</h5><blockquote>
<p>定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。</p>
<p>语法: array.join(str)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str = a.join(); <span class="comment">// &#x27;hello,world&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = a.join(<span class="string">&#x27;+&#x27;</span>); <span class="comment">// &#x27;hello+world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [[<span class="string">&#x27;OBKoro1&#x27;</span>, <span class="string">&#x27;23&#x27;</span>], <span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str1 = a.join(); <span class="comment">// OBKoro1,23,test</span></span><br><span class="line"><span class="keyword">let</span> b = [&#123; <span class="attr">name</span>: <span class="string">&#x27;OBKoro1&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;23&#x27;</span> &#125;, <span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str2 = b.join(); <span class="comment">// [object Object],test</span></span><br><span class="line"><span class="comment">// 对象转字符串推荐JSON.stringify(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结论：</span></span><br><span class="line"><span class="comment">// join()/toString() 方法在数组元素是数组的时候，会将里面的数组也调用 join()/toString() ,</span></span><br><span class="line"><span class="comment">// 如果是对象的话，对象会被转为 [object Object] 字符串。</span></span><br></pre></td></tr></table></figure>

<h5 id="toLocaleString-数组转字符串"><a href="#toLocaleString-数组转字符串" class="headerlink" title="toLocaleString() 数组转字符串"></a>toLocaleString() 数组转字符串</h5><blockquote>
<p>定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [&#123;</span><br><span class="line">    name: <span class="string">&#x27;OBKoro1&#x27;</span></span><br><span class="line">&#125;, <span class="number">23</span>, <span class="string">&#x27;abcd&#x27;</span>, <span class="keyword">new</span> <span class="built_in">Date</span>()]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.join(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(a.toString())</span><br><span class="line"><span class="built_in">console</span>.log(a.toLocaleString(<span class="string">&#x27;en-us&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(a.toLocaleString(<span class="string">&#x27;zh-cn&#x27;</span>))</span><br><span class="line"></span><br><span class="line">[object <span class="built_in">Object</span>],<span class="number">23</span>,abcd,Tue Feb <span class="number">26</span> <span class="number">2019</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span> GMT+<span class="number">0800</span> (中国标准时间)</span><br><span class="line">[object <span class="built_in">Object</span>],<span class="number">23</span>,abcd,Tue Feb <span class="number">26</span> <span class="number">2019</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span> GMT+<span class="number">0800</span> (中国标准时间)</span><br><span class="line">[object <span class="built_in">Object</span>],<span class="number">23</span>,abcd,<span class="number">2</span>/<span class="number">26</span>/<span class="number">2019</span>, <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span> AM</span><br><span class="line">[object <span class="built_in">Object</span>],<span class="number">23</span>,abcd,<span class="number">2019</span>/<span class="number">2</span>/<span class="number">26</span> 上午<span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span></span><br></pre></td></tr></table></figure>

<h5 id="concat-合并数组"><a href="#concat-合并数组" class="headerlink" title="concat 合并数组"></a>concat 合并数组</h5><blockquote>
<p>定义： 方法用于合并两个或多个数组，返回一个新数组。</p>
<p>语法：var newArr =oldArray.concat(arrayX,arrayX,……,arrayX)</p>
<p>参数：arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">//连接两个数组</span></span><br><span class="line"><span class="keyword">let</span> newVal = a.concat(b); <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment">// 连接三个数组</span></span><br><span class="line"><span class="keyword">let</span> c = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> newVal2 = a.concat(b, c); <span class="comment">// [1,2,3,4,5,6,7,8,9]</span></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="keyword">let</span> newVal3 = a.concat(<span class="string">&#x27;添加元素&#x27;</span>, b, c, <span class="string">&#x27;再加一个&#x27;</span>);</span><br><span class="line"><span class="comment">// [1,2,3,&quot;添加元素&quot;,4,5,6,7,8,9,&quot;再加一个&quot;]</span></span><br><span class="line"><span class="comment">// 合并嵌套数组  会浅拷贝嵌套数组</span></span><br><span class="line"><span class="keyword">let</span> d = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> f = [<span class="number">3</span>, [<span class="number">4</span>]];</span><br><span class="line"><span class="keyword">let</span> newVal4 = d.concat(f); <span class="comment">// [1,2,3,[4]]</span></span><br></pre></td></tr></table></figure>

<h5 id="ES6-扩展运算符-合并数组"><a href="#ES6-扩展运算符-合并数组" class="headerlink" title="ES6 扩展运算符 ... 合并数组"></a>ES6 扩展运算符 <code>...</code> 合并数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>, ...a, <span class="number">4</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">//  [2, 3, 4, 5] [4,2,3,4,5,4,4]</span></span><br></pre></td></tr></table></figure>

<h5 id="indexOf-查找数组是否存在某个元素，返回下标"><a href="#indexOf-查找数组是否存在某个元素，返回下标" class="headerlink" title="indexOf() 查找数组是否存在某个元素，返回下标"></a>indexOf() 查找数组是否存在某个元素，返回下标</h5><blockquote>
<p>定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p>
<p>p.s. 字符串也有此方法，要注意当 ‘lance’.indexOf(‘’) 一个空字符串时，返回 0 而不是-1</p>
<p>语法：array.indexOf(searchElement,fromIndex)</p>
<p>参数：</p>
<p>searchElement (必须):被查找的元素</p>
<p>fromIndex (可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为 0。</p>
<p>严格相等的搜索:</p>
<p>数组的 indexOf 搜索跟字符串的 indexOf 不一样,数组的 indexOf 使用严格相等<code>===</code>搜索元素，即<strong>数组元素要完全匹配</strong>才能搜索成功。</p>
<p><strong>注意</strong>：indexOf() 不能识别<code>NaN</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&#x27;啦啦&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">24</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">&#x27;啦&#x27;</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">&#x27;NaN&#x27;</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">&#x27;啦啦&#x27;</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h5 id="lastIndexOf-查找指定元素在数组中的最后一个位置"><a href="#lastIndexOf-查找指定元素在数组中的最后一个位置" class="headerlink" title="lastIndexOf() 查找指定元素在数组中的最后一个位置"></a>lastIndexOf() 查找指定元素在数组中的最后一个位置</h5><blockquote>
<p>定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）</p>
<p>语法：arr.lastIndexOf(searchElement,fromIndex)</p>
<p>参数:</p>
<p>searchElement(必须): 被查找的元素</p>
<p>fromIndex(可选): 逆向查找开始位置，默认值数组的 <code>长度-1</code>，即查找整个数组。</p>
<p>关于 fromIndex 有三个规则:</p>
<ol>
<li>正值。如果该值大于或等于数组的长度，则整个数组会被查找。</li>
<li>负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)</li>
<li>负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&#x27;OB&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;Koro1&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;Koro1&#x27;</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">&#x27;Koro1&#x27;</span>]; <span class="comment">// 数组长度为10</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,4) // 从下标4开始往前找 返回下标2</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,100) //  大于或数组的长度 查找整个数组 返回9</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,-11) // -1 数组不会被查找</span></span><br><span class="line"><span class="keyword">let</span> b = a.lastIndexOf(<span class="string">&#x27;Koro1&#x27;</span>, -<span class="number">9</span>); <span class="comment">// 从第二个元素4往前查找，没有找到 返回-1</span></span><br></pre></td></tr></table></figure>

<h5 id="ES7-includes-查找数组是否包含某个元素-返回布尔"><a href="#ES7-includes-查找数组是否包含某个元素-返回布尔" class="headerlink" title="ES7 includes() 查找数组是否包含某个元素 返回布尔"></a>ES7 includes() 查找数组是否包含某个元素 返回布尔</h5><blockquote>
<p>定义： 返回一个布尔值，表示某个数组是否包含给定的值</p>
<p>语法：array.includes(searchElement,fromIndex=0)</p>
<p>参数：</p>
<p>searchElement (必须):被查找的元素</p>
<p>fromIndex (可选):默认值为 0 ，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回 false 。负值绝对值超过长数组度，重置从 0 开始搜索。</p>
<p><strong>includes 方法是为了弥补 indexOf 方法的缺陷而出现的:</strong></p>
<ol>
<li>indexOf 方法不能识别 <code>NaN</code></li>
<li>indexOf 方法检查是否包含某个值不够语义化，需要判断是否不等于 <code>-1</code> ，表达不够直观</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&#x27;OB&#x27;</span>, <span class="string">&#x27;Koro1&#x27;</span>, <span class="number">1</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="comment">// let b=a.includes(NaN) // true 识别NaN</span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,100) // false 超过数组长度 不搜索</span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,-3)  // true 从倒数第三个元素开始搜索</span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,-100)  // true 负值绝对值超过数组长度，搜索整个数组</span></span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://juejin.im/post/5b0903b26fb9a07a9d70c7e0">js 数组详细操作方法及解析合集</a></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h3><h4 id="charAt-返回字符串字符"><a href="#charAt-返回字符串字符" class="headerlink" title="charAt 返回字符串字符"></a>charAt 返回字符串字符</h4><blockquote>
<p>从一个字符串中返回指定字符<br>如果指定的 index 值超出了该范围，则返回一个空字符串</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anyString = <span class="string">&#x27;Brave new world&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anyString.charAt(<span class="number">0</span>)); <span class="comment">// B</span></span><br></pre></td></tr></table></figure>

<h4 id="substring-返回字符串子集"><a href="#substring-返回字符串子集" class="headerlink" title="substring 返回字符串子集"></a>substring 返回字符串子集</h4><blockquote>
<p>返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。</p>
<ul>
<li>如果 <code>indexStart</code> 等于 <code>indexEnd</code>，<code>substring</code> 返回一个空字符串。</li>
<li>如果省略 <code>indexEnd</code>，<code>substring</code> 提取字符一直到字符串末尾。</li>
<li>如果任一参数小于 0 或为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a>，则被当作 0。</li>
<li>如果任一参数大于 <code>stringName.length</code>，则被当作 <code>stringName.length</code>。</li>
<li>如果 <code>indexStart</code> 大于 <code>indexEnd</code>，则 <code>substring</code> 的执行效果就像两个参数调换了一样。见下面的例子。</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anyString = <span class="string">&#x27;Mozilla&#x27;</span>;</span><br><span class="line"><span class="comment">// 输出 &quot;Moz&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">3</span>, -<span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">3</span>, <span class="literal">NaN</span>));</span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(-<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="literal">NaN</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<h4 id="replace-替换字符串"><a href="#replace-替换字符串" class="headerlink" title="replace 替换字符串"></a>replace 替换字符串</h4><blockquote>
<p>返回一个由替换值（replacement）替换一些或所有匹配的模式（pattern）后的新字符串。模式可以是一个字符串或者一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp">正则表达式</a> ，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。</p>
</blockquote>
<h4 id="toLowerCase-toUpperCase-转换字母大小写"><a href="#toLowerCase-toUpperCase-转换字母大小写" class="headerlink" title="toLowerCase / toUpperCase 转换字母大小写"></a>toLowerCase / toUpperCase 转换字母大小写</h4><p>字母转为全小写或全大写</p>
<h4 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h4><blockquote>
<p>includes() 返回布尔值：表示是否找到了参数字符。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;qdywxs&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">&#x27;y&#x27;</span>)); <span class="comment">//--&gt;true</span></span><br></pre></td></tr></table></figure>

<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><blockquote>
<p>获取字符串重复 n 次。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;qdywxs&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.repeat(<span class="number">3</span>)); <span class="comment">//--&gt;qdywxsqdywxsqdywxs</span></span><br></pre></td></tr></table></figure>

<h4 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h4><blockquote>
<p>返回布尔值：表示参数字符串是否在源字符串的头部。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;swlance&#x27;</span>.startsWith(<span class="string">&#x27;s&#x27;</span>)); <span class="comment">//--&gt;true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;swlance&#x27;</span>.startsWith(<span class="string">&#x27;l&#x27;</span>)); <span class="comment">//--&gt;false</span></span><br></pre></td></tr></table></figure>

<h4 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith"></a>endsWith</h4><blockquote>
<p>返回布尔值，表示参数字符串是否在源字符串的尾部。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;swlance&#x27;</span>.endsWith(<span class="string">&#x27;e&#x27;</span>)); <span class="comment">//--&gt;true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;swlance&#x27;</span>.endsWith(<span class="string">&#x27;o&#x27;</span>)); <span class="comment">//--&gt;false</span></span><br></pre></td></tr></table></figure>

<h2 id="什么是-JavaScript-作用链域？"><a href="#什么是-JavaScript-作用链域？" class="headerlink" title="什么是 JavaScript 作用链域？"></a>什么是 JavaScript 作用链域？</h2><p>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。</p>
<p>当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找， 直至全局函数，这种组织形式就是作用域链。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="什么是闭包-对闭包的理解"><a href="#什么是闭包-对闭包的理解" class="headerlink" title="什么是闭包/对闭包的理解"></a>什么是闭包/对闭包的理解</h3><p>函数中有另一个函数或有另一个对象，里面的函数或者是对象都可以使用外面函数中定义的变量或者参数，此时形成闭包。</p>
<blockquote>
<p>YouDontKnowJS 对闭包的解释 —— 闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。由于这个性质，<strong>闭包让我们能够从一个函数内部访问其外部函数的作用域</strong></p>
<p>闭包就是能够读取其他函数内部变量的函数。可以简单理解成“定义在一个函数内部的函数”</p>
</blockquote>
<h3 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h3><ul>
<li><strong>保存</strong>：缓存数据，延长作用域链</li>
<li><strong>保护</strong>：形成私有作用域，保护里面私有变量不受外界干扰，避免全局污染</li>
</ul>
<blockquote>
<p>缺点：<strong>耗内存，耗性能</strong>，函数中的变量不能及时释放</p>
</blockquote>
<h3 id="如何使用闭包"><a href="#如何使用闭包" class="headerlink" title="如何使用闭包"></a>如何使用闭包</h3><p>要使用闭包，只需要简单地将一个函数定义在另一个函数内部，并将它暴露出来。要暴露一个函数，可以将它返回或者传给其他函数。</p>
<p><strong>内部函数将能够访问到外部函数作用域中的变量</strong>，即使外部函数已经执行完毕。</p>
<p>想要缓存数据的时候就用闭包，把想要缓存的数据放在外层函数和内层函数的中间位置。</p>
<h3 id="闭包应用场景"><a href="#闭包应用场景" class="headerlink" title="闭包应用场景"></a>闭包应用场景</h3><h4 id="li-节点的-onclick-事件都能正确的弹出当前被点击的-li-索引"><a href="#li-节点的-onclick-事件都能正确的弹出当前被点击的-li-索引" class="headerlink" title="li 节点的 onclick 事件都能正确的弹出当前被点击的 li 索引"></a>li 节点的 onclick 事件都能正确的弹出当前被点击的 li 索引</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;testUL&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>index = 0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>index = 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>index = 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>index = 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> nodes = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i += <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">    nodes[i].onclick = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// &lt;----重点是此处返回了个一个匿名函数，这个函数能访问</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 立即执行函数作用域内的i这个变量，形成闭包</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(i);</span></span><br><span class="line"><span class="javascript">      &#125;; <span class="comment">//不用闭包的话，值每次都是4</span></span></span><br><span class="line">    &#125;)(i);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="用闭包模拟私有方法"><a href="#用闭包模拟私有方法" class="headerlink" title="用闭包模拟私有方法"></a>用闭包模拟私有方法</h4><p>使用闭包定义能访问私有函数和私有变量的公有函数（也叫做模块模式）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(); <span class="comment">// 立即执行函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter.value()); <span class="comment">// logs 0</span></span><br><span class="line">counter.increment();</span><br><span class="line">counter.increment();</span><br><span class="line"><span class="built_in">console</span>.log(counter.value()); <span class="comment">// logs 2</span></span><br><span class="line">counter.decrement();</span><br><span class="line"><span class="built_in">console</span>.log(counter.value()); <span class="comment">// logs 1</span></span><br></pre></td></tr></table></figure>

<p>环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。 它俩都无法在匿名函数外部直接访问。必须通过匿名包装器返回的对象的三个公共函数访问。</p>
<h3 id="解决-循环-闭包-问题"><a href="#解决-循环-闭包-问题" class="headerlink" title="解决 循环+闭包 问题"></a>解决 循环+闭包 问题</h3><p>直接 <a target="_blank" rel="noopener" href="https://juejin.im/post/58f1fa6a44d904006cf25d22">点击此处</a> 查看</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="对-this-的理解"><a href="#对-this-的理解" class="headerlink" title="对 this 的理解"></a>对 this 的理解</h3><ul>
<li>this 总是指向函数的直接调用者（而非间接调用者）</li>
<li>如果有 new 关键字，this 指向 new 出来的那个对象</li>
<li>在事件中，this 指向触发这个事件的对象，特殊的是，IE 中的 attachEvent 中的 this 总是指向全局对象 window</li>
</ul>
<p><strong>重要</strong>：</p>
<ul>
<li>普通函数的 this 指向是在函数的<strong>执行期间</strong>绑定的</li>
<li>箭头函数的 this 指向是在函数<strong>创建期间</strong>就绑定好了的，指向的是创建该箭头函数所在的作用域对象</li>
<li>一般不在事件（比如 onclick ）上传递箭头函数，使用 function 就好</li>
</ul>
<h3 id="判定-this"><a href="#判定-this" class="headerlink" title="判定 this"></a>判定 <code>this</code></h3><blockquote>
<p>摘自 YouDontKnowJS</p>
</blockquote>
<p>现在，我们可以按照优先顺序来总结一下从函数调用的调用点来判定 <code>this</code> 的规则了。按照这个顺序来问问题，然后在第一个规则适用的地方停下。</p>
<ol>
<li>函数是通过 <code>new</code> 被调用的吗（<strong>new 绑定</strong>）？如果是，<code>this</code> 就是新构建的对象。<br><code>var bar = new foo()</code></li>
<li>函数是通过 <code>call</code> 或 <code>apply</code> 被调用（<strong>明确绑定</strong>），甚至是隐藏在 <code>bind</code> <em>硬绑定</em> 之中吗？如果是，<code>this</code> 就是那个被明确指定的对象。<br><code>var bar = foo.call( obj2 )</code></li>
<li>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（<strong>隐含绑定</strong>）？如果是，<code>this</code> 就是那个环境对象。<br><code>var bar = obj1.foo()</code></li>
<li>否则，使用默认的 <code>this</code>（<strong>默认绑定</strong>）。如果在 <code>strict mode</code> 下，就是 <code>undefined</code>，否则是 <code>global</code> 对象。<br><code>var bar = foo()</code></li>
</ol>
<p>以上，就是理解对于普通的函数调用来说的 <code>this</code> 绑定规则 _所需的全部_。是的……几乎是全部。</p>
<h2 id="apply-call-bind-的区别"><a href="#apply-call-bind-的区别" class="headerlink" title="apply, call, bind 的区别"></a>apply, call, bind 的区别</h2><blockquote>
<p>apply, call, bind 本身存在于大 Function 构造函数的 prototype 中</p>
<p>所有的函数都是大 Function 的实例对象</p>
</blockquote>
<img src="/posts/31920/1549791418436-78a38fa1-d824-45c0-8caa-7a6314637140.png" class="" title="apply">

<p>apply, call, bind 方法都可以改变 this 的指向</p>
<ul>
<li>apply(对象, [参数 1, 参数 2, 餐数 3, …])</li>
<li>call(对象, 参数 1, 参数 2, 餐数 3,…)</li>
<li>bind(对象,参数 1, 参数 2, 餐数 3,…)<ul>
<li>函数名称.bind()—-&gt;返回值是复制之后的这个函数</li>
</ul>
</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>apply，call 是调用的时候改变 this 指向，然后返回函数执行的结果。<ul>
<li>参数较多时用 apply ，参数较少时用 call</li>
</ul>
</li>
<li>bind 是复制一份函数并返回，并且这个函数的 this 指向变成了传入的第一个参数。</li>
</ul>
<h2 id="JavaScript-原型"><a href="#JavaScript-原型" class="headerlink" title="JavaScript 原型"></a>JavaScript 原型</h2><h3 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h3><blockquote>
<p><strong>实例对象</strong>中有个属性 <strong>proto</strong> ，是个对象，叫原型，不是标准的属性，浏览器使用的—–&gt;可以叫<strong>原型对象</strong></p>
<p><strong>构造函数</strong>中有一个属性 <strong>prototype</strong> ，也是个对象，叫原型，是标准属性，程序员使用—&gt;可以叫<strong>原型对象</strong></p>
<p><em>实例对象的 <strong>proto</strong> 和构造函数中的 prototype 相等—&gt; true</em></p>
<p><em>又因为实例对象是通过构造函数来创建的，构造函数中有原型对象 prototype</em></p>
<p><em>实例对象的 <strong>proto</strong> 指向了构造函数的原型对象 prototype</em></p>
</blockquote>
<p>每个对象都会在其内部初始化一个属性，就是 prototype（原型）。原型就是 <strong>proto</strong>（IE8 不支持，非标准属性） 或者是 prototype ，都是原型对象。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>共享数据，目的是：节省内存空间</li>
<li>实现继承，目的是：节省内存空间</li>
</ul>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a>什么是原型链</h3><p><strong>精简版</strong></p>
<p>原型链是一种关系，实例对象和原型对象之间的关系，关系是通过原型（<strong>proto</strong>）来联系的。</p>
<p><strong>详细版</strong></p>
<p>每个对象都会在其内部初始化一个属性 prototype（原型），当我们访问一个对象的属性时， 如果这个对象内部不存在这个属性，那么他就会去 prototype 里找这个属性，这个 prototype 又会有自己的 prototype ，于是就这样一直找下去，也就是我们平时所说的原型链的概念。</p>
<p><strong>原型和原型链</strong></p>
<img src="/posts/31920/1549711479179-356c282c-60db-41ea-82df-5ebfb9550785.png" class="" title="prototype">

<p><strong>原型链最终指向</strong></p>
<img src="/posts/31920/1549711526339-9b043225-9ad9-4f88-b1b5-95da79cc4bf8.png" class="" title="原型链最终指向">

<h3 id="分别使用原型链和-class-的方式实现继承"><a href="#分别使用原型链和-class-的方式实现继承" class="headerlink" title="分别使用原型链和 class 的方式实现继承"></a>分别使用原型链和 class 的方式实现继承</h3><h4 id="1-组合继承（原型链-借用构造函数）【不推荐】"><a href="#1-组合继承（原型链-借用构造函数）【不推荐】" class="headerlink" title="1. 组合继承（原型链 + 借用构造函数）【不推荐】"></a>1. 组合继承（原型链 + 借用构造函数）【不推荐】</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, weight</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 借用构造函数</span></span><br><span class="line">  Person.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">  <span class="built_in">this</span>.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改变原型指向----继承</span></span><br><span class="line"><span class="comment">// 我们让 Student.prototype 指向一个 Person 的实例对象</span></span><br><span class="line"><span class="comment">// 这个对象的 __proto__ 指向的是 Person.prototype</span></span><br><span class="line"><span class="comment">// 所以我们就可以借助这个实例对象拿到 sayHi 方法，实现继承</span></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">Student.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">&#x27;Lance&#x27;</span>, <span class="number">20</span>, <span class="number">120</span>);</span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> Student(<span class="string">&#x27;Will&#x27;</span>, <span class="number">200</span>, <span class="number">110</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性和方法都被继承了</span></span><br></pre></td></tr></table></figure>

<p>由上面方案引出的问题：</p>
<h5 id="为什么不能-Student-prototype-Person-prototype"><a href="#为什么不能-Student-prototype-Person-prototype" class="headerlink" title="为什么不能 Student.prototype = Person.prototype"></a>为什么不能 Student.prototype = Person.prototype</h5><p>对象的赋值只是引用的赋值, 上面两者都指向同一个内存地址，只要随便通过 1 个途径就能修改该内存地址的对象，这样子类就无法单独扩展方法，因为会影响父类。</p>
<h5 id="单纯的原型链继承有什么缺陷"><a href="#单纯的原型链继承有什么缺陷" class="headerlink" title="单纯的原型链继承有什么缺陷"></a>单纯的原型链继承有什么缺陷</h5><p>虽然改变了原型的指向，但属性在初始化的时候就已经固定了【Student.prototype = new Person(“小明”, 29, 90)】，如果是多个对象实例化，那么每个实例对象的属性的初始值就都是一样的。换句话说，无法向父类传递参数。</p>
<h5 id="单纯的借用构造函数继承有什么缺陷"><a href="#单纯的借用构造函数继承有什么缺陷" class="headerlink" title="单纯的借用构造函数继承有什么缺陷"></a>单纯的借用构造函数继承有什么缺陷</h5><p>只能继承父类构造函数里面的属性和方法【Person.call(this, name, age)】，但父类的 prototype（原型）上的属性和方法不能继承。</p>
<h5 id="组合继承的缺点"><a href="#组合继承的缺点" class="headerlink" title="组合继承的缺点"></a>组合继承的缺点</h5><p>调用了两次父类的构造函数。第一次给子类的原型添加了父类构造函数中的属性方法，第二次又给子类的构造函数添加了父类的构造函数的属性方法，从而覆盖了子类原型中的同名参数。这种被覆盖的情况造成了性能上的浪费：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>); <span class="comment">// 第二次调用SuperType</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">// 第一次调用SuperType</span></span><br></pre></td></tr></table></figure>

<h4 id="2-寄生组合继承【推荐】"><a href="#2-寄生组合继承【推荐】" class="headerlink" title="2. 寄生组合继承【推荐】"></a>2. 寄生组合继承【推荐】</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, weight</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">  <span class="built_in">this</span>.weight = weight;</span><br><span class="line">  <span class="built_in">this</span>.study = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费</span></span><br><span class="line">F.prototype = Person.prototype; <span class="comment">// 创建了父类原型的浅复制</span></span><br><span class="line">Student.prototype = <span class="keyword">new</span> F();</span><br><span class="line"><span class="comment">// 上面三段js代码也可以用 Student.prototype = Object.create(Person.prototype) 代替</span></span><br><span class="line">Student.prototype.constructor = Student; <span class="comment">// 修正原型的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> Student(<span class="string">&#x27;Lance&#x27;</span>, <span class="number">19</span>, <span class="number">120</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(stu1);</span><br></pre></td></tr></table></figure>

<h4 id="3-class-实现继承"><a href="#3-class-实现继承" class="headerlink" title="3. class 实现继承"></a>3. class 实现继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="comment">// 类本身的方法</span></span><br><span class="line">    <span class="built_in">this</span>.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里的 eat 相当于 prototype 中的 eat</span></span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键点：extends super</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age, weight</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age);</span><br><span class="line">    <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    <span class="built_in">this</span>.study = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">&#x27;Jerry&#x27;</span>, <span class="number">20</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(stu);</span><br></pre></td></tr></table></figure>

<h3 id="原型链，proto-和-prototype-的区别"><a href="#原型链，proto-和-prototype-的区别" class="headerlink" title="原型链，proto 和 prototype 的区别"></a>原型链，proto 和 prototype 的区别</h3><p>对象拥有 <strong>proto</strong> 属性，函数拥有 prototype 属性。某个实例对象的 <strong>proto</strong> 指向构造它的构造函数的 prototype 属性。所以：实例对象的 <strong>proto</strong> 指向了构造函数的原型对象 prototype<br>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例对象</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="string">&#x27;lc&#x27;</span>);</span><br><span class="line">b.__proto__ === B.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lc237423551/article/details/80010100"><strong>彻底理解什么是原型链，prototype 和**proto**的区别。</strong></a></p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><blockquote>
<p>函数（包括构造函数）是对象</p>
<p>对象不一定是函数</p>
<p>对象有 <strong>proto</strong></p>
<p>函数有 prototype</p>
</blockquote>
<h3 id="创建对象的三种方式"><a href="#创建对象的三种方式" class="headerlink" title="创建对象的三种方式"></a>创建对象的三种方式</h3><h4 id="字面量的方式"><a href="#字面量的方式" class="headerlink" title="字面量的方式"></a>字面量的方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lance&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="调用系统的构造函数"><a href="#调用系统的构造函数" class="headerlink" title="调用系统的构造函数"></a>调用系统的构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">&#x27;Lance&#x27;</span>;</span><br><span class="line">obj.age = <span class="number">20</span>;</span><br><span class="line">obj.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="自定义构造函数"><a href="#自定义构造函数" class="headerlink" title="自定义构造函数"></a>自定义构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="new-操作符具体干了什么呢？"><a href="#new-操作符具体干了什么呢？" class="headerlink" title="new 操作符具体干了什么呢？"></a>new 操作符具体干了什么呢？</h4><ol>
<li>创建一个新对象，如：var obj = {};</li>
<li>新对象的 <code>__proto__</code> 属性指向构造函数的原型对象。</li>
<li>将构造函数的作用域赋值给新对象。（也所以 this 对象指向新对象）</li>
<li>执行构造函数内部的代码，将属性添加给 obj 中的 this 对象。</li>
<li>返回新对象 obj。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">  <span class="keyword">const</span> ret = fn.apply(obj, args);</span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过-new-的方式创建对象和通过字面量创建有什么区别？"><a href="#通过-new-的方式创建对象和通过字面量创建有什么区别？" class="headerlink" title="通过 new 的方式创建对象和通过字面量创建有什么区别？"></a>通过 new 的方式创建对象和通过字面量创建有什么区别？</h4><ol>
<li>字面量创建对象，不会调用 Object 构造函数, 简洁且性能更好;</li>
<li>new Object() 方式创建对象本质上是方法调用，涉及到在 proto 链中遍历该方法，当找到该方法后，又会生产方法调用必须的 堆栈信息，方法调用结束后，还要释放该堆栈，性能不如字面量的方式</li>
</ol>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="什么是事件，IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#什么是事件，IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="什么是事件，IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>什么是事件，IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><ol>
<li>我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。</li>
<li>事件处理机制：IE9 以下只支持事件冒泡、Firefox、Chrome 等则同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。</li>
<li>ev.stopPropagation();（旧 ie 的方法 ev.cancelBubble = true）</li>
</ol>
<h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><img src="/posts/31920/1550160415749-0297296f-0559-485f-bfe4-05859bdc757a.jpeg" class="" title="事件阶段">

<h3 id="什么是-DOM-事件模型"><a href="#什么是-DOM-事件模型" class="headerlink" title="什么是 DOM 事件模型"></a>什么是 DOM 事件模型</h3><p>主要有三种 DOM 事件模型：</p>
<ol>
<li><strong>事件冒泡</strong>：元素先监听到这个事件，往外传播；</li>
<li><strong>事件捕获</strong>：Document 最先监听到这个事件；</li>
<li><strong>DOM 事件流</strong>：先捕获，再冒泡。允许在某些地方监听事件，假设在某个元素两阶段都绑定一个事件监听器，看你是决定在左边捕获阶段监听，还是右边冒泡阶段监听，哪一边有响应，哪一边事件就被触发。即可以在任一阶段、任意时机监听事件。</li>
</ol>
<h3 id="事件绑定的三种方式"><a href="#事件绑定的三种方式" class="headerlink" title="事件绑定的三种方式"></a>事件绑定的三种方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【 DOM0 级事件 】</span></span><br><span class="line"><span class="comment">// 第一种：作为属性，写在标签上</span></span><br><span class="line"><span class="comment">// &lt;div onclick=&quot;fun();&quot;&gt;click&lt;/div&gt; ← 绑定在事件冒泡阶段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种，使用 onclick</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;xxx&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// ← 绑定在事件冒泡阶段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 【 DOM2 级事件 】</span></span><br><span class="line"><span class="comment">// 第三种：使用推荐的标准模式</span></span><br><span class="line"><span class="built_in">document</span></span><br><span class="line">  .getElementById(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">  .addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 第三种可以改变事件绑定的阶段</span></span><br><span class="line"><span class="comment">// ---&gt; 为 false 时，绑定在事件冒泡阶段（默认下是绑定在冒泡阶段）</span></span><br><span class="line"><span class="comment">// ---&gt; 为 true 时，绑定在捕获阶段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果绑定在捕获阶段，监听函数就只在捕获阶段触发</span></span><br><span class="line"><span class="comment">// 如果绑定在冒泡阶段，监听函数只在冒泡阶段触发。</span></span><br></pre></td></tr></table></figure>

<h3 id="DOM2-事件传播机制"><a href="#DOM2-事件传播机制" class="headerlink" title="DOM2 事件传播机制"></a>DOM2 事件传播机制</h3><p>DOM 作为事件处理的一个基本标准，DOM2 级事件为 DOM 事件的升级；</p>
<p>DOM2 级事件定义用于处理指定和删除事件处理程序的操作：</p>
<ul>
<li>addEventListener</li>
<li>removeEventListener</li>
</ul>
<p>所有的 DOM 节点都包含这两个方法，并且它们都接受三个参数：</p>
<ol>
<li>事件类型；</li>
<li>事件处理方法；</li>
<li>布尔参数。如果是 true 表示在捕获阶段调用事件处理程序；如果是 false，则是在事件冒泡阶段处理。</li>
</ol>
<h3 id="事件的执行顺序"><a href="#事件的执行顺序" class="headerlink" title="事件的执行顺序"></a>事件的执行顺序</h3><ul>
<li>无论是哪种绑定方式，对于同一个绑定元素，都是遵循先绑定的先执行原则。</li>
<li>如果是以 onclick 的方式绑定的，如果对同一个元素重复绑定的话，后面的会覆盖前面的。但是如果是以 addEventListener 方式绑定的话，同一个元素绑定多少次，就会执行多少次。</li>
<li>如果在 DOM 中直接使用 onclick ，则 onclick 的绑定是早于 addEventListener 的。</li>
</ul>
<h4 id="我们给一个-dom-同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？"><a href="#我们给一个-dom-同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？" class="headerlink" title="我们给一个 dom 同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？"></a>我们给一个 dom 同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？</h4><p>会执行两次事件，按代码执行顺序来</p>
<p><strong>规律</strong>：绑定在被点击元素的事件是按照代码顺序发生，其他元素通过冒泡或者捕获“感知”的事件，按照<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=W3C&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">W3C</a>的标准，先发生捕获事件，后发生冒泡事件。所有事件的顺序是：其他元素捕获阶段事件 -&gt; 本元素代码顺序事件 -&gt; 其他元素冒泡阶段事件</p>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>绑定在父级元素，利用事件冒泡去触发父级事件处理函数的一种技巧。</p>
<h4 id="实现一个事件委托"><a href="#实现一个事件委托" class="headerlink" title="实现一个事件委托"></a>实现一个事件委托</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span>(<span class="params">element, eventType, targetElement, fn</span>) </span>&#123;</span><br><span class="line">  element.addEventListener(eventType, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 先拿到当前事件的直接触发对象</span></span><br><span class="line">    <span class="keyword">var</span> curTarget = e.target;</span><br><span class="line">    <span class="comment">// 看它是不是使用者监听的目标对象类型</span></span><br><span class="line">    <span class="comment">// 一旦发现不是，就执行循环</span></span><br><span class="line">    <span class="keyword">while</span> (!curTarget.matches(targetElement)) &#123;</span><br><span class="line">      <span class="comment">// 先看看当前对象是不是和父元素相同</span></span><br><span class="line">      <span class="comment">// 相同则把当前对象置为空，且不执行回调</span></span><br><span class="line">      <span class="keyword">if</span> (curTarget === element) &#123;</span><br><span class="line">        curTarget = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 不相同则把当前对象设置成自己的父对象</span></span><br><span class="line">      curTarget = curTarget.parentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是，则先看当前对象有没有值，有值则执行回调函数</span></span><br><span class="line">    curTarget &amp;&amp; fn(e, curTarget, e);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listen(ul, <span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;li&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, el</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event, el);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// jquery 使用方式</span></span><br><span class="line">$(<span class="string">&#x27;ul&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;li&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log($(e.target).html());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这个 on 事件是绑定在 ul 上面的，li 是目标元素，</span></span><br><span class="line"><span class="comment">// on 事件内部是通过 e.target 来判断点击元素是不是 li 的</span></span><br></pre></td></tr></table></figure>

<h3 id="解释以下概念：事件传播机制、阻止传播、取消默认事件、事件代理？"><a href="#解释以下概念：事件传播机制、阻止传播、取消默认事件、事件代理？" class="headerlink" title="解释以下概念：事件传播机制、阻止传播、取消默认事件、事件代理？"></a>解释以下概念：事件传播机制、阻止传播、取消默认事件、事件代理？</h3><p><strong>1. 事件传播机制主要有三种：</strong></p>
<ul>
<li>事件冒泡：事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的元素（从小到大）；</li>
<li>事件捕获：不太具体的节点更早接收事件，而最具体的元素最后接收事件，和事件冒泡相反（从大到小）；</li>
<li>DOM 事件流：DOM2 级事件规定事件流包括三个阶段，事件捕获阶段，处于目标阶段，事件冒泡阶段，首先发生的是事件捕获，为截取事件提供机会，然后是实际目标接收事件，最后是冒泡阶段（标准浏览器现在都使用 DOM 事件流，IE 不支持事件流，只支持事件冒泡）。</li>
</ul>
<p><strong>2. 阻止传播</strong></p>
<p>stopPropagation() 取消事件进一步捕获或冒泡。</p>
<p><strong>3. 取消默认事件</strong></p>
<p>preventDefault() 取消事件默认行为。</p>
<p><strong>4. 事件代理</strong></p>
<p>通过事件冒泡（或者事件捕获）给父元素添加事件监听，e.target 指向引发触发事件的元素。</p>
<h3 id="什么是节流和防抖"><a href="#什么是节流和防抖" class="headerlink" title="什么是节流和防抖"></a>什么是节流和防抖</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>debounce（防抖）的作用是在让在用户动作停止后延迟 x ms 再执行回调</li>
<li>throttle（节流）的作用是在用户动作时每隔一定时间（如 200ms）执行一次回调</li>
</ul>
<h4 id="节流防抖作用"><a href="#节流防抖作用" class="headerlink" title="节流防抖作用"></a>节流防抖作用</h4><ul>
<li>debounce 应用在搜索框的即时搜索（input 事件），避免用户狂按键盘导致的频繁请求</li>
<li>throttle 应用在监听 resize 改变布局或 onscroll 滚动</li>
</ul>
<p><strong>防抖</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; oninput=&quot;change()&quot;&gt;</span></span><br><span class="line"><span class="comment">// 防抖（一段时间会等，然后带着一起做了）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="built_in">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">window</span>.clearTimeout(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> change = debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> input = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(input.value);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p><strong>节流</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;div class=&quot;sw&quot;&gt;23333&lt;/div&gt;</span></span><br><span class="line"><span class="comment">// 节流（一段时间执行一次之后，就不执行第二次）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canUse = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (canUse) &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      canUse = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> (canUse = <span class="literal">true</span>), delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sw = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.sw&#x27;</span>);</span><br><span class="line"></span><br><span class="line">sw.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  throttle(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37860930/article/details/83545473%E2%80%98">在 React、Vue 和小程序中使用函数节流和函数防抖</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38313717">函数防抖与函数节流</a></li>
<li><a target="_blank" rel="noopener" href="http://www.webfront-js.com/articaldetail/99.html">JS 事件中防抖 debounce 和节流 throttle 概念原理的学习</a></li>
</ul>
<h3 id="mouseover-和-mouseenter-的区别"><a href="#mouseover-和-mouseenter-的区别" class="headerlink" title="mouseover 和 mouseenter 的区别"></a>mouseover 和 mouseenter 的区别</h3><ul>
<li>mouseover：<br>不论鼠标指针穿过被选元素或其子元素，都会触发 <code>mouseover</code> 事件。<br>支持事件冒泡。<br>相对应 <code>mouseout</code> 事件。</li>
<li>mouseenter：<br>只有在鼠标指针穿过被选元素时，才会触发 <code>mouseenter</code> 事件。<br>不支持事件冒泡。<br>相对应 <code>mouseleave</code> 事件。</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010297791/article/details/57412796">JavaScript 中的 mouseover 与 mouseenter ，mouseout 和 mouseleave 的区别</a></p>
<h3 id="window-onload-和-document-onDOMContentLoaded-有什么区别？"><a href="#window-onload-和-document-onDOMContentLoaded-有什么区别？" class="headerlink" title="window.onload 和 document.onDOMContentLoaded 有什么区别？"></a>window.onload 和 document.onDOMContentLoaded 有什么区别？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当页面所有资源加载完成，则触发（涉及到所有资源，所以触发时机较晚）。</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;window loaded&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DOM 结构解析完成（并不是页面上资源加载完成，而是 dom 结构渲染完成）。</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;DOMContentLoaded&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="ES6-相关"><a href="#ES6-相关" class="headerlink" title="ES6 相关"></a>ES6 相关</h2><h3 id="ES6-用到过吗，新增了哪些东西，你用到过什么？"><a href="#ES6-用到过吗，新增了哪些东西，你用到过什么？" class="headerlink" title="ES6 用到过吗，新增了哪些东西，你用到过什么？"></a>ES6 用到过吗，新增了哪些东西，你用到过什么？</h3><ul>
<li><code>let</code> 和 <code>const</code></li>
<li>模板字符串</li>
<li>箭头函数（自己没有 this ，从自己的作用域链的<code>上一层继承 this</code> ）</li>
<li><code>for-of</code>（用来遍历数据—例如数组中的值）e.g. Array，String，Set，Map</li>
<li><code>arguments</code> 对象可被不定参数和默认参数完美代替</li>
<li>Promise</li>
<li>数组的拓展<ul>
<li>数组.find((item,index,arr) =&gt; {条件}) 返回满足条件的第一个元素的值。否则返回 undefined</li>
<li>数组.findIndex((item,index,arr)=&gt;{…}) 返回满足条件的第一个元素的索引值。否则返回 -1</li>
<li>数组.includes(数据,[searchIndex]) 判断数据是否在数组中,第二个参数(可选参数)为从指定索引处(包含索引处的值)开始搜索 返回布尔值(es7 时加入)</li>
<li>扩展运算符 …</li>
</ul>
</li>
<li>引入 <code>module</code> 模块的概念</li>
</ul>
<h3 id="const-和-let-区别"><a href="#const-和-let-区别" class="headerlink" title="const 和 let 区别"></a>const 和 let 区别</h3><ul>
<li>let 定义变量可以只声明不赋值</li>
<li>const 定义常量声明时必须赋值，一旦定义不可轻易改变值</li>
</ul>
<h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><p>解决 var 没有块作用域、变量提升、可以重复声明的问题。let 和 const 有自己的块作用域，不存在变量提升问题，同一块作用域中不可重复声明（会报错）</p>
<h4 id="let-var-区别"><a href="#let-var-区别" class="headerlink" title="let var 区别"></a>let var 区别</h4><ul>
<li><p>var 有变量提升，let 没有</p>
</li>
<li><p>let 的作用域是块，而 var 的作用域是函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">5</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">4</span>; <span class="comment">// The scope is inside the if-block</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>; <span class="comment">// The scope is inside the function</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 4</span></span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>let 有暂时性死区，只要 let/const 声明的变量，在未声明之前使用或者赋值都会报错（ReferenceError）</p>
</li>
<li><p>let 不能重复定义</p>
</li>
</ul>
<h4 id="可以改变-const-定义的某个对象的属性吗"><a href="#可以改变-const-定义的某个对象的属性吗" class="headerlink" title="可以改变 const 定义的某个对象的属性吗"></a>可以改变 const 定义的某个对象的属性吗</h4><p>可以，因为对象是复杂类型，const 存储的是引用，所以改变对象的成员不会报错，但不建议这样做。</p>
<h3 id="箭头函数（-this-指向）"><a href="#箭头函数（-this-指向）" class="headerlink" title="箭头函数（ this 指向）"></a>箭头函数（ this 指向）</h3><ul>
<li>箭头函数，本质上，就是一个匿名函数</li>
<li>箭头函数无法通过 call、apply、bind 来手动改变内部 this 指向</li>
<li>箭头函数：自动 .bind(this) 也就是说箭头函数中的 this 指向与其所在作用域的 this 指向相同</li>
</ul>
<p><strong>总结</strong>：</p>
<p>箭头函数不会创建自己的 <code>this</code> ，它只会从自己的作用域链的 <code>上一层继承 this</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Person() 构造函数定义 `this` 作为它自己的实例.</span></span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">growUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在非严格模式, growUp() 函数定义 `this`作为全局对象,</span></span><br><span class="line">    <span class="comment">// 与在 Person() 构造函数中定义的 `this`并不相同.</span></span><br><span class="line">    <span class="built_in">this</span>.age++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age++; <span class="comment">// |this| 正确地指向 p 实例</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<h4 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h4><ol>
<li>箭头函数是匿名函数，不能作为构造函数，不能使用 new。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> B = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  value: <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(); <span class="comment">//--&gt;TypeError: B is not a constructor</span></span><br></pre></td></tr></table></figure>

<ol>
<li>箭头函数不绑定 arguments，取而代之用 rest 参数 … 解决。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="params">b</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...c 即为 rest 参数</span></span><br><span class="line"><span class="keyword">var</span> C = <span class="function">(<span class="params">...c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;;</span><br><span class="line">A(<span class="number">1</span>); <span class="comment">//--&gt;[object Arguments] &#123;0: 1&#125;</span></span><br><span class="line">B(<span class="number">2</span>); <span class="comment">//--&gt;ReferenceError: arguments is not defined</span></span><br><span class="line">C(<span class="number">3</span>); <span class="comment">//--&gt;[3]</span></span><br></pre></td></tr></table></figure>

<ol>
<li>箭头函数不绑定 this，会捕获其所在的上下文的 this 值，作为自己的 this 值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.b(); <span class="comment">//--&gt;10</span></span><br><span class="line">obj.c()(); <span class="comment">//--&gt;10</span></span><br></pre></td></tr></table></figure>

<ol>
<li>箭头函数通过 call() 或 apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="built_in">this</span>.a;</span><br><span class="line">    <span class="keyword">return</span> f(n);</span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="built_in">this</span>.a;</span><br><span class="line">    <span class="keyword">var</span> m = &#123; <span class="attr">a</span>: <span class="number">20</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> f.call(m, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.b(<span class="number">1</span>)); <span class="comment">//--&gt;11</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.c(<span class="number">1</span>)); <span class="comment">//--&gt;11</span></span><br></pre></td></tr></table></figure>

<ol>
<li>箭头函数没有原型属性。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.prototype); <span class="comment">//--&gt;undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b.prototype); <span class="comment">//--&gt;object&#123;...&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>箭头函数不能当做 Generator 函数,不能使用 yield 关键字。箭头函数不能换行。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = ()</span><br><span class="line">          =&gt; <span class="number">1</span>;  <span class="comment">//--&gt;SyntaxError: Unexpected token =&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a>Set 和 Map</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>Set 是有序列表，类似于数组，但是没有重复值</li>
<li>Map 是存储许多键值对的有序列表，key 和 value 支持所有数据类型</li>
</ul>
<h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul>
<li>都是有序列表</li>
<li>Set 值不重复；Map 键不重复</li>
</ul>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><blockquote>
<p>SET</p>
</blockquote>
<ul>
<li>属性：<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是 Set 函数</li>
<li><code>Set.prototype.size</code>：返回实例的成员总数</li>
</ul>
</li>
<li>操作方法：<ul>
<li><code>add(value)</code>：添加一个值，返回 Set 结构本身</li>
<li><code>delete(value)</code>：删除某个值，返回布尔值</li>
<li><code>has(value)</code>：返回布尔值，表示是否是成员</li>
<li><code>clear()</code>：清除所有成员，无返回值</li>
</ul>
</li>
<li>遍历方法（ key() 和 values() 行为是一致的。）<ul>
<li><code>keys()</code>：返回键名的遍历器（什么是遍历器？Iterator）</li>
<li><code>values()</code>：返回键值的遍历器</li>
<li><code>entries()</code>：返回键值对的遍历器</li>
<li><code>forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
</li>
</ul>
<blockquote>
<p>MAP</p>
</blockquote>
<ul>
<li><p>属性</p>
<ul>
<li><code>size</code> ：返回 Map 结构的成员总数。</li>
</ul>
</li>
<li><p>操作方法</p>
<ul>
<li><p><code>set(key, value)</code>: <code>set</code> 方法设置键名 <code>key</code> 对应的键值为 <code>value</code> ，然后返回整个 Map 结构。</p>
</li>
<li><p><code>get(key)</code> ：<code>get</code> 方法读取 <code>key</code> 对应的键值，如果找不到 <code>key</code> ，返回 <code>undefined</code> 。</p>
</li>
<li><p><code>has(key)</code>：<code>has</code> 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>
</li>
<li><pre><code>delete(key)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
delete
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">方法删除某个键，返回</span><br><span class="line"></span><br></pre></td></tr></table></figure>
true
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">。如果删除失败，返回</span><br><span class="line"></span><br></pre></td></tr></table></figure>
false
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    。</span><br><span class="line"></span><br><span class="line">    - &#96;clear()&#96;：&#96;clear&#96;方法清除所有成员，没有返回值。</span><br><span class="line"></span><br><span class="line">- 遍历方法</span><br><span class="line"></span><br><span class="line">  - &#96;keys()&#96;：返回键名的遍历器。</span><br><span class="line">  - &#96;values()&#96;：返回键值的遍历器。</span><br><span class="line">  - &#96;entries()&#96;：返回所有成员的遍历器。</span><br><span class="line">  - &#96;forEach()&#96;：遍历 Map 的所有成员。</span><br><span class="line"></span><br><span class="line">#### 用途</span><br><span class="line"></span><br><span class="line">Set 集合可以用来过滤数组中重复的元素，只能通过 has 方法检测指定的值是否存在，或者是通过 forEach 处理每个值。</span><br><span class="line"></span><br><span class="line">Map 集合通过 set() 添加键值对，通过 get() 获取键值，各种方法的使用查看文章教程，你可以把它看成是比 Object 更加强大的对象。</span><br><span class="line"></span><br><span class="line">#### Set 与 数组 的区别</span><br><span class="line"></span><br><span class="line">set 不可重复，array 可重复</span><br><span class="line"></span><br><span class="line">#### Map 与 对象 的区别</span><br><span class="line"></span><br><span class="line">- Object 的键只能是字符串或者 symbol ，Map 的键可以是任意类型的值（包括对象）</span><br><span class="line">- Map 可以通过 size 获取元素个数，对象得遍历。</span><br><span class="line">- Map 是有序的（根据用户插入的顺序进行排序），对象排序有自己规则（比如先排数字开头的 key ，再到字符串）</span><br><span class="line">- &#96;Map&#96; 可直接进行迭代，而 &#96;Object&#96; 的迭代需要先获取它的键数组，然后再进行迭代。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">var map &#x3D; new Map();</span><br><span class="line">map.set(&#39;name&#39;, &#39;Lance&#39;);</span><br><span class="line">map.set(&#39;age&#39;, 18);</span><br><span class="line"></span><br><span class="line">var per &#x3D; &#123;</span><br><span class="line">  name: &#39;Jerry&#39;,</span><br><span class="line">  age: 19</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (const attr of map.values()) &#123;</span><br><span class="line">  console.log(attr);</span><br><span class="line">&#125; &#x2F;&#x2F; Lance 18</span><br><span class="line"></span><br><span class="line">for (const attr of Object.keys(per)) &#123;</span><br><span class="line">  console.log(per[attr]);</span><br><span class="line">&#125; &#x2F;&#x2F; Jerry 19</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="promise-是什么"><a href="#promise-是什么" class="headerlink" title="promise 是什么"></a>promise 是什么</h4><p>Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。</p>
<h4 id="诞生的原因"><a href="#诞生的原因" class="headerlink" title="诞生的原因"></a>诞生的原因</h4><p>异步网络请求的回调地狱，而且我们还得对每次请求的结果进行一些处理，代码会更加臃肿。</p>
<h4 id="promise-使用场景有哪些"><a href="#promise-使用场景有哪些" class="headerlink" title="promise 使用场景有哪些"></a>promise 使用场景有哪些</h4><ul>
<li>ajax 请求得到返回值的时间不同,有了 callback 的回调结果之后才能知道接下来应该做什么</li>
<li>node 中读取文件</li>
</ul>
<h4 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h4><ul>
<li>pending: 初始状态，既不是成功，也不是失败状态。</li>
<li>fulfilled: 意味着操作成功完成。</li>
<li>rejected: 意味着操作失败。</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>Promise 的优点:</strong></p>
<ul>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果；</li>
<li>可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</li>
</ul>
<p><strong>Promise 的缺点:</strong></p>
<ul>
<li>无法取消 Promise，错误需要通过回调函数来捕获；</li>
<li>当处于 pending 状态时，无法得知目前进展到哪一个阶段。</li>
</ul>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//defined Promise async function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(resolve) &#123;</span><br><span class="line">            resolve(<span class="comment">/*resolve parameter*/</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="comment">/*Error*/</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//use Promise&amp;then</span></span><br><span class="line">asyncFun().then(<span class="comment">/*function*/</span>).then(<span class="comment">/*function*/</span>)...</span><br></pre></td></tr></table></figure>

<h4 id="promise-特性"><a href="#promise-特性" class="headerlink" title="promise 特性"></a>promise 特性</h4><p>参考：<a target="_blank" rel="noopener" href="https://juejin.im/post/597724c26fb9a06bb75260e8">八段代码彻底掌握 Promise</a></p>
<h4 id="promise-里面-return-一个-string，和在-resolve-一个-string-的区别"><a href="#promise-里面-return-一个-string，和在-resolve-一个-string-的区别" class="headerlink" title="promise 里面 return 一个 string，和在 resolve 一个 string 的区别"></a>promise 里面 return 一个 string，和在 resolve 一个 string 的区别</h4><p>return 一个 string 后续的 then 不会执行; resolve 一个 string 会返回一个 promise 对象，对象的值是这个 string</p>
<h4 id="在-then-里面-throw-一个-error，怎么捕捉"><a href="#在-then-里面-throw-一个-error，怎么捕捉" class="headerlink" title="在 then 里面 throw 一个 error，怎么捕捉"></a>在 then 里面 throw 一个 error，怎么捕捉</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// throw 这个 error 后，在紧挨的下一个 then 中添加两个回调方法（ resolve 的，和 reject ）。</span></span><br><span class="line"><span class="comment">// 然后在第二个 reject 方法中可以捕获</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="string">&#x27;返回Promise&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第一个then&#x27;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;我是错误&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    resolve =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(resolve);</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;紧挨的失败&#x27;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;catch错误&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 第一个then</span></span><br><span class="line"><span class="comment">// 紧挨的失败</span></span><br><span class="line"><span class="comment">// Error: 我是错误</span></span><br><span class="line"><span class="comment">// at Promise.then.data (&lt;anonymous&gt;:6:15)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 then 的链式调用后添加一个 catch 来捕获</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="string">&#x27;返回Promise&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第一个then&#x27;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;我是错误&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;then错误&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;catch错误&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 第一个 then</span></span><br><span class="line"><span class="comment">// catch 错误</span></span><br><span class="line"><span class="comment">// Error: 我是错误</span></span><br><span class="line"><span class="comment">// at Promise.then.data</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-Promise-封装一个-url"><a href="#使用-Promise-封装一个-url" class="headerlink" title="使用 Promise 封装一个 url"></a>使用 Promise 封装一个 url</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="params">url</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">    xhr.onreadystatechange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// &lt;= 请求已完成，且响应已就绪</span></span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="comment">// &lt;= 状态OK</span></span><br><span class="line">          resolve(<span class="built_in">JSON</span>.parse(xhr.responseText));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请求失败&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">getJSON(url).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure>

<h4 id="在-Promise-链式调用中，怎样才能保证上一个-promise-出现报错不会影响到后续-then-的正常执行"><a href="#在-Promise-链式调用中，怎样才能保证上一个-promise-出现报错不会影响到后续-then-的正常执行" class="headerlink" title="在 Promise 链式调用中，怎样才能保证上一个 promise 出现报错不会影响到后续 .then 的正常执行"></a>在 Promise 链式调用中，怎样才能保证上一个 promise 出现报错不会影响到后续 .then 的正常执行</h4><p>为了不影响后续 .then 的执行，需要在每一个 then 中指定失败的回调</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> asyncFunc = <span class="function">() =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;123&#x27;</span>); <span class="comment">// 123, 二楼</span></span><br><span class="line">    <span class="comment">// throw new Error(&quot;出错了&quot;)    // Error: 出错了, 二楼</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">asyncFunc()</span><br><span class="line">  .then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;二楼&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="comment">// &lt;====== 指定失败的回调</span></span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;二楼&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Promise-构造函数是同步执行还是异步执行，那么-then-方法呢？"><a href="#Promise-构造函数是同步执行还是异步执行，那么-then-方法呢？" class="headerlink" title="Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？"></a>Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span> <span class="keyword">new</span>的时候会立即执行里面的代码 then是微任务 会在本次任务执行完的时候执行 <span class="built_in">setTimeout</span>是宏任务 会在下次任务执行的时候执行</span><br></pre></td></tr></table></figure>

<h3 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async / Await"></a>Async / Await</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><ul>
<li>async 用于声明一个异步的 function</li>
<li>await 用于等待一个异步方法执行完成</li>
</ul>
<h4 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h4><p>async 函数会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p>
<h4 id="Await"><a href="#Await" class="headerlink" title="Await"></a>Await</h4><p>await 是在等待一个 async 函数完成。不过按 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/await">语法说明</a> ，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;something&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello async&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> v1 = <span class="keyword">await</span> getSomething();</span><br><span class="line">  <span class="keyword">const</span> v2 = <span class="keyword">await</span> testAsync();</span><br><span class="line">  <span class="built_in">console</span>.log(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>让代码更易读</p>
<p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。</p>
<p>传统 promise ，链式调用 then 一个接一个</p>
<p>改用 async/await 后就像同步代码一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">&#x27;doIt&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">  step1(time1)</span><br><span class="line">    .then(<span class="function"><span class="params">time2</span> =&gt;</span> step2(time2))</span><br><span class="line">    .then(<span class="function"><span class="params">time3</span> =&gt;</span> step3(time3))</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;doIt&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">&#x27;doIt&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">  <span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);</span><br><span class="line">  <span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time2);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> step3(time3);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;doIt&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007535316">理解 JavaScript 的 async/await</a></p>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><h4 id="数组用法"><a href="#数组用法" class="headerlink" title="数组用法"></a>数组用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前后的形式必须完全一致 才可以完成结构赋值</span></span><br><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo; <span class="comment">// 1</span></span><br><span class="line">bar; <span class="comment">// 2</span></span><br><span class="line">baz; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [, , third] = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>];</span><br><span class="line">third; <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x; <span class="comment">// 1</span></span><br><span class="line">y; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head; <span class="comment">// 1</span></span><br><span class="line">tail; <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">x; <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y; <span class="comment">// undefined</span></span><br><span class="line">z; <span class="comment">// []</span></span><br><span class="line"><span class="comment">// 如果解构不成功，变量的值就等于undefined。</span></span><br></pre></td></tr></table></figure>

<h4 id="对象用法"><a href="#对象用法" class="headerlink" title="对象用法"></a>对象用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</span></span><br><span class="line">&#123;name, age&#125; = &#123;<span class="attr">name</span>:<span class="string">&#x27;wang&#x27;</span>,<span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">name <span class="comment">// wang</span></span><br><span class="line">age <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持别名</span></span><br><span class="line">&#123;<span class="attr">name</span>:nname, age&#125; = &#123;<span class="attr">name</span>:<span class="string">&#x27;wang&#x27;</span>,<span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">name <span class="comment">// &#x27;&#x27; 取别名时原名就会为空字符串</span></span><br><span class="line">nname <span class="comment">// wang</span></span><br><span class="line">age <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<h4 id="…运算符"><a href="#…运算符" class="headerlink" title="…运算符"></a>…运算符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">a; <span class="comment">// 1</span></span><br><span class="line">b; <span class="comment">// [2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="function">(<span class="params">...sum</span>) =&gt;</span> &#123;</span><br><span class="line">  sum.forEach(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">console</span>.log(item));</span><br><span class="line">&#125;;</span><br><span class="line">app(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 1,2,3,4</span></span><br><span class="line"><span class="comment">// 此运算符或得值为数组形式 主要用于替代函数中的 arguments(伪数组) 属性</span></span><br><span class="line"><span class="comment">// 这样可以非常方便的遍历获取到的未知个数的实参</span></span><br></pre></td></tr></table></figure>

<h3 id="函数中的-rest（剩余）参数"><a href="#函数中的-rest（剩余）参数" class="headerlink" title="函数中的 rest（剩余）参数"></a>函数中的 rest（剩余）参数</h3><blockquote>
<p><strong>剩余参数</strong>语法允许我们将一个不定数量的参数表示为一个数组。</p>
<p>——&gt; MDN - <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters">剩余参数</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.reduce(<span class="function">(<span class="params">previous, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> previous + current;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// expected output: 6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// expected output: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">multiplier, ...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.map(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> multiplier * element;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = multiply(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<h4 id="剩余参数和-arguments-对象的区别"><a href="#剩余参数和-arguments-对象的区别" class="headerlink" title="剩余参数和 arguments 对象的区别"></a>剩余参数和 arguments 对象的区别</h4><p>剩余参数和 <code>arguments</code> 对象之间的区别主要有三个：</p>
<ul>
<li><p>剩余参数只包含那些没有对应形参的实参，而 <code>arguments</code> 对象包含了传给函数的所有实参。</p>
</li>
<li><p><code>arguments</code> 对象不是一个真正的数组，而剩余参数是真正的 <code>Array</code> 实例，也就是说你能够在它上面直接使用所有的数组方法，比如 <code>sort</code>，<code>map</code>，<code>forEach</code> 或 <code>pop</code> 。</p>
</li>
<li><pre><code>arguments
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对象还有一些附加的属性 （如</span><br><span class="line"></span><br></pre></td></tr></table></figure>
callee
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  属性）。</span><br><span class="line"></span><br><span class="line">  - arguments.callee 属性包含当前正在执行的函数。</span><br><span class="line"></span><br><span class="line">### 模块化</span><br><span class="line"></span><br><span class="line">#### 模块化发展</span><br><span class="line"></span><br><span class="line">无模块化 –&gt; CommonJS 规范 –&gt; AMD 规范 –&gt; CMD 规范 –&gt; ES6 模块化</span><br><span class="line"></span><br><span class="line">#### 无模块劣势</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">&lt;script src&#x3D;&quot;jquery.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;jquery_scroller.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;main.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">被依赖的放在前面，否则使用就会报错</span><br><span class="line">污染全局作用域</span><br><span class="line">维护成本高</span><br><span class="line">依赖关系不明显</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="CommonJS-规范（NodeJS）"><a href="#CommonJS-规范（NodeJS）" class="headerlink" title="CommonJS 规范（NodeJS）"></a>CommonJS 规范（NodeJS）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块math.js</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; <span class="comment">//在这里写上需要向外暴露的函数、变量</span></span><br><span class="line">  add,</span><br><span class="line">  basicNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用自定义的模块时，参数包含路径，可省略.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>)</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用核心模块时，不需要带路径</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line">http.createService(...).listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<p><strong>exports 是对 module.exports 的引用</strong>。比如我们可以认为在一个模块的顶部有这句代码： <code>exports = module.exports</code> 所以，我们不能直接给 <code>exports</code> 赋值:</p>
<ul>
<li>✅ exports.foo = ‘bar’</li>
<li>❌ exports = {foo: ‘bar’} //error 这种方式是错误的，相当于重新定义了 exports</li>
</ul>
<p><strong>优点</strong></p>
<p>解决了依赖、全局变量污染的问题</p>
<p><strong>缺点</strong></p>
<p>CommonJS 用同步的方式加载模块，这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。所以<strong>不适合浏览器端模块加载</strong>，更合理的方案是使用异步加载。</p>
<h4 id="AMD-规范（RequireJS）"><a href="#AMD-规范（RequireJS）" class="headerlink" title="AMD 规范（RequireJS）"></a>AMD 规范（RequireJS）</h4><p>AMD 规范采用<strong>异步方式加载模块</strong>，模块的加载不影响它后面语句的运行。所有<strong>依赖这个模块的语句，都定义在一个回调函数中</strong>，等到加载完成之后，这个回调函数才会运行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 网页中引入 require.js 及 main.js **/</span></span><br><span class="line">&lt;script src=<span class="string">&quot;js/require.js&quot;</span> data-main=<span class="string">&quot;js/main&quot;</span>&gt;&lt;/script&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** main.js 入口文件/主模块 **/</span></span><br><span class="line"><span class="comment">// 首先用 config() 指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  baseUrl: <span class="string">&#x27;js/lib&#x27;</span>,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    jquery: <span class="string">&#x27;jquery.min&#x27;</span>, <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    underscore: <span class="string">&#x27;underscore.min&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行基本操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;underscore&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$, _</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<p>适合在浏览器环境中异步加载模块、并行加载多个模块</p>
<p><strong>缺点</strong></p>
<p>必须要<strong>提前加载所有的依赖</strong>，然后才可以使用，而不是需要使用时再加载。（<strong>不能按需加载</strong>）</p>
<h4 id="CMD（SeaJS）"><a href="#CMD（SeaJS）" class="headerlink" title="CMD（SeaJS）"></a>CMD（SeaJS）</h4><p>与 AMD 类似，不同点在于：</p>
<ul>
<li>AMD 推崇依赖前置、提前执行</li>
<li>CMD 推崇依赖就近、延迟执行。</li>
</ul>
<p><strong>CMD 与 AMD 区别</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** AMD写法 **/</span></span><br><span class="line">define([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c, d, e, f</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span></span><br><span class="line">    b.doSomething();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CMD写法 **/</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>); <span class="comment">//在需要时申明</span></span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line">    b.doSomething();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h4><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为<strong>浏览器和服务器通用</strong>的模块解决方案。其模块功能主要由两个命令构成： <code>export</code> 和 <code>import</code> 。 <code>export</code> 命令用于规定模块的对外接口，<code>import</code> 命令用于输入其他模块提供的功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 定义模块 math.js **/</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; basicNum, add &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 引用模块 **/</span></span><br><span class="line"><span class="keyword">import</span> &#123; basicNum, add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  ele.textContent = add(<span class="number">99</span> + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>es6 在导出的时候有一个默认导出， <code>export default</code> ，使用它导出后，在 import 的时候，不需要加上 {} ，模块名字可以随意起。该名字实际上就是个对象，包含导出模块里面的函数或者变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** export default **/</span></span><br><span class="line"><span class="comment">//定义输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; basicNum, add &#125;;</span><br><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  ele.textContent = math.add(<span class="number">99</span> + math.basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5aaa37c8f265da23945f365c">前端模块化：CommonJS,AMD,CMD,ES6</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b4420e7f265da0f4b7a7b27">这一次，我要弄懂 javascript 的模块化</a></li>
</ul>
<h4 id="模块化开发怎么做？"><a href="#模块化开发怎么做？" class="headerlink" title="模块化开发怎么做？"></a>模块化开发怎么做？</h4><p><a target="_blank" rel="noopener" href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">立即执行函数</a>,不暴露私有成员</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    m1,</span><br><span class="line">    m2</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h4 id="Ajax-是什么-如何创建一个-Ajax？"><a href="#Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="Ajax 是什么? 如何创建一个 Ajax？"></a>Ajax 是什么? 如何创建一个 Ajax？</h4><p>使用 JavaScript 异步获取数据，而且页面不会发生整页刷新的，提高了用户体验。</p>
<ol>
<li>创建 XMLHttpRequest 对象,也就是创建一个异步调用对象</li>
<li>创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息</li>
<li>设置响应 HTTP 请求状态变化的函数</li>
<li>发送 HTTP 请求</li>
<li>获取异步调用返回的数据</li>
<li>使用 JavaScript 和 DOM 实现局部刷新</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个 XMLHttpRequest 类型的对象 —— 相当于打开了一个浏览器</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 打开与一个网址之间的连接 —— 相当于在地址栏输入访问地址</span></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;news/list?type=gn&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 通过连接发送一次请求 —— 相当于回车或者点击访问发送请求</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST请求：</span></span><br><span class="line"><span class="comment">// xhr.open(&#x27;POST&#x27;, &#x27;login&#x27;, true)</span></span><br><span class="line"><span class="comment">// xhr.send(&#x27;username=admin&amp;password=admin&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 指定 xhr 状态变化事件处理函数 —— 相当于处理网页呈现后的操作</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 xhr 的 readyState 判断此次请求的响应是否接收完成</span></span><br><span class="line">  <span class="comment">// 4代表done</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过 xhr 的 responseText 获取到响应的响应体</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Ajax-原理"><a href="#Ajax-原理" class="headerlink" title="Ajax 原理"></a>Ajax 原理</h4><p>Ajax 的原理简单来说是在用户和服务器之间加了—个中间层（Ajax 引擎），通过 XMLHttpRequest 对象来向服务器发异步请求，从服务器获得数据，然后用 JavaScript 来操作 DOM 而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据</p>
<p>Ajax 的过程只涉及 JavaScript、XMLHttpRequest 和 DOM。XMLHttpRequest 是 Ajax 的核心机制。</p>
<h4 id="Ajax-解决浏览器缓存问题？"><a href="#Ajax-解决浏览器缓存问题？" class="headerlink" title="Ajax 解决浏览器缓存问题？"></a>Ajax 解决浏览器缓存问题？</h4><ol>
<li>在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)</li>
<li>在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)</li>
<li>在 URL 后面加上一个随机数： “fresh=” + Math.random()</li>
<li>在 URL 后面加上时间戳：”nowtime=” + new Date().getTime()</li>
</ol>
<h3 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h3><p>同源策略是浏览器的一种安全策略，所谓同源是指 <strong>域名，协议，端口</strong> 完全相同，只有同源的地址才可以相互通过 AJAX 的方式请求。</p>
<h3 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h3><h4 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h4><p>借助于 <code>script</code> 标签发送跨域请求的技巧</p>
<p><strong>原理</strong></p>
<p>css，script 标签允许跨域。客户端借助 <code>script</code> 标签请求服务端的一个动态网页（php 文件），服务端的这个动态网页返回一段带有函数调用的 JavaScript 全局函数调用的脚本，将原本需要返回给客户端的数据传递进去。</p>
<p>客户端：</p>
<ul>
<li>foo(…arr) {console.log(arr.join(“,”))} 定义方法，名称随便</li>
<li><ul>
<li>服务端会获取参数名 callback 的值 foo ，然后把数据扔进 foo 中调用</li>
<li>一旦数据返回，就相当于在调用上面的 foo</li>
</ul>
</li>
</ul>
<p>服务端：</p>
<ul>
<li>foo([‘我’, ‘是’, ‘你’, ‘原’, ‘本’, ‘需’, ‘要’, ‘的’, ‘数’, ‘据’])</li>
</ul>
<p><strong>特色</strong></p>
<ol>
<li>JSONP 需要服务端配合，服务端按照客户端的要求返回一段 JavaScript 调用客户端的函数</li>
<li>只能发送 GET 请求</li>
</ol>
<h4 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h4><p>服务端设置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端请求头设置：允许远端访问</span></span><br><span class="line">header(<span class="string">&#x27;Access‐Control‐Allow‐Origin: *&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种方案无需客户端作出任何变化（客户端不用改代码），只是在被请求的服务端响应的时候添加一个</span></span><br><span class="line"><span class="comment">// Access-Control-Allow-Origin  的响应头，表示这个资源是否允许指定域请求。</span></span><br></pre></td></tr></table></figure>

<p>如果跨域 + 发送 cookie：</p>
<ul>
<li>前端：withCredentials = true</li>
<li>后端：Access-Control-Allow-Origin 不为 * ，(Access-Control-Allow-Credentials, true)</li>
<li>如果还需要发送 post 请求：<ul>
<li>前端：<ul>
<li>post:[‘Content-Type’] = ‘application/x-www-form-urlencoded’;</li>
<li>qs.stringify(): 对象序列化成 URL 的形式，以 &amp; 进行拼接</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>除此之外，还可以通过前端设置代理实现跨域，原理是利用后端不存在跨域问题。比如可以在 <code>@vue/cli</code> 项目中新建 <code>vue.config.js</code> 文件来配置代理。如果你想了解更多这方面的设置，可以阅读我的这篇博客 <a href="https://evestorm.github.io/posts/15391/">Axios 异步请求跨域解决方案</a></p>
<h3 id="JSON-和-JSONP-的区别"><a href="#JSON-和-JSONP-的区别" class="headerlink" title="JSON 和 JSONP 的区别"></a>JSON 和 JSONP 的区别</h3><p>JSON 返回的是一串 JSON 格式数据；而 JSONP 返回的是脚本代码（包含一个函数调用）。</p>
<p>JSONP 的全名叫做 JSON with padding，就是把 JSON 对象用符合 JS 语法的形式包裹起来以使其他的网站可以请求到，也就是将 JSON 封装成 JS 文件传过去。</p>
<h3 id="defer-和-async-的区别"><a href="#defer-和-async-的区别" class="headerlink" title="defer 和 async 的区别"></a>defer 和 async 的区别</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/img/bVWhRl?w=801&h=814"><img src="JS%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%EF%BC%89/bVWhRl.png" alt="一图胜千言"></a></p>
<p>两者都是异步加载，但 defer 是按照加载顺序执行脚本的；async 则是无序加载脚本，例如 a.js 写在 b.js 前面，但如果 b.js 先加载完，则立即执行，不会等 a.js 的加载。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000000640869">https://segmentfault.com/q/1010000000640869</a></p>
<h3 id="preload-和-prefetch-的区别是什么？"><a href="#preload-和-prefetch-的区别是什么？" class="headerlink" title="preload 和 prefetch 的区别是什么？"></a>preload 和 prefetch 的区别是什么？</h3><p>对当前页面需要的资源，使用 preload 进行预加载，对其它页面需要的资源进行 prefetch 空闲加载。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对sty1e.cs5和 index.js进行pre1oad预加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;index.js&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对资源进行 prefetch预加载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;next.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;next.js&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="setTimeout、setInterval、requestAnimationFrame-各有什么特点？"><a href="#setTimeout、setInterval、requestAnimationFrame-各有什么特点？" class="headerlink" title="setTimeout、setInterval、requestAnimationFrame 各有什么特点？"></a>setTimeout、setInterval、requestAnimationFrame 各有什么特点？</h3><p><code>setTimeout</code> 和 <code>setInterval</code> 都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器 UI 线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。</p>
<p><code>requestAnimationFrame</code> 采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</p>
<h3 id="setTimeout-倒计时为什么会出现误差？"><a href="#setTimeout-倒计时为什么会出现误差？" class="headerlink" title="setTimeout 倒计时为什么会出现误差？"></a>setTimeout 倒计时为什么会出现误差？</h3><p><code>setTimeout()</code> 只是将事件插入了“任务队列”，必须等当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码消耗时间很长，也有可能要等很久，所以并没办法保证回调函数一定会在 setTimeout() 指定的时间执行。所以， <code>setTimeout()</code> 的第二个参数表示的是最少时间，并非是确切时间。</p>
<p>HTML5 标准规定了 <code>setTimeout()</code> 的第二个参数的最小值不得小于 4 毫秒，如果低于这个值，则默认是 4 毫秒。在此之前。老版本的浏览器都将最短时间设为 10 毫秒。另外，对于那些 DOM 的变动（尤其是涉及页面重新渲染的部分），通常是间隔 16 毫秒执行。这时使用 <code>requestAnimationFrame()</code> 的效果要好于 <code>setTimeout()</code>。</p>
<h3 id="简单解释单线程、任务队列的概念？"><a href="#简单解释单线程、任务队列的概念？" class="headerlink" title="简单解释单线程、任务队列的概念？"></a>简单解释单线程、任务队列的概念？</h3><p><strong>单线程：</strong></p>
<p>JavaScript 是浏览器用来与用户进行交互、进行 DOM 操作的，这也使得了它必须是单线程这一特性。</p>
<p>所谓单线程也就是只有一条线，一步一步走。</p>
<p><strong>任务队列：</strong></p>
<p>任务（消息）队列是一个先进先出的队列，它里面存放着各种任务（消息）。</p>
<p>在 JavaScript 中任务有两种，一种是同步任务，一种是异步任务。</p>
<ol>
<li>同步任务：各个任务按照文档定义的顺序一一推入“执行栈”中，当前一个任务执行完毕，才会开始执行下一个任务。</li>
<li>异步任务：各个任务推入“任务队列”中，只有在当前的所有同步任务执行完毕，才会将队列中的任务“出队”执行。</li>
</ol>
<p>当线程中没有执行任何同步代码的前提下才会执行异步代码。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="JSON-的了解"><a href="#JSON-的了解" class="headerlink" title="JSON 的了解"></a>JSON 的了解</h3><p>一种轻量级的数据交换格式。 它是基于 JavaScript 的一个子集。</p>
<p>数据格式简单、易于读写、占用带宽小。 e.g. {“age”:”12”, “name”:”back”}</p>
<p>JSON 读写的基本封装：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> storage = &#123;</span><br><span class="line">  set: <span class="function">(<span class="params">key, val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(key, <span class="built_in">JSON</span>.stringify(val));</span><br><span class="line">  &#125;,</span><br><span class="line">  get: <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(</span><br><span class="line">      <span class="built_in">localStorage</span>.getItem(key) === <span class="literal">null</span> ? <span class="string">&#x27;[]&#x27;</span> : <span class="built_in">localStorage</span>.getItem(key)</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  remove: <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">localStorage</span>.removeItem(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> storage;</span><br></pre></td></tr></table></figure>

<h4 id="JSON-方法的缺点"><a href="#JSON-方法的缺点" class="headerlink" title="JSON 方法的缺点"></a>JSON 方法的缺点</h4><ul>
<li>不能复制 function、正则、Symbol</li>
<li>循环引用报错</li>
<li>相同的引用会被重复复制</li>
</ul>
<h2 id="概念性问题"><a href="#概念性问题" class="headerlink" title="概念性问题"></a>概念性问题</h2><h3 id="你理解的面向对象"><a href="#你理解的面向对象" class="headerlink" title="你理解的面向对象"></a>你理解的面向对象</h3><p>一种编程开发思想。是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。</p>
<h3 id="什么叫优雅降级和渐进增强？"><a href="#什么叫优雅降级和渐进增强？" class="headerlink" title="什么叫优雅降级和渐进增强？"></a>什么叫优雅降级和渐进增强？</h3><ul>
<li>优雅降级：Web 站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的 IE 进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。 如：border-shadow</li>
<li>渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 如：默认使用 flash 上传，但如果浏览器支持 HTML5 的文件上传功能，则使用 HTML5 实现更好的体验</li>
</ul>
<h3 id="compose-函数-❌"><a href="#compose-函数-❌" class="headerlink" title="compose 函数 ❌"></a>compose 函数 ❌</h3><h3 id="函数柯里化-❌"><a href="#函数柯里化-❌" class="headerlink" title="函数柯里化 ❌"></a>函数柯里化 ❌</h3>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/55598/" rel="prev" title="HTML知识点（面试系列）">
                  <i class="fa fa-chevron-left"></i> HTML知识点（面试系列）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/4115/" rel="next" title="JS笔试题（面试系列）">
                  JS笔试题（面试系列） <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments">
    <div id="SOHUCS"></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lance</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  

<script src="/js/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






  <script>
  NexT.utils.loadComments('#SOHUCS', () => {
    NexT.utils.getScript('https://changyan.sohu.com/upload/changyan.js', () => {
      window.changyan.api.config({
        appid: 'cyvaqAKVv',
        conf : 'c7535289deb20d0d9235ebae6a69b912'
      });
    });
  });
  </script>
  <script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>

</body>
</html>
