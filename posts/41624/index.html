<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"evestorm.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="关键渲染路径What关键渲染路径（Critical Rendering Path）指的是：「浏览器所经历的一系列步骤，从而将 HTML、CSS 和 JavaScript 转换为在屏幕上呈现的像素内容」我们要做的，就是优化关键渲染路径，这样就能提高网页呈现的速度，从而使用户和老板更满意。 网页生成过程说白了，「关键渲染路径」即「网页生成的过程」，简要概述就是：  处理 HTML 标记并构建 DOM">
<meta property="og:type" content="article">
<meta property="og:title" content="网站性能优化">
<meta property="og:url" content="https://evestorm.github.io/posts/41624/index.html">
<meta property="og:site_name" content="EVE | 暴风雨前夕">
<meta property="og:description" content="关键渲染路径What关键渲染路径（Critical Rendering Path）指的是：「浏览器所经历的一系列步骤，从而将 HTML、CSS 和 JavaScript 转换为在屏幕上呈现的像素内容」我们要做的，就是优化关键渲染路径，这样就能提高网页呈现的速度，从而使用户和老板更满意。 网页生成过程说白了，「关键渲染路径」即「网页生成的过程」，简要概述就是：  处理 HTML 标记并构建 DOM">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-05-10T11:48:05.000Z">
<meta property="article:modified_time" content="2020-12-17T12:17:39.056Z">
<meta property="article:author" content="Lance">
<meta property="article:tag" content="性能优化">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://evestorm.github.io/posts/41624/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>网站性能优化 | EVE | 暴风雨前夕</title>
  


  <script>
    !function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.growingio.com/2.1/gio.js","gio");
    gio('init', 'cc683d67407a283ba8d0382c43e8ca28', {});
    gio('send');
  </script>

  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">EVE | 暴风雨前夕</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Lance的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="nav-number">1.</span> <span class="nav-text">关键渲染路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#What"><span class="nav-number">1.1.</span> <span class="nav-text">What</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">网页生成过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86-HTML-%E8%BD%AC%E4%B8%BA-DOM"><span class="nav-number">1.2.1.</span> <span class="nav-text">将 HTML 转为 DOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86-CSS-%E8%BD%AC%E4%B8%BA-CSSOM"><span class="nav-number">1.2.2.</span> <span class="nav-text">将 CSS 转为 CSSOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E6%B8%B2%E6%9F%93%E6%A0%91"><span class="nav-number">1.2.3.</span> <span class="nav-text">合并渲染树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B1%80%E4%B8%8E%E7%BB%98%E5%88%B6"><span class="nav-number">1.2.4.</span> <span class="nav-text">布局与绘制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">网页加载的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96-DOM"><span class="nav-number">2.1.</span> <span class="nav-text">优化 DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9-%E5%88%A0%E9%99%A4%E6%B3%A8%E9%87%8A"><span class="nav-number">2.1.1.</span> <span class="nav-text">压缩+删除注释</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96-CSSOM"><span class="nav-number">2.2.</span> <span class="nav-text">优化 CSSOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9-%E5%88%A0%E9%99%A4%E6%B3%A8%E9%87%8A-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">压缩+删除注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94-CSS"><span class="nav-number">2.2.2.</span> <span class="nav-text">内联 CSS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-Media-%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.2.3.</span> <span class="nav-text">利用 Media 媒体查询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96-JavaScript"><span class="nav-number">2.3.</span> <span class="nav-text">优化 JavaScript</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#window-onload"><span class="nav-number">2.3.1.</span> <span class="nav-text">window.onload</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer-async"><span class="nav-number">2.3.2.</span> <span class="nav-text">defer &#x2F; async</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-%E7%BC%93%E5%AD%98"><span class="nav-number">2.4.</span> <span class="nav-text">HTTP 缓存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">渲染性能的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%83%8F%E7%B4%A0%E7%AE%A1%E9%81%93"><span class="nav-number">3.1.</span> <span class="nav-text">像素管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-requestAnimationFrame"><span class="nav-number">3.2.</span> <span class="nav-text">使用 requestAnimationFrame</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E9%87%8D%E6%8E%92%E4%B8%8E%E9%87%8D%E7%BB%98"><span class="nav-number">3.3.</span> <span class="nav-text">避免重排与重绘</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#What-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">What</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E9%98%9F%E5%88%97"><span class="nav-number">3.3.2.</span> <span class="nav-text">浏览器的渲染队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E5%88%B7%E6%96%B0%E9%98%9F%E5%88%97"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">强制刷新队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%8E%92%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="nav-number">3.3.3.</span> <span class="nav-text">重排优化建议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">分离读写操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E5%BC%8F%E9%9B%86%E4%B8%AD%E6%94%B9%E5%8F%98"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">样式集中改变</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%B8%83%E5%B1%80%E4%BF%A1%E6%81%AF"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">缓存布局信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A6%BB%E7%BA%BF%E6%94%B9%E5%8F%98-dom"><span class="nav-number">3.3.3.4.</span> <span class="nav-text">离线改变 dom</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#position-%E5%B1%9E%E6%80%A7%E4%B8%BA-absolute-%E6%88%96-fixed"><span class="nav-number">3.3.3.5.</span> <span class="nav-text">position 属性为 absolute 或 fixed</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%8A%A8%E7%94%BB"><span class="nav-number">3.3.3.6.</span> <span class="nav-text">优化动画</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90"><span class="nav-number">4.</span> <span class="nav-text">参考资源</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lance"
      src="/uploads/avatar_lance.jpeg">
  <p class="site-author-name" itemprop="name">Lance</p>
  <div class="site-description" itemprop="description">Front-end developer and iOS developer</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">229</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">77</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/evestorm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;evestorm" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1572534835@qq.com" title="E-Mail → mailto:1572534835@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://evestorm.github.io/posts/41624/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar_lance.jpeg">
      <meta itemprop="name" content="Lance">
      <meta itemprop="description" content="Front-end developer and iOS developer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EVE | 暴风雨前夕">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          网站性能优化
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-10 19:48:05" itemprop="dateCreated datePublished" datetime="2019-05-10T19:48:05+08:00">2019-05-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-17 20:17:39" itemprop="dateModified" datetime="2020-12-17T20:17:39+08:00">2020-12-17</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">性能优化</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    
      <a title="changyan" href="/posts/41624/#SOHUCS" itemprop="discussionUrl">
        <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="posts/41624/" itemprop="commentCount"></span>
      </a>
    
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="关键渲染路径"><a href="#关键渲染路径" class="headerlink" title="关键渲染路径"></a>关键渲染路径</h1><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>关键渲染路径（Critical Rendering Path）指的是：<br>「浏览器所经历的一系列步骤，从而将 HTML、CSS 和 JavaScript 转换为在屏幕上呈现的像素内容」<br>我们要做的，就是<strong>优化关键渲染路径</strong>，这样就能提高网页呈现的速度，从而使用户和老板更满意。</p>
<h2 id="网页生成过程"><a href="#网页生成过程" class="headerlink" title="网页生成过程"></a>网页生成过程</h2><p>说白了，「关键渲染路径」即「网页生成的过程」，简要概述就是：</p>
<ol>
<li>处理 HTML 标记并构建 DOM 树</li>
<li>处理 CSS 标记并构建 CSSOM 树</li>
<li>将 DOM 与 CSSOM 合并成一个渲染树</li>
<li>根据渲染树来布局，以计算每个节点的几何信息</li>
<li>将各个节点绘制到屏幕上</li>
</ol>


<a id="more"></a>

<h3 id="将-HTML-转为-DOM"><a href="#将-HTML-转为-DOM" class="headerlink" title="将 HTML 转为 DOM"></a>将 HTML 转为 DOM</h3><p>文档对象模型（DOM）存储的是「页面内容」及每个节点「属性方面的数据」。DOM 中对象之间的关系展示了父子节点以及兄弟节点。</p>
<p><strong>注意</strong>：<br>DOM 的构建过程是逐步实现的，意味着一旦获得了 HTML 就可以开始构建 DOM 了，<strong>不需要</strong>等待整个 HTML 页面加载完毕后再去构建 DOM 。</p>


<h3 id="将-CSS-转为-CSSOM"><a href="#将-CSS-转为-CSSOM" class="headerlink" title="将 CSS 转为 CSSOM"></a>将 CSS 转为 CSSOM</h3>

<h3 id="合并渲染树"><a href="#合并渲染树" class="headerlink" title="合并渲染树"></a>合并渲染树</h3><p>完成了 DOM 树和 CSSOM 树的构建以后，就要将它们合并成一个渲染树。</p>
<p><strong>注意：</strong><br>某些节点如果通过 CSS 隐藏，那么在渲染树中也会被忽略，例如我们在 HTML 中编写的 span 节点，它就不会出现在渲染树中。因为有一个 CSS 规则在 span 上设置了 <code>display: none</code> 属性。</p>


<h3 id="布局与绘制"><a href="#布局与绘制" class="headerlink" title="布局与绘制"></a>布局与绘制</h3><p>在渲染树构建阶段，我们已经计算了哪些节点应该是可见的以及它们的计算样式，所以在布局阶段，我们就需要计算它们在设备视口内的确切位置和大小。这个过程称为布局，或者叫做重排。</p>
<p>最后，既然我们知道了哪些节点可见、它们的计算样式以及几何信息，我们终于可以将这些信息传递给最后一个阶段：将渲染树中的每个节点转换成屏幕上的实际像素。这一步通常称为“绘制”或“栅格化”。到此，浏览器对网页的第一次生成过程已经结束。</p>
<p>而我们的前端网站性能优化，也就是针对整个「关键渲染路径」而言的。只有<strong>最大限度的缩短上面第 1 至 5 步耗费的总时间，</strong>才能尽快的将内容渲染到屏幕上，此外还能缩短首屏的加载时间。</p>
<h1 id="网页加载的优化"><a href="#网页加载的优化" class="headerlink" title="网页加载的优化"></a>网页加载的优化</h1><h2 id="优化-DOM"><a href="#优化-DOM" class="headerlink" title="优化 DOM"></a>优化 DOM</h2><h3 id="压缩-删除注释"><a href="#压缩-删除注释" class="headerlink" title="压缩+删除注释"></a>压缩+删除注释</h3><p>为了将 HTML 文件尽可能快的传输给浏览器（客户端），我们需要压缩文件的大小，例如下面 html 文件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="comment">/* reset */</span></span></span><br><span class="line">      * &#123;</span><br><span class="line">        padding: 0;</span><br><span class="line">        margin: 0;</span><br><span class="line">        list-style: none;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 头部 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 正文 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 底部 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段代码包含了非常多的注释，这些注释对开发者来说可能有用，然而浏览器在遇到注释时却会忽略它们的，所以根本没必要展示给浏览器，我们完全可以移除它们。另外空格和换行也是个大问题，它会增加我们文件的体积，所以我们需要利用一些工具去压缩它。</p>


<p>上图是在删除掉所有注释，并使用 <a target="_blank" rel="noopener" href="http://tool.chinaz.com/tools/jsformat.aspx">在线 JS 压缩工具</a> 压缩后的文件大小对比。当然，这种策略同样适用于 CSS 文件，你可以使用类似的步骤对 CSS 进行注释的删除与压缩。</p>
<p>如果你使用 webpack 构建你的应用，你可以使用下面插件来优化 html、css 和 js：</p>
<ul>
<li>optimize-css-assets-webpack-plugin（优化 css）</li>
<li>html-webpack-plugin（配置与优化 html）</li>
<li>webpack-parallel-uglify-plugin（优化 js）</li>
</ul>
<h2 id="优化-CSSOM"><a href="#优化-CSSOM" class="headerlink" title="优化 CSSOM"></a>优化 CSSOM</h2><p>CSS 在默认情况下是<strong>阻塞渲染</strong>的一类资源，也就是说浏览器在 CSSOM 构建完成以前是<strong>不会渲染任何已处理</strong>的内容的，所以我们必须对 CSS 进行精简。<br>由于浏览器必须同时具有 DOM 以及 CSSOM 才能构建渲染树，所以 <strong>HTML 和 CSS 都是阻塞渲染的资源。</strong>刚才已经针对 HTML 进行了优化，现在该轮到 CSS 了。</p>
<h3 id="压缩-删除注释-1"><a href="#压缩-删除注释-1" class="headerlink" title="压缩+删除注释"></a>压缩+删除注释</h3><p>这一点不多赘述，参考上面 html 的优化步骤。</p>
<h3 id="内联-CSS"><a href="#内联-CSS" class="headerlink" title="内联 CSS"></a>内联 CSS</h3><p>如果你的 css 文件很小，小到仅有几十甚至几 KB，那么你完全可以将 css 内联进 html ，因为相比使用 link 外链还得发一个请求，内联的代价要小的多得多。</p>
<h3 id="利用-Media-媒体查询"><a href="#利用-Media-媒体查询" class="headerlink" title="利用 Media 媒体查询"></a>利用 Media 媒体查询</h3><p>有时候一些 CSS 样式只在特定条件下使用，比如打印网页或者网页在大型显示器上显示时。这个时候我们的 media 媒体查询就能大显身手了，它能让这些特定的 CSS 资源不去阻塞页面的渲染。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;print.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;other.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(min-width: 980px)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子在我们的项目中很常见，第一个样式表适用于所有情况，它始终会阻塞渲染。但第二个样式表则不然，它只在打印内容时适用，因此在网页首次加载时，该样式表不需要阻塞渲染。最后一个样式表声明则只在特定环境下被执行，一旦不符合最小宽度大于 980px，则始终不会被加载，这样我们就又少了一个不阻塞页面渲染的 CSS 资源。</p>
<p><strong>注意：</strong></p>
<ol>
<li>「阻塞渲染」仅是指浏览器是否需要暂停网页的首次渲染，直至该资源准备就绪。无论哪一种情况，浏览器仍会下载 CSS 资源，只不过不阻塞渲染的资源优先级较低罢了。</li>
<li>CSS 会造成阻塞吗？<ol>
<li>css 加载不会阻塞 DOM 树的解析</li>
<li>css 加载会阻塞 DOM 树也就是页面的渲染</li>
<li>css 加载会阻塞后面 js 语句的执行</li>
<li>css 加载不阻塞外部脚本的加载<br>了解更多：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenjg/p/7126822.html">https://www.cnblogs.com/chenjg/p/7126822.html</a></li>
</ol>
</li>
</ol>
<h2 id="优化-JavaScript"><a href="#优化-JavaScript" class="headerlink" title="优化 JavaScript"></a>优化 JavaScript</h2><p>默认情况下，无论内联还是外联，浏览器遇到文档中的 JavaScript 时都会暂停 DOM 构建，并立即开始执行 JavaScript ，等到脚本执行完毕后，再继续构建 DOM。所以为了提高页面渲染速度，我们可以让 JavaScript 异步执行。</p>
<h3 id="window-onload"><a href="#window-onload" class="headerlink" title="window.onload"></a>window.onload</h3><p>这种解决方案是让脚本在网页加载完毕后再执行。当网页加载完毕后，浏览器会发出 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onload">onload</a> 事件，我们可以将 JavaScript 放进 onload 事件的回调函数中，这样当 onload 事件被触发后，就能执行我们的脚本了，示例如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        init();</span><br><span class="line">        doSomethingElse();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onload = load;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="defer-async"><a href="#defer-async" class="headerlink" title="defer / async"></a>defer / async</h3><p>我们还可以向 script 标签添加异步关键字，那样可以让浏览器在等待脚本期间不阻止 DOM 以及 CSSOM 的构建。</p>
<p>而关于 defer 和 async 的区别，一图胜千言：</p>


<p>（出处：<a target="_blank" rel="noopener" href="https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html%EF%BC%89">https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html）</a></p>
<p>简单来说，当浏览器遇到 script 脚本的时候：</p>
<ol>
<li><code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br>没有 <code>defer</code> 或 <code>async</code>，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 <code>script</code> 标签之下的文档元素之前，即不等待后续载入的文档元素，读到就加载并执行。</li>
<li><code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br>有 <code>async</code>，加载和渲染后续文档元素的过程将和 <code>script.js</code> 的加载与执行并行进行（异步）。</li>
<li><code>&lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt;</code><br>有 <code>defer</code>，加载后续文档元素的过程将和 <code>script.js</code> 的加载并行进行（异步），但是 <code>script.js</code> 的执行要在所有元素解析完成之后，<code>DOMContentLoaded</code> 事件触发之前完成。</li>
</ol>
<p><strong>注意：</strong><br>HTML5 规定，defer 脚本最后的延迟执行应该按照书写顺序来执行，即下面示例脚本，a.js 一定在 b.js 前面执行：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;./js/a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;./js/b.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但在 「JavaScript 高级程序设计（第三版）」中作者表示：</p>
<blockquote>
<p>在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 <code>DOMContentLoaded</code> 事件触发前执行，因此最好只包含一个延迟脚本。</p>
</blockquote>
<p>我个人是试验过各种浏览器的，Chrome、Firefox、Safari，没有出现作者所说的情况。所以我猜测作者写上这一句话的原因是：即使在 HTML5 规范中有这么一条，不一定所有的浏览器厂商都会遵照这个规定，可能某些浏览器厂商并没有实现这个规范，所以为了安全起见，在开发中使用一个 defer 是非常有必要的。</p>
<h2 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h2><p>这部分内容可以点击<a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching">此处查看</a></p>
<h1 id="渲染性能的优化"><a href="#渲染性能的优化" class="headerlink" title="渲染性能的优化"></a>渲染性能的优化</h1><p>页面不仅要快速加载，而且要顺畅地运行；例如列表页的滚动应与手指的滑动一样快，侧边栏的弹出隐藏动画应如丝绸般顺滑。<br>所以除了对关键渲染路径的优化以外，我们还得确保自己编写的代码能（包括其他第三方代码）更高效地运行。</p>
<h2 id="像素管道"><a href="#像素管道" class="headerlink" title="像素管道"></a>像素管道</h2><p>首先我们要了解下「像素管道」的概念。像素管道是「网页从像素到屏幕」的一系列关键节点：</p>


<ul>
<li>JavaScript：指的是使用 JavaScript 来实现一些视觉变化的效果。（e.g. 给页面添加 DOM 元素）</li>
<li>样式计算：指的是根据「匹配选择器」计算出元素所应用的 CSS 规则的过程。</li>
<li>布局：指的是浏览器根据元素所应用的规则计算它们要占据的空间大小及其在屏幕的位置。</li>
<li>绘制：指的是填充像素的过程。（e.g. 绘制文本、颜色、边框和阴影，基本上包括元素的每个可视部分）绘制一般是在多个层上完成的。</li>
<li>合成：由于页面的各部分可能被绘制到多层，所以它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。</li>
</ul>
<p>我们在编写代码的时候要时刻注意这五个关键节点，因为其中的每一个部分都可能为我们的应用带来“卡顿”。</p>
<h2 id="使用-requestAnimationFrame"><a href="#使用-requestAnimationFrame" class="headerlink" title="使用 requestAnimationFrame"></a>使用 requestAnimationFrame</h2><p>试想一下，假设现在浏览器正在执行有关样式方面的工作，然后出现了需要处理的 JavaScript 。这个时候浏览器会马上停下手中的活儿，转而执行插进来的 JavaScript ，然而新来的 JavaScript 是有可能导致刚才处理的样式工作重新返工的（配合上面的「管道图」来看，相当于 style 阶段完成后却执行了 JavaScript ，导致丢帧），这样一来浏览器就很有可能丢失了刚才处理完的这一帧，从而导致卡顿现象。所以没错，当你在使用 JavaScript 编写一段动画时，可以使用 RequestAnimationFrame API，该 API 能够提升我们的动画流畅度，因为它会安排 JavaScript 尽早在每一帧的开始执行，这样尽量给浏览器留出足够的时间来运行代码，然后是样式过程——&gt;布局过程——&gt;绘制过程——&gt;渲染层合并过程。示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animationWidth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">  div.style.width = <span class="built_in">parseInt</span>(div.style.width) + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">parseInt</span>(div.style.width) &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    requestAnimationFrame(animationWidth);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(animationWidth);</span><br></pre></td></tr></table></figure>

<h2 id="避免重排与重绘"><a href="#避免重排与重绘" class="headerlink" title="避免重排与重绘"></a>避免重排与重绘</h2><h3 id="What-1"><a href="#What-1" class="headerlink" title="What"></a>What</h3><ul>
<li><strong>重排：</strong>当 DOM 的变化影响了元素的几何信息（DOM 对象的<strong>位置和尺寸大小</strong>），浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。</li>
<li><strong>重绘：</strong>当一个元素更改了<strong>非几何属性</strong>（e.g. 背景、文本或阴影），但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。</li>
</ul>
<h3 id="浏览器的渲染队列"><a href="#浏览器的渲染队列" class="headerlink" title="浏览器的渲染队列"></a>浏览器的渲染队列</h3><p>思考以下代码将会触发几次渲染？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.style.left = <span class="string">&#x27;10px&#x27;</span>;</span><br><span class="line">div.style.top = <span class="string">&#x27;10px&#x27;</span>;</span><br><span class="line">div.style.width = <span class="string">&#x27;20px&#x27;</span>;</span><br><span class="line">div.style.height = <span class="string">&#x27;20px&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>根据我们上文的定义，这段代码理论上会触发 4 次重排+重绘，因为每一次都改变了元素的几何属性。但实际上最后只触发了一次重排，这都得益于浏览器的<strong>渲染队列机制</strong>：<br>当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了<strong>一定的数量或者到了一定的时间间隔</strong>时，浏览器就会批量执行这些操作。</p>
<h4 id="强制刷新队列"><a href="#强制刷新队列" class="headerlink" title="强制刷新队列"></a>强制刷新队列</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div.style.left = &#x27;10px&#x27;;</span><br><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">div</span><span class="selector-class">.offsetLeft</span>);</span><br><span class="line">div.style.top = &#x27;10px&#x27;;</span><br><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">div</span><span class="selector-class">.offsetTop</span>);</span><br><span class="line">div.style.width = &#x27;20px&#x27;;</span><br><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">div</span><span class="selector-class">.offsetWidth</span>);</span><br><span class="line">div.style.height = &#x27;20px&#x27;;</span><br><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">div</span><span class="selector-class">.offsetHeight</span>);</span><br></pre></td></tr></table></figure>

<p>这段代码会触发 4 次重排+重绘，因为在<code>console</code>中你请求的这几个样式信息，无论何时浏览器都会立即执行渲染队列的任务，即使该值与你操作中修改的值没关联。<br><strong>因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘</strong>。<br><strong>强制刷新队列的 style 样式请求</strong>：</p>
<ol>
<li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li>
<li>scrollTop, scrollLeft, scrollWidth, scrollHeight</li>
<li>clientTop, clientLeft, clientWidth, clientHeight</li>
<li>getComputedStyle(), 或者 IE 的 currentStyle</li>
</ol>
<p><strong>所以我们在开发中，应该谨慎的使用这些 style 请求，注意上下文关系，避免一行代码一个重排，这对性能是个巨大的消耗。</strong></p>
<h3 id="重排优化建议"><a href="#重排优化建议" class="headerlink" title="重排优化建议"></a>重排优化建议</h3><h4 id="分离读写操作"><a href="#分离读写操作" class="headerlink" title="分离读写操作"></a>分离读写操作</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div.style.left = &#x27;10px&#x27;;</span><br><span class="line">div.style.top = &#x27;10px&#x27;;</span><br><span class="line">div.style.width = &#x27;20px&#x27;;</span><br><span class="line">div.style.height = &#x27;20px&#x27;;</span><br><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">div</span><span class="selector-class">.offsetLeft</span>);</span><br><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">div</span><span class="selector-class">.offsetTop</span>);</span><br><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">div</span><span class="selector-class">.offsetWidth</span>);</span><br><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">div</span><span class="selector-class">.offsetHeight</span>);</span><br></pre></td></tr></table></figure>

<p>还是上面触发 4 次重排+重绘的代码，这次只触发了一次重排：<br>在第一个<code>console</code>的时候，浏览器把之前上面四个写操作的渲染队列都给清空了。剩下的 console，因为渲染队列本来就是空的，所以并没有触发重排，仅仅拿值而已。</p>
<h4 id="样式集中改变"><a href="#样式集中改变" class="headerlink" title="样式集中改变"></a>样式集中改变</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.style.left = <span class="string">&#x27;10px&#x27;</span>;</span><br><span class="line">div.style.top = <span class="string">&#x27;10px&#x27;</span>;</span><br><span class="line">div.style.width = <span class="string">&#x27;20px&#x27;</span>;</span><br><span class="line">div.style.height = <span class="string">&#x27;20px&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>虽然现在大部分浏览器有渲染队列优化，不排除有些浏览器以及老版本的浏览器效率仍然低下。</p>
<p>建议通过改变 class 或者 csstext 属性集中改变样式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> left = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> top = <span class="number">10</span>;</span><br><span class="line">el.style.left = left + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">el.style.top = top + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">el.className += <span class="string">&#x27; theclassname&#x27;</span>;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">el.style.cssText += <span class="string">&#x27;; left: &#x27;</span> + left + <span class="string">&#x27;px; top: &#x27;</span> + top + <span class="string">&#x27;px;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="缓存布局信息"><a href="#缓存布局信息" class="headerlink" title="缓存布局信息"></a>缓存布局信息</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad 强制刷新 触发两次重排</span></span><br><span class="line">div.style.left = div.offsetLeft + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.style.top = div.offsetTop + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"><span class="comment">// good 缓存布局信息 相当于读写分离</span></span><br><span class="line"><span class="keyword">var</span> curLeft = div.offsetLeft;</span><br><span class="line"><span class="keyword">var</span> curTop = div.offsetTop;</span><br><span class="line">div.style.left = curLeft + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.style.top = curTop + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="离线改变-dom"><a href="#离线改变-dom" class="headerlink" title="离线改变 dom"></a>离线改变 dom</h4><ul>
<li>隐藏要操作的 dom<br>在要操作 dom 之前，通过 display 隐藏 dom ，当操作完成之后，才将元素的 display 属性为可见，因为不可见的元素不会触发重排和重绘。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dom.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line"><span class="comment">// 修改dom样式</span></span><br><span class="line">dom.display = <span class="string">&#x27;block&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment">DocumentFragment</a> 创建一个 <code>dom</code> 碎片,在它上面批量操作 dom ，操作完成之后，再添加到文档中，这样只会触发一次重排。</li>
<li>复制节点，在副本上工作，然后替换它！</li>
</ul>
<h4 id="position-属性为-absolute-或-fixed"><a href="#position-属性为-absolute-或-fixed" class="headerlink" title="position 属性为 absolute 或 fixed"></a>position 属性为 absolute 或 fixed</h4><p>position 属性为 absolute 或 fixed 的元素，重排开销比较小，不用考虑它对其他元素的影响</p>
<h4 id="优化动画"><a href="#优化动画" class="headerlink" title="优化动画"></a>优化动画</h4><ul>
<li>可以把动画效果应用到 position 属性为 absolute 或 fixed 的元素上，这样对其他元素影响较小<br>动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量：<br>比如实现一个动画，以 1 个像素为单位移动这样最平滑，但是 reflow 就会过于频繁，大量消耗 CPU 资源，如果以 3 个像素为单位移动则会好很多。</li>
<li>启用 GPU 加速<br>此部分来自<a target="_blank" rel="noopener" href="http://caibaojian.com/css-reflow-repaint.html">优化 CSS 重排重绘与浏览器性能</a><br><strong>GPU（图像加速器）：</strong><br>GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成，因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。<br>GPU 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3 转换（transitions），CSS3 3D 变换（transforms），WebGL 和视频(video)。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据上面的结论</span></span><br><span class="line"><span class="comment"> * 将 2d transform 换成 3d</span></span><br><span class="line"><span class="comment"> * 就可以强制开启 GPU 加速</span></span><br><span class="line"><span class="comment"> * 提高动画性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">10px</span>, <span class="number">10px</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 又或者使用 will-change 属性来创建新层 */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">will-change</span>: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><ul>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/why-performance-matters/">Google Web Fundamentals - Performance</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenjg/p/7126822.html">css 加载会造成阻塞吗？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html">async vs defer attributes</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag"><i class="fa fa-tag"></i> 性能优化</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/61492/" rel="prev" title="转载-Event Loop、计时器、nextTick">
                  <i class="fa fa-chevron-left"></i> 转载-Event Loop、计时器、nextTick
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/7498/" rel="next" title="Vue使用全局filter">
                  Vue使用全局filter <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments">
    <div id="SOHUCS"></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lance</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  

<script src="/js/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






  <script>
  NexT.utils.loadComments('#SOHUCS', () => {
    NexT.utils.getScript('https://changyan.sohu.com/upload/changyan.js', () => {
      window.changyan.api.config({
        appid: 'cyvaqAKVv',
        conf : 'c7535289deb20d0d9235ebae6a69b912'
      });
    });
  });
  </script>
  <script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/clipboard.min.js"></script>  
<script type="text/javascript" src="/js/clipboard-use.js"></script>
</body>
</html>
