<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vscode自定义snippet片段]]></title>
    <url>%2Fposts%2F17235%2F</url>
    <content type="text"><![CDATA[最近我有个需求，想要在 github 上使用 markdown 语法时居中图片，然而搜了几种办法都无效，最后在 DavidWells 的 gist 中找到了答案（p.s. 如果无法翻墙，你还可以参考 这篇博客） 解决了一个问题又出现了另一个，其实我已经把博客写完了，但其中需要居中的图片比较多，而居中代码还比较繁琐，要是一个个手动替换也太麻烦了。然后就想到了使用 snippet ，官网教程在这里：Creating your own snippets 具体该如何实现呢： Code → 首选项 → 用户代码片段 在弹出的下拉列表中输入你想要在哪种文件中使用这种片段（例如我只希望在 markdown 文件中使用，就键入 markdown） 此时 vs code 就会帮我们自动新建一个名为 markdown.json 的文件，我们在这个 json 文件中定义我们的代码片段就好了 接着我们进入该文件，编写 snippet 配置： 1234567891011&#123; "Img centered": &#123; "prefix": "mimg", "body": [ "&lt;div align=center&gt;", "\t&lt;img src='$1' alt='$2' width='$3'&gt;", "&lt;/div&gt;" ], "description": "Centered image in markdown" &#125;&#125; 然而当我保存后在 md 文件中使用时，按下 tab 并没有效果，经过阅读官方文档，发现有这样一句话：Enable it with &quot;editor.tabCompletion&quot;: &quot;on&quot;, type a snippet prefix, and press Tab to insert a snippet. 所以你还需要进入 首选项 → 设置 ，在顶部输入框键入 editor.tabCompletion 来搜索此配置，将 off 改为 on 就 OK 了 现在大功告成，在 md 文件中，键入 mimg 后按下 tab 键，先前写好的 snippet 就能够使用了 结语：关于 vs code 的 snippet 片段，网上非常多教程，大家自行搜索就好，这篇笔记的重点是上方第 6 步把 editor.tabCompletion 改为 on 。这一步至关重要，不修改会导致你以为自己的 snippet 设置没生效。]]></content>
      <categories>
        <category>其他</category>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器知识点（面试系列）]]></title>
    <url>%2Fposts%2F38402%2F</url>
    <content type="text"><![CDATA[浏览器介绍一下你对浏览器内核的理解主要分成两部分： 渲染引擎(Layout engineer 或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 详细文章：浏览器内核的解析和对比 cookies, localStorage 和 sessionStorage 的区别用途 cookie：是服务器发给浏览器保存的（字符串）数据，一般用来记录用户信息方便服务端确认用户身份 localStorage、sessionStorage：本地存储，可以保存一些不太重要的数据，例如当前用户坐标，购物车信息等 存储大小 cookie：4k localStorage, sessionStorage：5M 有效期 cookie：关闭浏览器失效（默认） localStorage：永久，除非js手动删和清除浏览器缓存 sessionStorage：页面不关闭就不失效，包括重新加载或恢复页面也不失效。但在新标签或窗口打开一个页面，则会重新生成 cookie 与 session 区别都是用来确认用户身份的，区别在于 cookie 保存在客户端，session 保存在服务端。 另外，session 是基于 cookie 的。服务器端在生成 session 后，会让客户端的 cookie 代为保存 sessionID 。 如何处理 HTML5 新标签的浏览器兼容问题支持HTML5新标签： IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式。 当然也可以直接使用成熟的框架、比如 html5shim.js: 123&lt;!--[if lt IE 9]&gt;&lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt;&lt;![endif]--&gt; HTML5的离线储存使用，解释工作原理？❌ 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。 原理：HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 如何使用： 页面头部像下面一样加入一个manifest的属性 在 cache.manifest 文件的编写离线存储的资源 在离线状态时，操作 window.applicationCache 进行需求实现。 详细的使用请参考： HTML5 离线缓存-manifest简介 有趣的HTML5：离线存储 浏览器对 HTML5 离线储存资源的管理和加载？在线的情况下: 浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下: 浏览器就直接使用离线存储的资源。 如何实现浏览器内多个标签页之间的通信? (阿里)WebSocket、SharedWorker； 也可以调用 localStorage 、cookies 等本地存储方式； localStorage 另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件， 我们通过监听事件，控制它的值来进行页面信息通信； 注意：Safari 在无痕模式下设置localStorage 值时会抛出 QuotaExceededError 的异常； webSocket 如何兼容低浏览器？(阿里)Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 页面可见性(Page Visibility API)有哪些用途 通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等; 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放； 实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。1&lt;div style="height:1px;overflow:hidden;background:red"&gt;&lt;/div&gt; 网页验证码干嘛的,是为了解决什么安全问题区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。 HTTP 缓存策略执行过程 浏览器渲染页面的过程从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面 五件事情 上： DNS 查询 TCP 连接 HTTP 请求即响应 服务器响应 客户端渲染 浏览器对内容的渲染，这一部分（渲染树构建、布局及绘制），又可以分为下面 五个步骤 ： 处理 HTML 标记并构建 DOM 树。 处理 CSS 标记并构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，以计算每个节点的几何信息。 将各个节点绘制到屏幕上。 这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM 参考来源：浏览器的渲染：过程与原理 在做移动端项目时遇到过什么问题？ 参考阅读：H5与APP混合开发遇到的问题总结 经常遇到的浏览器的兼容性有哪些？ IE 浏览器不支持 Promise babel-polyfill → webpack.config.js 的 entry 中设置 [‘babel-polyfill’, ‘./src/main.js’] 各浏览器之间默认样式的差异 normalize.css 与 reset 区别 → normalize.css 消除各浏览器之间默认样式的差异、保留有用的默认样式；而 reset 会清除所有的默认样式，过于暴力，例如会让 h 标题标签不再默认加粗，ul li 前面默认的小圆点也没了） html5 某些新增标签不被识别 html5shiv.js - 解决 ie9 以下对 html5 某些新增标签不识别的问题（e.g. video标签不识别不显示） 用法：[if lt IE 9]&gt;&lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;&lt;![endif] CSS3 媒体查询失效 respond.js - 能解决 ie9 以下不支持媒体查询问题 自动添加浏览器前缀 posscss-loader+autoprefixer ie6 不支持 min-height/width 添加额外的 _min-height ie6 识别 常见hack（针对特定ie版本的样式控制） _color - ie6 识别 *color - ie6/7 识别 color: red\9; ie8及以下识别 ie条件注释写法：(lt 小于 | gt 大于 | lte 小于等于 | gte 大于等于 | ! 不等于) 移动端点透问题 解决方案 ios滚动卡顿 使用 better-scroll 插件 ios 顶部输入框 fixed 布局失效（当键盘弹起时）❌ 安卓 键盘遮挡输入框 ❌ position:fixed; 在 android 下无效怎么处理？【❌待验证】原因： fixed 的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的 viewport ，原来的网页还好好的在那，fixed 的内容也没有变过位置。 解决： 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"/&gt; 如果需要手动写动画，你认为最小时间间隔是多久，为什么？多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms style 标签写在 body 后与 body 前（head）有什么区别？style 标签放在 body 后，会导致当加载到此样式时，页面将停止之前的渲染。此样式表被解析后，将重新渲染页面，也就出现了短暂的花屏现象。 所以不要写在 body 后，要把样式放在 head 中。]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript知识点（面试系列）]]></title>
    <url>%2Fposts%2F41818%2F</url>
    <content type="text"><![CDATA[JS基础JS类型string，number，boolean，undefined，null，symbol，object 值类型和引用类型的区别两种类型的区别是：存储位置不同； 值类型存储在栈（stack）中，占空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用类型存储在堆（heap）中,占据空间大、大小不固定。如果存在栈中，影响程序运行性能；引用类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 JS的类型检测 typeof （判断一个变量是什么类型）undefined object function boolean string number symbol instanceof （判断当前对象是不是某个类型） 1234567891011121314&lt;!-- 要检测的对象 instanceof 某个构造函数 --&gt;function Car(make, model, year) &#123; this.make = make; this.model = model;&#125;var auto = new Car('Honda', 'Accord');console.log(auto instanceof Car);// expected output: trueconsole.log(auto instanceof Object);// expected output: true Object.prototype.toString.call()（检测一个对象的类型） 1console.log(Object.prototype.toString.call("Lance"));//[object String] === 和 == 的区别== 在允许强制转换的条件下检查值的等价性，而 === 是在不允许强制转换的条件下检查值的等价性； 因此 === 常被称为「严格等价」。（”55” == 55 true, “55” === 55 false。p.s. 把字符串转为数值） 哪些非 boolean 值被强制转换为一个 boolean 时，它是 false ？ &quot;&quot;（空字符串） 0, -0, NaN （非法的 number ） null, undefined null，undefined 的区别？ null 表示一个对象是「没有值」的值，也就是值为 “空”； undefined 表示一个变量声明了没有初始化(赋值)； undefined 的类型（typeof）是 undefined ； null 的类型（typeof）是 object ； JavaScript 将未赋值的变量默认值设为undefined； JavaScript 从来不会将变量设为 null 。它是用来让程序员表明某个用 var 声明的变量时没有值的。 在验证 null 时，一定要使用 === ，因为 == 无法分别 null 和 undefined 12null == undefined // truenull === undefined // false DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？1234567891011121314（1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点（2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点（3）查找 querySeletor("ul") / querySelectorAll("ul li"); // 查找单个元素 / 多个元素 getElementsByTagName("div") getElementsByClassName() getElementById() 对象的原生方法Object.assign()copy 对象的可枚举属性 语法：Object.assign(target, …sources) 参数：目标对象, …源对象 返回值：目标对象 123const obj = &#123; a: 1 &#125;;const copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; a: 1 &#125; Object.create()创建新对象 语法：Object.create(proto, [ propertiesObject ]) 参数：新创建对象的原型对象, 用于指定创建对象的一些属性，（eg：是否可读、是否可写，是否可以枚举etc） Object.is()用来判断两个值是否是同一个值 123456789101112131415Object.is('haorooms', 'haorooms'); // trueObject.is(window, window); // trueObject.is('foo', 'bar'); // falseObject.is([], []); // falsevar test = &#123; a: 1 &#125;;Object.is(test, test); // trueObject.is(null, null); // true// 特例Object.is(0, -0); // falseObject.is(-0, -0); // trueObject.is(NaN, 0/0); // true Object.keys / Object.values返回给定对象的自身可枚举属性 / 值 的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 1234567891011121314// simple arrayvar arr = ['a', 'b', 'c'];console.log(Object.keys(arr)); // console: ['0', '1', '2']// array like objectvar obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.keys(obj)); // console: ['0', '1', '2']var obj = &#123; foo: 'bar', baz: 42 &#125;;console.log(Object.values(obj)); // ['bar', 42]// array like objectvar obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.values(obj)); // ['a', 'b', 'c'] Object.entries()**Object.entries()** 方法返回对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。 12345678const obj = &#123; foo: 'bar', baz: 42 &#125;;console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]// iterate through key-value gracefullyconst obj = &#123; a: 5, b: 7, c: 9 &#125;;for (const [key, value] of Object.entries(obj)) &#123; console.log(`$&#123;key&#125; $&#123;value&#125;`); // "a 5", "b 7", "c 9"&#125; 数组的遍历方法 标准for循环 forEach((当前值, 当前索引,当前数组)=&gt;{}） 无法中途退出循环，只能用 return 退出本次回调，进行下一次回调。 它总是返回 undefined 值,即使你 return 了一个值。 for-in（不推荐）会把继承链的对象属性都会遍历一遍，而且数组遍历不一定按次序 for-in 循环返回的是所有能通过对象访问的、可枚举的属性。 for (variable of iterable)（ES6）可迭代 Array ，Map，Set，String 等（迭代的是值 value ） 在 for-of 中如果遍历中途要退出，可以使用 break 退出循环。 ES5 map (不改变原数组) 会给原数组中的每个元素都按顺序调用一次 callback 函数 reduce (不改变原数组) 数组中的前项和后项做某种计算,并累计最终值。 12345678// arr.reduce(function(total, currentValue, currentIndex, arr), initialValue)// callback 参数// (累积器, 当前元素, 当前元素索引, 当前数组)// initialValue:指定第一次回调 的第一个参数var wallets = [4, 7.8, 3]var totalMoney = wallets.reduce(function (countedMoney, curMoney) &#123; return countedMoney + curMoney;&#125;, 0) filter（不改变原数组） 1234var arr = [2, 3, 4, 5, 6]var morearr = arr.filter(function (number) &#123; return number &gt; 3&#125;) // [4,5,6] every（不改变原数组）测试数组的所有元素是否都通过了指定函数的测试 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。 如果所有元素都满足条件，则返回 true 。1234var arr = [1,2,3,4,5]var result = arr.every(function (item, index) &#123; return item &gt; 2&#125;) // false some（不改变原数组）测试是否至少有一个元素通过 callback 中的条件.对于放在空数组上的任何条件，此方法返回 false 。 如果有一个元素满足条件，则表达式返回 true , 剩余的元素不会再执行检测。 如果没有满足条件的元素，则返回 false 。12345678// some(callback, thisArg)// callback:// (当前元素, 当前索引, 调用some的数组)var arr = [1,2,3,4,5]var result = arr.some(function (item,index) &#123; return item &gt; 3&#125;) // true ES6 find() &amp; findIndex() 根据条件找到数组成员 find() 定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回 undefined 。 findIndex() 定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 -1 。 1234567891011121314&lt;!-- 语法 --&gt;let new_array = arr.find(function(currentValue, index, arr), thisArg)let new_array = arr.findIndex(function(currentValue, index, arr), thisArg)&lt;!-- 这两个方法都可以识别NaN,弥补了indexOf的不足 --&gt;&lt;!-- find --&gt;let a = [1, 4, -5, 10].find((n) =&gt; n &lt; 0);&lt;!-- 返回元素-5 --&gt;let b = [1, 4, -5, 10,NaN].find((n) =&gt; Object.is(NaN, n));&lt;!-- 返回元素NaN --&gt;&lt;!-- findIndex --&gt;let a = [1, 4, -5, 10].findIndex((n) =&gt; n &lt; 0);&lt;!-- 返回索引2 --&gt;let b = [1, 4, -5, 10,NaN].findIndex((n) =&gt; Object.is(NaN, n));&lt;!-- 返回索引4 --&gt; keys() &amp; values() &amp; entries() 遍历键名、遍历键值、遍历键名+键值 三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。 1234567891011121314151617181920// 语法array.keys() array.values() array.entries()for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" for in 和 for of 区别12345678910111213141516171819Object.prototype.objCustom = function() &#123;&#125;;Array.prototype.arrCustom = function() &#123;&#125;;let iterable = [3, 5, 7];iterable.foo = 'hello';for (let i in iterable) &#123; &lt;-- 循环的是索引 console.log(i); // 打印 0, 1, 2, "foo", "arrCustom", "objCustom"&#125;for (let i in iterable) &#123; if (iterable.hasOwnProperty(i)) &#123; console.log(i); // 打印 0, 1, 2, "foo" &#125;&#125;for (let i of iterable) &#123; &lt;-- 迭代的是值 console.log(i); // 打印 3, 5, 7&#125; 参考：JavaScript 数组遍历方法的对比 JS 数组有哪些方法改变原数组的方法（9个）splice() 添加 / 删除数组元素 splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目 array.splice(index,howmany,item1,…..,itemX) index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX： 可选。向数组添加的新项目。 返回值: 如果有元素被删除,返回包含被删除项目的新数组。 删除元素 1234567// 从数组下标0开始，删除3个元素let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0, 3); // [1,2,3]console.log(a); // [4,5,6,7]// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7let item = a.splice(-1, 3); // [7] 删除并添加 123456789// 从数组下标0开始，删除3个元素，并添加元素'添加'let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0,3,'添加'); // [1,2,3]console.log(a); // ['添加',4,5,6,7]// 从数组最后第二个元素开始，删除3个元素，并添加两个元素'添加1'、'添加2'let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-2,3,'添加1','添加2'); // [6,7]console.log(b); // [1,2,3,4,5,'添加1','添加2'] 不删除只添加 1234567let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0,0,'添加1','添加2'); // [] 没有删除元素，返回空数组console.log(a); // ['添加1','添加2',1,2,3,4,5,6,7]let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-1,0,'添加1','添加2'); // [] 没有删除元素，返回空数组console.log(b); // [1,2,3,4,5,6,'添加1','添加2',7] 在最后一个元素的前面添加两个元素 sort() 数组排序 定义: sort() 方法对数组元素进行排序，并返回这个数组。 参数可选: 规定排序顺序的比较函数。 默认情况下 sort() 方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用 toString() 方法将元素转化为字符串的 Unicode (万国码)位点，然后再比较字符。 不传参 1234567// 字符串排列 看起来很正常var a = ["Banana", "Orange", "Apple", "Mango"];a.sort(); // ["Apple","Banana","Mango","Orange"]// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的var a = [10, 1, 3, 20,25,8];console.log(a.sort()) // [1,10,20,25,3,8]; 比较函数的两个参数： sort 的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素： 若比较函数返回值 &lt;0 ，那么 a 将排到 b 的前面; 若比较函数返回值 =0 ，那么 a 和 b 相对位置不变； 若比较函数返回值 &gt;0 ，那么 b 排在 a 将的前面； 数字升降序 12345678910var array = [10, 1, 3, 4, 20, 4, 25, 8]; array.sort(function(a,b)&#123; return a-b;&#125;);console.log(array); // [1,3,4,4,8,10,20,25];array.sort(function(a,b)&#123; return b-a;&#125;);console.log(array); // [25,20,10,8,4,4,3,1]; 不改变原数组的方法（8个）slice() 浅拷贝数组的元素 定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。 语法：array.slice(begin, end); 12345678910111213let a= ['hello','world'];let b=a.slice(0,1); // ['hello']// 新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。// 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。a[0] = '改变原数组';console.log(a,b); // ['改变原数组','world'] ['hello']let a = [&#123;name:'OBKoro1'&#125;];let b = a.slice();console.log(b,a); // [&#123;"name":"OBKoro1"&#125;] [&#123;"name":"OBKoro1"&#125;]// a[0].name='改变原数组';// console.log(b,a); // [&#123;"name":"改变原数组"&#125;] [&#123;"name":"改变原数组"&#125;] join() 数组转字符串 定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。 语法: array.join(str) 12345678910111213let a = ['hello','world'];let str = a.join(); // 'hello,world'let str2 = a.join('+'); // 'hello+world'let a = [['OBKoro1','23'],'test'];let str1 = a.join(); // OBKoro1,23,testlet b = [&#123;name:'OBKoro1',age:'23'&#125;,'test'];let str2 = b.join(); // [object Object],test// 对象转字符串推荐JSON.stringify(obj);// 结论：// join()/toString() 方法在数组元素是数组的时候，会将里面的数组也调用 join()/toString() ,// 如果是对象的话，对象会被转为 [object Object] 字符串。 toLocaleString() 数组转字符串 定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。 12345678910111213let a = [&#123; name: 'OBKoro1'&#125;, 23, 'abcd', new Date()];console.log(a.join(","));console.log(a.toString());console.log(a.toLocaleString('en-us'));console.log(a.toLocaleString('zh-cn'));[object Object],23,abcd,Tue Feb 26 2019 11:47:03 GMT+0800 (中国标准时间)[object Object],23,abcd,Tue Feb 26 2019 11:47:03 GMT+0800 (中国标准时间)[object Object],23,abcd,2/26/2019, 11:47:03 AM[object Object],23,abcd,2019/2/26 上午11:47:03 concat 定义： 方法用于合并两个或多个数组，返回一个新数组。 语法：var newArr =oldArray.concat(arrayX,arrayX,……,arrayX) 参数：arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。 1234567891011121314let a = [1, 2, 3];let b = [4, 5, 6];//连接两个数组let newVal = a.concat(b); // [1,2,3,4,5,6]// 连接三个数组let c = [7, 8, 9]let newVal2 = a.concat(b, c); // [1,2,3,4,5,6,7,8,9]// 添加元素let newVal3 = a.concat('添加元素',b, c,'再加一个');// [1,2,3,"添加元素",4,5,6,7,8,9,"再加一个"]// 合并嵌套数组 会浅拷贝嵌套数组let d = [1,2 ];let f = [3,[4]];let newVal4 = d.concat(f); // [1,2,3,[4]] ES6扩展运算符 ... 合并数组123let a = [2, 3, 4, 5]let b = [ 4,...a, 4, 4]console.log(a,b); // [2, 3, 4, 5] [4,2,3,4,5,4,4] indexOf() 查找数组是否存在某个元素，返回下标 定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 p.s. 字符串也有此方法，要注意当 ‘lance’.indexOf(‘’) 一个空字符串时，返回0而不是-1 语法：array.indexOf(searchElement,fromIndex) 参数： searchElement (必须):被查找的元素 fromIndex (可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。 严格相等的搜索: 数组的 indexOf 搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等===搜索元素，即数组元素要完全匹配才能搜索成功。 注意：indexOf() 不能识别NaN 1234let a=['啦啦',2,4,24,NaN]console.log(a.indexOf('啦')); // -1console.log(a.indexOf('NaN')); // -1console.log(a.indexOf('啦啦')); // 0 lastIndexOf() 查找指定元素在数组中的最后一个位置 定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找） 语法：arr.lastIndexOf(searchElement,fromIndex) 参数: searchElement(必须): 被查找的元素 fromIndex(可选): 逆向查找开始位置，默认值数组的 长度-1，即查找整个数组。 关于fromIndex有三个规则: 正值。如果该值大于或等于数组的长度，则整个数组会被查找。 负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找) 负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 12345let a = ['OB',4,'Koro1',1,2,'Koro1',3,4,5,'Koro1']; // 数组长度为10// let b=a.lastIndexOf('Koro1',4); // 从下标4开始往前找 返回下标2// let b=a.lastIndexOf('Koro1',100); // 大于或数组的长度 查找整个数组 返回9// let b=a.lastIndexOf('Koro1',-11); // -1 数组不会被查找let b = a.lastIndexOf('Koro1',-9); // 从第二个元素4往前查找，没有找到 返回-1 ES7 includes() 查找数组是否包含某个元素 返回布尔 定义： 返回一个布尔值，表示某个数组是否包含给定的值 语法：array.includes(searchElement,fromIndex=0) 参数： searchElement (必须):被查找的元素 fromIndex (可选):默认值为 0 ，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回 false 。负值绝对值超过长数组度，重置从 0 开始搜索。 includes 方法是为了弥补 indexOf 方法的缺陷而出现的: indexOf 方法不能识别 NaN indexOf 方法检查是否包含某个值不够语义化，需要判断是否不等于 -1 ，表达不够直观 12345let a = ['OB','Koro1',1,NaN];// let b=a.includes(NaN); // true 识别NaN// let b=a.includes('Koro1',100); // false 超过数组长度 不搜索// let b=a.includes('Koro1',-3); // true 从倒数第三个元素开始搜索// let b=a.includes('Koro1',-100); // true 负值绝对值超过数组长度，搜索整个数组 参考：js 数组详细操作方法及解析合集 字符串的方法charAt 从一个字符串中返回指定字符如果指定的 index 值超出了该范围，则返回一个空字符串 12var anyString = "Brave new world";console.log(anyString.charAt(0)); // B substring 返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。 如果 indexStart 等于 indexEnd，substring 返回一个空字符串。 如果省略 indexEnd，substring 提取字符一直到字符串末尾。 如果任一参数小于 0 或为 NaN，则被当作 0。 如果任一参数大于 stringName.length，则被当作 stringName.length。 如果 indexStart 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。见下面的例子。 12345678var anyString = "Mozilla";// 输出 "Moz"console.log(anyString.substring(0,3));console.log(anyString.substring(3,0));console.log(anyString.substring(3,-3));console.log(anyString.substring(3,NaN));console.log(anyString.substring(-2,3));console.log(anyString.substring(NaN,3)); replace 返回一个由替换值（replacement）替换一些或所有匹配的模式（pattern）后的新字符串。模式可以是一个字符串或者一个 正则表达式 ，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。 toLowerCase / toUpperCase字母转为全小写或全大写 JS进阶闭包什么是闭包/对闭包的理解函数中有另一个函数或有另一个对象，里面的函数或者是对象都可以使用外面函数中定义的变量或者参数，此时形成闭包。 YouDontKnowJS对闭包的解释 —— 闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。由于这个性质，闭包让我们能够从一个函数内部访问其外部函数的作用域 闭包就是能够读取其他函数内部变量的函数。可以简单理解成“定义在一个函数内部的函数” 闭包的用途 保存：缓存数据，延长作用域链 保护：形成私有作用域，保护里面私有变量不受外界干扰，避免全局污染 缺点：耗内存，耗性能，函数中的变量不能及时释放 如何使用闭包要使用闭包，只需要简单地将一个函数定义在另一个函数内部，并将它暴露出来。要暴露一个函数，可以将它返回或者传给其他函数。 内部函数将能够访问到外部函数作用域中的变量，即使外部函数已经执行完毕。 想要缓存数据的时候就用闭包，把想要缓存的数据放在外层函数和内层函数的中间位置。 闭包应用场景li 节点的 onclick 事件都能正确的弹出当前被点击的 li 索引1234567891011121314151617&lt;ul id="testUL"&gt; &lt;li&gt; index = 0&lt;/li&gt; &lt;li&gt; index = 1&lt;/li&gt; &lt;li&gt; index = 2&lt;/li&gt; &lt;li&gt; index = 3&lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var nodes = document.getElementsByTagName("li"); for (var i = 0; i &lt; nodes.length; i += 1) &#123; nodes[i].onclick = (function (i) &#123; return function () &#123; // &lt;----重点是此处返回了个一个匿名函数，这个函数能访问 // 立即执行函数作用域内的i这个变量，形成闭包 console.log(i); &#125; //不用闭包的话，值每次都是4 &#125;)(i); &#125;&lt;/script&gt; 用闭包模拟私有方法使用闭包定义能访问私有函数和私有变量的公有函数（也叫做模块模式） 123456789101112131415161718192021222324var counter = (function() &#123; var privateCounter = 0 function changeBy(val) &#123; privateCounter += val &#125; return &#123; increment: function() &#123; changeBy(1) &#125;, decrement: function() &#123; changeBy(-1) &#125;, value: function() &#123; return privateCounter; &#125; &#125;&#125;)(); // 立即执行函数console.log(counter.value()) // logs 0counter.increment()counter.increment()console.log(counter.value()) // logs 2counter.decrement()console.log(counter.value()) // logs 1 环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。 它俩都无法在匿名函数外部直接访问。必须通过匿名包装器返回的对象的三个公共函数访问。 解决 循环+闭包 问题直接 点击此处 查看 什么是 JavaScript 作用链域？全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找， 直至全局函数，这种组织形式就是作用域链。 this对 this 的理解 this 总是指向函数的直接调用者（而非间接调用者） 如果有 new 关键字，this 指向 new 出来的那个对象 在事件中，this 指向触发这个事件的对象，特殊的是，IE 中的 attachEvent 中的 this 总是指向全局对象 window 重要： 普通函数的 this 指向是在函数的执行期间绑定的 箭头函数的 this 指向是在函数创建期间就绑定好了的，指向的是创建该箭头函数所在的作用域对象 一般不在事件（比如 onclick ）上传递箭头函数，使用 function 就好 判定 this 摘自 YouDontKnowJS 现在，我们可以按照优先顺序来总结一下从函数调用的调用点来判定 this 的规则了。按照这个顺序来问问题，然后在第一个规则适用的地方停下。 函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。var bar = new foo() 函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。var bar = foo.call( obj2 ) 函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。var bar = obj1.foo() 否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。var bar = foo() 以上，就是理解对于普通的函数调用来说的 this 绑定规则 所需的全部。是的……几乎是全部。 apply, call, bind 的区别 apply, call, bind 本身存在于大 Function 构造函数的 prototype 中 所有的函数都是大 Function 的实例对象 apply, call, bind 方法都可以改变 this 的指向 apply(对象, [参数1, 参数2, 餐数3, …]) call(对象, 参数1, 参数2, 餐数3,…) bind(对象,参数1, 参数2, 餐数3,…) 函数名称.bind()—-&gt;返回值是复制之后的这个函数 区别 apply，call 是调用的时候改变 this 指向，然后返回函数执行的结果。 参数较多时用 apply ，参数较少时用 call bind 是复制一份函数并返回，并且这个函数的 this 指向变成了传入的第一个参数。 JavaScript 原型什么是原型 实例对象中有个属性 __proto__ ，是个对象，叫原型，不是标准的属性，浏览器使用的—–&gt;可以叫原型对象 构造函数中有一个属性 prototype ，也是个对象，叫原型，是标准属性，程序员使用—&gt;可以叫原型对象 实例对象的 __proto__ 和构造函数中的 prototype 相等—&gt; true 又因为实例对象是通过构造函数来创建的，构造函数中有原型对象prototype 实例对象的 __proto__ 指向了构造函数的原型对象 prototype 每个对象都会在其内部初始化一个属性，就是 prototype（原型）。原型就是 __proto__（IE8不支持，非标准属性） 或者是 prototype ，都是原型对象。 作用 共享数据，目的是：节省内存空间 实现继承，目的是：节省内存空间 什么是原型链精简版 原型链是一种关系，实例对象和原型对象之间的关系，关系是通过原型（proto）来联系的。 详细版 每个对象都会在其内部初始化一个属性 prototype（原型），当我们访问一个对象的属性时， 如果这个对象内部不存在这个属性，那么他就会去 prototype 里找这个属性，这个 prototype 又会有自己的 prototype ，于是就这样一直找下去，也就是我们平时所说的原型链的概念。 原型和原型链 原型链最终指向 分别使用原型链和 class 的方式实现继承1. 组合继承（原型链 + 借用构造函数）【不推荐】123456789101112131415161718192021function Person(name, age) &#123; this.name = name this.age = age&#125;Person.prototype.sayHi=function () &#123;&#125;function Student(name, age, weight) &#123; // 借用构造函数 Person.call(this, name, age) this.weight = weight&#125;// 改变原型指向----继承// 我们让 Student.prototype 指向一个 Person 的实例对象// 这个对象的 __proto__ 指向的是 Person.prototype// 所以我们就可以借助这个实例对象拿到 sayHi 方法，实现继承Student.prototype = new Person()Student.prototype.eat = function () &#123;&#125;var stu = new Student("Lance", 20, 120)var stu2 = new Student("Will", 200 , 110)// 属性和方法都被继承了 由上面方案引出的问题： 为什么不能 Student.prototype = Person.prototype对象的赋值只是引用的赋值, 上面两者都指向同一个内存地址，只要随便通过 1 个途径就能修改该内存地址的对象，这样子类就无法单独扩展方法，因为会影响父类。 单纯的原型链继承有什么缺陷虽然改变了原型的指向，但属性在初始化的时候就已经固定了【Student.prototype = new Person(“小明”, 29, 90)】，如果是多个对象实例化，那么每个实例对象的属性的初始值就都是一样的。换句话说，无法向父类传递参数。 单纯的借用构造函数继承有什么缺陷只能继承父类构造函数里面的属性和方法【Person.call(this, name, age)】，但父类的 prototype（原型）上的属性和方法不能继承。 组合继承的缺点调用了两次父类的构造函数。第一次给子类的原型添加了父类构造函数中的属性方法，第二次又给子类的构造函数添加了父类的构造函数的属性方法，从而覆盖了子类原型中的同名参数。这种被覆盖的情况造成了性能上的浪费： 123456789101112function SuperType() &#123; this.name = 'parent' this.arr = [1, 2, 3]&#125;SuperType.prototype.say = function() &#123;&#125;function SubType() &#123; SuperType.call(this) // 第二次调用SuperType&#125;SubType.prototype = new SuperType() // 第一次调用SuperType 2. 寄生组合继承【推荐】12345678910111213141516171819202122function Person(name, age) &#123; this.name = name this.age = age this.sayHi = function() &#123;&#125;&#125;Person.prototype.eat = function() &#123;&#125;function Student(name, age, weight) &#123; Person.call(this, name, age) this.weight = weight this.study = function() &#123;&#125;&#125;var F = function ()&#123;&#125;// 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费F.prototype = Person.prototype // 创建了父类原型的浅复制Student.prototype = new F();Student.prototype.constructor = Student // 修正原型的构造函数var stu1 = new Student("Lance", 19, 120)console.dir(stu1) 3. class 实现继承1234567891011121314151617181920212223class Person &#123; constructor(name, age) &#123; this.name = name this.age = age // 类本身的方法 this.sayHi = function() &#123;&#125; &#125; // 这里的 eat 相当于 prototype 中的 eat eat() &#123;&#125;&#125;// 关键点：extends superclass Student extends Person &#123; constructor(name, age, weight) &#123; super(name, age) this.weight = weight this.study = function() &#123;&#125; &#125; run() &#123;&#125;&#125;var stu = new Student("Jerry", 20, 100)console.dir(stu) 原型链，proto 和 prototype 的区别对象拥有 __proto__ 属性，函数拥有 prototype 属性。某个实例对象的 __proto__ 指向构造它的构造函数的 prototype 属性。所以：实例对象的 __proto__ 指向了构造函数的原型对象 prototype： 1234567// 构造函数function B(b) &#123; this.b = b&#125;// 实例对象var b = new B('lc')b.__proto__ === B.prototype // true 参考：彻底理解什么是原型链，prototype和proto的区别。 对象 函数（包括构造函数）是对象 对象不一定是函数 对象有 __proto__ 函数有 prototype 创建对象的三种方式字面量的方式12345var obj = &#123; name: "Lance", age: 20, sayHi: function()&#123;&#125;&#125; 调用系统的构造函数1234var obj = new Object()obj.name = 'Lance'obj.age = 20obj.sayHi = function()&#123;&#125; 自定义构造函数12345function Person(name, age) &#123; this.name = name this.age = age this.sayHi = function()&#123;&#125;&#125; new 操作符具体干了什么呢？ 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 属性和方法被加入到 this 引用的对象中。 新创建的对象由 this 所引用，并且最后隐式的返回 this 。 123var obj = &#123;&#125;obj.__proto__ = Base.prototypeBase.call(obj) 事件什么是事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 事件处理机制：IE9以下只支持事件冒泡、Firefox、Chrome等则同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。 ev.stopPropagation();（旧 ie 的方法 ev.cancelBubble = true） 事件流 事件绑定的三种方式1234567891011121314151617// 【 DOM0 级事件 】// 第一种：作为属性，写在标签上// &lt;div onclick="fun();"&gt;click&lt;/div&gt; ← 绑定在事件冒泡阶段// 第二种，使用 onclickdocument.getElementById("xxx").onclick = function()&#123;&#125; // ← 绑定在事件冒泡阶段// 【 DOM2 级事件 】// 第三种：使用推荐的标准模式document.getElementById("xxx").addEventListener("click", function(e)&#123;&#125;, false)// 第三种可以改变事件绑定的阶段// ---&gt; 为 false 时，绑定在事件冒泡阶段（默认下是绑定在冒泡阶段）// ---&gt; 为 true 时，绑定在捕获阶段// 如果绑定在捕获阶段，监听函数就只在捕获阶段触发// 如果绑定在冒泡阶段，监听函数只在冒泡阶段触发。 事件的执行顺序 无论是哪种绑定方式，对于同一个绑定元素，都是遵循先绑定的先执行原则。 如果是以 onclick 的方式绑定的，如果对同一个元素重复绑定的话，后面的会覆盖前面的。但是如果是以 addEventListener 方式绑定的话，同一个元素绑定多少次，就会执行多少次。 如果在 DOM 中直接使用 onclick ，则 onclick 的绑定是早于 addEventListener 的。 事件委托绑定在父级元素，利用事件冒泡去触发父级事件处理函数的一种技巧。 实现一个事件委托123456789101112131415161718192021222324252627282930313233var ul = document.querySelector('ul')function listen(element, eventType, targetElement, fn) &#123; element.addEventListener(eventType, function(e) &#123; // 先拿到当前事件的直接触发对象 var curTarget = e.target // 看它是不是使用者监听的目标对象类型 // 一旦发现不是，就执行循环 while(!curTarget.matches(targetElement)) &#123; // 先看看当前对象是不是和父元素相同 // 相同则把当前对象置为空，且不执行回调 if (curTarget === element) &#123; curTarget = null break &#125; // 不相同则把当前对象设置成自己的父对象 curTarget = curTarget.parentNode &#125; // 是，则先看当前对象有没有值，有值则执行回调函数 curTarget &amp;&amp; fn(e, curTarget, e) &#125;)&#125;listen(ul, 'click', 'li', function(event, el) &#123; console.log(event, el)&#125;);// jquery 使用方式$("ul").on("click", "li", function(e) &#123; console.log($(e.target).html());&#125;);// 这个 on 事件是绑定在 ul 上面的，li 是目标元素，// on 事件内部是通过 e.target 来判断点击元素是不是 li 的 我们给一个 dom 同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？会执行两次事件，按代码执行顺序来 规律：绑定在被点击元素的事件是按照代码顺序发生，其他元素通过冒泡或者捕获“感知”的事件，按照W3C的标准，先发生捕获事件，后发生冒泡事件。所有事件的顺序是：其他元素捕获阶段事件 -&gt; 本元素代码顺序事件 -&gt; 其他元素冒泡阶段事件 什么是节流和防抖介绍 debounce（防抖）的作用是在让在用户动作停止后延迟x ms再执行回调 throttle（节流）的作用是在用户动作时每隔一定时间（如200ms）执行一次回调 节流防抖作用 debounce 应用在搜索框的即时搜索（input 事件），避免用户狂按键盘导致的频繁请求 throttle 应用在监听 resize 改变布局或 onscroll 滚动 防抖： 123456789101112131415161718192021// &lt;input type="text" oninput="change()"&gt;// 防抖（一段时间会等，然后带着一起做了）function debounce(fn, delay) &#123; let timer = null return function() &#123; const context = this, args = arguments if (timer) &#123; window.clearTimeout(timer) &#125; timer = setTimeout(() =&gt; &#123; fn.apply(context, args) timer = null &#125;, delay) &#125;&#125;var change = debounce(function() &#123; var input = document.querySelector("input") console.log(input.value)&#125;, 1000) 节流： 1234567891011121314151617181920// &lt;div class="sw"&gt;23333&lt;/div&gt;// 节流（一段时间执行一次之后，就不执行第二次）function throttle(fn, delay) &#123; let canUse = true return function() &#123; var context = this, args = arguments if (canUse) &#123; fn.apply(context, args) canUse = false setTimeout(()=&gt;canUse = true, delay) &#125; &#125;&#125;var sw = document.querySelector(".sw")sw.addEventListener("click", throttle(function(e) &#123; console.log(e)&#125;, 1000)) 参考： 在React、Vue和小程序中使用函数节流和函数防抖 函数防抖与函数节流 JS事件中防抖debounce和节流throttle概念原理的学习 ES6相关ES6 用到过吗，新增了哪些东西，你用到过什么？ let 和 const 模板字符串 箭头函数（自己没有 this ，从自己的作用域链的上一层继承 this ） for-of（用来遍历数据—例如数组中的值）e.g. Array，String，Set，Map arguments 对象可被不定参数和默认参数完美代替 Promise 数组的拓展 数组.find((item,index,arr) =&gt; {条件}) 返回满足条件的第一个元素的值。否则返回 undefined 数组.findIndex((item,index,arr)=&gt;{…}) 返回满足条件的第一个元素的索引值。否则返回 -1 数组.includes(数据,[searchIndex]) 判断数据是否在数组中,第二个参数(可选参数)为从指定索引处(包含索引处的值)开始搜索 返回布尔值(es7时加入) 扩展运算符 … 引入 module 模块的概念 const 和 let 区别 let 定义变量可以只声明不赋值 const 定义常量声明时必须赋值，一旦定义不可轻易改变值 共同点解决 var 没有块作用域、变量提升、可以重复声明的问题。let 和 const 有自己的块作用域，不存在变量提升问题，同一块作用域中不可重复声明（会报错） let var 区别 var 有变量提升，let 没有 let 的作用域是块，而 var 的作用域是函数 12345678910111213var a = 5var b = 10if (a === 5) &#123;let a = 4 // The scope is inside the if-blockvar b = 1 // The scope is inside the functionconsole.log(a) // 4console.log(b) // 1&#125;console.log(a) // 5console.log(b) // 1 let 有暂时性死区，只要 let/const 声明的变量，在未声明之前使用或者赋值都会报错（ReferenceError） let 不能重复定义 可以改变 const 定义的某个对象的属性吗可以，因为对象是复杂类型，const 存储的是引用，所以改变对象的成员不会报错，但不建议这样做。 箭头函数（ this 指向） 箭头函数，本质上，就是一个匿名函数 箭头函数无法通过 call、apply、bind 来手动改变内部 this 指向 箭头函数：自动 .bind(this) 也就是说箭头函数中的 this 指向与其所在作用域的 this 指向相同 总结： 箭头函数不会创建自己的 this ，它只会从自己的作用域链的 上一层继承 this 1234567891011121314151617181920212223function Person() &#123; // Person() 构造函数定义 `this` 作为它自己的实例. this.age = 0 setInterval(function growUp() &#123; // 在非严格模式, growUp() 函数定义 `this`作为全局对象, // 与在 Person() 构造函数中定义的 `this`并不相同. this.age++ &#125;, 1000)&#125;var p = new Person()// 使用箭头函数function Person() &#123; this.age = 0 setInterval(() =&gt; &#123; this.age++ // |this| 正确地指向 p 实例 &#125;, 1000)&#125;var p = new Person() Set 和 Map概念 Set 是有序列表，类似于数组，但是没有重复值 Map 是存储许多键值对的有序列表，key 和 value 支持所有数据类型 相同点 都是有序列表 Set 值不重复；Map 键不重复 用法 SET 属性： Set.prototype.constructor：构造函数，默认就是 Set 函数 Set.prototype.size：返回实例的成员总数 操作方法： add(value)：添加一个值，返回Set结构本身 delete(value)：删除某个值，返回布尔值 has(value)：返回布尔值，表示是否是成员 clear()：清除所有成员，无返回值 遍历方法（ key() 和 values() 行为是一致的。） keys()：返回键名的遍历器（什么是遍历器？Iterator） values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 MAP 属性 size ：返回 Map 结构的成员总数。 操作方法 set(key, value): set 方法设置键名 key 对应的键值为 value ，然后返回整个 Map 结构。 get(key) ：get 方法读取 key 对应的键值，如果找不到 key ，返回 undefined 。 has(key)：has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。 delete(key)：delete 方法删除某个键，返回 true 。如果删除失败，返回 false 。 clear()：clear方法清除所有成员，没有返回值。 遍历方法 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历 Map 的所有成员。 用途Set 集合可以用来过滤数组中重复的元素，只能通过 has 方法检测指定的值是否存在，或者是通过 forEach 处理每个值。 Map 集合通过 set() 添加键值对，通过 get() 获取键值，各种方法的使用查看文章教程，你可以把它看成是比 Object 更加强大的对象。 Set 与 数组 的区别set不可重复，array可重复 Map 与 对象 的区别 Object 的键只能是字符串或者 symbol ，Map 的键可以是任意类型的值（包括对象） Map 可以通过 size 获取元素个数，对象得遍历。 Map 是有序的（根据用户插入的顺序进行排序），对象排序有自己规则（比如先排数字开头的 key ，再到字符串） Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。 12345678910111213141516var map = new Map()map.set("name", "Lance")map.set("age", 18)var per = &#123; name: 'Jerry', age: 19&#125;for (const attr of map.values()) &#123; console.log(attr)&#125; // Lance 18for (const attr of Object.keys(per)) &#123; console.log(per[attr])&#125; // Jerry 19 Promisepromise 是什么Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。 诞生的原因异步网络请求的回调地狱，而且我们还得对每次请求的结果进行一些处理，代码会更加臃肿。 promise 使用场景有哪些 ajax请求得到返回值的时间不同,有了 callback 的回调结果之后才能知道接下来应该做什么 node 中读取文件 三种状态 pending: 初始状态，既不是成功，也不是失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 基本用法12345678910111213//defined Promise async functionfunction asyncFun()&#123; return new Promise((reslove,reject)=&gt;&#123; if(reslove)&#123; reslove(/*reslove parameter*/) &#125;else&#123; reject(new Error(/*Error*/)) &#125; &#125;)&#125;//use Promise&amp;thenasyncFun().then(/*function*/).then(/*function*/)... promise 特性参考：八段代码彻底掌握 Promise promise 里面 return 一个 string，和在 resolve 一个 string 的区别return 一个 string 后续的 then 不会执行; resolve 一个 string 会返回一个 promise 对象，对象的值是这个 string 在 then 里面 throw 一个 error，怎么捕捉1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// throw 这个 error 后，在紧挨的下一个 then 中添加两个回调方法（ resolve 的，和 reject ）。// 然后在第二个 reject 方法中可以捕获new Promise(function (resolve, rej) &#123; return resolve("返回Promise") &#125;) .then(data =&gt; &#123; console.log("第一个then") throw new Error("我是错误") &#125;) .then(resolve =&gt; &#123; console.log("成功") console.log(resolve) &#125;, err =&gt; &#123; console.log("紧挨的失败") console.log(err) &#125;) .catch(err =&gt; &#123; console.log("catch错误") console.log(err) &#125;);// 123// 第一个then// 紧挨的失败// Error: 我是错误// at Promise.then.data (&lt;anonymous&gt;:6:15)// 在 then 的链式调用后添加一个 catch 来捕获new Promise(function (resolve, reject) &#123; return resolve("返回Promise")&#125;).then(data =&gt; &#123; console.log("第一个then") throw new Error("我是错误")&#125;).then(err =&gt; &#123; console.log("then错误") console.log(err)&#125;).catch(err =&gt; &#123; console.log("catch错误") console.log(err)&#125;)console.log("123")// 123// 第一个 then// catch 错误// Error: 我是错误// at Promise.then.data 使用 Promise 封装一个 url1234567891011121314151617var url = ''var getJSON = url =&gt; new Promise((resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest() xhr.open('GET', url) xhr.send(null) xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; // &lt;= 请求已完成，且响应已就绪 if (xhr.status === 200) &#123; // &lt;= 状态OK resolve(JSON.parse(xhr.responseText)) &#125; else &#123; reject(new Error("请求失败")) &#125; &#125; &#125;&#125;)getJSON(url).then(res =&gt; console.log(res)) 在 Promise 链式调用中，怎样才能保证上一个 promise 出现报错不会影响到后续 .then 的正常执行为了不影响后续 .then 的执行，需要在每一个 then 中指定失败的回调 1234567891011121314let asyncFunc = () =&gt; new Promise(resolve =&gt; &#123; resolve("123") // 123, 二楼 // throw new Error("出错了") // Error: 出错了, 二楼&#125;);asyncFunc().then(res =&gt; &#123; console.log(res) return Promise.resolve("二楼")&#125;, err =&gt; &#123; // &lt;====== 指定失败的回调 console.log(err) return Promise.resolve("二楼")&#125;).then(res =&gt; &#123; console.log(res)&#125;) Async / Await是什么 async 用于声明一个异步的 function await 用于等待一个异步方法执行完成 Asyncasync 函数会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。 Awaitawait 是在等待一个 async 函数完成。不过按 语法说明 ，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值 123456789101112131415function getSomething() &#123; return "something"&#125;function testAsync() &#123; return Promise.resolve("hello async")&#125;async function test() &#123; const v1 = await getSomething() const v2 = await testAsync() console.log(v1, v2)&#125;test() 优势让代码更易读 假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。 传统 promise ，链式调用 then 一个接一个 改用 async/await 后就像同步代码一样 123456789101112131415161718192021222324252627function doIt() &#123; console.time("doIt") const time1 = 300 step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`) console.timeEnd("doIt") &#125;);&#125;doIt()// =======async function doIt() &#123; console.time("doIt"); const time1 = 300 const time2 = await step1(time1) const time3 = await step2(time2) const result = await step3(time3) console.log(`result is $&#123;result&#125;`) console.timeEnd("doIt")&#125;doIt() 参考：理解 JavaScript 的 async/await 解构赋值数组用法12345678910111213141516171819202122// 前后的形式必须完全一致 才可以完成结构赋值let [foo, [[bar], baz]] = [1, [[2], 3]]foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"]third // "baz"let [x, , y] = [1, 2, 3]x // 1y // 3let [head, ...tail] = [1, 2, 3, 4]head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a']x // "a"y // undefinedz // []// 如果解构不成功，变量的值就等于undefined。 对象用法12345678910// 对象的属性没有次序，变量必须与属性同名，才能取到正确的值。&#123;name, age&#125; = &#123;name:'wang',age: 18&#125;name // wangage // 18// 支持别名&#123;name:nname, age&#125; = &#123;name:'wang',age: 18&#125;name // '' 取别名时原名就会为空字符串nname // wangage // 18 …运算符12345678[a, ...b] = [1, 2, 3, 4, 5]a // 1b // [2,3,4,5]var app = (...sum) =&gt; &#123;sum.forEach(item =&gt; console.log(item))&#125;app(1,2,3,4) // 1,2,3,4// 此运算符或得值为数组形式 主要用于替代函数中的 arguments(伪数组) 属性// 这样可以非常方便的遍历获取到的未知个数的实参 函数中的 rest（剩余） 参数 剩余参数语法允许我们将一个不定数量的参数表示为一个数组。 ——&gt; MDN - 剩余参数 123456789101112131415161718192021function sum(...theArgs) &#123; return theArgs.reduce((previous, current) =&gt; &#123; return previous + current &#125;);&#125;console.log(sum(1, 2, 3))// expected output: 6console.log(sum(1, 2, 3, 4))// expected output: 10// 下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们function multiply(multiplier, ...theArgs) &#123; return theArgs.map(function (element) &#123; return multiplier * element &#125;);&#125;var arr = multiply(2, 1, 2, 3)console.log(arr) // [2, 4, 6] 剩余参数和 arguments 对象的区别剩余参数和 arguments 对象之间的区别主要有三个： 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。 arguments 对象不是一个真正的数组，而剩余参数是真正的 Array 实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach 或 pop 。 arguments 对象还有一些附加的属性 （如 callee 属性）。 arguments.callee 属性包含当前正在执行的函数。 模块化模块化发展无模块化 –&gt; CommonJS规范 –&gt; AMD规范 –&gt; CMD规范 –&gt; ES6模块化 无模块劣势12345678910&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="jquery_scroller.js"&gt;&lt;/script&gt;&lt;script src="main.js"&gt;&lt;/script&gt;...缺点：被依赖的放在前面，否则使用就会报错污染全局作用域维护成本高依赖关系不明显 CommonJS规范（NodeJS）1234567891011121314151617// 定义模块math.jsvar basicNum = 0function add(a, b) &#123; return a + b&#125;module.exports = &#123; //在这里写上需要向外暴露的函数、变量 add, basicNum&#125;// 引用自定义的模块时，参数包含路径，可省略.jsvar math = require('./math')math.add(2, 5)// 引用核心模块时，不需要带路径var http = require('http')http.createService(...).listen(3000) exports 是对 module.exports 的引用。比如我们可以认为在一个模块的顶部有这句代码： exports = module.exports 所以，我们不能直接给 exports 赋值: ✅ exports.foo = ‘bar’ ❌ exports = {foo: ‘bar’} //error 这种方式是错误的，相当于重新定义了 exports 优点 解决了依赖、全局变量污染的问题 缺点 CommonJS 用同步的方式加载模块，这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。所以不适合浏览器端模块加载，更合理的方案是使用异步加载。 AMD规范（RequireJS）AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 12345678910111213141516/** 网页中引入 require.js 及 main.js **/&lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt;/** main.js 入口文件/主模块 **/// 首先用 config() 指定各模块路径和引用名require.config(&#123; baseUrl: "js/lib", paths: &#123; "jquery": "jquery.min", //实际路径为js/lib/jquery.min.js "underscore": "underscore.min", &#125;&#125;);// 执行基本操作require(["jquery","underscore"], function($,_)&#123; // some code here&#125;); 优点 适合在浏览器环境中异步加载模块、并行加载多个模块 缺点 必须要提前加载所有的依赖，然后才可以使用，而不是需要使用时再加载。（不能按需加载） CMD（SeaJS）与AMD类似，不同点在于： AMD 推崇依赖前置、提前执行 CMD 推崇依赖就近、延迟执行。 CMD 与 AMD 区别 12345678910111213141516171819/** AMD写法 **/define(["a", "b", "c", "d", "e", "f"], function(a, b, c, d, e, f) &#123; // 等于在最前面声明并初始化了要用到的所有模块 a.doSomething() if (false) &#123; // 即便没用到某个模块 b，但 b 还是提前执行了 b.doSomething() &#125;&#125;)/** CMD写法 **/define(function(require, exports, module) &#123; var a = require('./a') //在需要时申明 a.doSomething() if (false) &#123; var b = require('./b'); b.doSomething() &#125;&#125;) ES6模块化ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成： export 和 import 。 export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。 123456789101112/** 定义模块 math.js **/var basicNum = 0var add = function (a, b) &#123; return a + b&#125;;export &#123; basicNum, add &#125;/** 引用模块 **/import &#123; basicNum, add &#125; from './math'function test(ele) &#123; ele.textContent = add(99 + basicNum)&#125; es6 在导出的时候有一个默认导出， export default ，使用它导出后，在 import 的时候，不需要加上 {} ，模块名字可以随意起。该名字实际上就是个对象，包含导出模块里面的函数或者变量。 12345678/** export default **///定义输出export default &#123; basicNum, add &#125;//引入import math from './math'function test(ele) &#123; ele.textContent = math.add(99 + math.basicNum)&#125; 参考： 前端模块化：CommonJS,AMD,CMD,ES6 这一次，我要弄懂javascript的模块化 模块化开发怎么做？立即执行函数,不暴露私有成员 12345678910111213var module1 = (function()&#123; var _count = 0 var m1 = function()&#123; //... &#125; var m2 = function()&#123; //... &#125; return &#123; m1, m2 &#125;&#125;)(); 异步AjaxAjax 是什么? 如何创建一个Ajax？使用 JavaScript 异步获取数据，而且页面不会发生整页刷新的，提高了用户体验。 创建 XMLHttpRequest 对象,也就是创建一个异步调用对象 创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息 设置响应 HTTP 请求状态变化的函数 发送 HTTP 请求 获取异步调用返回的数据 使用 JavaScript 和 DOM 实现局部刷新 123456789101112131415161718// 1. 创建一个 XMLHttpRequest 类型的对象 —— 相当于打开了一个浏览器var xhr = new XMLHttpRequest()// 2. 打开与一个网址之间的连接 —— 相当于在地址栏输入访问地址xhr.open('GET', './time.php')// 3. 通过连接发送一次请求 —— 相当于回车或者点击访问发送请求xhr.send(null)// 4. 指定 xhr 状态变化事件处理函数 —— 相当于处理网页呈现后的操作xhr.onreadystatechange = function () &#123; // 通过 xhr 的 readyState 判断此次请求的响应是否接收完成 // 4代表done if (this.readyState === 4) &#123; // 通过 xhr 的 responseText 获取到响应的响应体 console.log(this) &#125;&#125; Ajax 解决浏览器缓存问题？ 在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”) 在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”) 在URL后面加上一个随机数： “fresh=” + Math.random() 在URL后面加上时间戳：”nowtime=” + new Date().getTime() 什么是同源策略？同源策略是浏览器的一种安全策略，所谓同源是指 域名，协议，端口 完全相同，只有同源的地址才可以相互通过 AJAX 的方式请求。 如何解决跨域问题jsonp借助于 script 标签发送跨域请求的技巧 原理 css，script 标签允许跨域。客户端借助 script 标签请求服务端的一个动态网页（php 文件），服务端的这个动态网页返回一段带有函数调用的 JavaScript 全局函数调用的脚本，将原本需要返回给客户端的数据传递进去。 客户端： foo(…arr) {console.log(arr.join(“,”))} 定义方法，名称随便 服务端会获取参数名 callback 的值 foo ，然后把数据扔进 foo 中调用 一旦数据返回，就相当于在调用上面的 foo 服务端： foo([‘我’, ‘是’, ‘你’, ‘原’, ‘本’, ‘需’, ‘要’, ‘的’, ‘数’, ‘据’]) 特色 JSONP 需要服务端配合，服务端按照客户端的要求返回一段 JavaScript 调用客户端的函数 只能发送 GET 请求 CORS 跨域资源共享服务端设置： 12345// 服务端请求头设置：允许远端访问header('Access‐Control‐Allow‐Origin: *');// 这种方案无需客户端作出任何变化（客户端不用改代码），只是在被请求的服务端响应的时候添加一个 // Access-Control-Allow-Origin 的响应头，表示这个资源是否允许指定域请求。 defer 和 async 的区别参考：https://segmentfault.com/q/1010000000640869 概念性问题你理解的面向对象一种编程开发思想。是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。 什么叫优雅降级和渐进增强？ 优雅降级：Web 站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。 如：border-shadow 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 如：默认使用 flash 上传，但如果浏览器支持 HTML5 的文件上传功能，则使用 HTML5 实现更好的体验 compose 函数 ❌函数柯里化 ❌]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS知识点（面试系列）]]></title>
    <url>%2Fposts%2F49170%2F</url>
    <content type="text"><![CDATA[盒模型标准盒模型（W3C标准）： 一个块的总宽度 = 内容宽度 + margin(左右) + padding(左右) + border(左右) 怪异盒模型（IE标准）： 一个块的总宽度 = width（包含 padding 和 border） + margin(左右) 怪异盒模型触发条件如果 html 文件最顶部 doctype 缺失，则在 ie6、7、8 将会触发怪异模式(quirks); 通过css来设置盒模型123box-sizing: content-box; /* 标准模型 */ border-box; /* IE模型 */ inherit; /* 从父元素继承 */ 应用场景 怪异盒模型（border-box） 比如我们想做一个内边距 10px ，边框为 2px ，最终包括边框宽度为 100px 的 div ，之前的做法是先算出内容宽 width 。但有点繁琐，需要人算。此时我们可以把 div 的 box-sizing 设置为 border-box ，我们就可以直接把 width 设置为 100px ，其余的 padding 和 border 按照给定好的值一一填入，就可以完成这一切工作，省去了人为的计算内容宽 content 的过程，减少计算量的同时减少了错误率。 CSS选择符有哪些？哪些属性可以继承？ id选择器（ #my-id ） 类选择器（ .my-class-name ） 标签选择器（ div, h1, p ） 相邻选择器（ h1 + p 紧贴在 h1 后面的第一个 p 标签。同级标签，之间不能有其他标签 ） 子代选择器（ ul &gt; li ul 标签下的下一个层级的 li ，并不是所有 ） 后代选择器（ li a ） 通配符选择器（ * ） 属性选择器（ a[rel = “external”] ） 伪类选择器（ a:hover, li:nth-child ） 可继承属性font-size font-family color, UL LI DL DD DT; 不可继承属性border padding margin width height CSS优先级算法如何计算？ 写在后面的覆盖写在前面的 描述越具体优先级越高 (div , div[class=’restart’]) 同权重 行内样式 &gt; 内嵌样式 &gt; 外部样式 !important 优先级最高 CSS3新增伪类有那些？ p:first-of-type 属于其父元素的特定类型首个子元素 等同于 :nth-of-type(1) p:last-of-type 属于其父元素的特定类型的最后一个子元素 等同于 :nth-last-of-type(1) ::after 在元素之前添加内容,也可以用来做清除浮动。 ::before 在元素之后添加内容 :enabled/:disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中。 如何居中div？行内元素水平居中123#container &#123; text-align: center;&#125; 单个 div（块级元素）水平居中1234#center &#123; width: 200px; margin: 0 auto;&#125; 多个 div 水平居中12345678910111213/* 传统方案 */#container &#123; text-align: center;&#125;#center &#123; display: inline-block;&#125;/* flex 布局方案 */#container &#123; justify-content: center; display: flex;&#125; 绝对定位的 div 居中（已知宽高）子绝父相 + margin1234567891011#center &#123; position: absolute; width: 300px; height: 300px; margin: auto; /* 0 auto 水平居中；auto 水平垂直居中 */ top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /* 方便看效果 */&#125; 子绝父相 + 负边距123456789#center &#123; position: absolute; width:500px; height:300px; top: 50%; left: 50%; margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */ background-color: pink; /* 方便看效果 */&#125; 当被居中的元素是 inline or inline-block 元素12345#container &#123; display: table-cell; text-align: center; vertical-align: middle;&#125; 任意元素（未知宽高）子绝父相 + translate1234567891011#container &#123; position: relative;&#125;/* 利用transform */#center &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; flex（需考虑兼容性）1234567891011#container &#123; display: flex; display: -webkit-flex; /* Safari仍旧需要使用特定的浏览器前缀 */ align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */&#125;#center &#123; width: 100px; height: 100px; background-color: pink; /* 方便看效果 */&#125; display: none 与 visibility: hidden 的区别？ display: none 不显示对应的元素，在文档布局中不再分配空间（重排+重绘） visibility: hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘） position 跟 display 、 overflow 、float 这些特性相互叠加后会怎么样？ position 属性规定元素的定位类型 display 属性规定元素应该生成的框的类型 float 属性是一种布局方式，定义元素在哪个方向浮动。 优先级机制：position：absolute/fixed 优先级最高，有他们在时，float 不起作用，display 值需要调整。float 或者 absolute 定位的元素，只能是块元素或表格。 讲一讲 position 属性中的各种值 值 是否脱标占有位置 可使用边偏移 描述 static 不脱标，正常模式 不可以 自动（没有）定位（默认定位方式） relative(自恋) 不脱标，占有位置 可以 相对定位，相对于其原文档流的位置进行定位 absolute(拼爹) 完全脱标，不占位置 可以 绝对定位，相对于其上一个已经定位（不为static）的父元素进行定位 fixed(浏览器) 完全脱标，不占位置 可以 固定定位，相对于浏览器窗口进行定位（老IE不支持） inherit 规定从父元素继承 position 属性的值 CSS3 有哪些新特性？过渡12345678910111213/* 语法 */transition: CSS属性，过渡时间，效果曲线（默认ease），延迟时间（默认0）/* demo1 *//*宽度从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒，0.2秒后执行过渡*/transition: width .5s ease .2s/* demo2 *//* 分开写 */transition-property: width;transition-duration: 1s;transition-timing-function: linear;transition-delay: 2s; 动画1234567891011121314151617181920212223242526/* 语法 */animation：动画名称，动画时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）/* demo1 *//* 执行一次logo2-line动画，运动时间2秒，运动曲线为 linear */animation: logo2-line 2s linear;/* demo2 *//* 2秒后开始执行一次 logo2-line 动画，运动时间2秒，运动曲线为 linear */animation: logo2-line 2s linear 2s;/* demo3 *//*无限执行 logo2-line 动画，每次运动时间2秒，运动曲线为 linear，并且执行反向动画*/animation: logo2-line 2s linear alternate infinite;还有一个重要属性：用来指定在动画执行之前和之后如何给动画的目标应用样式。animation-fill-mode: none | forwards | backwards | both;/*动画分为 初始状态 等待期 动画执行期 完成期 四个阶段。- none 表示 等待期和完成期，元素样式都为初始状态样式，不受动画定义（@keyframes）的影响- forwards 表示等待期保持初始样式，完成期间保持最后一帧样式- backwards 表示等待期为第一帧样式，完成期跳转为初始样式- both 表示 等待期样式为第一帧样式，完成期保持最后一帧样式*/ 参考：如何理解animation-fill-mode及其使用？ 形状转换transform: 适用于2D或3D转换的元素 (3d看这里)transform-origin: 转换元素的位置（围绕那个点进行转换,默认中心）。默认 x, y, z ： 50%, 50%, 0 对应 left, top 缩放 scale 位移 translate 旋转 rotate 倾斜 skew 12345transform: rotate(30deg);transform: translate(30px, 30px);transform: scale(.8);transform: skew(10deg, 10deg);transform-origin: left top; /* 左上（默认中心）【改变元素变形的原点】 */ 资源对 transition 、animation 和 transform 这块儿内容不熟的同学可以参考我的博客简单上手教程，基本上每个属性都有相应的 demo 展示：Lance的个人博客-css分类 另外，上面的知识点参考于下方资源，可自取： 个人总结（css3新特性） cubic-bezier贝塞尔在线预览 transition-timing-function | cssreference Understanding The CSS3 transition-timing-function Property 翻译 | 深入理解CSS时序函数 css3动画详解【推荐】 选择器属性选择器 div[index] { background: red } 表示 div 下面带 index 属性的背景为红色 div[index=a] { background: red } 表示 div 下面的自定义属性 index=a 的 div 的颜色变成红色。 div[index~=a] { background: red } 只要 div 中 index 属性带 a 这个单词的就生效。[a这个单词必须独立存在] p[class~=’lance’] 只会匹配到 class=”xxx lance”，而不会匹配 class=”xxlancexx” div[index*=a] { background: red } 只要 div 里面的 index 属性带 a 字母的就生效。 div[index^=a] { background: red } 以 a 开头的 div[index$=a] { background: red } 以 a 结尾 div[index|=a] { background:red } 只要以 a- 开头的 当需要多个的时候： div[key1=value1][key2=value2][key3=value3]…. { background:red } 结构性伪类选择器前提：假如 div 是下面 p 标签的父元素 p:nth-child(n) div 下类型为 p 的第 n 个子元素，下标从 1 开始！！ :nth-child(odd) 奇数 :nth-child(even) 偶数 p:nth-last-child(n) 从倒数，div 下类型为 p 的第 n 个子元素 p:last-child div 下最后一个子元素如果是 p ，则生效，否则不生效 p:first-child div 下第一个子元素如果是 p ，则生效，否则不生效【css2的】 p:first-of-type div 下第一个类型为 p 的子元素【不需要 p 是这个 div 下的第一个子元素】 p:last-of-type div 下最后一个类型为 p 的子元素 参考：css选择器中:first-child与:first-of-type的区别 伪元素选择器 ::first-letter 文本的第一个单词或字（如中文、日文、韩文等） ::first-line 文本第一行； ::selection 可改变选中文本的样式； ::before 和 ::after 在元素内部的开始火结束为止创建一个元素，该元素为行内元素，必须结合 content 属性使用 div::before { content: ‘开始’ } 目标伪类选择器:target 目标伪类选择器， : 选择器可用于选取当前活动的目标元素 1234:target &#123; color: red; font-size: 30px;&#125; 阴影12/* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */box-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2); 边框 边框图片 border-image 1border-image: image-source image-height image-width image-repeat 圆角边框 border-radius 1border-radius: 左上角，右上角，右下角，左下角 请解释一下CSS3的 Flexbox（弹性盒布局模型）,以及适用场景？该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。 在传统的布局方式中:block 布局是把块在垂直方向从上到下依次排列的；inline 布局则是在水平方向来排列。flex 弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。 适用场景：弹性布局适合于移动前端开发，在 Android 和 iOS 上也完美支持。 参考：http://www.w3cplus.com/css3/flexbox-basics.html 用纯CSS创建一个三角形的原理是什么？12345678把上、左、右三条边隐藏掉（颜色设为 transparent）#demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent;&#125; css多列等高如何实现？原理利用 padding-bottom|margin-bottom 正负值相抵； 设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定 padding-bottom 时的高度， 当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度， 其他比这列矮的列则会用它们的 padding-bottom 来补偿这部分高度差。 因为背景是可以用在 padding 占用的空间里的，而且边框也是跟随 padding 变化的，所以就成功的完成了一个障眼法。 实现 HTML 1234567891011121314&lt;ul class="Article"&gt; &lt;li class="js-equalheight"&gt; &lt;p&gt; 一家将客户利益置于首位的经纪商， 为客户提供专业的交易工具一家将客户利益置于首位的经纪商 &lt;/p&gt; &lt;/li&gt; &lt;li class="js-equalheight"&gt; &lt;p&gt;一家将客户利益置于首位的经纪商，为客户提供专业的交易工具&lt;/p&gt; &lt;/li&gt; &lt;li class="js-equalheight"&gt; &lt;p&gt;一家将客户利益置于首位的经纪商&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; CSS 12345678910111213141516.Article &#123; overflow: hidden;&#125;.Article &gt; li &#123; float: left; margin: 0 10px -9999px 0; padding-bottom: 9999px; background: #4577dc; width: 200px; color: #fff;&#125;.Article &gt; li &gt; p &#123; padding: 10px;&#125; li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？场景 有时，在写页面的时候，会需要将 这个块状元素横排显示，此时就需要将 display 属性设置为 inline-block ，此时问题出现了，在两个 元素之间会出现大约 8px 左右的空白间隙 原因浏览器的默认行为是把 inline 元素间的空白字符（空格换行 tab ）渲染成一个空格，也就是我们上面的代码 换行后会产生换行字符，而它会变成一个空格，当然空格就占用一个字符的宽度。 解决给 ul 标签设置 font-size: 0; 并为 li 元素重新设置 font-size: xxpx; BFC(块级格式化上下文：block formatting context)理解BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。我们可以利用这些特性解决特定环境下的布局问题。 常见 BFC 应用清除元素内部浮动 计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。 只要把父元素设为 BFC 就可以清理子元素的浮动了，最常见的用法就是在父元素上设置 overflow: hidden 样式，对于 IE6 加上 zoom: 1 就可以了。 解决外边距合并问题 盒子垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠 属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠，那么我们创建不属于同一个 BFC ，就不会发生 margin 重叠了。 1234567&lt;div class="container4 green" style="height: 500px;"&gt; &lt;!-- 给其中一个 div 外面包一个 div ，然后通过触发外面这个 div 的 BFC ，就可以阻止这两个 div 的 margin 重叠 --&gt; &lt;div style="overflow: hidden;"&gt; &lt;div class="blue w100 h100" style="margin-bottom: 20px;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="red w200 h200" style="margin-top: 20px;"&gt;&lt;/div&gt;&lt;/div&gt; 两栏布局，实现左定宽+右宽自适应 普通流体元素BFC后，为了和浮动元素不产生任何交集，顺着浮动边缘形成自己的封闭上下文 12345&lt;div class="container" style="height: 300px; background-color: red;"&gt; &lt;div style="width: 100px; height: 100px; float: left; background-color: blue;"&gt;&lt;/div&gt; &lt;div style="overflow: hidden; background-color: green;"&gt;我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容&lt;/div&gt; &lt;!-- 给右侧div添加 overflow: hidden即可 --&gt;&lt;/div&gt; 注意：设置浮动后，div 会被 float 覆盖，而文本却不会被 float 覆盖，是因为 float 当初设计的时候就是为了使文本围绕在浮动对象的周围。 参考: [布局概念] 关于CSS-BFC深入理解 请解释一下为什么需要清除浮动？清除浮动的方式浮动本质是用来做一些文字混排效果的，但是被我们拿来做布局用，则会有很多的问题出现。 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，为了解决这些问题，此时就需要在该元素中清除浮动。准确地说，并不是清除浮动，而是清除浮动后造成的影响 本质清除浮动主要为了解决父级元素因为子级浮动引起内部高度为 0 的问题。 如何清除设置一个 clearfix 类，在出现浮动问题的父元素上添加此类即可： 12345678910.clearfix::after &#123; content: ""; display: block; clear: both; height: 0; visibility: hidden;&#125;.clearfix &#123; *zoom: 1;&#125; 什么是外边距合并？外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并： 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并： 尽管看上去有些奇怪，但是外边距甚至可以与自身发生合并。 假设有一个空元素，它有外边距，但是 没有边框或填充 。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并： 如果这个外边距遇到另一个元素的外边距，它还会发生合并： 注释：只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。 浏览器是怎样解析CSS选择器的？从右向左的，这样会提高查找选择器所对应的元素的效率 样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。 只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。 抽离样式模块怎么写，说出思路，有无实践经验？我们按照 CSS 的性质和用途，将 CSS 文件分成 「公共型样式」、「特殊型样式」、「皮肤型样式」，并以此顺序引用（按需求决定是否添加版本号）。 公共型样式：包括了以下几个部分：“标签的重置和设置默认值”、“统一调用背景图和清除浮动或其他需统一处理的长样式”、“网站通用布局”、“通用模块和其扩展”、“元件和其扩展”、“功能类样式”、“皮肤类样式”。 特殊型样式：当某个栏目或页面的样式与网站整体差异较大或者维护率较高时，可以独立引用一个样式：“特殊的布局、模块和元件及扩展”、“特殊的功能、颜色和背景”，也可以是某个大型控件或模块的独立样式。 皮肤型样式：如果产品需要换肤功能，那么我们需要将颜色、背景等抽离出来放在这里。 参考：CSS规范 - 分类方法 元素竖向的百分比设定是相对于父容器的高度吗？ 对于 height 属性来说是的。 对于 margin-top/bottom(padding-top/bottom) 来讲不是，而是相对于容器的宽度计算的 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？响应式网站设计（Responsive Web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。 1234567@media screen and (max-width: 990px)&#123; .container&#123; background: orange; &#125;&#125;/* &lt;head&gt;里边 &lt;link rel=”stylesheet” href=”xxx.css” media=”only screen and (max-width:480px)”&gt; */ 页面头部必须有 meta 声明的 viewport ： 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"&gt; 兼容ie6-8方案：使用 respond.js 插件： 123&lt;!--[if lte IE 8]&gt;&lt;script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 响应式和自适应设计的区别其实 RWD 和 AWD 都是响应式设计，从外观上很难分辨，但他们自己运行机理不同， RWD 是主动式的响应设计，AWD 是被动式的响应式设计。 RWD 不管用户使用的是什么设备都是在服务器把数据推送到浏览器后，脚本或 CSS 自行侦测屏幕大小后执行对应的样式表内容，并且一直通过本地脚本在监听屏幕大小的变化，随时做出样式响应的变化，所以是主动的。 AWD 是用户通过浏览器发送请求后，服务器根据请求中用户设备信息（request headers 的 user-agent）做出判断，调用已经在服务器里准备好的，适应对应设备样式文件+HTML内容+JS，返回给浏览器以这种方式响应不同设备。 1234567var deviceAgent = request.headers["user-agent"].toLowerCase();var agentID = deviceAgent.match(/(iphone|ipod|ipad|android)/);if (agentID) &#123; console.log("手机访问");&#125; else &#123; console.log("电脑访问");&#125; 你对 line-height 是如何理解的？如何单行文本垂直居中？多行文本呢？行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS 中起高度作用的是 height 和 line-height ，没有定义 height 属性，最终其表现作用一定是 line-height 。 单行文本垂直居中：（行高 == 元素高度）12height:40px;line-height:40px; /* 行高==高 */ 多行文本垂直居中：（父容器table，子容器table-cell+vertical-align:center）12345678910111213141516&lt;div&gt; &lt;span&gt; 啊实打实大苏打啊实打实大师大师的啊实打实大苏打 &lt;/span&gt;&lt;/div&gt;div &#123; width: 300px; height: 200px; display: table; background-color: pink;&#125;span &#123; display: table-cell; vertical-align: middle;&#125; 设置元素浮动后，该元素的display值是多少？自动变成了 display: block 让页面里的字体变清晰，变细用CSS怎么做？1-webkit-font-smoothing: antialiased; overflow: scroll 时不能平滑滚动的问题怎么处理？一个 div 使用了 overflow:scroll; ，在移动端可以滚动，但是无法平滑滚动（就像浏览网页那样） 开启滚动硬件加速： 1-webkit-overflow-scrolling: touch; 有一个高度自适应的 div ，里面有两个 div ，一个高度 100px ，希望另一个填满剩下的高度。 HTML 123456&lt;body&gt; &lt;div class="outer"&gt; &lt;div class="A"&gt;&lt;/div&gt; &lt;div class="B"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; CSS 方案1123456789.A &#123; height: 100px; background-color: pink;&#125;.B &#123; background-color: blue; height: calc(100vh - 100px);&#125; 方案2123456789101112131415161718192021222324/* 利用border-box将padding包含在高度内； */.outer &#123; height: 100%; padding: 100px 0 0; box-sizing: border-box; background-color: pink;&#125;/* 用负margin值将A子容器顶到页面顶部*/.A &#123; height: 100px; margin: -100px 0 0; background: #BBE8F2;&#125;/* 剩下的高度100%-100px就是B容器所谓的100%高了*/.B &#123; height: 100%; background: #D9C666;&#125; 方案312345678910111213141516171819202122.outer &#123; height: 100%; padding: 100px 0 0; box-sizing: border-box; position: relative;&#125;/* 绝对定*/.A &#123; height: 100px; background: #BBE8F2; position: absolute; top: 0; left: 0; width: 100%;&#125;.B &#123; height: 100%; background: #D9C666;&#125; 方案4123456789101112131415161718.outer &#123; height: 100%; position: relative;&#125;.A &#123; height: 100px; background: #BBE8F2;&#125;.B &#123; background: #D9C666; width: 100%; position: absolute; top: 100px; left: 0; bottom: 0;&#125; 方案512345678910111213141516171819.outer &#123; height: 100%; background: red; display: flex; display: -webkit-flex; flex-direction: column; -webkit-flex-direction: row;&#125;.A &#123; width: 100%; height: 100px; background: green;&#125;.B &#123; background: blue; flex: 1;&#125; 什么是 CSS 预处理器 / 后处理器？CSS 预处理器CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件 Sass（SCSS）、LESS CSS 后处理器CSS 后处理器 是对 CSS 进行处理，并最终生成 CSS 的 预处理器，它属于广义上的 CSS 预处理器。 我们很久以前就在用 CSS 后处理器 了，最典型的例子是 CSS 压缩工具（如 clean-css），只不过以前没单独拿出来说过。还有最近比较火的 Autoprefixer，以 Can I Use 上的 浏览器支持数据 为基础，自动处理兼容性问题。 Rework、PostCSS 参考：CSS预处理器和后处理器 rem布局的优缺点优点： 能维持能整体的布局效果，移动端兼容性好，不用写多个css代码，而且还可以利用@media进行优化。 缺点： 开头要引入一段 js 代码，单位都要改成 rem（ font-size 可以用 px ），计算 rem 比较麻烦(可以引用预处理器，但是增加了编译过程，相对麻烦了点)。PC 和 Mobile 要分开。 参考： 用 rem 实现 WebApp 自适应的优劣分析 CSS3 的字体大小单位[rem]到底好在哪？ 总结个人使用过的移动端布局方法 图片为什么有左右上下间隙,怎么去除：原因： 左右：因为 img 是 inline-block 行内元素，行内元素之间有『换行（回车），空格，tab』时会产生左右间隙 上下：行内元素默认与父容器基线对齐，而基线与父容器底部有一定间隙，所以上下图片间有间隙 解决办法： 移除上下间隙： img本身设置 display: block; 父元素设置 font-size: 0; （基线与字体大小有关，字体为零，基线间就没距离了） img本身设置 vertical-align: bottom;（让 inline-block 的 img 与每行的底部对齐） 移除左右间距： 行内元素间不要有换行，连成一行写消除间隙 第一行结尾写上 &lt;!-- ，第二行开头跟上 --&gt; 。即利用注释消除间距 父元素 font-size 设置 0 慎用 em 的原因em会叠加计算。在这个机制下太容易犯错了，因为你不知道这段css指定的字号具体是多少。 HTML 12345&lt;span&gt; abc &lt;span&gt;def&lt;/span&gt; abc&lt;/span&gt; CSS 1span &#123; font-size: 1.5em; &#125; 实际效果： 先要搞清楚 em 的计算原理，它是根据当前元素的字号按比例计算的。 外层 span 的字号是 16px（浏览器默认值），所以 1.5em 之后是 24px 。由于字号是继承的，导致内层 span 的字号继承过来是 24px ，再经过 1.5em 之后就成了 36px 。 所以，就算要用 em 的话，尽量不要用在继承属性（font-size）上，除非你真的清楚你在做什么！ Flex 弹性布局对 flex 不熟悉的同学可以参考下面网站进行学习： 30 分钟学会 Flex 布局 flex网页布局首选方案 灵活应用 flex 弹性布局快速构建 web 结构 不愿意看长篇大论的可以通过这个塔防游戏来学习：Flexbox Defense 两列布局（左列定宽，右列自适应） HTML 1234&lt;body&gt; &lt;div id="left"&gt;左列定宽&lt;/div&gt; &lt;div id="right"&gt;右列自适应&lt;/div&gt;&lt;/body&gt; 1. 利用 float + margin123456789101112131415#left &#123; background-color: #f00; float: left; width: 100px; height: 500px;&#125;#right &#123; background-color: #0f0; height: 500px; margin-left: 100px; /*设置间隔，大于等于#left的宽度*/&#125;原理：#left左浮动，脱离文档流，#right为了不被#left挡住，设置margin-left大于等于#left的宽度达到视觉上的两栏布局 2. 使用 float + overflow（触发bfc）1234567891011121314#left &#123; background-color: #f00; float: left; width: 100px; height: 500px;&#125;#right &#123; background-color: #0f0; height: 500px; overflow: hidden; /*触发bfc达到自适应*/&#125;原理：#left左浮动，#right触发bfc达到自适应 3. 使用 table 实现123456789101112131415161718#parent &#123; width: 100%; display: table; height: 500px;&#125;#left &#123; width: 100px; background-color: #f00;&#125;#right &#123; background-color: #0f0;&#125;/*利用单元格自动分配宽度*/#left, #right &#123; display: table-cell;&#125; 4. 使用 position 实现123456789101112131415161718192021#parent&#123; position: relative;&#125; /*父相*/#left &#123; position: absolute; /*子绝*/ top: 0; left: 0; background-color: #f00; width: 100px; height: 500px;&#125;#right &#123; position: absolute; /*子绝*/ top: 0; left: 100px; /*值大于等于#left的宽度*/ right: 0; background-color: #0f0; height: 500px;&#125; 5. 使用 flex 实现123456789101112131415#parent &#123; width: 100%; height: 500px; display: flex;&#125;#left &#123; width: 100px; background-color: #f00;&#125;#right &#123; flex: 1; /*均分了父元素剩余空间*/ background-color: #0f0;&#125; 两列布局（一列不定宽，一列自适应）1. float + overflow1234567891011121314#left &#123; margin-right: 10px; float: left; /*只设置浮动,不设宽度*/ height: 500px; background-color: #f00;&#125;#right &#123; overflow: hidden; /*触发bfc*/ height: 500px; background-color: #0f0;&#125;原理：#left不设宽度左浮动，#right触发 bfc 达到自适应 2. flex 布局123456789101112131415#parent&#123; display: flex;&#125;#left &#123; /*不设宽度*/ margin-right: 10px; height: 500px; background-color: #f00;&#125;#right &#123; height: 500px; background-color: #0f0; flex: 1; /*均分#parent剩余的部分*/&#125; 三列布局（左中定宽，右侧自适应） HTML 1234567&lt;body&gt;&lt;div id="parent"&gt; &lt;div id="left"&gt;左列定宽&lt;/div&gt; &lt;div id="center"&gt;中间定宽&lt;/div&gt; &lt;div id="right"&gt;右列自适应&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 1. float + margin123456789101112131415161718192021222324#parent&#123; min-width: 310px;&#125; /*100+10+200,防止宽度不够,子元素换行*/#left &#123; margin-right: 10px; /*#left和#center间隔*/ float: left; width: 100px; height: 500px; background-color: #f00;&#125;#center&#123; float: left; width: 200px; height: 500px; background-color: #eeff2b;&#125;#right &#123; margin-left: 320px; /*等于#left和#center的宽度之和加上间隔,多出来的就是#right和#center的间隔*/ height: 500px; background-color: #0f0;&#125; 2. float + overflow12345678910111213141516171819202122232425#parent&#123; min-width: 320px;&#125; /*100+10+200+20,防止宽度不够,子元素换行*/#left &#123; margin-right: 10px; /*间隔*/ float: left; width: 100px; height: 500px; background-color: #f00;&#125;#center&#123; margin-right: 10px; /*在此定义和#right的间隔*/ float: left; width: 200px; height: 500px; background-color: #eeff2b;&#125;#right &#123; overflow: hidden; /*触发bfc*/ height: 500px; background-color: #0f0;&#125; 3. 利用 position123456789101112131415161718192021222324252627282930#parent &#123; position: relative;&#125; /*父相*/#left &#123; position: absolute; /*子绝*/ top: 0; left: 0; width: 100px; height: 500px; background-color: #f00;&#125;#center &#123; position: absolute; /*子绝*/ left: 100px; /*对应#left的width值*/ top: 0; width: 200px; height: 500px; background-color: #eeff2b;&#125;#right &#123; position: absolute; /*子绝*/ left: 300px; /*对应#left和#center的width值之和*/ top: 0; right: 0; height: 500px; background-color: #0f0;&#125; 4. 利用 table12345678910111213141516171819202122232425#parent &#123; width: 100%; height: 520px; /*抵消上下间距10*2的高度影响*/ margin: -10px 0; /*抵消上下边间距10的位置影响*/ display: table; /*左右两边间距无法消除,子元素改用padding设置盒子间距就没有这个问题*/ border-spacing: 10px; /*关键!!!设置间距*/&#125;#left &#123; display: table-cell; width: 100px; background-color: #f00;&#125;#center &#123; display: table-cell; width: 200px; background-color: #eeff2b;&#125;#right &#123; display: table-cell; background-color: #0f0;&#125; 5. 利用 flex123456789101112131415161718192021#parent &#123; height: 500px; display: flex;&#125;#left &#123; margin-right: 10px; /*间距*/ width: 100px; background-color: #f00;&#125;#center &#123; margin-right: 10px; /*间距*/ width: 200px; background-color: #eeff2b;&#125;#right &#123; flex: 1; /*均分#parent剩余的部分达到自适应*/ background-color: #0f0;&#125; 三列布局（两侧定宽，中间自适应）圣杯布局 详解 HTML 12345&lt;div class="container"&gt; &lt;div class="center"&gt;中间&lt;/div&gt; &lt;!-- 让中间第一，这样浮动的时候它会先占据100%宽 --&gt; &lt;div class="left"&gt;左边&lt;/div&gt; &lt;div class="right"&gt;右边&lt;/div&gt;&lt;/div&gt; CSS 12345678910111213141516171819202122232425262728293031.container &#123; height: 500px; min-width: 400px; /* 左边w*2+右边w */ padding: 0 100px 0 150px; /* 1. 父容器左右留出固定padding */ background-color: gray;&#125;.left &#123; margin-left: -100%; /* 4.1 让被挤到center下方的left左移整个容器的宽度，此时左上角与center重叠 */ position: relative; /* 4.2 为了让left移到最左边,设置相对定位 */ left: -150px; /* 4.3 然后相对自己左移自已宽度的单位，使自己移动到最左边 */ height: 100%; float: left; /* 2.1 左浮动 */ width: 150px; background-color: rgba(233, 233, 0, .2);&#125;.center &#123; height: 100%; width: 100%; /* 3. 让center占据剩下父容器的100%宽 */ float: left; /* 2.1 左浮动 */ background-color: rgba(165, 12, 23, .4);&#125;.right &#123; margin-right: -100px; /* 5. 给在第二行的right设置一个负自己宽度的margin-right。让其最右边 */ height: 100%; width: 100px; float: left; /* 2.1 左浮动 */ background-color: green;&#125; 双飞翼布局方法 详情 HTML 1234567&lt;div class="container"&gt; &lt;div class="center"&gt; &lt;div&gt;中间&lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;左边&lt;/div&gt; &lt;div class="right"&gt;右边&lt;/div&gt;&lt;/div&gt; CSS 1234567891011121314151617181920212223242526272829303132.container &#123; width: 100%; /* 1. 整个容器宽100%自适应 */ height: 500px; background-color: gray;&#125;.left &#123; width: 100px; /* 3.1 设置定宽 */ margin-left: -100%; /* 5. 左移容器宽度100%个单位，就把自己排在了center前面 */ background-color: rgba(233, 233, 0, .2);&#125;.center &#123; width: 100%; /* 4. 中间容器100%，此时会把左右挤到第二行 */ background-color: rgba(165, 12, 23, .4);&#125;.center div &#123; margin: 0 150px 0 100px; /* 7. 此时center的左右分别有100和150宽与left，right重叠。所以让center子容器左右margin抵消 */&#125;.right &#123; width: 150px; /* 3.2 设置定宽 */ margin-left: -150px; /* 6. 同样左移自身宽度的单位，让right也回到第一行 */ background-color: green;&#125;.left, .center, .right &#123; height: 100%; float: left; /*2. 子容器全部左浮动 */&#125; 布局的几种方式 伸缩布局 flex 流式布局 百分比 响应式布局 媒体查询（超小屏设备时：流式布局） &lt;!- 以上布局共同点：元素只能做到宽度的适配（排除图片）-&gt; rem布局 宽度和高度都能做到适配（等比适配）]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML知识点（面试系列）]]></title>
    <url>%2Fposts%2F13781%2F</url>
    <content type="text"><![CDATA[HTMLHTML5 的新特性 画布：canvas 123456789101112131415&lt;body&gt; &lt;canvas width="500" height="500"&gt;&lt;/canvas&gt; &lt;script&gt; var canvas = document.querySelector("canvas") &lt;!-- 获取上下文 --&gt; var ctx = canvas.getContext("2d") ctx.beginPath() &lt;!-- 设置图形轮廓的颜色 --&gt; ctx.strokeStyle = "red" &lt;!-- 绘制直线 --&gt; ctx.moveTo(10, 20) ctx.lineTo(100, 200) ctx.stroke() &lt;/script&gt; &lt;/body&gt; 媒体元素：video 和 audio 12&lt;video src="视频资源路径" poster="海报资源路径" controls autoplay&gt;&lt;audio src="音频资源路径" controls autoplay loop&gt; 本地存储：localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删除; 语义元素：header, nav, main, section, article, footer; 表单控件：calendar, date, time, email, url, search 新技术：Web Worker, WebSocket, Geolocation 你对 HTML 语义化的理解 使代码结构清晰，方便阅读 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页 利于搜索引擎优化（SEO），使搜索引擎爬虫能更好的确定网页上下文和各个关键字的权重]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站性能优化]]></title>
    <url>%2Fposts%2F41624%2F</url>
    <content type="text"><![CDATA[关键渲染路径What关键渲染路径（Critical Rendering Path）指的是：「浏览器所经历的一系列步骤，从而将 HTML、CSS 和 JavaScript 转换为在屏幕上呈现的像素内容」我们要做的，就是优化关键渲染路径，这样就能提高网页呈现的速度，从而使用户和老板更满意。 网页生成过程说白了，「关键渲染路径」即「网页生成的过程」，简要概述就是： 处理 HTML 标记并构建 DOM 树 处理 CSS 标记并构建 CSSOM 树 将 DOM 与 CSSOM 合并成一个渲染树 根据渲染树来布局，以计算每个节点的几何信息 将各个节点绘制到屏幕上 将 HTML 转为 DOM文档对象模型（DOM）存储的是「页面内容」及每个节点「属性方面的数据」。DOM 中对象之间的关系展示了父子节点以及兄弟节点。 注意：DOM 的构建过程是逐步实现的，意味着一旦获得了 HTML 就可以开始构建 DOM 了，不需要等待整个 HTML 页面加载完毕后再去构建 DOM 。 将 CSS 转为 CSSOM 合并渲染树完成了 DOM 树和 CSSOM 树的构建以后，就要将它们合并成一个渲染树。 注意：某些节点如果通过 CSS 隐藏，那么在渲染树中也会被忽略，例如我们在 HTML 中编写的 span 节点，它就不会出现在渲染树中。因为有一个 CSS 规则在 span 上设置了 display: none 属性。 布局与绘制在渲染树构建阶段，我们已经计算了哪些节点应该是可见的以及它们的计算样式，所以在布局阶段，我们就需要计算它们在设备视口内的确切位置和大小。这个过程称为布局，或者叫做重排。 最后，既然我们知道了哪些节点可见、它们的计算样式以及几何信息，我们终于可以将这些信息传递给最后一个阶段：将渲染树中的每个节点转换成屏幕上的实际像素。这一步通常称为“绘制”或“栅格化”。到此，浏览器对网页的第一次生成过程已经结束。 而我们的前端网站性能优化，也就是针对整个「关键渲染路径」而言的。只有最大限度的缩短上面第 1 至 5 步耗费的总时间，才能尽快的将内容渲染到屏幕上，此外还能缩短首屏的加载时间。 网页加载的优化优化DOM压缩+删除注释为了将 HTML 文件尽可能快的传输给浏览器（客户端），我们需要压缩文件的大小，例如下面html文件： 123456789101112131415161718&lt;html&gt;&lt;head&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* reset */ * &#123; padding: 0; margin: 0; list-style: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 头部 --&gt; &lt;header&gt;...&lt;/header&gt; &lt;!-- 正文 --&gt; &lt;main&gt;...&lt;/main&gt; &lt;!-- 底部 --&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 这段代码包含了非常多的注释，这些注释对开发者来说可能有用，然而浏览器在遇到注释时却会忽略它们的，所以根本没必要展示给浏览器，我们完全可以移除它们。另外空格和换行也是个大问题，它会增加我们文件的体积，所以我们需要利用一些工具去压缩它。 上图是在删除掉所有注释，并使用 在线JS压缩工具 压缩后的文件大小对比。当然，这种策略同样适用于 CSS 文件，你可以使用类似的步骤对 CSS 进行注释的删除与压缩。 如果你使用 webpack 构建你的应用，你可以使用下面插件来优化html、css和js： optimize-css-assets-webpack-plugin（优化css） html-webpack-plugin（配置与优化html） webpack-parallel-uglify-plugin（优化js） 优化 CSSOMCSS 在默认情况下是阻塞渲染的一类资源，也就是说浏览器在 CSSOM 构建完成以前是不会渲染任何已处理的内容的，所以我们必须对 CSS 进行精简。由于浏览器必须同时具有 DOM 以及 CSSOM 才能构建渲染树，所以 HTML 和 CSS 都是阻塞渲染的资源。刚才已经针对 HTML 进行了优化，现在该轮到 CSS 了。 压缩+删除注释这一点不多赘述，参考上面html的优化步骤。 内联 CSS如果你的 css 文件很小，小到仅有几十甚至几KB，那么你完全可以将 css 内联进 html ，因为相比使用 link 外链还得发一个请求，内联的代价要小的多得多。 利用 Media 媒体查询有时候一些 CSS 样式只在特定条件下使用，比如打印网页或者网页在大型显示器上显示时。这个时候我们的 media 媒体查询就能大显身手了，它能让这些特定的 CSS 资源不去阻塞页面的渲染。 123&lt;link rel="stylesheet" href="style.css"&gt;&lt;link rel="stylesheet" href="print.css" media="print"&gt;&lt;link rel="stylesheet" href="other.css" media="(min-width: 980px)"&gt; 上面的例子在我们的项目中很常见，第一个样式表适用于所有情况，它始终会阻塞渲染。但第二个样式表则不然，它只在打印内容时适用，因此在网页首次加载时，该样式表不需要阻塞渲染。最后一个样式表声明则只在特定环境下被执行，一旦不符合最小宽度大于980px，则始终不会被加载，这样我们就又少了一个不阻塞页面渲染的 CSS 资源。 注意： 「阻塞渲染」仅是指浏览器是否需要暂停网页的首次渲染，直至该资源准备就绪。无论哪一种情况，浏览器仍会下载 CSS 资源，只不过不阻塞渲染的资源优先级较低罢了。 CSS会造成阻塞吗？ css 加载不会阻塞 DOM 树的解析 css 加载会阻塞 DOM 树的渲染 css 加载会阻塞后面 js 语句的执行 了解更多：https://www.cnblogs.com/chenjg/p/7126822.html 优化 JavaScript默认情况下，无论内联还是外联，浏览器遇到文档中的 JavaScript 时都会暂停 DOM 构建，并立即开始执行 JavaScript ，等到脚本执行完毕后，再继续构建 DOM。所以为了提高页面渲染速度，我们可以让 JavaScript 异步执行。 window.onload这种解决方案是让脚本在网页加载完毕后再执行。当网页加载完毕后，浏览器会发出 onload 事件，我们可以将 JavaScript 放进 onload 事件的回调函数中，这样当 onload 事件被触发后，就能执行我们的脚本了，示例如下： 1234567891011121314&lt;html&gt; &lt;head&gt; &lt;script&gt; function load() &#123; init() doSomethingElse() &#125; window.onload = load &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;...&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; defer / async我们还可以向 script 标签添加异步关键字，那样可以让浏览器在等待脚本期间不阻止 DOM 以及 CSSOM 的构建。 而关于 defer 和 async 的区别，一图胜千言： （出处：https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html） 简单来说，当浏览器遇到 script 脚本的时候： &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，即不等待后续载入的文档元素，读到就加载并执行。 &lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 &lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt;有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 注意：HTML5 规定，defer 脚本最后的延迟执行应该按照书写顺序来执行，即下面示例脚本，a.js 一定在 b.js 前面执行： 1234567&lt;html&gt;&lt;head&gt; &lt;script defer src="./js/a.js"&gt;&lt;/script&gt; &lt;script defer src="./js/b.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 但在 「JavaScript 高级程序设计（第三版）」中作者表示： 在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。 我个人是试验过各种浏览器的，Chrome、Firefox、Safari，没有出现作者所说的情况。所以我猜测作者写上这一句话的原因是：即使在 HTML5 规范中有这么一条，不一定所有的浏览器厂商都会遵照这个规定，可能某些浏览器厂商并没有实现这个规范，所以为了安全起见，在开发中使用一个 defer 是非常有必要的。 HTTP 缓存这部分内容可以点击此处查看 渲染性能的优化页面不仅要快速加载，而且要顺畅地运行；例如列表页的滚动应与手指的滑动一样快，侧边栏的弹出隐藏动画应如丝绸般顺滑。所以除了对关键渲染路径的优化以外，我们还得确保自己编写的代码能（包括其他第三方代码）更高效地运行。 像素管道首先我们要了解下「像素管道」的概念。像素管道是「网页从像素到屏幕」的一系列关键节点： JavaScript：指的是使用 JavaScript 来实现一些视觉变化的效果。（e.g. 给页面添加 DOM 元素） 样式计算：指的是根据「匹配选择器」计算出元素所应用的 CSS 规则的过程。 布局：指的是浏览器根据元素所应用的规则计算它们要占据的空间大小及其在屏幕的位置。 绘制：指的是填充像素的过程。（e.g. 绘制文本、颜色、边框和阴影，基本上包括元素的每个可视部分）绘制一般是在多个层上完成的。 合成：由于页面的各部分可能被绘制到多层，所以它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。 我们在编写代码的时候要时刻注意这五个关键节点，因为其中的每一个部分都可能为我们的应用带来“卡顿”。 使用 requestAnimationFrame试想一下，假设现在浏览器正在执行有关样式方面的工作，然后出现了需要处理的 JavaScript 。这个时候浏览器会马上停下手中的活儿，转而执行插进来的 JavaScript ，然而新来的 JavaScript 是有可能导致刚才处理的样式工作重新返工的（配合上面的「管道图」来看，相当于 style 阶段完成后却执行了 JavaScript ，导致丢帧），这样一来浏览器就很有可能丢失了刚才处理完的这一帧，从而导致卡顿现象。所以没错，当你在使用 JavaScript 编写一段动画时，可以使用 RequestAnimationFrame API，该 API 能够提升我们的动画流畅度，因为它会安排 JavaScript 尽早在每一帧的开始执行，这样尽量给浏览器留出足够的时间来运行代码，然后是样式过程——&gt;布局过程——&gt;绘制过程——&gt;渲染层合并过程。示例： 123456789function animationWidth() &#123; var div = document.getElementById('box'); div.style.width = parseInt(div.style.width) + 1 + 'px'; if (parseInt(div.style.width) &lt; 200) &#123; requestAnimationFrame(animationWidth) &#125;&#125;requestAnimationFrame(animationWidth); 避免重排与重绘What 重排：当 DOM 的变化影响了元素的几何信息（DOM 对象的位置和尺寸大小），浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。 重绘：当一个元素更改了非几何属性（e.g. 背景、文本或阴影），但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。 浏览器的渲染队列思考以下代码将会触发几次渲染？ 1234div.style.left = '10px';div.style.top = '10px';div.style.width = '20px';div.style.height = '20px'; 根据我们上文的定义，这段代码理论上会触发4次重排+重绘，因为每一次都改变了元素的几何属性。但实际上最后只触发了一次重排，这都得益于浏览器的渲染队列机制：当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。 强制刷新队列12345678div.style.left = '10px';console.log(div.offsetLeft);div.style.top = '10px';console.log(div.offsetTop);div.style.width = '20px';console.log(div.offsetWidth);div.style.height = '20px';console.log(div.offsetHeight); 这段代码会触发4次重排+重绘，因为在console中你请求的这几个样式信息，无论何时浏览器都会立即执行渲染队列的任务，即使该值与你操作中修改的值没关联。因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘。强制刷新队列的style样式请求： offsetTop, offsetLeft, offsetWidth, offsetHeight scrollTop, scrollLeft, scrollWidth, scrollHeight clientTop, clientLeft, clientWidth, clientHeight getComputedStyle(), 或者 IE的 currentStyle 所以我们在开发中，应该谨慎的使用这些style请求，注意上下文关系，避免一行代码一个重排，这对性能是个巨大的消耗。 重排优化建议分离读写操作12345678div.style.left = '10px';div.style.top = '10px';div.style.width = '20px';div.style.height = '20px';console.log(div.offsetLeft);console.log(div.offsetTop);console.log(div.offsetWidth);console.log(div.offsetHeight); 还是上面触发4次重排+重绘的代码，这次只触发了一次重排：在第一个console的时候，浏览器把之前上面四个写操作的渲染队列都给清空了。剩下的console，因为渲染队列本来就是空的，所以并没有触发重排，仅仅拿值而已。 样式集中改变1234div.style.left = '10px';div.style.top = '10px';div.style.width = '20px';div.style.height = '20px'; 虽然现在大部分浏览器有渲染队列优化，不排除有些浏览器以及老版本的浏览器效率仍然低下。 建议通过改变 class 或者 csstext 属性集中改变样式 123456789// badvar left = 10;var top = 10;el.style.left = left + "px";el.style.top = top + "px";// good el.className += " theclassname";// goodel.style.cssText += "; left: " + left + "px; top: " + top + "px;"; 缓存布局信息12345678// bad 强制刷新 触发两次重排div.style.left = div.offsetLeft + 1 + 'px';div.style.top = div.offsetTop + 1 + 'px';// good 缓存布局信息 相当于读写分离var curLeft = div.offsetLeft;var curTop = div.offsetTop;div.style.left = curLeft + 1 + 'px';div.style.top = curTop + 1 + 'px'; 离线改变dom 隐藏要操作的dom在要操作dom之前，通过 display 隐藏 dom ，当操作完成之后，才将元素的 display 属性为可见，因为不可见的元素不会触发重排和重绘。 123dom.display = 'none'// 修改dom样式dom.display = 'block' 通过使用 DocumentFragment 创建一个 dom 碎片,在它上面批量操作 dom ，操作完成之后，再添加到文档中，这样只会触发一次重排。 复制节点，在副本上工作，然后替换它！ position属性为absolute或fixedposition属性为absolute或fixed的元素，重排开销比较小，不用考虑它对其他元素的影响 优化动画 可以把动画效果应用到position属性为absolute或fixed的元素上，这样对其他元素影响较小动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量：比如实现一个动画，以1个像素为单位移动这样最平滑，但是 reflow 就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多。 启用 GPU 加速此部分来自优化CSS重排重绘与浏览器性能GPU（图像加速器）：GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成，因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。GPU 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。 1234567891011121314/* * 根据上面的结论 * 将 2d transform 换成 3d * 就可以强制开启 GPU 加速 * 提高动画性能 */div &#123; transform: translate3d(10px, 10px, 0);&#125;/* 又或者使用 will-change 属性来创建新层 */div &#123; will-change: transform;&#125; 参考资源 Google Web Fundamentals - Performance css加载会造成阻塞吗？ async vs defer attributes]]></content>
      <categories>
        <category>前端</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event Loop、计时器、nextTick（转载）]]></title>
    <url>%2Fposts%2F61492%2F</url>
    <content type="text"><![CDATA[这是一篇转载文章，源地址是方应杭在掘金上发表的一篇译文：Event Loop、计时器、nextTick 原文：https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/ 以下是译文： 什么是事件循环（Event Loop，注意空格）JavaScript 是单线程的，有了 event loop 的加持，Node.js 才可以非阻塞地执行 I/O 操作，把这些操作尽量转移给操作系统来执行。 我们知道大部分现代操作系统都是多线程的，这些操作系统可以在后台执行多个操作。当某个操作结束了，操作系统就会通知 Node.js，然后 Node.js 就（可能）会把对应的回调函数添加到 poll（轮询）队列，最终这些回调函数会被执行。下文中我们会阐述其细节。 Event Loop 详解当 Node.js 启动时，会做这几件事 初始化 event loop 开始执行脚本（或者进入 REPL，本文不涉及 REPL）。这些脚本有可能会调用一些异步 API、设定计时器或者调用 process.nextTick() 开始处理 event loop 如何处理 event loop 呢？下图给出了一个简单的概览： 123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ 其中每个方框都是 event loop 中的一个阶段。 每个阶段都有一个「先入先出队列」，这个队列存有要执行的回调函数（译注：存的是函数地址）。不过每个阶段都有其特有的使命。一般来说，当 event loop 达到某个阶段时，会在这个阶段进行一些特殊的操作，然后执行这个阶段的队列里的所有回调。 什么时候停止执行这些回调呢？下列两种情况之一会停止： 队列的操作全被执行完了 执行的回调数目到达指定的最大值 然后，event loop 进入下一个阶段，然后再下一个阶段。 一方面，上面这些操作都有可能添加计时器；另一方面，操作系统会向 poll 队列中添加新的事件，当 poll 队列中的事件被处理时可能会有新的 poll 事件进入 poll 队列。结果，耗时较长的回调函数可以让 event loop 在 poll 阶段停留很久，久到错过了计时器的触发时机。你可以在下文的 timers 章节和 poll 章节详细了解这其中的细节。 注意，Windows 的实现和 Unix/Linux 的实现稍有不同，不过对本文内容影响不大。本文囊括了 event loop 最重要的部分，不同平台可能有七个或八个阶段，但是上面的几个阶段是我们真正关心的阶段，而且是 Node.js 真正用到的阶段。 各阶段概览 timers 阶段：这个阶段执行 setTimeout 和 setInterval 的回调函数。 I/O callbacks 阶段：不在 timers 阶段、close callbacks 阶段和 check 阶段这三个阶段执行的回调，都由此阶段负责，这几乎包含了所有回调函数。 idle, prepare 阶段（译注：看起来是两个阶段，不过这不重要）：event loop 内部使用的阶段（译注：我们不用关心这个阶段） poll 阶段：获取新的 I/O 事件。在某些场景下 Node.js 会阻塞在这个阶段。 check 阶段：执行 setImmediate() 的回调函数。 close callbacks 阶段：执行关闭事件的回调函数，如 socket.on(‘close’, fn) 里的 fn。 一个 Node.js 程序结束时，Node.js 会检查 event loop 是否在等待异步 I/O 操作结束，是否在等待计时器触发，如果没有，就会关掉 event loop。 各阶段详解timers 阶段计时器实际上是在指定多久以后可以执行某个回调函数，而不是指定某个函数的确切执行时间。当指定的时间达到后，计时器的回调函数会尽早被执行。如果操作系统很忙，或者 Node.js 正在执行一个耗时的函数，那么计时器的回调函数就会被推迟执行。 注意，从原理上来说，poll 阶段能控制计时器的回调函数什么时候被执行。 举例来说，你设置了一个计时器在 100 毫秒后执行，然后你的脚本用了 95 毫秒来异步读取了一个文件： 12345678910111213141516171819202122232425const fs = require('fs');function someAsyncOperation(callback) &#123; // 假设读取这个文件一共花费 95 毫秒 fs.readFile('/path/to/file', callback);&#125;const timeoutScheduled = Date.now();setTimeout(() =&gt; &#123; const delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;毫秒后执行了 setTimeout 的回调`);&#125;, 100);// 执行一个耗时 95 毫秒的异步操作someAsyncOperation(() =&gt; &#123; const startCallback = Date.now(); // 执行一个耗时 10 毫秒的同步操作 while (Date.now() - startCallback &lt; 10) &#123; // 什么也不做 &#125;&#125;); 当 event loop 进入 poll 阶段，发现 poll 队列为空（因为文件还没读完），event loop 检查了一下最近的计时器，大概还有 100 毫秒时间，于是 event loop 决定这段时间就停在 poll 阶段。在 poll 阶段停了 95 毫秒之后，fs.readFile 操作完成，一个耗时 10 毫秒的回调函数被系统放入 poll 队列，于是 event loop 执行了这个回调函数。执行完毕后，poll 队列为空，于是 event loop 去看了一眼最近的计时器（译注：event loop 发现卧槽，已经超时 95 + 10 - 100 = 5 毫秒了），于是经由 check 阶段、close callbacks 阶段绕回到 timers 阶段，执行 timers 队列里的那个回调函数。这个例子中，100 毫秒的计时器实际上是在 105 毫秒后才执行的。 注意：为了防止 poll 阶段占用了 event loop 的所有时间，libuv（Node.js 用来实现 event loop 和所有异步行为的 C 语言写成的库）对 poll 阶段的最长停留时间做出了限制，具体时间因操作系统而异。 I/O callbacks 阶段这个阶段会执行一些系统操作的回调函数，比如 TCP 报错，如果一个 TCP socket 开始连接时出现了 ECONNREFUSED 错误，一些 *nix 系统就会（向 Node.js）通知这个错误。这个通知就会被放入 I/O callbacks 队列。 poll 阶段（轮询阶段）poll 阶段有两个功能： 如果发现计时器的时间到了，就绕回到 timers 阶段执行计时器的回调。 然后再，执行 poll 队列里的回调。 当 event loop 进入 poll 阶段，如果发现没有计时器，就会： 如果 poll 队列不是空的，event loop 就会依次执行队列里的回调函数，直到队列被清空或者到达 poll 阶段的时间上限。 如果 poll 队列是空的，就会： 如果有 setImmediate() 任务，event loop 就结束 poll 阶段去往 check 阶段。 如果没有 setImmediate() 任务，event loop 就会等待新的回调函数进入 poll 队列，并立即执行它。 一旦 poll 队列为空，event loop 就会检查计时器有没有到期，如果有计时器到期了，event loop 就会回到 timers 阶段执行计时器的回调。 check 阶段这个阶段允许开发者在 poll 阶段结束后立即执行一些函数。如果 poll 阶段空闲了，同时存在 setImmediate() 任务，event loop 就会进入 check 阶段。 setImmediate() 实际上是一种特殊的计时器，有自己特有的阶段。它是通过 libuv 里一个能将回调安排在 poll 阶段之后执行的 API 实现的。 一般来说，当代码执行后，event loop 最终会达到 poll 阶段，等待新的连接、新的请求等。但是如果一个回调是由 setImmediate() 发出的，同时 poll 阶段空闲下来了，event loop就会结束 poll 阶段进入 check 阶段，不再等待新的 poll 事件。 （译注：感觉同样的话说了三遍） close callbacks 阶段如果一个 socket 或者 handle 被突然关闭（比如 socket.destroy()），那么就会有一个 close 事件进入这个阶段。否则（译注：我没看到这个否则在否定什么，是在否定「突然」吗？），这个 close 事件就会进入 process.nextTick()。 setImmediate() vs setTimeout()setImmediate 和 setTimeout 很相似，但是其回调函数的调用时机却不一样。 setImmediate() 的作用是在当前 poll 阶段结束后调用一个函数。 setTimeout() 的作用是在一段时间后调用一个函数。 这两者的回调的执行顺序取决于 setTimeout 和 setImmediate 被调用时的环境。 如果 setTimeout 和 setImmediate 都是在主模块（main module）中被调用的，那么回调的执行顺序取决于当前进程的性能，这个性能受其他应用程序进程的影响。 举例来说，如果在主模块中运行下面的脚本，那么两个回调的执行顺序是无法判断的： 12345678// timeout_vs_immediate.jssetTimeout(() =&gt; &#123; console.log('timeout');&#125;, 0);setImmediate(() =&gt; &#123; console.log('immediate');&#125;); 运行结果如下： 1234567$ node timeout_vs_immediate.jstimeoutimmediate$ node timeout_vs_immediate.jsimmediatetimeout 但是，如果把上面代码放到 I/O 操作的回调里，setImmediate 的回调就总是优先于 setTimeout 的回调： 1234567891011// timeout_vs_immediate.jsconst fs = require('fs');fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log('timeout'); &#125;, 0); setImmediate(() =&gt; &#123; console.log('immediate'); &#125;);&#125;); 运行结果如下： 1234567$ node timeout_vs_immediate.jsimmediatetimeout$ node timeout_vs_immediate.jsimmediatetimeout setImmediate 的主要优势就是，如果在 I/O 操作的回调里，setImmediate 的回调总是比 setTimeout 的回调先执行。（译者注：怎么总是把一个道理翻来覆去地说） process.nextTick()你可能发现 process.nextTick() 这个重要的异步 API 没有出现在任何一个阶段里，那是因为从技术上来讲 process.nextTick() 并不是 event loop 的一部分。实际上，不管 event loop 当前处于哪个阶段，nextTick 队列都是在当前阶段后就被执行了。 回过头来看我们的阶段图，你在任何一个阶段调用 process.nextTick(回调)，回调都会在当前阶段继续运行前被调用。这种行为有的时候会造成不好的结果，因为你可以递归地调用 process.nextTick()，这样 event loop 就会一直停在当前阶段不走……无法进入 poll 阶段。 为什么 Node.js 要这样设计 process.nextTick 呢？ 因为有些异步 API 需要保证一致性，即使可以同步完成，也要保证异步操作的顺序，看下面代码： 1234function apiCall(arg, callback) &#123; if (typeof arg !== 'string') return process.nextTick(callback, new TypeError('argument should be string'));&#125; 这段代码检查了参数的类型，如果类型不是 string，就会将 error 传递给 callback。 这段代码保证 apiCall 调用之后的同步代码能在 callback 之前运行。用于用到了 process.nextTick()，所以 callback 会在 event loop 进入下一个阶段前执行。为了做到这一点，JS 的调用栈可以先 unwind 再执行 nextTick 的回调，这样无论你递归调用多少次 process.nextTick() 都不会造成调用栈溢出（V8 里对应 RangeError: Maximum call stack size exceeded）。 如果不这样设计，会造成一些潜在的问题，比如下面的代码： 123456789101112let bar;// 这是一个异步 API，但是却同步地调用了 callbackfunction someAsyncApiCall(callback) &#123; callback(); &#125;//`someAsyncApiCall` 在执行过程中就调用了回调someAsyncApiCall(() =&gt; &#123; // 此时 bar 还没有被赋值为 1 console.log('bar', bar); // undefined&#125;);bar = 1; 开发者虽然把 someAsyncApiCall 命名得像一个异步函数，但是实际上这个函数是同步执行的。当 someAsyncApiCall 被调用时，回调也在同一个 event loop 阶段被调用了。结果回调中就无法得到 bar 的值。因为赋值语句还没被执行。 如果把回调放在 process.nextTick() 中执行，后面的赋值语句就可以先执行了。而且 process.nextTick() 的回调会在 eventLoop 进入下一个阶段前调用。（译注：又是把一个道理翻来覆去地讲） 1234567891011let bar;function someAsyncApiCall(callback) &#123; process.nextTick(callback);&#125;someAsyncApiCall(() =&gt; &#123; console.log('bar', bar); // 1&#125;);bar = 1; 一个更符合现实的例子是这样的： 123const server = net.createServer(() =&gt; &#123;&#125;).listen(8080);server.on('listening', () =&gt; &#123;&#125;); .listen(8080) 这句话是同步执行的。问题在于 listening 回调无法被触发，因为 listening 的监听代码在 .listen(8080) 的后面。 为了解决这个问题，.listen() 函数可以使用 process.nextTick() 来执行 listening 事件的回调。 process.nextTick() vs setImmediate()这两个函数功能很像，而且名字也很令人疑惑。 process.nextTick() 的回调会在当前 event loop 阶段「立即」执行。 setImmediate() 的回调会在后续的 event loop 周期（tick）执行。 （译注：看起来名字叫反了） 二者的名字应该互换才对。process.nextTick() 比 setImmediate() 更 immediate（立即）一些。 这是一个历史遗留问题，而且为了保证向后兼容性，也不太可能得到改善。所以就算这两个名字听起来让人很疑惑，也不会在未来有任何变化。 我们推荐开发者在任何情况下都使用 setImmediate()，因为它的兼容性更好，而且它更容易理解。 什么时候用 process.nextTick()？There are two main reasons: 使用的理由有两个： 让开发者处理错误、清除无用的资源，或者在 event loop 当前阶段结束前尝试重新请求资源 有时候有必要让一个回调在调用栈 unwind 之后，event loop 进入下阶段之前执行 为了让代码更合理，我们可能会写这样的代码： 12345const server = net.createServer();server.on('connection', (conn) =&gt; &#123; &#125;);server.listen(8080);server.on('listening', () =&gt; &#123; &#125;); 假设 listen() 在 event loop 一启动的时候就执行了，而 listening 事件的回调被放在了 setImmediate() 里，listen 动作是立即发生的，如果想要 event loop 执行 listening 回调，就必须先经过 poll 阶段，当时 poll 阶段有可能会停留，以等待连接，这样一来就有可能出现 connect 事件的回调比 listening 事件的回调先执行。（译注：这显然不合理，所以我们需要用 process.nextTick） 再举一个例子，一个类继承了 EventEmitter，而且想在实例化的时候触发一个事件： 12345678910111213const EventEmitter = require('events');const util = require('util');function MyEmitter() &#123; EventEmitter.call(this); this.emit('event');&#125;util.inherits(MyEmitter, EventEmitter);const myEmitter = new MyEmitter();myEmitter.on('event', () =&gt; &#123; console.log('an event occurred!');&#125;); 你不能直接在构造函数里执行 this.emit(‘event’)，因为这样的话后面的回调就永远无法执行。把 this.emit(‘event’) 放在 process.nextTick() 里，后面的回调就可以执行，这才是我们预期的行为： 1234567891011121314151617const EventEmitter = require('events');const util = require('util');function MyEmitter() &#123; EventEmitter.call(this); // use nextTick to emit the event once a handler is assigned process.nextTick(() =&gt; &#123; this.emit('event'); &#125;);&#125;util.inherits(MyEmitter, EventEmitter);const myEmitter = new MyEmitter();myEmitter.on('event', () =&gt; &#123; console.log('an event occurred!');&#125;);]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Node</tag>
        <tag>EventLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS垃圾回收机制]]></title>
    <url>%2Fposts%2F20229%2F</url>
    <content type="text"><![CDATA[一直以来我对JS垃圾回收机制的了解仅仅停留在两个词儿上：标记清除和引用计数。除此之外我就啥不知道了。最近空下来阅读了不少相关文章，算是对JS的垃圾回收机制有了点粗浅的认识。这篇博客算是一个笔记，也是一个总结。而我阅读的文章也会在最后的“资源”一节列出，想更加深入了解JS垃圾回收机制的小伙伴可以点击查看。 什么是垃圾要想理解JS的垃圾回收机制，首先得确定什么才是所谓的要被回收的垃圾。一般情况下，没有被引用的对象就是垃圾，是需要被清除的。下面是我总结的几大类型。 全局变量所有全局的变量都不是垃圾，因为浏览器会认为你在任何情况下都有可能使用到全局变量。例如下面这种情况： 12345var str = "hello world";// 此处省略若干代码console.log(str); 在顶部定义了一个全局变量str，你是完全有可能在 n 行代码以后打印这个变量的。 局部变量通常情况下，局部作用域变量在函数执行完毕后就是垃圾，再也用不到了： 1234567function fn() &#123; var str = "hello world"; console.log(str);&#125;fn();fn(); 当开始执行fn时，才产生 str ，它的作用域就在 fn 中，fn 执行结束后，str 就是垃圾，会被销毁。你可能会说，我完全有可能调用两次 fn 啊，但这里要注意的一点是，当你再次执行 fn 时，产生的是一个全新的 str ，和刚才的 str 完全没关系。 单引用一个单引用对象，没有引用就是垃圾： 12345var user = &#123; name: "John"&#125;;user = null; 我在全局作用域下定义了变量 user ，指向一个对象，然而却在最后把变量 user 设置为 null。此时就没有谁在引用 {name: “John”} 这个对象了，所以它是垃圾，会被销毁。 多引用如果一个对象有两个及以上的引用，它不一定会被回收： 1234567var user = &#123; name: "John"&#125;;var admin = user;user = null; 即使我们删掉了其中一个引用，但 admin 仍然还引用着 object ，所以此 object 还不会被回收。 环引用还记得文章开头说的下面这段话吗？ 一般情况下，没有被引用的对象就是垃圾，是需要被清除的。 环引用就是个例外，当几个对象相互引用，但没有被其它任何人引用时，它们仍然是垃圾，需要被回收，我们考虑下面代码： 123456789101112131415function marry(man, woman) &#123; woman.husband = man; man.wife = woman; return &#123; father: man, mother: woman &#125;&#125;var family = marry(&#123; name: "John"&#125;, &#123; name: "Ann"&#125;); 上述代码我们创建了一个家庭（family）对象，其中包含一个男人（man）对象和一个女人（woman）对象，并让女人的丈夫（husband）设为男人，男人的妻子（wife）设为女人。它们之间的关系可以用下图表示： 接着我们执行下面操作： 12delete family.father;delete family.mother.husband; 此刻删掉家庭对丈夫的引用，以及妻子对丈夫的引用，此时不再有任何人引用丈夫，所以此时丈夫是垃圾，需要被回收： 让我们回到丈夫还没有被家庭和妻子去除引用的时刻。然后执行下面代码： 1family = null; 这个时候，我们直接删掉了全局（外界）对家庭这个对象的引用，则家庭和丈夫以及妻子就都“死掉”了，需要被回收。你可能会说，它们之间不是存在相互引用关系吗？但此刻它们已经不被外界所引用，所以它们会被回收。 如何实现垃圾回收分析完什么是所谓的垃圾之后，我们就可以开始讨论如何实现垃圾回收了。也就是文章开头提到的「标记清除」和「引用计数」。 标记清除简单来理解，标记清除机制会从全局作用域开始，把所有它遇到的变量都标记一遍，如果这些被标记的变量还引用了其他变量，就再标记，一直标记到再也没有新的对象为止，这个标记过程就结束了。标记过程结束后就开始进行清除过程，把所有刚才没有被标记过的对象都删掉。这就是标记清除算法： 听起来这种实现很美好不是吗？但是此方法有个缺点很伤，那就是在变量对象多了以后，造成遍历很慢的后果。而且我们会不定时对这些变量都要再标记一遍，然而我们知道JS是单线程的，标记期间JS代码的执行会被中断，而标记的时间又很久，就造成不好的影响，这就是它的缺点。 所以针对这个缺点，我们会对标记清除做一些改进： 分代收集（Generational collection）类比我们手机网络的2G，3G和4G，这里的G就是 Generational 的意思，而我们的对象可以大致分为两种： 新一代（e.g. 一个函数中的临时变量） 老一代（e.g. window 对象） 不同代的回收策略是不一样的，一般老一代的对象停留时间会很久，而这种停留时间越久的对象，后面用到它的时间也可能越久（这只是一种推测，不一定对，仅仅是一种策略）。所以可能在第一轮标记后，会隔一段时间才会去再看它，比如3s后。 而新一代的对象，比如一个函数中的临时变量，函数执行完就可回收，不用从头开始遍历，这样的临时对象就会被马上标记然后立即马上删除，这样的对象就有可能隔1毫秒就看它一次，没被标记就删除了它。 增量收集（Incremental collection）举个例子，假如此刻有 10000 个需要遍历的对象，我不一次性遍历完，而是先遍历1000个，然后执行JS，再遍历1000个，再执行JS… 这样遍历10次就能遍历完，而且JS也不会有明显卡顿。 空闲收集（Idle-time collection）这个优化即字面意思，由于JS不是一直在执行的，所以我等到JS执行完后空闲下来再开始遍历。 引用计数每次对象被引用的时候就+1，再被引用时就再+1，有人不引用它时就-1，再不引用就又-1，当这个对象被减到0时就该被垃圾回收了。 此算法的缺点也有不少，但被大家所熟知的一个缺点就是循环引用无法被回收。在早期的IE版本里（ie4-ie6），对宿主对象（也就是 Document 对象）采用是引用计数的垃圾回收机制，一旦你在JS中没有正确使用闭包，就会导致内存泄漏，这也就是此算法的一个缺陷。循环引用会导致没法回收，这个循环引用只限定于有宿主对象参与的循环引用，而js对象之间即使形成循环引用，也不会产生内存泄漏，因为对js对象的回收算法不是计数的方式。示例如下： 1234567891011121314151617181920212223function closure()&#123; var oDiv = document.getElementById('oDiv');//oDiv用完之后一直驻留在内存中 oDiv.onclick = function () &#123; alert(oDiv.innerHTML);//这里用oDiv导致内存泄露 &#125;;&#125;// 以上代码创建了一个作为 div 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。// 由于匿名函数保存了一个对closure()的活动对象的引用，因此就会导致无法减少div 的引用数。// 只要匿名函数存在，element 的引用数至少也是1，因此它所占用的内存就永远不会被回收closure();//最后应将oDiv解除引用来避免内存泄露function closure()&#123; var oDiv = document.getElementById('oDiv'); var test = oDiv.innerHTML; oDiv.onclick = function () &#123; alert(test); &#125;; oDiv = null;&#125;// 解决办法: 把 oDiv.innerHTML 的一个副本保存在一个变量中，// 从而消除闭包中该变量的循环引用,同时将 oDiv 变量设为null。 好了，有关JS的垃圾回收机制就写到这里，想要了解更多可以点击下面的资源链接~ 完。 资源 Garbage collection 几种垃圾回收算法 V8 之旅： 垃圾回收器]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue数据响应式的简单实现]]></title>
    <url>%2Fposts%2F44406%2F</url>
    <content type="text"><![CDATA[今天来实现一个简单的 Vue 数据响应式，最终达到两个基本效果： 当用户在 input 中输入内容时，文本节点会跟着改变 当直接更新 message 属性后，页面中 input 标签和文本节点的值会跟着改变 最终效果： 原理Vue 实现数据响应式的核心原理是：借助发布/订阅模式 + 数据劫持 。 创建 vue 实例时深度遍历 data 下所有属性，利用 Object.defineProperty 把属性转为 getter/setter。 Vue 实现了 发布订阅者模式，在模板编译过程中解析 Vue 指令，给组件中的属性添加上相应订阅者（Watcher），这样在数据变更后会触发相应属性的 setter ，通过消息订阅器（Dep）发消息给所有订阅者（Watcher），从而触发相应组件的更新。 文件结构12345678.├── Compiler.js # 指令解析器├── Dep.js # 消息订阅器├── Observer.js # 观察者├── Vue.js # Vue的简单实现├── Watcher.js # 订阅者├── index.html└── main.js # 入口文件 具体代码index.html包含一个 input 标签和文本节点。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="message"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;script src="dist/main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Dep.js 消息订阅器发布订阅者模式的简单实现。包含核心方法 listen 以及 notify ，listen 负责给属性添加订阅者，notify 负责在属性发生变化时通知所有该属性的订阅者。 123456789101112131415161718192021class Dep &#123; constructor() &#123; console.log("【Dep】实例化了一个消息订阅器") // 订阅者数组 this.list = []; &#125; listen(sub) &#123; // 谁要订阅我，就调用listen，把自己添加进订阅者数组中去 this.list.push(sub); &#125; notify() &#123; // 当属性发生变化后，会在 setter 中调用此方法， // 消息订阅者通知订阅者数组中的所有人执行update操作 this.list.forEach(function (item, index) &#123; item.update(); &#125;); &#125;&#125;Dep.prototype.target = null;export default Dep; main.js 入口文件该文件中 new 一个 Vue 实例，并把该实例挂载到 window 对象上。 123456789import Vue from './Vue'var vm = new Vue(&#123; el: '#app', data: &#123; message: 'lance' &#125;&#125;)window.vm = vm; Observer.js 观察者深度遍历 data 下的所有属性，利用 Object.defineProperty 把属性转为 getter/setter ，并在此过程中给每个属性都绑定上发布/订阅模块。 1234567891011121314151617181920212223242526272829import Dep from './Dep';class Observer &#123; constructor(data) &#123; this.data = data; Object.keys(this.data).forEach(key =&gt; &#123; this._bind(data, key, data[key]); &#125;); &#125; _bind(data, key, val) &#123; var myDep = new Dep(); Object.defineProperty(data, key, &#123; // 新建vm实例时，给data添加属性就是第一次赋值，就调用了get get() &#123; // 第一次访问这个属性时 // 把订阅者(Watcher对象)注入发布/订阅模块 // 后续访问就不用再添加这个属性的订阅者了 if (Dep.target) myDep.listen(Dep.target); return val &#125;, set(newValue) &#123; if (newValue === val) return val = newValue; myDep.notify(); &#125; &#125;); &#125;&#125;export default Observer; Watcher.js 订阅者实现 update 方法，在属性发生变化时收到通知并执行它，从而更新组件数据。 1234567891011121314151617181920212223import Dep from './Dep';class Watcher &#123; // watcher需要当前组件中的： // 【节点】，【节点上相关的data属性】，【vm实例】 constructor(node, name, vm) &#123; this.node = node; this.name = name; this.vm = vm; // 将消息订阅器实例的当前订阅者设置为自己 Dep.target = this; this.update() Dep.target = null; &#125; update() &#123; // 得到数据变更通知后更新组件 if (this.node.nodeType === 1) &#123; this.node.value = this.vm[this.name]; &#125; this.node.nodeValue = this.vm[this.name]; &#125;&#125;export default Watcher; Compiler.js 指令解析器负责解析挂载到 Vue 上的 html 模板，找出 Vue 相关的指令。例如遇到 input 标签上有 v-model ，则给绑定的属性添加订阅者（Watcher），并为 input 标签添加 input 事件，在用户输入 value 后更改 data 中相应属性的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import Watcher from './Watcher';// 辨认 &#123;&#123;&#125;&#125; 的正则const REG = /\&#123;\&#123;(.*)\&#125;\&#125;/class Compiler &#123; constructor(el, vm) &#123; this.el = document.querySelector(el); this.vm = vm; this.frag = this._createFragment() this.el.appendChild(this.frag); &#125; _createFragment() &#123; var frag = document.createDocumentFragment(); var child; // 遍历挂载对象下的所有节点 while (child = this.el.firstChild) &#123; this._compile(child); frag.appendChild(child); &#125; return frag; &#125; _compile(node) &#123; var self = this; // 类型为元素 if (node.nodeType === 1) &#123; var attr = node.attributes; if (attr.hasOwnProperty('v-model')) &#123; var name = attr['v-model'].nodeValue; // 添加 input 监听事件 node.addEventListener('input', function(e) &#123; self.vm[name] = e.target.value; &#125;); node.value = this.vm[name]; // 给该属性添加订阅者 new Watcher(node, name, this.vm); &#125; &#125; // 元素为文本 if (node.nodeType === 3) &#123; // 目标：转化html中的 &#123;&#123;message&#125;&#125; 和 绑上watcher if (REG.test(node.nodeValue)) &#123; // 获取匹配到的字符串 var name = RegExp.$1; name = name.trim(); // 给元素添加订阅者，当vm实例的数据发生改变时, // 能收到通知并触发watcher中的update来更新元素上的值 // 传递： // node节点（因为要改变元素中的值） // name属性名 // 实例vm（为了调用vm下的属性） console.log("【Compiler】解析到文本元素，给它创建一个watcher实例") new Watcher(node, name, this.vm); &#125; &#125; &#125;&#125;export default Compiler; Vue.js调用 Compiler 和 Observer ，实现数据响应式。 12345678910111213141516171819202122232425262728293031import Observer from './Observer';import Compiler from './Compiler';class Vue &#123; constructor(options) &#123; this.$options = options; this.$el = this.$options.el; this._data = this.$options.data; Object.keys(this._data).forEach(key =&gt; &#123; this._proxy(key); &#125;); new Observer(this._data); new Compiler(this.$el, this); &#125; // 每次获取或赋值data中的属性时这样写代码： // Vue.$options.data.message 很长 // 我们的期望：Vue.message _proxy(key) &#123; var self = this; Object.defineProperty(this, key, &#123; get () &#123; return self._data[key]; &#125;, set (value) &#123; self._data[key] = value; &#125; &#125;); &#125;&#125;export default Vue 最后根目录下运行 webpack main.js 进行打包，浏览器运行 index.html 文件后便能看到文章开头的实现效果，完。]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS严格模式vs非严格模式]]></title>
    <url>%2Fposts%2F15966%2F</url>
    <content type="text"><![CDATA[前言以下为《JavaScript高级程序设计（第3版）》中有关 严格模式 的笔记。 介绍“严格模式” 是 ECMAScript5 最早引入的概念。可以在函数内部选择进行较为严格的全局或局部的错误条件检测。使用严格模式的好处是可以提早知道代码中存在的错误，及时捕获一些可能导致编程错误的 ECMAScript 行为。 如何使用在JS文件代码的顶部或者函数中输入下面字符串来开启严格模式： 12345678"use strict";orfunction fn() &#123; "use strict"; ...&#125; 严格模式 VS 非严格模式变量在严格模式下，不允许意外的创建全局变量： 12345// 未声明变量message = "Hello world";// 非严格模式: 创建全局变量// 严格模式: 抛出 ReferenceError 不能对变量调用 delete 操作符： 123456var color = "red";// 删除变量delete color;// 非严格模式: 静默失败// 严格模式: 抛出 ReferenceError 严格模式下对变量名也有限制。 不能使用 implements、interface、let、package、 private、protected、public、static 和 yield 作为变量名。这些都是保留字，将来的 ECMAScript 版本中可能会用到它们。在严格模式下，用以上标识符作为变量名会导致语法错误。 对象在严格模式下操作对象比在非严格模式下更容易导致错误。一般来说，非严格模式下会静默失败的 情形，在严格模式下就会抛出错误。因此，在开发中使用严格模式会加大早发现错误的可能性。 在下列情形下操作对象的属性会导致错误: 为只读属性赋值会抛出 TypeError; 对不可配置的(nonconfigurable)的属性使用 delete 操作符会抛出 TypeError; 为不可扩展的(nonextensible)的对象添加属性会抛出 TypeError。 使用对象的另一个限制与通过对象字面量声明对象有关。在使用对象字面量时，属性名必须唯一。 例如： 12345678// 重名属性var person = &#123; name: "Nicholas", name: "Greg"&#125;;// 非严格模式: 没有错误，以第二个属性为准// 严格模式: 抛出语法错误 函数函数的命名参数严格模式要求命名函数的参数必须唯一。例如： 1234567// 重名参数function sum(num, num) &#123; // do something&#125;// 非严格模式: 没有错误，只能访问第二个参数//严格模式: 抛出语法错误 在非严格模式下，这个函数声明不会抛出错误。通过参数名只能访问第二个参数，要访问第一个参数必须通过 arguments 对象。 argumentsarguments 对象的行为所不同。 在非严格模式下，修改命名参数的值也会反映到 arguments 对象中。 而严格模式下这两个值是完全独立的。 例如： 1234567// 修改命名参数的值function showValue(value) &#123; value = "Foo"; alert(value); //"Foo" alert(arguments[0]); // 非严格模式: "Foo" &lt;---&gt; 严格模式: "Hi"&#125;showValue("Hi"); 以上代码中，函数 showValue() 只有一个命名参数 value。调用这个函数时传入了一个参数”Hi”， 这个值赋给了 value。而在函数内部，value 被改为”Foo”。在非严格模式下，这个修改也会改变 arguments[0] 的值，但在严格模式下，arguments[0] 的值仍然是传入的值。 另一个变化是淘汰了 arguments.callee 和 arguments.caller。在非严格模式下，这两个属性一个引用函数本身，一个引用调用函数。而在严格模式下，访问哪个属性都会抛出 TypeError。 例如： 123456789101112// 访问 arguments.calleefunction factorial(num)&#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) &#125;&#125;var result = factorial(5);// 非严格模式: 没有问题// 严格模式: 抛出 TypeError 类似地，尝试读写函数的 caller 属性，也会导致抛出 TypeError。所以，对于上面的例子而言， 访问 factorial.caller 也会抛出错误。 函数名与变量类似，严格模式对函数名也做出了限制，不允许用 implements、interface、let、package、private、protected、public、static 和 yield 作为函数名。 函数声明的位置只能在脚本的顶级和在函数内部声明函数。也就是说，在 if 语句中声明函数会导致语法错误： 12345678//在 if 语句中声明函数if (true)&#123; function doSomething() &#123; //... &#125;&#125;// 非严格模式: 将函数提升到 if 语句外部// 严格模式: 抛出语法错误 eval()eval在包含上下文中不再创建变量或函数。例如： 1234567//使用 eval() 创建变量function doSomething() &#123; eval("var x=10"); alert(x);&#125;// 非严格模式: 弹出对话框显示 10// 严格模式: 调用 alert(x) 时会抛出 ReferenceError 如果是在非严格模式下，以上代码会在函数 doSomething() 中创建一个局部变量 x，然后 alert() 还会显示该变量的值。但在严格模式下，在 doSomething() 函数中调用 eval() 不会创建变量 x，因此 调用 alert() 会导致抛出 ReferenceError，因为 x 没有定义。 可以在 eval() 中声明变量和函数，但这些变量或函数只能在被求值的特殊作用域中有效，随后就 将被销毁。因此，以下代码可以运行，没有问题： 123"use strict";var result = eval("var x=10, y=11; x+y");alert(result); //21 这里在 eval() 中声明了变量 x 和 y，然后将它们加在一起，返回了它们的和。于是，result 变 量的值是 21，即 x 和 y 相加的结果。而在调用 alert() 时，尽管 x 和 y 已经不存在了，result 变量的值仍然是有效的。 eval 与 arguments严格模式已经明确禁止使用 eval 和 arguments 作为标识符，也不允许读写它们的值。例如： 12345// 把 eval 和 arguments 作为变量引用var eval = 10;var arguments = "Hello world!";// 非严格模式: 没问题，不出错// 严格模式: 抛出语法错误 在非严格模式下，可以重写 eval，也可以给 arguments 赋值。但在严格模式下，这样做会导致语 法错误。不能将它们用作标识符，意味着以下几种使用方式都会抛出语法错误： 使用var声明 赋予另一个值 尝试修改包含的值，如使用++ 用作函数名 用作命名的函数参数 在 try-catch 语句中用作例外名 抑制 this在非严格模式下使用函数的 apply() 或 call() 方法时，null 或 undefined 值会被转换为全局对象。而在严格模式下，函数的 this 值始终是指定的值，无论指定的是什么值。例如： 12345678//访问属性var color = "red";function displayColor() &#123; alert(this.color);&#125;displayColor.call(null);// 非严格模式: 访问全局属性// 严格模式: 抛出错误，因为 this 的值为 null 以上代码向 displayColor.call() 中传入了 null，如果在是非严格模式下，这意味着函数的 this 值是全局对象。结果就是弹出对话框显示”red”。而在严格模式下，这个函数的 this 的值是 null，因 此在访问 null 的属性时就会抛出错误。 其他变化with抛弃了 with 语句。非严格模式下的 with 语句能够改变解析标识符的路径，但在严格模式下，with 被简化掉了。因此，在严格模式下使用 with 会导致语法错误。例如： 123456//with 的语句用法with(location) &#123; alert(href);&#125;// 非严格模式: 允许// 严格模式: 抛出语法错误 八进制字面量严格模式也去掉了 JavaScript 中的八进制字面量。以 0 开头的八进制字面量过去经常会导致很多错 误。在严格模式下，八进制字面量已经成为无效的语法了。例如： 1234//使用八进制字面量var value = 010;// 非严格模式: 值为 8// 严格模式: 抛出语法错误 ECMAScript5 也修改了严格模式下 parseInt() 的行为。如今，八进制字面量在严格模式下会被当作以 0 开头的十进制字面量。例如： 1234//使用 parseInt() 解析八进制字面量var value = parseInt("010");// 非严格模式: 值为 8// 严格模式: 值为 10]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue+Koa实现cookie传输]]></title>
    <url>%2Fposts%2F26486%2F</url>
    <content type="text"><![CDATA[后端登录接口设置 cookie： 1234567891011121314router.post('/login', async ctx =&gt; &#123; ... let user = &#123; username: 'Lance', age: 20, ... &#125; ctx.cookies.set('username', user.username), &#123; // httpOnly：表示当前设置的cookie是否允许客户端进行操作（js） // 默认true，表示这个cookie能用于http协议的数据传输，但不允许js操作和篡改 httpOnly: false, &#125;); ...&#125;); 读取浏览器自动带上的cookie： 123456router.post(&apos;/like&apos;, async ctx =&gt; &#123; ... // 从cookie中读取 username let username = ctx.cookies.get(&apos;username&apos;); ...&#125;); 文档：Koa - response 前端123456789101112131415161718created() &#123; // 从cookie中获取用户信息cookie // 如果有cookie if (document.cookie) &#123; // cookie = "uid=1; username=admin;" =&gt; ['uid=1', 'username=admin'] let arr1 = document.cookie.split("; "); let cookiesArr = arr1.map(item =&gt; &#123; // item = "uid=1" =&gt; ['uid', 1] let arr2 = item.split("="); return &#123; [arr2[0]]: arr2[1] &#125; &#125;); // &#123;uid: "6", username: "YWRtaW4"&#125; let cookie = Object.assign(&#123;&#125;, ...cookiesArr); ... &#125;&#125;, 后端cookie的加密在 app.js 中添加密钥： 123const app = new Koa();// 密钥app.keys = ['sw_lance']; 然后在 routers/main.js 路由中的cookie设置中增加一个字段： 1234// 设置cookiectx.cookies.set('username', user.username, &#123; signed: true, // 使用加密方式处理&#125;); 这样就能加密了，但在前端chrome下查看cookie会发现，虽然有了加密cookie，但明文的cookie仍然在： 后端session加密首先仍然要在 app.js 中添加密钥： 1234const app = new Koa();// 密钥app.keys = ['sw_lance'];npm i koa-session 在 app.js 中引入： 123456789101112131415const session = require("koa-session")const app = new Koa();// 密钥app.keys = ['sw_lance'];const CONFIG = &#123; key: 'koa:sess', maxAge: 86400000, autoCommit: true, overwrite: true, httpOnly: true, signed: true, rolling: false, renew: false,&#125;;app.use(Session(CONFIG, app)); 在 routers/main.js 的 login API中种下cookie和session： 1234567891011router.post('/login', async ctx =&gt; &#123; ... // uid用下面的session存，username没那么重要，可以用cookie ctx.cookies.set('username', new Buffer(user.get('username')).toString('base64'), &#123; httpOnly: false, signed: true, // maxAge: 10000, &#125;); // uid用session存 ctx.session.uid = user.get('id');&#125;); 在 routers/main.js 的 like API中获取session： 123router.post('/like', async ctx =&gt; &#123; let uid = ctx.session.uid;&#125;);]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>koa</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios异步请求跨域解决方案]]></title>
    <url>%2Fposts%2F15391%2F</url>
    <content type="text"><![CDATA[场景 后端 127.0.0.1（默认80）；前端 127.0.0.1:8081 在 vue 开发过程中使用 axios 发起 POST 请求： 123456axios(&#123; method: 'GET', url: 'http://127.0.0.1'&#125;).then(data =&gt; &#123;&#125;); 会报跨域错误： 原因是浏览器同源策略，只有 同协议、同域名、同端口 三同的地址才能互相通过 AJAX 的方式请求。而上面情形虽然协议（http）和域名（127.0.0.1）都相同，但端口不同（80 和 8081），所以无法正常请求。 解决方案方案一服务端添加响应头，以 Koa 为例，在 app.js 中添加响应头： 1234app.use(async (ctx, next) =&gt; &#123; ctx.set("Access-Control-Allow-Origin", "*"); await next();&#125;); 这样设置会允许任何来源（*）的跨域。 但往往后端的某些接口是需要身份验证的，比如用户对文章、商品之类的进行评论或点赞，就需要用户登录才能操作。这种情况下就需要使用到 cookie 或者 session ，所以还得设置 Access-Control-Allow-Credentials 为 true ，表示在 CORS 请求中允许客户端发送 cookie 。然而一旦这样设置，Access-Control-Allow-Origin 就不能再是通配符 * ，必须指定具体的域，所以服务端最终的 header 设置为： 12345app.use(async (ctx, next) =&gt; &#123; ctx.set("Access-Control-Allow-Origin", "http://127.0.0.1:8081"); ctx.set("Access-Control-Allow-Credentials", true); await next();&#125;); 后端这样设置后，前端就能够实现跨域请求了。 方案二如果服务端不加 ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); 这一段。可以在 @vue-cli 中 配置代理 。也就是 前端设置代理 的解决方案。 原理利用后端不存在跨域问题，而让vue服务器代为获取数据。因为启动vue项目本质上也是用 node 启了个服务器（127.0.0.1:8080），配置了代理后，就不再是浏览器直接请求我们在 axios 中配置的 http://127.0.0.1/（默认80端口） ，而是用vue启动的这个服务器去请求 http://127.0.0.1/ 这个接口，由于后端相互之前请求不存在跨域问题，所以能获取数据，获取后给到前端。 在前端项目根目录下新建 vue.config.js 文件： 1234567891011121314module.exports = &#123; devServer: &#123; proxy: &#123; // 前端 axios 发这样的请求：http://127.0.0.1:8081/api/ (8081是启动vue项目时的端口)，会被此处捕获，然后代为请求真正的服务器API地址 `http://127.0.0.1` '/api': &#123; target: 'http://127.0.0.1', // 此处是服务端API接口，不写端口默认80 changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125; &#125;, &#125; &#125;&#125; 前端发送 POST 跨域请求上面也提到了，前端有时候往往不止需要发送 GET 请求，POST 请求也是常有的事儿。所以还需要对 Axios 进行如下配置： vue 项目下的 main.js 中全局配置 axios 123456import axios from 'axios';axios.defaults.baseURL = 'http://127.0.0.1';axios.defaults.withCredentials = true; // 让 ajax 携带 cookieaxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; // 设置post请求的头部格式Vue.prototype.$ajax = axios 由于需要把请求时的数据序列化为url的形式，所以要下载 qs 包 1npm i qs 在具体页面中发送 POST 请求 123456789101112import qs from 'qs'let loginInfo = &#123; username: '', password: '',&#125;,this.$ajax(&#123;(&#123; method: 'post', url: 'http://127.0.0.1/login', data: qs.stringify(login_info),&#125;)]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CORS详解（转载）]]></title>
    <url>%2Fposts%2F52542%2F</url>
    <content type="text"><![CDATA[转载文章博客源：CORS详解 关于CORS说到CORS，就不得不先了解跨站HTTP请求（Cross-site HTTP request）。 跨域HTTP请求是指发起请求的资源所在域不同于该请求所指向资源所在的域的HTTP请求。 正如大家所知，出于安全考虑，浏览器会限制脚本中发起的跨站请求。使用XMLHttpRequest发起HTTP请求必须遵守同源策略。 具体而言，Web 应用程序能且只能使用 XMLHttpRequest 对象向其加载的源域名发起 HTTP 请求，而不能向任何其它域名发起请求。 由于Web应用技术越来越丰富，我们非常渴望在不丢失安全的前提下，能够实现跨站请求。特别是现在的Web程序结构，一般是HTML+REST API。在之前的实现中，我们一般采用jsonp来发起跨站请求，这其实是利用了html标签的特点。 W3C的Web应用工作组推荐了一种新的机制，即跨域资源共享（Cross-Origin Resource Sharing），也就是当前我们提到的CORS。 CORS的核心，就是让服务器来确定是否允许跨域访问。 1、典型场景1.1、简单请求什么是简单请求？全部满足以下条件的请求可以称之为简单请求： 只使用GET、HEAD或者POST请求方法。如果是POST，则数据类型（Content-Type）只能是application/x-www-form-urlencodeed、multipart/form-data、text/plain中的一种。 没有使用自定义的请求头（如x-token） 按照这个规则，那我们的能实现跨域请求的情况如下： Server代码： 12345678910111213'use strict';var http = require('http');var server = http.createServer((req, res) =&gt; &#123; //之后设置了Access-Control-Allow-Origin，才会允许跨域 res.setHeader('Access-Control-Allow-Origin', '*'); res.write('abc'); res.end();&#125;);server.listen(10000, () =&gt; &#123; console.log('started.');&#125;); Client代码： 1234567891011121314151617181920212223242526var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readyState === XMLHttpRequest.DONE)&#123; console.log('Result：', xhr.responseText); &#125;&#125;//场景一：GET请求，不需要Header，允许跨域xhr.open('GET', 'http://localhost:10000/', true);xhr.send();//场景二： POST请求，需要设置为指定Header（不设置content-type也可），允许跨域xhr.open('POST', 'http://localhost:10000/', true);//此处value必须是text/plain或者application/x-www-form-urlencoded或者multipart/form-data。//此处也可以不设置xhr.setRequestHeader('Content-Type', 'text/plain');xhr.send();//场景三：DELETE请求（不允许跨域）xhr.open('DELETE', 'http://localhost:10000/', true);xhr.send();//场景四：POST请求，有自定义Header（不允许跨域）xhr.open('POST', 'http://localhost:10000/', true);xhr.setRequestHeader('x-token', 'a');xhr.send(); 1.2、预请求不同于简单请求，预请求要求必须先发送一个OPTIONS请求给站点，来查明该站点是否允许跨域请求，这样做的原因是为了避免跨站请求可能对目的站点的数据造成的损坏。 如果请求满足以下任一条件，则会产生预请求： 请求以GET、HEAD、POST之外的方法发起。或者，使用POST，但数据类型为application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。（注：之前的版本只有text/plain可以不用发起预请求）。 使用了自定义请求头。 按照如上规则，我们来列举几个应用场景： Server端代码： 123456789101112131415161718'use strict';var http = require('http');var server = http.createServer((req, res) =&gt; &#123; //之后设置了Access-Control-Allow-Origin，才会允许跨域 res.setHeader('Access-Control-Allow-Origin', '*'); res.setHeader('Access-Control-Allow-Methods', 'POST, DELETE, GET'); res.setHeader('Access-Control-Allow-Headers', 'x-token'); //设置预请求缓存1天，1天内再次请求，可以跳过预请求 //此功能需要客户端缓存支持，如果客户端禁用缓存，那么每次都会预请求 res.setHeader('Access-Control-Max-Age', 60 * 60 * 24); res.write('abc'); res.end();&#125;);server.listen(10000, () =&gt; &#123; console.log('started.');&#125;); Client端代码： 123456789101112131415161718192021222324var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readyState === XMLHttpRequest.DONE)&#123; console.log('Result：', xhr.responseText); &#125;&#125;//场景一：DELETE请求，发送OPTIONS，匹配，允许跨域xhr.open('DELETE', 'http://localhost:10000/', true);xhr.send();//场景二：PUT请求，发送OPTIONS，不匹配，不允许跨域xhr.open('PUT', 'http://localhost:10000/', true);xhr.send();//场景三：DELETE请求匹配，使用自定义Header不匹配，不允许跨域xhr.open('DELETE', 'http://localhost:10000/', true);xhr.setRequestHeader('x-token1', 'aa');xhr.send();//场景四：POST请求，匹配的自定义Header，允许跨域xhr.open('POST', 'http://localhost:10000/', true);xhr.setRequestHeader('x-token', 'a');xhr.send(); 1.3、带凭证的请求一般来说，对于跨站请求，浏览器是不会发送凭证（HTTP Cookies和验证信息）的。如果要发送带凭证的信息，只需要给XMLHttpRequest设置一个特殊的属性withCredentials = true，通过这种方式，浏览器就允许发送凭证信息。 带凭证的请求可能是简单请求，也可以是会有预请求。是否允许跨域，会先判断简单请求和预请求的规则，然后还会带上带凭证的请求自己的规则。 在带凭证的请求中，后端的响应必须包含HeaderAccess-Control-Allow-Credentials=true，同时Header Access-Control-Allow-Origin，不能再使用*号这种匹配符。 具体示例如下： 服务端代码： 123456789101112131415161718'use strict';var http = require('http');var server = http.createServer((req, res) =&gt; &#123; //要处理带凭证的请求，此Header不能使用*。 res.setHeader('Access-Control-Allow-Origin', 'http://10.16.85.170:8000'); res.setHeader('Access-Control-Allow-Methods', 'POST, DELETE, GET'); res.setHeader('Access-Control-Allow-Headers', 'x-token'); res.setHeader('Access-Control-Max-Age', 60 * 60 * 24); //只有设置了该Header，才允许带凭证的请求。 res.setHeader('Access-Control-Allow-Credentials', true); res.write('abc'); res.end();&#125;);server.listen(10000, () =&gt; &#123; console.log('started.');&#125;); 客户端代码： 1234567891011var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readyState === XMLHttpRequest.DONE)&#123; console.log('Result：', xhr.responseText); &#125;&#125;//优先满足预请求，然后满足凭证请求，允许跨域。xhr.open('POST', 'http://localhost:10000/', true);xhr.withCredentials = true;xhr.setRequestHeader('x-token', 'a');xhr.send(); 2、HTTP响应头2.1、 后端HTTP响应头此处列举后端有关CORS的响应头： Access-Control-Allow-Origin： | 允许的域名，只能有一个值。比如“”或“abc.com”，”a.com,b.com”这种不允许 Access-Control-Expose-Headers: 允许的白名单Header，多个用逗号隔开 Access-Control-Max-Age: 预请求缓存时间，单位秒，禁用缓存时无效哦！ Access-Control-Allow-Credentials: true | false 是否允许带凭证的请求，如果为true，则Origin只能是具体的值 Access-Control-Allow-Methods: 允许的请求类型，多个用逗号隔开 Access-Control-Allow-Headers: 在实际请求中，允许的自定义header，多个用逗号隔开 2.2、 浏览器发出跨域请求的响应头此处列举出浏览器在发送跨域请求时，会带上的响应头： Origin: 告诉服务器，请求来自哪里，仅仅是服务器名，不包含路径。 Access-Control-Request-Method: 预请求时，告诉服务器实际的请求方式 Access-Control-Request-Headers: 预请求时，告诉服务器，实际请求所携带的自定义Header 3、参考资料 MDN HTTP access control (CORS) MDN HTTP访问控制(CORS)]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>转载</tag>
        <tag>cors</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsonp解决跨域问题的原理]]></title>
    <url>%2Fposts%2F39860%2F</url>
    <content type="text"><![CDATA[介绍 Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。 ———— 菜鸟教程-jsonp 原理script标签的 src 不受同源策略影响，允许跨域。但需要借助服务端的配合。 示例 前端 index.html 1234567891011121314151617181920212223242526&lt;body&gt; &lt;h1&gt;天气查询&lt;/h1&gt; &lt;input type="text" id="city" placeholder="请输入城市名称"&gt; &lt;input type="button" id="btn" value="查询"&gt; &lt;script&gt; window.onload = function() &#123; // 创建方法用来获取跨域数据（名称随意） window["foo"] = function(data) &#123; // 打印获取的数据 console.log(data); &#125; const btn = document.querySelector("#btn"); btn.onclick = function() &#123; // 获取用户输入城市名 const = city = document.querySelector("#city").value; // 动态创建script标签 const script = document.createElement("script"); // 把回调函数foo的名称 以及 城市名 传递给后端 script.src = `http://127.0.0.1:8084/weather.php?callback=foo&amp;city=$&#123;city&#125;`; const body = document.querySelector("body"); body.appendChild(script); &#125; &#125; &lt;/script&gt;&lt;/body&gt; 后端 weather.php 1234567891011&lt;?php // 获取前端回调函数名和城市名 $cb = $_GET["callback"]; $city = $_GET["city"]; if ($city == "shanghai") &#123; // 调用前端已经定义的函数，把数据当做参数传递给 foo echo $cb."('上海晴，无风')"; &#125; else &#123; echo $cb."('没有查询到你所在城市天气')"; &#125;?&gt; 这样一来当前端请求 http://127.0.0.1:8084/weather.php?callback=foo&amp;city=${city} 后，后端返回的内容就应该类似这种格式： 1foo('上海晴，无风'); 本质就是在调用前端已经定义好的 foo 方法，这样就能够获取到后端返回给我们的数据了。 注意事项由于 jsonp 解决跨域问题本质上是后端返回一个方法调用。所以不是任何接口都支持 jsonp 来获取到数据的，一旦接口不支持，返回的不是方法调用格式（foo(data)）而是 json 格式（{“msg”: “success”, “data”: {…}}）的话，就说明我们无法通过 jsonp 获取到数据。 第三方接口跨域数据获取一旦第三方接口返回的是 json 格式的字符串，我们就无法通过 ajax 或者 jsonp 的方式获取跨域数据。这种情况下我们只能通过自己的服务器当做中转站帮我们前端获取三方接口数据了，因为服务端之间是不存在跨域问题的，所以出现这种情况后，你可以让公司的后端帮帮忙，写一个接口去获取三方接口数据，并暴露一个接口让你能够获取到数据~]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript坑之一map参数传递（转载）]]></title>
    <url>%2Fposts%2F8767%2F</url>
    <content type="text"><![CDATA[转载文章博客源：JavaScript坑之一map参数传递 map()方法定义在JavaScript的Array中，他是一个高阶函数。我们向这个函数传入我们自己定义的回调函数（callback），然后map会对数组当中每一个元素去调用回调函数。 通常，我们只在回调函数里用一个参数，因为大多数回调函数只需要一个参数，或者一个必须参数和多个可选参数。这样的习惯会有时导致很诡异的行为。 1['1', '2', '3'].map(parseInt); //[1, NaN, NaN] 我们所希望看到的结果其实是[1, 2, 3]，原因是parseInt一般我们用的时候都是习惯性用一个参数，但他可以接收两个参数，第二个参数用来做基数。而map向回调函数传参有三个，数组中的元素，元素的下标和这个数组。第三个参数被parseInt忽略掉，前两个参数被接收。parseInt(‘0’, 0); //基数为0，或者undefined，用10进制 parseInt(‘1’, 1); //没有1进制，返回NaN parseInt(‘2’, 2); //二进制不能出现2，返回NaN 这里关键是要知道回调函数接收的参数有三个，那么如何解决上面的问题呢？ 1234function myParseInt(intString)&#123; return parseInt(intString, 10);&#125;['1', '2'].map(myParseInt); 或者，用更简单的写法 1['1', '2'].map(str =&gt; parseInt(str)); 或者，最简单的写法 1['1', '2'].map(Number)]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transform3D转换（二）]]></title>
    <url>%2Fposts%2F14243%2F</url>
    <content type="text"><![CDATA[在我当初了解到 transform 后的一段时间，其实是不知道它能够让元素实现3d转换的。直到有一天在逛 codepen 时，我发现了下面这个demo： See the Pen CSS3 Transforms 3D Perspective Carousel by JingW (@JingW) on CodePen. p.s. 原作者地址在这儿：https://codepen.io/Hubson/pen/XmrEGX OS：我靠，还能这样玩儿？赶紧查查如何实现的。（点我重现查找过程） 然后就发现了张鑫旭老师的 这篇文章 。算是给我打开了新世界的大门~ 原来现在的CSS都这么强大了，要知道几年前我在学 .NET 时就接触过HTML和CSS，那个时候不还是满屏div，没啥特效的时代嘛。 扯远了，言归正传。首先来看下面这个图（copy上面文章来的~）： 这个图就是咱们3d变形所依赖的坐标系。要想理解这张图，需要一点空间想象力。我们人在看这个坐标系时，是从左下角的眼睛处从 +Z 往 -Z 里面看的。可以把这个眼睛简单的想象成你自己，由网格组成的正方形平面相当于你在屏幕上创建的一个正方形div元素。那么当你设置 transform: translate(200px, 0) 时，你的元素将会向 +X 方向前进，也就是平常在2d变换中的向右移动。现在应该理解了吧~ rotateX, rotateY, rotateZrotateXrotateX就是沿着 x 轴进行3d旋转。 在下面示例中，我们实现让一个元素沿着它的x轴旋转180°。为了让效果看起来更加明显，我把该元素分成了上下两个部分，并在中间留出了缝隙，以便当做X轴看待，当鼠标移入该元素后，它便“沿着” x 轴旋转180°： See the Pen transform3d-rotateX by JingW (@JingW) on CodePen. rotateY用和上面类似的方式，我们实现 rotateY 的3d旋转效果，让元素沿着 y 轴进行3d旋转： See the Pen transform3d-rotateY by JingW (@JingW) on CodePen. rotateZ还记得那根 z 轴嘛，当我们垂直于屏幕看向元素时，z 轴在我们眼里就是一个“点”。所以当我们使用 rotateZ 来旋转元素时，元素会沿着 z 轴进行旋转，就是下方元素中间的“点”： See the Pen transform3d-rotateZ by JingW (@JingW) on CodePen. perspective 透视这个属性英文直译过来就是 透视、视角的意思。 电脑显示屏是个2d平面，要想让元素在一个2d平面上有立体感（3d效果），就得利用这个 perspective 透视属性。perspective 可以让一个2d平面在转换过程中呈现出3d效果。 不知道大家有没有注意到上面有关 rotateY 下的demo，虽说是沿着元素 y 轴进行旋转，但一点3d立体效果都没有，要知道在现实生活中，如果一张卡片沿着它宽度一半儿的 y 轴进行旋转，肯定有近大远小的透视效果，即离我们近的一面越来越大，离我们远的一面越来越小。如果还没有明白，看了下面的示例就知道了（鼠标移入body就能触发旋转~）： See the Pen transform3d-perspective by JingW (@JingW) on CodePen. 这下是不是明显多啦？其实这都全靠了 perspective 透视，它允许我们为场景添加深度感，原理就是使 z 轴在靠近观察者的元素看起来更大，而更远的元素看起来更小。也就是上面提到的“近大远小”。 我们来看看下面这张图： 上图中蓝色圆圈表示三维空间中的元素，字母 d 表示透视的值，即观看者的眼睛和屏幕之间的距离。字母 Z 表示元素在 z 轴上的位置。元素在 z 轴上越远，相对于观察者的外观越小，它越接近，就看起来越大。这就是三维空间中透视的效果。 perspective VS perspective()perspective有两种写法，一种是直接写在要使用3d转换的父元素身上（如上一个demo）：12345678910111213/* 父容器 */.contaienr &#123; /* 将透视属性写在父容器 */ perspective: 1000px;&#125;/* 需要3d转换的子元素 */.box &#123; transition: transform 1s;&#125;/* 触发转换 */.container:hover box &#123; transform: rotateY(180deg);&#125; 在这种写法下，一旦“舞台（浏览器显示区域）”上有多个元素都进行了3d转换，可能效果就与你的预想不太一样，靠近“舞台”两边的元素会“歪着”进行旋转： See the Pen transform3d-perspective2 by JingW (@JingW) on CodePen. 这是为什么呢？答案是因为默认我们观察者的“眼睛”是处于“舞台”正中央的前方的（这个前方是以“舞台”的视角），所以靠近我们观察者左前方的（观察者视角）卡片，在沿着 x 轴做旋转时，就是“歪着”的；同理观察者右前方卡片也是如此。 那么如果你想让它们都与正中央的卡片一样效果的旋转呢？这就引出了第二种写法：perspective() 。该属性写在3d转换元素本身上，而不是在其父元素上了：12345678.box &#123; transition: transform 1s;&#125;.container:hover .box &#123; /* 1. 沿着x轴旋转180° */ /* 2. 给3d旋转元素本身添加 perspective 透视 */ transform: perspective(500px) rotateX(180deg);&#125; 效果如下： See the Pen transform3d-perspective3 by JingW (@JingW) on CodePen. perspective-origin语法：12perspective-origin: 50% 50%; /* 默认值，表示观察者在“舞台”正中央的上方 */perspective-origin: left center; /* 表示观察者在“舞台”最左边且垂直居中的上方 */ 该属性用于定义观察者观看三维空间时的位置所在。默认情况下为x轴50%、y轴50%。也就是“舞台（屏幕）”正中央的上方。 读者可以尝试用鼠标拖动下方demo中的按钮“camera”到“舞台”的各个位置，然后看看三张卡片的3d转换效果。当你在拖动“camera”改变它的位置时，也就等同于改变了 perspective-origin 的位置。例如当你把按钮“camera”拖动到左上角，就相当于设置了 perspective-origin: left top。 See the Pen transform3d-perspective-origin by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transform转换（一）]]></title>
    <url>%2Fposts%2F45420%2F</url>
    <content type="text"><![CDATA[介绍 Transform属性应用于元素的2D或3D转换。这个属性允许你将元素旋转，缩放，移动，倾斜等。 ———— 出自 菜鸟教程 这次我们讨论的都是2D转换，3D的后面我会单独出一篇~ scale 缩放这个属性用来放大或缩小元素的大小。语法示例如下：123456div &#123; transition: transform 1s; /* 给div的transform属性添加过渡效果 */&#125;div:hover &#123; transform: scale(1.5); /* 让元素放大为原始大小的1.5倍 */&#125; See the Pen transform scale by JingW (@JingW) on CodePen. translate 位移该属性用来让元素向上/向下/向左/向右进行位移。 示例：123456div &#123; transition: transform 1s;&#125;div:hover &#123; transform: translate(20px, 20px);&#125; See the Pen LvbqKb by JingW (@JingW) on CodePen. rotate 旋转该属性让元素能够顺时针或逆时针旋转指定的度数。 示例：123456div &#123; transition: transform 1s;&#125;div:hover &#123; transform: rotate(720deg); /* 元素顺时针旋转720度 */&#125; See the Pen transform rotate by JingW (@JingW) on CodePen. skew 倾斜该属性能够让元素基于x, y轴倾斜转换 示例：12345678div &#123; transition: transform 1s;&#125;div:hover &#123; transform: skew(45deg, 45deg); /* transform: skewX(25deg); transform: skewY(10deg); */&#125; See the Pen transform skew by JingW (@JingW) on CodePen. 注意： 如果仔细观察上面的示例，当鼠标移入box后，不但整个box进行了倾斜，里面的子元素和文本内容也会发生倾斜。如果不希望里面的内容发生变化，可以使用相反的skew值将其恢复： See the Pen transform skew2 by JingW (@JingW) on CodePen. transform-origin 变形原点该属性可以配合 transform 属性一起使用，它允许我们指定元素转换的位置原点。默认情况原点位于元素的中心。 例如刚刚上面在讲到 rotate 属性时，我们的旋转是以中心为原点的。但你在某些情况下可能并不想让元素围绕中心旋转，而是左上角旋转，就可以用到该属性。 语法示例：1234567div &#123; transform-origin: left top; transition: transform 1s;&#125;div:hover &#123; transform: rotate(720deg);&#125; See the Pen transform transform-origin by JingW (@JingW) on CodePen. 变换组合有时候我们可能想要一个元素既旋转又位移，那么我们就可以使用 transform 的简写语法： 123456div &#123; transition: transform 1s;&#125;div:hover &#123; transform: rotate(90deg) scale(1.5);&#125; See the Pen ZZBNmN by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于浏览器的CSS前缀]]></title>
    <url>%2Fposts%2F496%2F</url>
    <content type="text"><![CDATA[突然想起来的，先占个坑，有空再更…]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宏任务&微任务]]></title>
    <url>%2Fposts%2F20664%2F</url>
    <content type="text"><![CDATA[先Mark一下，抽空再写…1234567891011121314151617181920212223242526console.log('sync1');setTimeout(function () &#123; console.log('setTimeout1')&#125;, 0);var promise = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; console.log('setTimeoutPromise') &#125;, 0); console.log('promise'); resolve();&#125;);promise.then(() =&gt; &#123; console.log('pro_then'); setTimeout(() =&gt; &#123; console.log('pro_timeout'); &#125;, 0)&#125;)setTimeout(function () &#123; console.log('last_setTimeout')&#125;, 0);console.log('sync2');]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS中的连等赋值操作]]></title>
    <url>%2Fposts%2F24177%2F</url>
    <content type="text"><![CDATA[金三银四正是面试的好时候，有不少学员面试后在前端群里分享JS面试题，我正巧没事儿翻到一题做做看，发现答案与我自己的预期大相径庭，当时我就震惊了，在chrome控制台打印了下结果，还真是我错了。没错，就是下面这道连等赋值题： 12345var a = &#123; name: 'a'&#125;;a.x = a = &#123;&#125;; 问：此刻的 a.x 是多少。 当时我简单的分析了下，由于 a 赋值给了一个新对象，接着又把 a 赋值给了 a.x ，那理所当然 a.x 不就是 {} 嘛。然而答案却是出乎意料的 undefined … 想了半天还是感觉理解不了，我就google了下，发现了这篇文章：千万不要在JS中使用连等赋值操作 。看完后理解了。 这道题的核心在于知道JS是如何执行 a.x = a = {} 这行代码的，分两步：一是确定 a 是什么，二是代码执行顺序是从右向左的。 我们一步步看，第一行代码 var a = {name: &#39;a&#39;} ，这句话应该都没什么疑问，我们把 a 的地址假设为 AAA 。 然后就是 a.x = a = {} ，按照步骤来，先确定 a 是什么，在还没有赋值操作前，a.x 的 a 指向 AAA，中间的 a 也是指向 AAA ，新创建的对象 {} 地址假设为 BBB 。然后代码从右向左执行，a = {} ，所以中间的 a 指向了新地址 BBB ；接着 a.x = a ，此刻的 a.x 的 a 仍然是 AAA（因为在赋值前就已经确定了 a 的地址），赋值后原地址 AAA 的对象就变成了 {name: ‘a’, x: {}} 这里的x指向的就是新对象地址 BBB 。 上述操作结束后再来问 a.x 的值是什么，此刻的 a 已经在 a = {} 这一步赋值操作后指向了新的地址 BBB ，所以此刻的 a 是空对象 {} ，而空对象是没有 x 属性的，所以输出 undefined 。 是不是有点绕？这种题出出来真是挺看JS功底的，它考察了你对JS编译原理的理解与掌握情况。借用上面博客里博主的一句话作为收尾：尽量不要使用JS的连续赋值操作，除非真的了解它的内部机制及可能会产生的后果。]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vuex的基本使用]]></title>
    <url>%2Fposts%2F19311%2F</url>
    <content type="text"><![CDATA[什么是 VuexVuex 是一个专为 Vue.js 应用程序开发的状态管理工具。 准备工作首先使用 vue-cli 脚手架工具新建一个项目： 1vue create vuex-demo src文件夹下的目录结构： 1234567src├── App.vue├── assets│ └── logo.png├── components│ └── HelloWorld.vue└── main.js # 入口文件 安装 vuex命令行下执行： 1npm i vuex 然后在入口文件引入 vuex ： 12import Vuex from 'vuex'Vue.use(Vuex) 一个例子为了了解 vuex 到底做了什么事情、解决了哪些问题。我们先来实现一个简单的 demo ，有一个标签显示数字，两个按钮分别做数字的 +1 和 -1 操作。 我们先在 src/components/ 下的 Normal.vue 组件中使用纯 Vue 版本编写代码： Normal.vue 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id="normal"&gt; &lt;p&gt;&#123;&#123;count&#125;&#125; &lt;button @click="inc"&gt; + &lt;/button&gt; &lt;button @click="dec"&gt; - &lt;/button&gt; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; count: 0 &#125; &#125;, methods: &#123; inc() &#123; this.count++ &#125;, dec() &#123; this.count-- &#125; &#125;,&#125;&lt;/script&gt; 然后在 src/App.vue 中引入并使用该组件： 1234567891011121314&lt;template&gt; &lt;div id="app"&gt; &lt;Normal&gt;&lt;/Normal&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Normal from '@/components/Normal'export default &#123; components: &#123; Normal, &#125;&#125;&lt;/script&gt; 命令行执行 npm run serve 就能运行 App 了。 如上的代码的含义是：两个 button 标签绑定函数，当点击的时候分别调用 inc 和 dec 方法，接着会调用 vue 中的 methods 的对应的方法。然后会让 data 中的 count 属性值发生改变，改变后会把最新值渲染到视图中。 现在我们来看看使用 vuex 的方式来实现如上 demo ： src下新建 vuex/store.js 123456789101112131415import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)// 注意是new【Vuex.Store】实例而不是【Vuex】export const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; inc: state =&gt; state.count++, dec: state =&gt; state.count-- &#125;&#125;) main.js 中引入 1234567...import store from '@/vuex/store'...new Vue(&#123; render: h =&gt; h(App), store&#125;).$mount('#app') 在 src/components/ 下新建 SWVuex.vue 组件 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id="vuex"&gt; &lt;p&gt;&#123;&#123;count&#125;&#125; &lt;button @click="inc"&gt;+&lt;/button&gt; &lt;button @click="dec"&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; computed: &#123; count() &#123; return this.$store.state.count &#125; &#125;, methods: &#123; inc() &#123; this.$store.commit('inc') &#125;, dec() &#123; this.$store.commit('dec') &#125; &#125;, &#125;&lt;/script&gt; 在 App.vue 中使用 SWVuex 组件 1234567891011121314&lt;template&gt; &lt;div id="app"&gt; &lt;SWVuex&gt;&lt;/SWVuex&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import SWVuex from '@/components/SWVuex'export default &#123; components: &#123; SWVuex &#125;&#125;&lt;/script&gt; 两者比较 需要引用 vuex 。 methods 的方法不变，但是方法内的逻辑不在函数内进行，而是让 store 对象去处理。 count 数据不再是一个 data 函数返回的对象的属性了。而是通过 store 方法内的计算字段返回的。 回到 store 对象上来，store 对象是 Vuex.Store 的实例。在 store 内分为 state 对象和 mutations 对象，其中 state 存放的是状态，比如 count 属性就是它的状态值，而 mutations 则是一个会引发状态改变的所有方法。 什么是状态管理模式简单的理解就是统一管理和维护各个 vue 组件的可变化状态。 我们明白 vue 是单向数据流的，那么它的状态管理一般包含如下几部分： state：驱动应用的数据（一般指 data 中返回的数据） view：一般指模板，以声明的方式将 state 的数据映射到视图 actions：响应在 view 上的用户输入导致的状态变化 但是当我们的应用遇到多个组件共享状态时候，那么单向数据流可能不太满足我们的需求，比如： 组件的多层嵌套 多个视图依赖同一个状态 上面这些情况确实能在不使用 vuex 的情况下实现，但往往会导致写出无法维护的代码。因此我们可以把组件的共享状态提取出来、全局管理，因此 vuex 产生了。 Vuex 的优点最主要解决了组件之间共享同一状态的问题。可以把组件的共享状态提取出来，作为全局来管理。 什么情况下才推荐使用 Vuex大型单页应用！！！如果你的项目不够大，足够简单，最好不要使用 Vuex ，一个简单的 global event bus 就足够所需了。 State 对象状态的访问通过 computed 计算属性直接赋值12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div id="vuex"&gt; &lt;p&gt;通过 $store.state 方式获取：&#123;&#123;$store.state.count&#125;&#125;&lt;/p&gt; &lt;p&gt;通过 computed 计算属性赋值：&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;p&gt; &lt;button @click="inc"&gt;+&lt;/button&gt; &lt;button @click="dec"&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; computed: &#123; count() &#123; return this.$store.state.count &#125; &#125;, methods: &#123; inc() &#123; this.$store.commit('inc') &#125;, dec() &#123; this.$store.commit('dec') &#125; &#125;, &#125;&lt;/script&gt; 借助 mapState 辅助函数对象形式123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id="vuex"&gt; &lt;p&gt;通过 $store.state 方式获取：&#123;&#123;$store.state.count&#125;&#125;&lt;/p&gt; &lt;p&gt;通过 computed 计算属性赋值：&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;p&gt; &lt;button @click="inc"&gt;+&lt;/button&gt; &lt;button @click="dec"&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState&#125; from 'vuex' export default &#123; computed: mapState(&#123; count: state =&gt; state.count &#125;), methods: &#123; inc() &#123; this.$store.commit('inc') &#125;, dec() &#123; this.$store.commit('dec') &#125; &#125;, &#125;&lt;/script&gt; 数组形式12// 数组中的 count 必须和 store.js 中定义的常量 count 同名，因为这是直接访问 state 的 countcomputed: mapState(['count']) Getters 计算过滤操作有时候我们需要从 store 的 state 中派生出一些状态，比如在使用 store 中的 state 之前，我们会对 state 中的某些字段进行过滤——让 count 字段都进行加 10 这样的数据操作；但是如果有多个组件需要用到这个操作的话，那么我们就需要复制这个函数，或者抽取到一个共享函数内，然后多处导入这个函数，但是这上面两种方式都不是太好，因为我们现在有更好的方式来解决它。 Vuex 允许我们在 store 中定义 getters，getters 的返回值会根据它的依赖被缓存起来，且只有当他的依赖值发生改变了才会重新计算。 现在我们对 store.js 文件中的 count 进行一个计算属性的操作，在它每次输出之前，加上20。 如下代码有两个按钮，一个加5，一个减5，那么在加5或者减5之前，先加20，然后再进行加5或者5操作。代码如下： store.js 12345678910111213141516171819import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; inc: (state, num) =&gt; state.count += num, dec: (state, num) =&gt; state.count -= num &#125;, getters: &#123; myCount(state) &#123; return state.count + 20 &#125; &#125;&#125;) SWVuex.vue 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div id="vuex"&gt; &lt;p&gt;通过 $store.state 方式获取：&#123;&#123;$store.state.count&#125;&#125;&lt;/p&gt; &lt;p&gt;通过 computed 计算属性赋值：&#123;&#123;myCount&#125;&#125;&lt;/p&gt; &lt;p&gt; &lt;p&gt;使用 $store.commit('inc', 5) 方式调用&lt;/p&gt; &lt;!-- $store.commit('inc', 5) 第一个参数是方法名，第二个是参数 --&gt; &lt;button @click="$store.commit('inc', 5)"&gt;+&lt;/button&gt; &lt;button @click="$store.commit('dec', 5)"&gt;-&lt;/button&gt; &lt;/p&gt; &lt;div&gt; &lt;p&gt;使用mapMutations修改状态：&lt;/p&gt; &lt;p&gt; &lt;button @click="inc(10)"&gt;+&lt;/button&gt; &lt;button @click="dec(10)"&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState, mapGetters, mapMutations&#125; from 'vuex' export default &#123; computed: &#123; // mapState(['count']) 此处的 count 必须和 store.js // state 中的 count 同名，因为这是直接访问 state 的 count ...mapState(['count']), // mapGetters 辅助函数， // 可以将 store 中的 getter 映射到局部计算属性 myCount ...mapGetters(['myCount']) &#125;, methods: &#123; ...mapMutations(['inc', 'dec']) &#125;, &#125;&lt;/script&gt; Mutations 修改状态Mutations 是修改 vuex 中的 store 的唯一方法。每个 mutations 都有一个字符串的事件类型(type)和一个回调函数(handler)。这个回调函数就是我们进行更改的地方。它也会接受 state 作为第一个参数。 回顾上面的 store.js 中有关 mutations 的代码： 1234mutations: &#123; inc: (state, num) =&gt; state.count += num, dec: (state, num) =&gt; state.count -= num&#125;, 当我们点击页面上的按钮后会触发事件并执行方法，方法中又会调用 $store.commit(type, args) 来传入参数改变 state 数据。 Actions 异步修改状态Actions 和 Mutations 类似，但它用来异步修改 state 的状态。而 Mutations 则是同步修改 state 的状态。 我们在 store.js 中声明 actions，actions 可以调用 mutations 的方法的。代码如下： store.js 1234567891011// 增加两个 actions 方法actions: &#123; incAction(context) &#123; console.log(context) // 调用 mutations 中的 inc 方法，并传参数5 context.commit('inc', 5) &#125;, decAction(context) &#123; context.commit('dec', 5) &#125;&#125; 上方代码中的参数 context 指上下文，即 store 本身。 然后在 SWVuex.vue 中通过 this.$store.dispatch(action方法名, 参数) 的方式调用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div id="vuex"&gt; &lt;p&gt;通过 $store.state 方式获取：&#123;&#123;$store.state.count&#125;&#125;&lt;/p&gt; &lt;p&gt;通过 computed 计算属性赋值：&#123;&#123;myCount&#125;&#125;&lt;/p&gt; &lt;div&gt; &lt;p&gt;使用 $store.commit('inc', 5) 方式调用&lt;/p&gt; &lt;!-- $store.commit('inc', 5) 第一个参数是方法名，第二个是参数 --&gt; &lt;button @click="$store.commit('inc', 5)"&gt;+&lt;/button&gt; &lt;button @click="$store.commit('dec', 5)"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;使用mapMutations修改状态：&lt;/p&gt; &lt;p&gt; &lt;button @click="inc(10)"&gt;+&lt;/button&gt; &lt;button @click="dec(10)"&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;actions的异步操作&lt;/p&gt; &lt;button @click="incAction"&gt; + &lt;/button&gt; &lt;button @click="decAction"&gt; - &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState, mapGetters, mapMutations&#125; from 'vuex' export default &#123; computed: &#123; // mapState(['count']) 此处的 count 必须和 store.js // state 中的 count 同名，因为这是直接访问 state 的 count ...mapState(['count']), // mapGetters 辅助函数， // 可以将 store 中的 getter 映射到局部计算属性 myCount ...mapGetters(['myCount']) &#125;, methods: &#123; ...mapMutations(['inc', 'dec']), incAction() &#123; this.$store.dispatch('incAction') &#125;, decAction() &#123; this.$store.dispatch('decAction') &#125;, &#125;, &#125;&lt;/script&gt; 当然，除了使用 this.$store.dispatch() 的方式以外，还可以借助 mapActions 来简化代码： 1234567// 新加 mapActionsimport &#123;mapState, mapGetters, mapMutations, mapActions&#125; from 'vuex'...methods: &#123; ...mapMutations(['inc', 'dec']), ...mapActions(['incAction', 'decAction']) // +&#125;,]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于sequelize的数据库迁移]]></title>
    <url>%2Fposts%2F16051%2F</url>
    <content type="text"><![CDATA[数据库迁移有时候我们也希望能够跟踪数据库的更改，像 git 一样在各个不同时期的数据库状态之间进行切换。或者能通过一套工具将数据库迁移到本机，让我们在家也能进行测试开发，而不用依赖公司的测试环境。这些特性，作为今天的主角 sequelize-cli 都能提供给我们。 npm链接请 点击这里。 安装首先创建项目，项目名随意，创建完毕后cd到项目根目录，老规矩命令行 npm init -y 创建 package.json ，然后输入安装一步到位：npm i sequelize mysql2 sequelize-cli 。 注意： sequelize-cli 依赖 sequelize，sequelize 依赖 mysql2 安装完毕后我们可以测试下是否可用，根目录命令行输入： 1./node_modules/.bin/sequelize 看见命令行输出类似下方提示代表安装成功： 1234567891011121314151617181920212223242526sequelize [命令]命令： sequelize db:migrate Run pending migrations sequelize db:migrate:schema:timestamps:add Update migration table to have timestamps sequelize db:migrate:status List the status of all migrations sequelize db:migrate:undo Reverts a migration sequelize db:migrate:undo:all Revert all migrations ran sequelize db:seed Run specified seeder sequelize db:seed:undo Deletes data from the database sequelize db:seed:all Run every seeder sequelize db:seed:undo:all Deletes data from the database sequelize db:create Create database specified by configuration sequelize db:drop Drop database specified by configuration sequelize init Initializes project sequelize init:config Initializes configuration sequelize init:migrations Initializes migrations sequelize init:models Initializes models sequelize init:seeders Initializes seeders sequelize migration:generate Generates a new migration file [aliases: migration:create] sequelize model:generate Generates a model and its migration [aliases: model:create] sequelize seed:generate Generates a new seed file [aliases: seed:create]选项： --help 显示帮助信息 [布尔] --version 显示版本号 [布尔] 使用初始化目前我们项目的树形结构为： 1234.├── node_modules├── package-lock.json└── package.json 接着根目录命令行输入 ./node_modules/.bin/sequelize init 来初始化 sequelize 项目，该命令会帮我们创建如下目录：12345678.├── config # 包含数据库的配置文件├── migrations # 包含所有迁移文件（e.g. 数据库、表的创建，字段的增加）跟数据库结构有关的操作都存放在这里├── models # 包含项目中的所有模型（e.g. Users, Message）├── node_modules├── seeders # 包含所有种子文件（e.g. 表中的数据）├── package-lock.json└── package.json config首先我们来看下 config 目录下的 config.json 文件。它里面包含了数据库的的基本配置，默认分为 development（开发） 、test（测试） 和 production（生产） 环境。当然你也可以删除或新增环境，比如新增一个在家编写代码所使用的 home 环境。 db:createsequelize-cli 默认读取 development 模式下的数据库配置来创建数据库，所以接下来就用它来配置：12345678"development": &#123; "username": "root", // 数据库用户名 "password": "root", // 数据库密码 "database": "database_development", // 需要创建的数据库名 "host": "127.0.0.1", // 主机 "port": 8889, // 端口号 "dialect": "mysql" // 使用的数据库类型&#125;, 配置完毕后在根目录下的命令行输入 ./node_modules/.bin/sequelize db:create。当你看到如下输出就代表创建数据库成功：123Loaded configuration file "config/config.json".Using environment "development".Database sw_sequelize_development created. db:drop能添加就能删除，我们可以键入 ./node_modules/.bin/sequelize db:drop 命令来删除数据库。当你看到命令行输出下面内容就代表删除成功：123Loaded configuration file "config/config.json".Using environment "development".Database sw_sequelize_development dropped. 模式切换前面已经说了，sequelize-cli 默认读取 development 模式下的数据库配置。那如果我现在想切到 test 模式下该怎么办呢？ 变更环境变量首先得切换服务器环境变量，MacOS下（其他系统切换命令见下方链接）使用 export NODE_ENV=test 来切换到 test 模式，然后使用 echo $NODE_ENV 查看是否已经切换成功，接着就可以再次执行 ./node_modules/.bin/sequelize db:create 命令，创建 test 模式下的数据库了： 123456789101112$ export NODE_ENV=test$ echo $NODE_ENVtest./node_modules/.bin/sequelize db:createSequelize CLI [Node: 9.0.0, CLI: 5.4.0, ORM: 5.3.3]Loaded configuration file "config/config.json".Using environment "test".Database sw_sequelize_test created. 各系统下NodeJS环境变量修改 还原环境变量如果想回到默认的 development 模式，MacOS下直接键入命令 export NODE_ENV= 就OK啦。 models创建模型我们通过 model:generate 或者 model:create 来创建模型文件，它一共需要两个参数，分别是： –name: 模型名称（必须） –attributes: 字段列表（必须） 回到我们的项目，在根目录执行下面命令来创建一个 User 模型文件： 1./node_modules/.bin/sequelize model:create --name User --attributes username:STRING 执行完毕后命令行会有类似下方输出：1234Sequelize CLI [Node: 9.0.0, CLI: 5.4.0, ORM: 5.3.3]New model was created at .../你的项目名/models/user.js .New migration was created at .../你的项目名/migrations/20190316035632-User.js 所以 model:create 命令执行后帮我们创建了两个文件，一个是用来定义 User 模型的文件 user.js :12345678910'use strict';module.exports = (sequelize, DataTypes) =&gt; &#123; const User = sequelize.define('User', &#123; username: DataTypes.STRING &#125;, &#123;&#125;); User.associate = function(models) &#123; // associations can be defined here &#125;; return User;&#125;; 一个是 migrations 迁移文件夹下的 用来创建 User 表 的文件：12345678910111213141516171819202122232425262728'use strict';module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; // 创建名为 Users 的数据表 return queryInterface.createTable('Users', &#123; id: &#123; allowNull: false, autoIncrement: true, primaryKey: true, type: Sequelize.INTEGER &#125;, username: &#123; type: Sequelize.STRING &#125;, createdAt: &#123; allowNull: false, type: Sequelize.DATE &#125;, updatedAt: &#123; allowNull: false, type: Sequelize.DATE &#125; &#125;); &#125;, down: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.dropTable('Users'); &#125;&#125;; 其中 models 文件夹下文件，例如生成的 user.js 模型文件是给程序用的；migrations 和 seeders 文件夹下的文件是个 cli 用的。 总结下来，model:create 命令帮我们做了两件事情： 创建 User 模型 创建跟模型对应的 Users 数据表文件，方便用此文件在数据库中创建 Users 表 migrations刚刚我们已经创建了一个 User 模型和用来创建 Users 表的脚本执行文件。下面就可以开始执行迁移了。首先我们重温何为执行迁移： 所谓迁移，就是对数据库进行结构的创建、升级（修改）等操作 执行迁移db:migrate执行迁移的命令为 db:migrate，我们直接在项目根目录下运行： 1./node_modules/.bin/sequelize db:migrate （如果在此之前你运行过 db:drop 命令来删除数据库，记得再重新执行一次 db:create，否则会导致创建表失败）。执行成功的输出类似下面文字： 123456Sequelize CLI [Node: 9.0.0, CLI: 5.4.0, ORM: 5.3.3]Loaded configuration file "config/config.json".Using environment "development".== 20190316035632-create-user: migrating ========= 20190316035632-create-user: migrated (0.047s) 此时刷新下你的本地数据库，就会发现之前空空如也的数据库中多了个 users 表和 sequelizemeta 表： users 表被创建出来我们能理解，重点说一下这个 sequelizemeta 表，其实它是用来记录已经被执行过的迁移脚本的，避免我们重复执行已经执行过的脚本。 db:migrate:status我们可以通过 db:migrate:status 命令来查看当前迁移脚本的执行状态： 1./node_modules/.bin/sequelize db:migrate:status 执行完毕后的打印结果为： 123Loaded configuration file "config/config.json".Using environment "development".up 20190316035632-create-user.js 这个 up ，表示我们已经执行该脚本。此时我们可以删掉 sequelizemeta 表中的记录，然后再次执行 db:migrate:status ，会发现输出的 up 已变为 down ，表示我们从未执行过该脚本。由此可知 db:migrate:status 会通过 sequelizemeta 表中的记录来判断脚本是否被执行过。而当我们已经执行过某些脚本后再次执行 db:migrate ，那些已经执行过的脚本就不会再次重复执行了： 123Loaded configuration file "config/config.json".Using environment "development".No migrations were executed, database schema was already up to date. db:migrate:undo除了上面的新增数据表操作，我们还可以进行撤销操作。执行 ./node_modules/.bin/sequelize db:migrate:status 命令后 sequelize-cli 会帮我们撤销掉上一次（最近一次）的迁移操作，比如我们的 sequelizemeta表中记录了两条迁移操作（假设创建了 user 和 message 表）： 1220190316035632-create-user.js20190316035921-create-message.js 那么执行 undo 后就会把最近的一次迁移，也就是 *-message.js 从表中移除，并且在数据库中删除 message 表。而这个删除操作，其实是执行了迁移文件下对应表的删除代码： 123down: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.dropTable('Messages');&#125; db:migrate:undo:all当执行 ./node_modules/.bin/sequelize db:migrate:undo:all 命令后，能帮我们撤销所有的迁移操作。 db:migrate:undo: –name此命令能帮我们撤销具体指定的迁移脚本，例如执行下面命令会撤销名称为 20190316035632-create-user 的脚本操作：1./node_modules/.bin/sequelize db:migrate:undo --name 20190316035632-create-user 执行完毕后再来刷新我们的数据库，就会发现 user 表已被删除，只留下了 message 表。 字段添加与删除随着业务的增长，我们很有可能需要扩充数据表的字段。例如我们需要给 user 表添加一个 username 字段，那么我们就可以键入以下命令来创建一个 migration : 1./node_modules/.bin/sequelize migration:create --name UserAddAge 执行完上述操作后我们能在 migrations 文件夹中看到新创建的 UserAddAge 文件，打开后代码如下：1234567891011121314151617181920212223'use strict';module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; /* Add altering commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.createTable('users', &#123; id: Sequelize.INTEGER &#125;); */ &#125;, down: (queryInterface, Sequelize) =&gt; &#123; /* Add reverting commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.dropTable('users'); */ &#125;&#125;; 我们要做的，就是在 up 和 down 方法中填入数据库操作逻辑的代码，up 方法中有注释作提示，让我们返回一个类型为 Promise 的对象，还给出了示例。因为我们要给数据表添加字段，所以使用 addColumn 方法： 123456789return queryInterface.addColumn( 'users', // 被添加字段的表名称 'age', // 需要添加的字段名称 &#123; type: Sequelize.TINYINT, allowNull: false, defaultValue: 0, &#125;, // 字段属性) 这样我们就可以给 user 表添加上 age 字段了。 p.s. 之所以代码中填写 users ，是因为 sequelize-cli 帮我们创建表是会自动给表名称加 s 。 能添加就能删除，删除操作我们在 down 方法中编写： 1234return queryInterface.removeColumn( 'users', 'age'); UserAddAge.js 文件完整代码：123456789101112131415161718192021222324252627282930313233343536'use strict';module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; /* Add altering commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.createTable('users', &#123; id: Sequelize.INTEGER &#125;); */ return queryInterface.addColumn( 'users', 'age', &#123; type: Sequelize.TINYINT, allowNull: false, defaultValue: 0, &#125; ) &#125;, down: (queryInterface, Sequelize) =&gt; &#123; /* Add reverting commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.dropTable('users'); */ return queryInterface.removeColumn( 'users', 'age' ); &#125;&#125;; 编写完毕后我们运行 ./node_modules/.bin/sequelize db:migrate 来重新执行一遍所有迁移，刷新 user 表后就能看见新增字段 age 了。 最后你还可以执行 ./node_modules/.bin/sequelize db:migrate:undo 来确认 down 方法正常工作，从而让 user 表删除刚刚添加的 age 字段。 文档参考：更多 QueryInterface 操作 seeders除了数据库结构的添加修改删除操作以外，我们通常还会给各种表批量添加一些假数据。这个时候就要用到 seeders 里的种子文件了。比方说现在要给 user 表批量添加一些数据，则可以执行下面代码：1./node_modules/.bin/sequelize seed:create --name userTest 执行完毕后你会发现在 seeders 文件夹下多了一个类似 20190316090425-userTest.js 的文件。 批量添加我们可以在里面编写代码让 cli 帮助我们批量添加数据：12345678910111213141516171819202122232425262728293031323334353637'use strict';module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; /* Add altering commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.bulkInsert('People', [&#123; name: 'John Doe', isBetaMember: false &#125;], &#123;&#125;); */ return queryInterface.bulkInsert('users', [ &#123; username: '狄仁杰', age: 56 &#125;, &#123; username: '李元芳', age: 27 &#125; ]); &#125;, down: (queryInterface, Sequelize) =&gt; &#123; /* Add reverting commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.bulkDelete('People', null, &#123;&#125;); */ return queryInterface.bulkDelete('users', null, &#123;&#125;); &#125;&#125;; 种子文件的执行方式有两种： db:seed 种子文件名 来运行指定种子文件 db:seed:all 来运行所有种子文件 知道执行方法后我们来运行下面命令： 1./node_modules/.bin/sequelize db:seed:all 执行成功后刷新我们的 user 表，就会发现数据已经被批量添加进去了。 批量删除命令行输入并执行： ./node_modules/.bin/sequelize db:seed:undo:all 便可以批量删除刚刚添加进 user 表中的数据。 记录种子数据的存储我们知道 migrations 迁移是会被记录的（数据库的 sequelizemeta 表中），但默认情况下，种子数据的存储不会被记录下来。但官方同样提供了 方法 来记录种子数据的存储。我们可以通过在配置文件中使用 seederStorage 来记录存储： JSON记录 config/config.json 12345"development": &#123; ... "seederStorage": "json", // 存储类型 "seederStoragePath": "userTestData.json" // 存储路径（当前项目根目录下）&#125;, p.s. 上方注释在 copy 到自己项目时需要删除，否则报错。 接着我们执行 ./node_modules/.bin/sequelize db:seed:undo:all 先删除数据表中数据，然后再执行 ./node_modules/.bin/sequelize db:seed:all 重新添加一次种子数据。你就会发现项目根目录下多出来了一个叫做 userTestData.json 的文件，里面记录了已经执行过的种子文件名：123[ "20190316090425-userTest.js"] sequelize记录p.s. 如果你已经用上面json记录的方式记录过种子文件的存储，再想要尝试用sequelize玩一遍的话，首先得执行一遍 ./node_modules/.bin/sequelize db:seed:undo:all 哦。 123456"development": &#123; ... "seederStorage": "sequelize", // 存储类型 "seederStoragePath": "userTestData.json", // 存储路径（当前项目根目录下） "seederStorageTableName": "userTestData" // 存储的表名&#125;, 编写完上述代码后你可以执行下面命令： 1./node_modules/.bin/sequelize db:seed:all 执行完毕后刷新数据库，就能在数据库中发现 userTestData 表，里面记录了已经执行完毕的种子文件 20190316090425-userTest.js 版本安装的 sequelize 和 mysql2 的版本为：1234"dependencies": &#123; "sequelize": "^5.3.3", "sequelize-cli": "^5.4.0"&#125; 资源 QueryInterface 操作]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
        <category>Sequelize</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>SQL</tag>
        <tag>Sequelize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minification 压缩与 Gzip 压缩的区别（翻译）]]></title>
    <url>%2Fposts%2F53167%2F</url>
    <content type="text"><![CDATA[原链接：https://css-tricks.com/the-difference-between-minification-and-gzipping/作者：Chris Coyier 这两种方法都针对你网站上的资源（比如 .css 文件和 .js 文件）所使用。它们都用来压缩文件大小，使服务器和浏览器之间的网络更加通畅，提高网页性能。网络是网页的速度瓶颈所在，而压缩文件大小能够改善这一点。 但这两者也截然不同。如果之前你并不知道这一点，那么你应当花时间来了解它。 Minification 能够删除空格符（whitespace）、注释符（comments）、无用的分号（semicolons）或是减少 hex 代码的长度………诸如此类。剩下的文件依然是有效代码。你不必尝试读取它或是使用它，它并没有违反任何规则。就像对原始文件那样，浏览器可以读取它和使用它。 Minification 能够创建你最终使用的新文件。比如当你创建了一个名为 style.css 的文件之后，你可以把它压缩为 style.min.css。 Gizpping 能识别所有重复的字符串，并使用指代该字符串第一个实例的指针来代替。Julia Evans 曾想出一个绝佳的方法来解释这一点（点击这里查阅她发布的内容和视频）。下面是一首诗的第一段： 123456Once upon a midnight dreary, while I &#123;pon&#125;dered weak an&#123;d wea&#125;&#123;ry,&#125;Over many&#123; a &#125;quaint&#123; and &#125;curious volume of forgotten lore,W&#123;hile I &#125;nodded, n&#123;ear&#125;ly napping, su&#123;dde&#125;n&#123;ly &#125;th&#123;ere&#125; ca&#123;me &#125;a t&#123;apping,&#125;As&#123; of &#125;so&#123;me o&#125;ne gent&#123;ly &#125;r&#123;apping, &#125;&#123;rapping&#125; at my chamb&#123;er &#125;door.`'Tis&#123; some &#125;visitor,'&#123; I &#125;mu&#123;tte&#125;r&#123;ed, &#125;`t&#123;apping at my chamber door&#125; -O&#123;nly th&#125;is,&#123; and &#125;no&#123;thi&#125;&#123;ng &#125;m&#123;ore&#125;. Gzip 识别出括弧里的文字都是重复的，因此将会使用指针来代替它们，这样这些文字占用的空间将会比原来更小。 对于减少文件大小、尤其是代码而言，这种方法十分高效，因为代码中有大量重复的内容。设想一下一个 HTML 文件里有多少个 &lt;div，一个 CSS 文件里又有多少 {。 你也可以创建某个文件的 Gzip 压缩版本，比如 style.css.zip。但你一般不会这样做，浏览器也不知道应该如何使用这个文件。 在网页中，Gzip 压缩直接通过服务器完成。因此你要做的是配置服务器。一旦完成配置，Gzip 压缩将会自动进行，你无需再做任何工作。服务器会压缩文件，并通过网络传送文件。浏览器则接受文件，并在使用之前进行解压。我从未听谁提到过压缩和解压的成本，因此在这里我假设这些成本可以忽略不计，并且我们获得的受益远大于成本。 点击这里查看如何在 Apache 服务器中进行配置，这里使用了 mod_deflate 模块。H5BP 也为所有常见的服务器提供了服务器配置，包括 Gzipping。 示例我们将用到 Bootstrap 中常见的 CSS 文件。 通过 Minification 来压缩这个 CSS 文件，你将节省 17% 的空间，而使用 Gzipping 能够节省 85%，将两种方法结合使用节省的空间是 86%。 下面是使用 DevTools 检查工作状况时的理想情况： Gzip压缩 要高效得多，而将两种方法结合起来更为理想。Gzip 压缩节省的空间大概是 Minification 压缩的五倍。然而，通过 Minification 压缩，你也可以获得一些帮助，不过在构建步骤时你需要耗费一些额外的力气。 同样有证据证明浏览器在读取和解析 Minification 压缩的文件时速度更快： 正如预期的那样，除了缩短网络传输时间以外，Minification 压缩还有助于解析和加载。这也许是因为缺少注释符和额外的空白符。 微软也开始为此优化它们的语法分析器： 因此，在 Window 10 和 Microsoft Edge 中，我们新添加了快速路径，改善了在 Chakra 的 JIT 编译器中嵌入和优化部分探视程序的体验，以保证压缩代码的运行速度不低于原始版本。通过这些改变，通过 UglifyJS 压缩过的个体代码模式的性能提高了 20% 到 50%。 缓存资源同样与这段对话相关，没有什么比一个不需要请求任何资源的浏览器速度更快了！关于这一点，网上或者书中还有许多相关知识，不过很快我们也许会发布一些有关使用技巧的内容。]]></content>
      <categories>
        <category>后端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>gzip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack4 如何优雅打包缓存文件（转载）]]></title>
    <url>%2Fposts%2F57458%2F</url>
    <content type="text"><![CDATA[一般来说，对于静态资源，我们都希望浏览器能够进行缓存，那样以后进入页面就可以直接使用缓存资源，页面直接直逼火箭速度打开，既提高了用户的体验也节省了宽带资源。 当然浏览器缓存方法有很多种，这里只简单讨论下 webpack 利用 hash 方式修改文件名，以达到缓存目的。 webpack hashwebpack 内置了多种可使用 hash，官网解释分别如下： hash：the hash of the module identifier chunkHash：the hash of the chunk content contentHash：the hash of extracted content 注：hash 的默认长度为 20 个字符，可通过 output.hashDigestLength 全局配置，或使用 [hash:16] 方式配置，还可以通过 output.hashDigest 配置何时生成 hash。 那么问题来了，这么多种 hash 该如何选择呢？ 实战 hash基础的配置文件如下（基于webpack 4，入口文件分别为 index 和 detail，其中每个文件中引入了一个图片）： 1234567891011module.exports = &#123; mode: 'none', // 设置为 none，避免 development 或 production 默认设置的一些影响 entry: &#123; index: './src/index.js', detail: './src/detail.js', &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'dist') &#125;&#125; hash（the hash of the module identifier）首先，我们来解释下 the module identifier。webpack 默认为给各个模块分配一个 id 以作标识，用来处理模块之间的依赖关系。而默认的 id 命名规则是根据模块引入的顺序，赋予一个整数(1、2、3……)。如下图就是使用 hash 的打包，index 和 detail 作为 entry 的两个入口，可以看到其 hash 值是一样的，而另外两个图片的 hash 值是不同的。 由于该 hash 是基于整个 module identifier 序列计算得到的，所以 JS 或 CSS 文件如果使用该 hash，则所有值都一样，而任意增添或删减一个模块的依赖，都会对整个 id 序列造成影响，从而改变 hash 值。这样的话 JS 或 CSS 文件是不适合使用该 hash 值的。 当然对于图片、字体、PDF 等资源该 hash 还是可以生成一个唯一值的。 runtime &amp; manifest假如我们什么都不改动，只是重新跑一次构建，会惊奇的发现 index 和 detail 的 hash 值居然变了（图片的 hash 是不变的），如下图： 这究竟是怎么回事呢？webpack 官方解释为： This is because webpack includes certain boilerplate, specifically the runtime and manifest, in the entry chunk. 为了解决这个不稳定的因素，webpack 4 提供了一个配置可以直接把 boilerplate 给单独抽离出来，配置如下： 123 optimization: &#123; runtimeChunk: 'single'&#125; 这样我们就能得到一个 runtime 的 js 文件，如下图： chunkhash（the hash of the chunk content）现在我们把 hash 改成 chunkhash ，如下： 1234output: &#123; filename: '[name].[chunkhash].js', path: path.resolve(__dirname, 'dist')&#125; 重新跑下构建，会发现打包出来的三个 JS 文件的 chunkhash 值是不一样的了，如下： 现在我们在 index 文件中再引入一个 JS 模块，重新打包如下： 我们会发现 index 和 detail 文件的 chunkhash 都变了，这就奇怪了，按理来说 detail 文件我们根本没有改变啊，为什么它的 chunkhash 值变了呢？ 其实根本原因还是 module identifier，因为 index 新引入的模块改变了以后所有模块的 id 值，所以 detail 文件中引入的模块 id 值发生了改变，于是 detail 的 chunkhash 也随着发生改变。 解决方案是将默认的数字 id 命名规则换成路径的方式。webpack 4 中当 mode 为 development 会默认启动 123optimization: &#123; namedModules: true&#125; 当然如果是生产环境的话，全路径是有点太长，所以我们可以换成使用HashedModuleIdsPlugin 插件来根据路径生成的 hash 作为 module identifier。 123plugins: [ new webpack.HashedModuleIdsPlugin(),], 这样最后 chunkhash 改变的就只有修改的文件了，也达到了我们想要的效果。 contenthash（the hash of extracted content）现在我们将 CSS 样式单独抽离生成文件（使用了 MiniCssExtractPlugin 插件），会发现其 chunkhash 值跟该 entry 的 js 文件的 chunkhash 是一样的，如下图： 现在如果只改变 CSS 文件，会发现对应的 entry JS 和 CSS 文件的 chunkhash 都会改变。（注意：可能以前 ExtractTextWebpackPlugin 不会改变，所以只能对抽离的 CSS 文件使用 contenthash）。 反正不管同时变或不变，可能都不是我们想要的效果，我们需要应该是改变了什么就反应到什么文件上。而不是 CSS 和 JS 文件的 chunkhash 同时改变或不变，无法区分 CSS 和 JS 的更新。 所以这里抽离出来的 CSS 文件将使用 contenthash，以区分 CSS 文件和 JS 文件的更新。 Chunks ID然而这还没有结束，还有个问题，那就是目前我们的 chunks ID 还是以自增的数字命名的，这当我们的 entry 文件发生改变（新增或删除）的时候，原先的 chunks ID 就有可能发生变化。于是我们也需要把数字改掉就好，webpack 4 在 optimization 新增了一个 namedChunks 配置，该配置开发环境为 true，生产环境为 false，所以在生产环境的时候我们为了构建稳定的 hash 时，还是需要把该选项设置为 true，如下： 123456module.exports = &#123; //... optimization: &#123; namedChunks: true &#125;&#125;; 总结为了一份理想的缓存文件，我们需要做这些事情： 抽离 boilerplate（[runtime &amp; manifest） 将 module identifier 默认的数字标识方式转成使用路径标识 JS 文件使用 chunkhash 抽离的 CSS 样式文件使用 contenthash gif|png|jpe?g|eot|woff|ttf|svg|pdf 等使用 hash 设置 namedChunks 为 true 原文地址Webpack4 如何优雅打包缓存文件]]></content>
      <categories>
        <category>前端</category>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sequelize框架进阶]]></title>
    <url>%2Fposts%2F3278%2F</url>
    <content type="text"><![CDATA[传送门 Sequelize框架入门 前言上一篇入门讲到了 Sequelize框架 的基本用法，比如实现简单的增删查改。原本打算一篇文章写到底的，但感觉内容太多，对读者不太友好，就另开了这篇文章。 虽然标题写着“进阶”，但其实有标题党的以为。这篇文章仍然着手于框架的使用，不涉及源码。大纲见侧边栏的目录，我们直接开始吧~ 连表查询准备工作既然是连表查询，至少得有两个表吧。所以我们还需要另外新建一张表，这里起名为 message 表，表结构如下： 其中 uid 对应用户的 id 。下面是两表的数据： 接着我们新建一个 app2.js 文件，引入之前 app.js 中的部分代码（连接数据库+UserModel）以及创建一个 MessageModel 模型：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const Sequelize = require('sequelize');const sequelize = new Sequelize("miaov", "root", "root", &#123; host: "127.0.0.1", port: 8889, dialect: "mysql"&#125;);try &#123; sequelize.authenticate(); console.log('数据库连接成功!');&#125; catch (err) &#123; console.log('连接失败');&#125;const UserModel = sequelize.define('User', &#123; id: &#123; type: Sequelize.INTEGER(11), allowNull: false, autoIncrement: true, primaryKey: true, &#125;, username: &#123; type: Sequelize.STRING(50), allowNull: false, defaultValue: '', &#125;, age: &#123; type: Sequelize.TINYINT(3), allowNull: false, &#125;, gender: &#123; type: Sequelize.ENUM(['men', 'women', 'other']), allowNull: false, defaultValue: 'men', &#125;,&#125;, &#123; timestamps: false, tableName: 'users',&#125;);const MessageModel = sequelize.define('Message', &#123; id: &#123; type: Sequelize.INTEGER(11), primaryKey: true, allowNull: false, autoIncrement: true, &#125;, uid: &#123; type: Sequelize.INTEGER(11), allowNull: false, defaultValue: 0, &#125;, content: &#123; type: Sequelize.STRING(255), allowNull: false, defaultValue: '', &#125;&#125;, &#123; timestamps: false, freezeTableName: true, // 默认 false 将自动修改表名为复数，true 表示不修改表名，与数据库表名同步 tableName: 'message'&#125;); 需求+普通做法我们这次的需求是获取某条留言的所有数据，其中包含 留言本身的数据 + 该留言的用户数据 ，先来看最“耿直”的做法： 123456789101112131415161718(async () =&gt; &#123; let data = &#123;&#125;; // 根据 id 查找 message let message = await MessageModel.findByPk(1); // 根据 message 的 uid 反查出发布这条 message 的 user let user = await UserModel.findByPk(message.get('uid')); Object.assign(data, &#123; id: message.id, uid: message.uid, content: message.content, username: user.username, age: user.age, gender: user.gender, &#125;); console.log(data);&#125;)(); BelongsTo除了上面这种做法外，我们还可以使用 sequelize 提供的 BelongsTo 来关联两个模型进行查询。 思考一下我们的 users 和 message 表，从 message 的角度来讲，一条留言属于一个用户发布的，是一对一的关系。而 BelongsTo 关联的含义就是 A 属于 B。那我们应该怎么写代码呢？步骤如下： 首先在模型中给关联的字段定义外键关系 1234references: &#123; model: 关联的外键表模型, e.g. UserModel key: 关联的外键表的字段, e.g. id&#125; 在调用 belongsTo 或 hasMany 等方法的时候，通过第二个参数设置对象 123&#123; foreignKey: 当前关联表的字段, e.g. uid&#125; 没有完全理解上面的步骤也没关系，直接上代码更加清晰：1234567891011121314151617181920212223242526272829const MessageModel = sequelize.define('Message', &#123; ..., uid: &#123; // 第一步：在模型中给关联的字段定义外键关系 ... references: &#123; model: UserModel, // 关联的外键表模型 key: 'id', // 关联的外键表的字段 &#125; &#125;, ...&#125;, ...);(async () =&gt; &#123; // 第二步：声明两表关系及外键 // 下面方法翻译过来：留言属于用户 MessageModel.belongsTo(UserModel, &#123; foreignKey: 'uid' // 声明自己（message）的外键是 uid &#125;); let data = await MessageModel.findByPk(1, &#123; include: [UserModel] // 表述查出的 message 记录中包含有对应的 user &#125;); console.log(` 留言id：$&#123;data.id&#125; 留言人名称：$&#123;data.User.username&#125; 留言内容：$&#123;data.content&#125; `);&#125;)(); HasMany这次我们换个角度，来通过某个用户查找他/她所有的留言。稍微想一下，一个用户是可以发布多条留言的，所以从 users 角度来讲，跟 message 是一对多的关系。而 sequelize 也提供了处理这种关系的方法，那就是 HasMany。直接上代码：123456789101112131415161718(async () =&gt; &#123; // users 拥有 UserModel.hasMany(MessageModel, &#123; foreignKey: 'uid', &#125;); let data = await UserModel.findByPk(3, &#123; include: [MessageModel] &#125;); console.log(` id为 $&#123;data.id&#125; 的留言人 $&#123;data.username&#125; 的留言内容： `); data.Messages.forEach(m =&gt; &#123; console.log(` $&#123;m.content&#125;`); &#125;);&#125;)(); 版本安装的 sequelize 和 mysql2 的版本为：1234"dependencies": &#123; "mysql2": "^1.6.5", "sequelize": "^5.3.1"&#125;]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
        <category>Sequelize</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>SQL</tag>
        <tag>Sequelize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sequelize框架入门]]></title>
    <url>%2Fposts%2F1183%2F</url>
    <content type="text"><![CDATA[前言平常写前端项目时，为了更方便的获取“真实”的动态数据，也会新建几个数据库表来作支撑。但每每需要用Node搭建后端服务时，数据库的查询真的让人头疼，难倒不难，就是特别繁琐，即使封装了个查询sql用工具模块，在遇到稍复杂的查询语句时还是得写完整SQL。 我又是个比较懒的人，在经历了几次痛苦折磨后，我开始google有没有谁帮我们解决了数据库表字段与对象之间的关系映射。也就是我们通常所说的 ORM 。经过几番搜索，我找到了 Sequelize 框架。在了解它之前，我们先简单介绍下什么是 ORM ：（我知道不少人是不会点击上面链接查看详情的 :)） 介绍ORMORM 全称 Object Relational Mapping，翻译成中文就是 对象关系映射 。是对 SQL 查询语句的封装，让我们可以用面向对象的方式操作数据库，来更加优雅的生成安全、可维护的 SQL 代码。说白了，就是通过对象来映射和操作数据库。 Sequelize而今天的主角 Sequelize 则是一个基于 promise 的 Node.js 异步ORM框架。它能够支持多种数据库，包含但不限于 PostgreSQL, MySQL 和 MSSQL 。 官网地址：http://docs.sequelizejs.com/github：https://github.com/sequelize/sequelize 使用起步在本地新建文件夹，例如 sequelize-demo ，然后在项目根目录下运行命令行命名 npm init -y。运行完该命令后项目tree如下： 接着使用 npm 安装 sequelize：1npm i sequelize 连接数据库完成上述步骤以后，我们在根目录下新建一个 app.js 文件来使用 sequelize ，代码如下： 12345678910111213141516171819// 导入 sequelizeconst Sequelize = require('sequelize');// 新建 sequelize 实例const sequelize = new Sequelize('数据库名称', '数据库用户名', '数据库密码', &#123; // 其他的数据库连接配置 host: '127.0.0.1', // 主机，默认 localhost port: 8889, // 端口，默认 3306 dialect: 'mysql', // 数据库类型， 默认 mysql 【必填】 timezone: '+08:00' // 时区，默认会根据系统当前所在时区进行设置，格式：'+08:00' 或字符串格式 'Asia/Shanghai' 参考：http://php.net/manual/zh/timezones.php 【使用场景：一般情况下默认配置就好，但如果服务器在美国，但想存储中国时区，就需要明确指定 '+08:00' 了】&#125;);// 测试数据库的连接（返回的是一个Promise，记得 catch 捕获错误）try &#123; sequelize.authenticate(); console.log('数据库连接成功!');&#125; catch (err) &#123; console.log('连接失败'); &#125; 此时你可以尝试运行 app.js 文件，即在根目录下运行 node app.js 命令。正常情况下你会收到报错信息，类似这样： 意思是你需要安装 mysql2 ，这是因为 sequelize 虽然依赖了 mysql2 ，但却没有内置安装。所以接下来你得在项目根目录下运行如下代码来安装 mysql2：1npm i mysql2 安装完毕后再次运行 app.js ，就能连接数据库成功了：123$ node app.jsExecuting (default): SELECT 1+1 AS result数据库连接成功! 定义模型（Model） 所谓模型，就是用来描述数据库表字段信息的对象，每一个模型对象表示数据库中的一个表，后续对数据库的操作都是用过对应的模型对象来完成的。 接下来我们就要定义数据的模型了。在此之前，你还需要做一些准备工作。以我为例，我在数据库中新建了一个 users 表，表字段和类型如下： 然后定义出对应此表的数据模型：123456789101112131415161718192021222324252627// 定义模型（用对象的方式来描述数据库中的表）const UserModel = sequelize.define('User', &#123; // 描述表中对应的字段信息 id: &#123; // 每一个字段的信息 type: Sequelize.INTEGER(11), // 字段类型 allowNull: false, // 不允许为空 autoIncrement: true, // id自增长 primaryKey: true, // 设为主键 &#125;, username: &#123; type: Sequelize.STRING(50), allowNull: false, defaultValue: '', // 设置字段默认值 &#125;, age: &#123; type: Sequelize.TINYINT(3), allowNull: false, &#125;, gender: &#123; type: Sequelize.ENUM(['men', 'women', 'other']), // 这是个枚举类型字段，表示性别只能为“男”，“女”，“保密”中的其中一个，传入 ENUM 中的可以是逗号隔开的字符串，也可以是个数组：ENUM(['men', 'women']) or ENUM('men', 'women', 'other') allowNull: false, defaultValue: 'men', &#125;,&#125;, &#123; // 用来设置字段以外的其他信息 timestamps: false, // 是否给每条记录添加 createAt 和 updateAt 字段，并在添加新数据和更新数据的时候自动设置这两个字段的值，默认为 true tableName: 'users', // 该模型映射的真实表名&#125;); 注意：在定义模型时，字段名称可以和数据库表中的字段名称不相同，但如果你想另起一个别名，则需要在字段信息设置中加入 field 来关联真正的表字段名称。例如：12345userName: &#123; // &lt;-- 你起的别名 type: Sequelize.STRING(50), allowNull: false, field: 'username', // 关联数据库表中真正的字段名&#125;, 数据查询查询所有完成表模型的定义以后，我们就可以通过 findAll 来查询表数据了：1234567891011// 查询 users 表中所有数据UserModel.findAll().then(users =&gt; &#123; // 返回的 users 是个数组 users.forEach(user =&gt; &#123; // 循环的每个 user 都是个 Model 实例 // 该 Model 实例包含 get 方法，我们能通过它获取 username console.log(user.get('username')); &#125;);&#125;).catch(err =&gt; &#123; console.log(err);&#125;); 写完上面代码后，再次运行 app.js ，你就应该能够查询到数据了~p.s. 查询之前别忘了在数据库中插入一些数据。 条件查询除了查询全部数据，我们还可以使用 where 查询指定的数据：12345678910// 这次不用 .then 形式，而采用 async + await(async function() &#123; // 查找 username 为 '李元芳' 的唯一数据 let res = await UserModel.findOne(&#123; where: &#123; username: '李元芳' &#125; &#125;) console.dir(res);&#125;)(); 而类似大于小于这样的查询会稍显麻烦一点。例如我们来编写查询 users 表中年龄大于某个值的代码：123456789101112(async function () &#123; // 查找满足 age &gt; 24 的所有数据 let res = await UserModel.findAll(&#123; where: &#123; age: &#123; [Sequelize.Op.gt]: 24, &#125; &#125; &#125;) // 打印出符合条件的用户的 username console.dir(res.map(r =&gt; r.get('username')));&#125;)(); 多条件查询除了单一条件查询，我们还可以通过嵌套 or 或 and 运算符的集合来生成复杂条件语句。例如我们来查询 年龄小于25 或者 性别为男 的所有数据：1234567891011121314151617181920(async function () &#123; let &#123; Op &#125; = Sequelize; // 查找满足 age &lt; 25 或 gender = 'men' 的所有数据 let res = await UserModel.findAll(&#123; where: &#123; [Op.or]: [ &#123; age: &#123; [Sequelize.Op.lt]: 25, &#125; &#125;, &#123; gender: 'men' &#125; ] &#125; &#125;) // 打印出符合条件的用户的 username console.dir(res.map(r =&gt; r.get('username')));&#125;)(); 从上面几组查询语句我们可以看出，where 通常用 attribute: value 键值对获取一个对象，其中 value 可以是匹配等式的数据或其他运算符的键值对象。更多查询语法可在下方链接查询： Sequelize - Querying Sequelize - Querying（中文文档） 查询限制 limit, offset我们还能限制查询的数量：1234567(async () =&gt; &#123; // 只从表中查询两条数据 let res = await UserModel.findAll(&#123; limit: 2, &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;)(); 跳过前2条数据：123456(async () =&gt; &#123; let res = await UserModel.findAll(&#123; offset: 2, &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;)(); 跳过前2条数据并获取3条：1234567(async () =&gt; &#123; let res = await UserModel.findAll(&#123; offset: 2, limit: 3 &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;)(); 查询排序我们还可以将查询数据进行排序：123456789(async () =&gt; &#123; // 查询的结果按年龄高到低排序 let res = await UserModel.findAll(&#123; order: [ ['age', 'desc'] ] &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;)(); 查询记录有些时候我们可能只是想单纯的查询数据表中有多少条数据，这时可以用 count() 方法：js(async () =&gt; { // 查询 users 表中有多少条数据 let count = await UserModel.count(); console.log(count);})();12345678910或者使用 `findAndCountAll()` 方法在数据库中搜索多条记录，它能返回给我们**数据和总计数**：```js(async () =&gt; &#123; // 查询 users 表中的前两条数据，并返回 users 表中总记录数 let res = await UserModel.findAndCountAll(&#123; limit: 2, &#125;); console.log(res);&#125;)(); 查询结果的格式如下：123456&#123; count: 总记录数, rows: [ &#123;第一条记录&#125;, &#123;第二条记录&#125;, ... ]&#125; 这个方法对我们为前端提供分页功能很方便，count是符合条件的总记录数，而rows中可以是当前页数下的记录数。 数据增加既然能查，当然就能往数据库插入数据，在 sequelize 中，插入数据可以用 build 方法：123456789101112131415// 新建一条数据（除了build外，还可以通过 new UserModel(&#123;&#125;) 的形式创建一条记录）let wangwu = UserModel.build(&#123; username: '王五', age: 22, gender: 'men'&#125;);// **注意：** 通过 new 或 build 出来的对象不会立即同步到数据库中，// 需要使用后续的一些方法（例如 save ）来同步// 你还可以修改这条数据wangwu.set('age', 25);// 最后别忘了保存才能成功插入数据wangwu.save(); 如果运行后没报错，去数据库刷新表吧，数据已经成功的插入到 users 表了~ 数据修改实际开发中修改数据是再平常不过的了，比如修改一篇博客，更新自己的个人信息… 在 sequelize 中，我们这样修改数据：1234567// 查询id为2的用户数据UserModel.findByPk(2).then(user =&gt; &#123; // 查询到以后修改其 age 字段为 99 user.set('age', 99); // 修改后别忘了保存 user.save();&#125;); 注意： 在 Sequelize v5 版本以前，通过id查询数据的方法名为 findById ，从 v5 版本开始，更改为 findByPk 。其实想一下这样非常合理，以前的 findById 太主观了，要知道不一定每个表的主键都为 id ，所以更改为 findByPk 后，表示通过主键（Pk -&gt; PrimaryKey）查找，sequelize 会自动通过你在创建表模型时定义的主键字段查找。例如我们一开始在定义 User 模型时，就给 id 字段添加了 primaryKey: true, 属性。 除了 set + update 来更新数据以外，还可以使用 update() 方法做相同的事情：12345678(async function () &#123; // 先查询 let xiaohong = await UserModel.findByPk(3); // update方法相当于 set + save await xiaohong.update(&#123; age: 22, &#125;);&#125;)(); 数据删除如果想要删除一条数据，可以使用 destroy 方法：123456(async function () &#123; // 先查询 let wangwu = await UserModel.findByPk(4); // 对查询到的数据进行删除 wangwu.destroy();&#125;)(); 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194const Sequelize = require('sequelize');const sequelize = new Sequelize("miaov", "root", "root", &#123; // 其他的数据库连接配置 host: "127.0.0.1", // 主机 port: 8889, // 端口 dialect: "mysql" // 数据库类型&#125;);// 测试连接try &#123; sequelize.authenticate(); console.log('数据库连接成功!');&#125; catch (err) &#123; console.log('连接失败'); &#125;// 定义模型（用对象的方式来描述数据库中的表）const UserModel = sequelize.define('User', &#123; // 定义字段 id: &#123; // 对字段属性的定义 type: Sequelize.INTEGER(11), // 字段类型 allowNull: false, // 不允许为空 autoIncrement: true, // id自增长 primaryKey: true, // 设为主键 &#125;, username: &#123; type: Sequelize.STRING(50), allowNull: false, defaultValue: '', // 设置字段默认值 &#125;, age: &#123; type: Sequelize.TINYINT(3), allowNull: false, &#125;, gender: &#123; type: Sequelize.ENUM(['men', 'women', 'other']), allowNull: false, defaultValue: 'men', &#125;,&#125;, &#123; // 用来设置字段以外的其他信息 timestamps: false, // 是否给每条记录添加 createAt 和 updateAt 字段，并在添加新数据和更新数据的时候自动设置这两个字段的值，默认为 true tableName: 'users', // 该模型映射的真实表名&#125;);// 为了方便学习，使用一个函数包裹一组代码// 这样代码就不会运行了，从而避免干扰其他代码的执行// 如果想要此函数中代码执行，添加 `()` 就好// (function()&#123;...&#125;)(); &lt;-- 加上括号(function() &#123; // 查询 users 表中所有数据 UserModel.findAll().then(users =&gt; &#123; // 返回的 users 是个数组 users.forEach(user =&gt; &#123; // 循环的每个 user 都是个 Model 实例 // 该 Model 实例包含 get 方法，我们能通过它获取 username console.log(user.get('username')); &#125;); &#125;).catch(err =&gt; &#123; console.log(err); &#125;);&#125;);(async function() &#123; // 新建一条数据（除了build外，还可以通过 new UserModel() 的形式创建一条记录） let liyuanfang = UserModel.build(&#123; username: '李元芳', age: 09, gender: 'men' &#125;); // 修改数据 liyuanfang.set('age', 25); // 别忘了保存 await liyuanfang.save();&#125;);(function() &#123; // 查询id为2的用户数据 UserModel.findByPk(2).then(user =&gt; &#123; // 查询到以后修改其 age 字段为 99 user.set('age', 99); // 修改后别忘了保存 user.save(); &#125;);&#125;);(async function() &#123; // 先查询 let xiaohong = await UserModel.findByPk(3); // update方法相当于 set + save await xiaohong.update(&#123; age: 18 &#125;);&#125;);(async function () &#123; // 先查询 let wangwu = await UserModel.findByPk(4); // 对查询到的数据进行删除 wangwu.destroy();&#125;);(async function() &#123; // 查找 username 为 '李元芳' 的唯一数据 let res = await UserModel.findOne(&#123; where: &#123; username: '李元芳' &#125; &#125;) console.dir(res);&#125;);(async function () &#123; // 查找满足 age &gt; 24 的所有数据 let res = await UserModel.findAll(&#123; where: &#123; age: &#123; [Sequelize.Op.gt]: 24, &#125; &#125; &#125;) // 打印出符合条件的用户的 username console.dir(res.map(r =&gt; r.get('username')));&#125;);(async function () &#123; let &#123; Op &#125; = Sequelize; // 查找满足 age &lt; 25 或 gender = 'men' 的所有数据 let res = await UserModel.findAll(&#123; where: &#123; [Op.or]: [ &#123; age: &#123; [Sequelize.Op.lt]: 25, &#125; &#125;, &#123; gender: 'men' &#125; ] &#125; &#125;) // 打印出符合条件的用户的 username console.dir(res.map(r =&gt; r.get('username')));&#125;);(async () =&gt; &#123; // 只从表中查询两条数据 let res = await UserModel.findAll(&#123; limit: 2, &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;);(async () =&gt; &#123; // 跳过前2条数据 let res = await UserModel.findAll(&#123; offset: 2, &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;);(async () =&gt; &#123; // 跳过前2条数据并获取3条 let res = await UserModel.findAll(&#123; offset: 2, limit: 3 &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;);(async () =&gt; &#123; // 查询的结果按年龄高到低排序 let res = await UserModel.findAll(&#123; order: [ ['age', 'desc'] ] &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;);(async () =&gt; &#123; // 查询的结果按年龄高到低排序 let count = await UserModel.count(); console.log(count);&#125;);(async () =&gt; &#123; // 查询 users 表中的前两条数据，并返回 users 表中总记录数 let res = await UserModel.findAndCountAll(&#123; limit: 2, &#125;); console.log(res);&#125;)(); 版本安装的 sequelize 和 mysql2 的版本为：1234"dependencies": &#123; "mysql2": "^1.6.5", "sequelize": "^5.3.1"&#125; 资源 Sequelize Docs Sequelize Docs 中文版]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
        <category>Sequelize</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[animation动画（二）]]></title>
    <url>%2Fposts%2F20298%2F</url>
    <content type="text"><![CDATA[传送门 animation动画（一） animation动画（二） 老规矩，二系列来谈谈具体每个动画属性的含义和用法，算是一个对知识点的总结吧。 animation-name 动画名称CSS语法：animation-name: shrink 用来设置元素的动画名称。 animation-duration 持续时间CSS语法：animation-duration: 1s 用来指定动画在一个周期内所花费的时间。 animation-timing-function 运动曲线CSS语法：animation-timing-function: ease-in-out 用来设置元素的动画速度曲线，它的用法和 transition-timing-function 类似，想要了解详情的直接点这个链接吧。 DEMO See the Pen animation-timing-function by JingW (@JingW) on CodePen. animation-delay 动画延迟CSS语法：animation-delay: 1s 用来设置动画延迟多少秒/毫秒后才开始执行。正值（例如2s）将在2s后启动动画；负值（例如-2s）将立即执行动画，但是动画会从它的动画序列中的第2s位置处立即开始。 animation-iteration-count 循环次数CSS语法：animation-iteration-count: 1s 用来设置动画循环的次数，默认值是1，表示动画只播放一次。除了使用正整数来设置次数外，还可以将值设置为 infinite ，表示无限循环。 animation-direction 是否反向CSS语法：animation-direction: normal | reverse | alternate | alternate-reverse 用来设置动画在循环过程中是否反向运动，默认值为 normal ，即正常模式，动画会从第一帧播放到最后一帧；reverse 表示反向模式，动画会从最后一帧倒着播放到第一帧；alternate 设置动画先正向播放，第二次再从反向播放，交替进行，例如 animation 系列一中的案例；alternate-reverse 则是先让动画反向播放，第二次再正向播放，交替进行。 animation-fill-mode 动画填充模式CSS语法：animation-fill-mode: none | forwards | backwards | both 用来指定在动画执行之前和之后如何给动画的目标应用样式。这个属性在我第一次接触时没太理解，直到我看了 segmentfault 上的 这篇文章 。 在理解它之前，我们需要在脑海里有个概念，那就是一个动画是分为初始状态、等待期、动画执行期、完成期四个阶段的。而上面 animation-fill-mode 接收的四个值则分别对应： none 表示 等待期和完成期，元素样式都为初始状态样式，不受动画定义（@keyframes）的影响 forwards 表示等待期保持初始样式，完成期间保持最后一帧样式 backwards 表示等待期为第一帧样式，完成期跳转为初始样式 both 表示 等待期样式为第一帧样式，完成期保持最后一帧样式 单纯的文字不直观？相信下面的这个demo能让你豁然开朗： See the Pen animation-fill-mode by JingW (@JingW) on CodePen. animation-play-state 动画播放状态CSS语法：animation-play-state: running | paused 用来设置动画的播放或者暂停。比如希望在鼠标经过的时候，让动画先停止下来，鼠标移开之后再继续播放，就可以通过设置 .element:hover { animation-play-state: paused; } 来实现。下面是一个案例，在鼠标移入时钟后指针暂停旋转；移出后时钟继续旋转。 See the Pen animation-play-state闹钟示例 by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[animation动画（一）]]></title>
    <url>%2Fposts%2F31280%2F</url>
    <content type="text"><![CDATA[传送门 animation动画（一） animation动画（二） 介绍 CSS Animations 是CSS的一个模块，它定义了如何用关键帧来随时间推移对CSS属性的值进行动画处理。关键帧动画的行为可以通过指定它们的持续时间，它们的重复次数以及它们如何重复来控制。 ———— 出自 CSS Animations | MDN 语法1234/* 简写 */animation: 动画名称，一个周期所花费的时间，运动曲线（默认ease）， 动画延迟（默认0），播放次数（默认1）， 是否反向播放动画（默认normal），是否暂停动画（默认running） 就像在介绍中写到的那样，整个 animations 是个模块，包含很多属性来定义动画，比方说 animation-name 、animation-duration 和 animation-delay 等等。但本着快速上手的目的，第一篇文章主要围绕 animation 这个简写属性来讲，因为用它最直观，而且就经验来讲，日常使用最多的也是这个属性。 如何使用一个CSS3动画由两个基本项组成： 关键帧（Keyforames） - 用来定义动画的阶段和样式。 动画属性 - 分配关键帧（@keyframes）到一个特定的css元素，来定义它的动画方式。 我们围绕这两项讨论，并在这个过程中实现一个按钮不断放大缩小的动画效果： keyframes关键帧 keyframes 定义了动画在每个阶段的动画效果。它包括： 动画名称：定义动画的名称 动画阶段：整个动画阶段用百分比来表示。0% 表示动画的开始状态。100% 表示动画的结束状态。可以在其间添加多个中间状态，比如 20%，60%… 动画属性：给动画每个阶段定义的CSS属性 现在我们来编写一段 @keyframes 。动画名称命名为 shrink 。它只有简单的两个阶段： 第一阶段（0%）：元素的缩放比例为 1:1 第二阶段（100%）：元素的缩放比例为 1:0.8 12345678910@keyframes shrink &#123; 0% &#123; -webkit-transform: scale(1); transform: scale(1); &#125; 100% &#123; -webkit-transform: scale(0.8); transform: scale(0.8); &#125;&#125; 动画属性接着，我们给要设置动画的元素添加上动画属性。要使动画生效，我们至少要添加以下两个动画属性： animation-name: 动画的名称，在 @keyframes 中定义。 animation-duration: 动画的持续时间，以秒为单位（例如 5s）或毫秒（例如 200ms）。 12345678button &#123; /* 其他样式 */ ... /* 动画名称: shrink */ animation-name: shrink; /* 动画持续时间: 0.5秒 */ animation-duration: .5s;&#125; 这样我们就实现页面加载后，一个按钮从开始的原始大小，经过0.5s后变成了原始大小的0.8的动画效果。然而我们希望最终的效果是一个按钮的不断放大和缩小，交替进行。这就得添加 animation-iteration-count 和 animation-direction 两个动画属性了，它们一个用来定义元素动画的循环次数，一个用来定义动画在循环过程中是否反向运动： 1234567button &#123; ... /* 动画的循环次数: 无限次 */ animation-iteration-count: infinite; /* 循环是否反向：先正向后反向 */ animation-direction: alternate;&#125; 最终的简写形式如下： 1234button &#123; ... animation: shrink .5s linear alternate infinite;&#125; 完整效果： See the Pen animation-shrink by JingW (@JingW) on CodePen. 资源 📚 animation | 一个CSS3动画库 【推荐】 点我查看效果 magic | 另一个CSS3动画库 点我查看效果]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用JS实现翻转二叉树]]></title>
    <url>%2Fposts%2F50491%2F</url>
    <content type="text"><![CDATA[简介翻转二叉树就是把二叉树每一层的左右顺序颠倒过来。 示例 输入 12345 4 / \ 2 7 / \ / \1 3 6 9 输出 12345 4 / \ 7 2 / \ / \9 6 3 1 算法步骤如果根节点不为空，那么将左右子结点交换，然后将左右子结点进行递归调用。 代码实现1234567891011var invertTree = function(root) &#123; if (root !== null) &#123; var temp = root.left; root.left = root.right; root.right = temp; invertTree(root.left); invertTree(root.right); &#125; return root; &#125;;]]></content>
      <categories>
        <category>后端</category>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[有序表查找之二分查找]]></title>
    <url>%2Fposts%2F39853%2F</url>
    <content type="text"><![CDATA[简介二分查找又名折半查找。它的前提是所操作的数据集是一个有序的数据集。它的基本思想是：开始时，先找出有序集合中间的那个元素。如果此元素比要查找的元素大，就接着在较小的一个半区进行查找；反之，如果此元素比要找的元素小，就在较大的一个半区进行查找。在每个更小的数据集中重复这个查找过程，直到找到要查找的元素或者数据集不能再分割。 图解 适用场景二分查找可以应用于任何类型的数据，但前提是这些数据是按某种规则进行排序的。这使得它在处理那些频繁插入和删除操作的数据集时不太高效。因为执行完插入和删除操作后，无法保证数据集的有序性，在查找前还得先维护一个有序数据集，从而导致查找过程代价太高。此外，元素必须存储在连续的空间中。 因此，当待搜索的集合是相对静态的数据集时，此时使用二分查找是最好的选择。 代码示例（JS） 非递归实现 123456789101112131415161718192021var arr = [4, 9, 12, 13, 15, 33, 46, 49, 50, 77, 101];function binary_search(arr, target) &#123; var min = 0, max = arr.length; while (min &lt;= max) &#123; var mid = parseInt((min + max) / 2); if (target === arr[mid]) &#123; return mid; &#125; else if (target &gt; arr[mid]) &#123; min = mid + 1; &#125; else &#123; max = mid - 1; &#125; &#125; return -1;&#125;console.log(binary_search(arr, 33)); 递归实现 123456789101112131415161718192021var arr = [4, 9, 12, 13, 15, 33, 46, 49, 50, 77, 101];function binary_search(arr, min, max, target) &#123; if (min &gt; max) &#123; return -1; &#125; var mid = parseInt((min + max) / 2); if (target === arr[mid]) &#123; return mid; &#125; else if (target &gt; arr[mid]) &#123; min = mid + 1; return binary_search(arr, min, max, target); &#125; else &#123; max = mid - 1; return binary_search(arr, min, max, target); &#125;&#125;console.log(binary_search(arr, 0, arr.length - 1, 33));]]></content>
      <categories>
        <category>后端</category>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法]]></title>
    <url>%2Fposts%2F59937%2F</url>
    <content type="text"><![CDATA[冒泡排序冒泡排序是一种交换排序，基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。 算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 动图演示 ———— 动图来自《菜鸟教程》 说明：绿色表示当前正在比较的两个相邻元素；橘黄色表示已排完序的元素，不再参与后续的比较 代码实现（JS）123456789101112131415var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function myBubbleSort(arr) &#123; var len = arr.length, temp; for (var i = 0; i &lt; len - 1; i++) &#123; // 趟数 for (var j = 0; j &lt; len - 1 - i; j++) &#123; // 当前趟要比较的次数 if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两比较 temp = arr[j]; // 元素交换 arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; return arr;&#125; 代码与图片配合食用更加~ 选择排序选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。 算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第2步，直到所有元素均排序完毕。 动图演示 代码实现（JS）123456789101112131415161718var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function mySelectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; // 第 i 轮选择 minIndex = i; // 每轮开始假设起始元素为最小值 for (var j = i + 1; j &lt; len; j++) &#123; // 遍历剩余未排序元素 if (arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数 minIndex = j; // 将最小数的索引保存 &#125; &#125; temp = arr[i]; // 交换起始元素与真正的最小值 arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 配图： 插入排序插入排序的原理应该是最容易理解的，因为只要你打过扑克牌就应该能秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 算法步骤 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 动图演示 代码实现（JS）12345678910111213141516171819202122var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function myInsertSort(arr) &#123; var len = arr.length; var insertItem; // 要插入的元素 // 从数组的第二个元素开始循环将数组中的元素插入 for (var i = 1; i &lt; len; i++) &#123; insertItem = arr[i]; // 设置数组中的第2个元素为第一次遍历要插入的数据 var j = i - 1; // 已排序好数组的最后一个元素的索引 // 将已排好序的元素从最后一个往前依次与待插入元素比较， while (j &gt;= 0 &amp;&amp; insertItem &lt; arr[j]) &#123; // 如果要插入的元素小于第j个元素,就将第j个元素向后移动 arr[j + 1] = arr[j]; j--; &#125; // 直到要插入的元素不小于第j个元素,将insertNote插入到数组中 arr[j + 1] = insertItem; &#125; return arr;&#125; 12345678// 例如for循环中 i 等于 2 时，已排序完毕的元素为[3,44]，进入for循环 // 待插入元素为 arr[2]，也就是38; // j=i-1也就是2-1等于1 // while循环比较，待插入元素38是小于arr[j]（j=1）44 的 =&gt; 条件成立 // arr[j+1]要等于arr[j] =&gt; arr[2]要等于arr[1] =&gt; arr[2]=44 =&gt; 此刻数组前三个元素：[3,44,44] // j-- =&gt; j=1-1也就是0 // 再来一轮while比较，待插入元素38现在不小于arr[j] 也就是arr[0]的3，所以直接退出while循环 // arr[j+1]=insertItem =&gt; arr[1]=38 =&gt; 数组前三排序完毕：[3,38,44] 希尔排序希尔排序也是一种插入排序，它是简单插入排序的一个改进版，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。本文会以图解的方式详细介绍希尔排序的基本思想及其代码实现。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 算法步骤(示例)在此我们选择增量 gap=数组长度length/2，缩小增量继续以 gap = gap/2 的方式，这种增量选择我们可以用一个序列来表示：{n/2,(n/2)/2...1}，称为增量序列。当然，希尔排序的增量序列有很多种，这里采用的是比较常用的一种作为示例： 在上面这幅图中： 初始时，有一个大小为 10 的无序序列。 在第一趟排序中，我们设 gap1 = 10 / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。接下来，按照直接插入排序的方法对每个组进行排序。 在第二趟排序中，我们把上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。按照直接插入排序的方法对每个组进行排序。 在第三趟排序中，再次把 gap 缩小一半，即gap3 = gap2 / 2 = 1。 这样相隔距离为 1 的元素组成一组，即只有一组。按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。 注意：图中有两个相等数值的元素 5 和 5 。我们可以清楚的看到，在排序过程中，两个元素位置交换了。所以，希尔排序是不稳定的算法。 代码演示（JS）123456789101112131415161718192021222324var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function myShellSort(arr) &#123; var gap = Math.floor(arr.length / 2); while (1 &lt;= gap) &#123; // 把距离为 gap 的元素编为一个组，扫描所有组 for (var i = gap; i &lt; arr.length; i++) &#123; var j = 0; var temp = arr[i]; // 对距离为 gap 的元素组进行排序 for (j = i - gap; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j = j - gap) &#123; arr[j + gap] = arr[j]; &#125; arr[j + gap] = temp; &#125; console.log(`gap = $&#123;gap&#125;`); console.log(arr); gap = Math.floor(gap / 2); // 减小增量 &#125; return arr;&#125; 归并排序归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略（分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 可以看到这种结构很像一棵完全二叉树，下面的归并排序代码将会采用递归去实现（你也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为logn。 算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤 3 直到某一指针达到序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 图片演示图片来自博客《图解排序算法之归并排序》 代码实现123456789101112131415161718192021222324252627282930313233var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function mergeSort(arr) &#123; // 采用自上而下的递归方法 var len = arr.length; if (len &lt; 2) return arr; var middle = Math.floor(len / 2), // 将未排序数组拆分成两半分而治之 left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right) &#123; var result = []; while (left.length &amp;&amp; right.length) &#123; // 两边的起始元素相互比较，始终将小的一方的头元素弹出，并push到准备好的容器result中 if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result;&#125; 快速排序快速排序的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的元素均比另一部分记录的元素小，继而再分别对这两部分记录递归的进行同样的排序操作。 算法步骤 把数组中第一个元素当做一个基准值，称为“基准”（Pivot） 重新排序数列，把所有比基准值小的元素摆放在基准前面，所有比基准值大元素摆放在基准后面。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序； 分区（Partition）思路首先把未排序数组的第一个（最左边）元素设置为基准，把它的位置叫做 l ： 然后依次向后查看所有元素，在查看过程中，不断的调整后面元素的位置，使得后面的元素分为两部分，一部分都小于 v ；一部分都大于 v 。 我们用 j 来不断记录这两部分的分割线位置。而 e 就是我们要判断的下一个元素，用索引 i 来表示，i 会遍历每一个元素，来看该如何调整这个元素。 在下图中，我们用 arr[l+1 ... j] 来表示小于 v 的橙色部分，用 arr[j+1 ... i-1] 来表示大于 v 的紫色部分。 接下来就要看如何来调整下一个元素 e 的位置。分情况讨论： 当 e 大于 v 时，我们直接让 e 融入大于 v 的部分，并让 i++ 当 e 小于 v 时，我们让 e 和大于 v 部分的第一个元素交换位置。把 e 融入到小于 v 的部分。此时就需要让分隔线的索引位置 j++ ，相应的，索引 i 的位置也要 i++ 以便查看下一个元素。 以这样的步骤我们就能遍历完整个数组，如下图所示 现在还差最后一个步骤，那就是把基准值 v ，与小于 v 部分的最后一个元素交换位置。此刻 v 左边都小于它，v 右边都大于它，而 j 指向的就是基准值所在的位置。这样我们就完成了分区（Partition）操作。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function quickSort(arr, left, right) &#123; var len = arr.length, partitionIndex, // 分区索引 left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left &gt;= right) return; // 通过分区找到分隔点，再分别快排左右两部分 partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); return arr;&#125;function partition(arr, left, right) &#123; // 分区操作 var v = left, // 设定基准值（pivot） j = left; // arr[l+1...j] ; arr[j+1...i] for (var i = j + 1; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[v]) &#123; // 当前要判断元素 小于 基准元素时 j++; // 分隔点右移 swap(arr, i, j); // 让 当前元素 与大于 v 部分的第一个元素交换位置 &#125; // 此处不用写 else ，因为当大于基准元素时，直接i++就好， // 而i++，for循环已经帮我们做了 &#125; // 循环完毕后，交换基准值和小于v部分的最后一个元素的位置 swap(arr, v, j); return j;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;console.log(quickSort(arr, 0, arr.length)); 计数排序计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 算法步骤 找出待排序的数组中最大和最小的元素； 统计数组中每个值为 i 的元素出现的次数，存入数组 Count 的第 i 项； 对所有的计数累加（从 Count 中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素 i 放在新数组的第 Count(i) 项，每放一个元素就将 Count(i) 减去1。 代码实现123456789101112131415161718192021222324252627282930var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function countingSort(arr) &#123; var len = arr.length, Result = [], Count = [], min = max = arr[0]; // 查找最大最小值,并将arr数置入Count数组中,统计出现次数 for (var i = 0; i &lt; len; i++) &#123; min = min &lt;= arr[i] ? min : arr[i]; max = max &gt;= arr[i] ? max : arr[i]; Count[arr[i]] = Count[arr[i]] ? Count[arr[i]] + 1 : 1; &#125; // 从最小值-&gt;最大值,将计数逐项相加 for (var j = min; j &lt; max; j++) &#123; Count[j + 1] = (Count[j + 1] || 0) + (Count[j] || 0); &#125; // Count中,下标为arr数值,数据为arr数值出现次数;反向填充数据进入Result数据 for (var k = len - 1; k &gt;= 0; k--) &#123; // Result[位置] = arr数据 Result[Count[arr[k]] - 1] = arr[k]; // 减少Count数组中保存的计数 Count[arr[k]]--; &#125; return Result;&#125;console.log(countingSort(arr));]]></content>
      <categories>
        <category>后端</category>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue的生命周期函数]]></title>
    <url>%2Fposts%2F33186%2F</url>
    <content type="text"><![CDATA[创建期间的生命周期函数beforeCreate实例刚在内存中被创建出来，此时还没有初始化好 data 和 methods 属性。 作用执行 loading 动画。 created实例已经在内存中创建完毕，data 和 methods 等属性也已经创建完成。但此刻还没有开始编译模板。 作用 结束掉 loading 动画 做一些初始化工作，比如函数自执行，发起异步请求获取数据 beforeMount此刻已经完成了模板的编译，但还没有挂载到页面上。换句话说，此时页面中类似 的语法还没有被替换成真正的数据。 mounted此刻已经将编译好的模板挂载到了页面中指定的容器中显示。用户已经可以看到渲染好的页面了。 作用 由于此刻已经把模板挂载到了页面，所以能够在此钩子函数中获取 DOM 节点。 此函数中也能发起异步请求 运行期间的生命周期函数beforeUpdate状态更新之前执行此函数，此刻 data 中的状态值是最新的，但是界面上显示的数据还是旧的。因此此时还没有开始重新渲染 DOM 节点。 updated实例更新完毕后调用此函数，此刻 data 中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了。 销毁期间的生命周期函数beforeDestroy实例销毁之前调用。此刻实例仍然完全可用。 作用一切你想要在组件销毁之前做事，例如弹出确认窗：“你确认删除XXX吗？” destroyed实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transition过渡（二）]]></title>
    <url>%2Fposts%2F13167%2F</url>
    <content type="text"><![CDATA[传送门 transition过渡（一） transition过渡（二） 上篇文章是对 transition过渡 的一个简单介绍和使用。这篇文章就来聊聊具体属性的含义和用法。 transition-property 过渡属性从上一篇文章能够知道 transition-property 是拿来设置元素中参与过渡的属性的。它的可选值为： none 指所有属性都不参与过渡 all 指所有属性都参与过渡 [IDENT] 指定个别属性参与过渡 下面来看一个案例： 👇温馨提示：为了方便看效果，可点击 CSS 按钮折叠代码部分，仅显示页面 👇 See the Pen transition-property-demo1 by JingW (@JingW) on CodePen. 当你依次将鼠标移入上方演示demo中的三个按钮就会发现，都在各自下方显示出了一段文本。我们想要实现的，就是这段文本的显示需要有一个过渡效果，不要太生硬。最简单的一种实现方案就是鼠标移入按钮前，文本容器的 height: 0 ，鼠标移入后固定容器高度 height: 150px （第一个按钮效果就用的此方案）。但在实际情况中，往往文本是自适应的，高度无法确定，所以很自然的，我们会想到将 height: 150px 设置为 height: auto ，这样不就能够实现自适应高度的容器过渡了嘛，这就是第二个按钮的一套实现方案。但结果大家都知道了，文本容器不再拥有过渡的动画，而是直接从 0px 瞬间变化到 auto，这是为什么呢？ 答案：并不是所有的属性和属性值都能存在过渡动画。 这里特别需要注意的是，如果想要指定某个属性有过渡状态，就需要保证我们能够计算出过渡过程中每个时间点的属性值。比如，从 height: 0; 过渡到 height: 150px; ，过渡时间是 t ，那我们可以算出在 x 时刻的属性状态是 height: (150px-0)*x/t; 。（注：这里公式成立的前提是假设 transition-timing-function: linear; ，如果transition-timing-function 为其他值，一样可以计算，只不过算法不同）然而刚才第二种方案设置了 height: auto;，则在 x 时刻的属性状态为 height: (auto-0px)*x/t; ，显然，这种状态是不存在的、无法被计算的，因此在设置高度变成 auto 之后，也自然不会再有过渡动画了。 解决方案 第三个按钮的效果就是我们的一种解决方案，在默认状态下，我们不设置文本容器的 height: 0 ，而是用 transform: scale(1, 0); 来代替它，意思是在初始状态下，我们的文本容器比例为宽1:1，高1:0，换句话说，宽为我们设置的宽，但高度为0。在鼠标移入按钮后，用 transform: scale(1, 1); 来代替方案二中的 height: auto ，设置文本容器的宽高为1，这样就又能出现过渡动画了。 延伸 由此进行延伸，再比如日常中最常使用的控制元素显示隐藏的代码是 display: block; 和 display: none; ，这也是不存在过渡动画的，因此，可以调整改为使用 opacity: 1; 和 opacity: 0; 来替换。 transition-duration 过渡花费的时间这个属性没什么可讲的，用它来设置元素过渡的持续时间 transition-timing-function 效果曲线这个属性是设置过渡的动画类型的，换句话说，就是设置在过渡过程中元素值的变化速度。它的可选值包含这样几组： ease | linear | ease-in | ease-out | ease-in-out step-start | step-end | steps([, [ start | end ] ]?) cubic-bezier(, , , ) 预设的五个时间曲线 See the Pen transition-timing-function-五个预设时间曲线 by JingW (@JingW) on CodePen. 阶跃函数 step直接上案例吧，看完效果再来讲阶跃函数几个参数的具体含义： See the Pen transition-timing-function-阶跃函数 by JingW (@JingW) on CodePen. 实际体验了阶跃函数带来的效果后应该对其有个大概认知了吧。阶跃函数接收两个参数，第一个参数为正整数，指定阶跃函数的间隔数，你可以理解为把整个过渡过程拆成若干份儿；第二个参数可选，值为[ start | end ]，叫做跃点，指定是在每个间隔的起点还是终点发生阶跃变化，默认值为end。查看上面案例的css代码，你会发现两种 steps 的简写形式：step-start 和 step-end ，它们分别等同于：step-start = steps(1, start) 和 step-end = steps(1, end) 。 cubic-bezier 贝塞尔曲线函数贝塞尔曲线函数接收四个参数，取值范围是 0 到 1 之间的数值（包括0和1）。 贝塞尔曲线函数，其实定义的是 属性状态 与 时间 的一个关系函数。如下坐标轴所示： 上图坐标轴中横坐标是时间，纵坐标是属性状态，右上角的坐标是(1,1)。在时间曲线中的每一个点，表示的就是对应时刻下属性的取值，每个点的斜率表示的就是在这个时刻属性的变化速度，因此在时间曲线中斜率越小，也就是越平缓的地方，表示属性变化速度越慢；斜率越大，也就是越陡峭的地方，表示属性变化速度越快。如上图中开始跟结束的时候，斜率都比较小，而中间的阶段，斜率比较大，因此这个曲线表示的就是在变化过程中由慢到快再到慢的一个过程。 回到贝塞尔曲线函数接收的四个参数上，前两个是上图中红色点的坐标(x1,y1)，后两个是图中蓝色点的坐标(x2,y2)，也就是 cubic-bezier(x1, y1, x2, y2) 这样的形式。我们可以在 http://cubic-bezier.com/ 这个工具上来调整我们独特的贝塞尔曲线，通过拖拽红色跟蓝色点，可以形成不一样的贝塞尔曲线。我们发现，其实规定取值范围在[0,1]之间，针对的是x坐标，也就是时间，因为时间如果超过了这个范围，就会出现在同一个时刻对应了两个不同的属性状态，这个是没有意义的；而y坐标是可以超过这个范围的，如下我们通过拖拽两个点形成了这样一个曲线： 它表示的是在过渡过程中属性值会超过终止状态的设定值然后再回到终点位置，表现为回弹的效果。大家可以在 http://cubic-bezier.com/ 上自己拖动两个点尝试一下，最后点击 go 按钮查看效果。 上面两个图的demo效果： See the Pen transition-timing-function-贝塞尔曲线 by JingW (@JingW) on CodePen. transition-delay 延迟这个属性同样没啥讲的，用它来设置元素延迟过渡的时间。 transition 的不足 无法在页面加载的时候自动触发，因为只有当属性值发生改变的时候才会触发过渡动画。 无法重复播放过渡动画，除非再次触发过渡事件。 无法设置多种状态（keyframes 只有 from，to），只能从初始状态过渡到终止状态，无法再设置其他的状态。 transition 规则作用的是单个属性的过渡状态，不能涉及多个属性，即使定义了 transition: all 1s ease 0s; 这样的规则，其对应的每个属性过渡动画也都是相互独立，相当于是定义了很多个 transition 规则，而每个 transition 只作用于一个属性。 资源 Easing Functions Cheat Sheet cubic-bezier]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transition过渡（一）]]></title>
    <url>%2Fposts%2F24967%2F</url>
    <content type="text"><![CDATA[传送门 transition过渡（一） transition过渡（二） 介绍 CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。要实现这一点，必须规定两项内容： 指定要添加效果的CSS属性 指定效果的持续时间。 ———— 出自 菜鸟教程 语法12345678/* 分开写：*/transition-property: css属性名称;transition-duration: 过渡所花时间(默认0);transition-timing-function: 过渡的时间曲线(默认ease);transition-delay: 延迟时间(默认0);/* 简写形式： */transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0) 栗子 🌰单个属性的变化 —&gt; 按钮 :hover 效果下面的两个按钮，在鼠标移入时都被设置了 background: yellow; 样式。但只给第一个加上了 transition: background 2s; 属性，意思是如果背景发生变化，则给2s的过渡效果。 See the Pen XGvqMB by JingW (@JingW) on CodePen. 多个属性的变化 —&gt; 单独设置针对多个属性设置过渡效果，用逗号隔开就好。下面案例鼠标移入后，使正方形过渡到圆形，且颜色逐渐变浅，核心代码：1transition: background .5s ease-out, border-radius .5s ease-in; See the Pen transition-多属性 by JingW (@JingW) on CodePen. 多个属性的变化 -&gt; all如果要过渡的css属性较多，可以尝试使用 all 一步搞定。下面案例中将鼠标移入正方形盒子，会使其慢慢缩小为一个圆形，且颜色逐渐变深，核心代码：1transition: all .5s ease-out; See the Pen transition-多属性-all by JingW (@JingW) on CodePen. 实用 demo下拉导航菜单 See the Pen transition-下拉导航 by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5的自定义属性]]></title>
    <url>%2Fposts%2F39974%2F</url>
    <content type="text"><![CDATA[在 HTML5 中我们可以自定义属性，其格式为 data-*=&quot;&quot; 1234567891011121314&lt;div id="demo" data-my-name="sw" data-age="10"&gt;&lt;script&gt;/* Node.dataset 是以对象形式存在的，当我们为同一个 DOM 节点指定了多个自定义属性时， Node.dataset 则存储了所有的自定义属性的值。 */var demo = document.querySelector("#demo");//获取//注：当我们如下格式设置时，则需要以驼峰格式才能正确获取var name = demo.dataset['myName'];var age = demo.dataset['age'];//设置demo.dataset['name'] = 'web developer';&lt;script/&gt; 资源mdn - data-*]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何使用webpack4]]></title>
    <url>%2Fposts%2F47462%2F</url>
    <content type="text"><![CDATA[为什么要使用 webpack网页中引用的常见静态资源 类型 静态资源 JS .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS .css .less .sass .scss Images .jpg .png .gif .bmp .svg 字体文件（Fonts） .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 引入过多静态资源有什么问题？ 网页加载速度慢， 因此我们要发起很多的二次请求 还要处理错综复杂的依赖关系 如何解决上述两个问题 合并、压缩、精灵图、图片的 Base64 编码 可以使用 requireJS、也可以使用 webpack 来解决各个包之间的复杂依赖关系 如何完美实现上述的2种解决方案 使用 Gulp， 基于 task 任务 使用 webpack， 基于整个项目进行构建 借助于 webpack 这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能 简介webpack 是基于 Node.js 开发出来的一个前端项目打包工具。 安装 &amp; 初步使用 如果第一次安装，需要全局安装 『 webpack &amp;&amp; webpack-cli 』: 1npm install -g webpack webpack-cli 初始化项目 123456# 创建文件夹mkdir webpack4-demo# 进入cd webpack4-demo# 初始化npm init -y 以下面的目录结构创建文件 123456789101112├── package.json└── src ├── css │ └── index.css ├── images │ └── temp.png ├── index.html ├── js │ ├── a.js │ ├── b.js │ └── index.js └── main.js index.css 1234567body &#123; display: flex;&#125;ul li &#123; box-shadow: 2px 2px 2px rgba(31, 31, 31, 0.05);&#125; index.html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; js/a.js 1234567891011import b from './b'import $ from 'jquery'const a = &#123; init() &#123; console.log("我是 a 模块，现在被初始化了") &#125;, binit() &#123; b.init() &#125;&#125;export default a js/b.js 123456const b = &#123; init() &#123; console.log("我是 b 模块，现在被初始化了") &#125;&#125;export default b js/index.js 12345678910111213import $ from 'jquery'const index = &#123; // init后执行隔行变色的代码 init() &#123; // 设置偶数行背景色，索引从0开始，0是偶数 $('#list li:even').css('backgroundColor', 'lightblue') // 设置奇数行背景色 $('#list li:odd').css('backgroundColor', 'pink') &#125;&#125;export default index main.js 12345678910111213import a from './js/a'import b from './js/b'import index from './js/index'import './css/index.css'const main = () =&gt; &#123; console.log('入口函数 main 被调用了') a.init() a.binit() b.init() index.init()&#125;main() 项目根文件夹下执行命令 npm i webpack webpack-cli -D 使用 npm i jquery 安装 jQuery 类库 直接在页面上引用 main.js 会报错，因为浏览器不认识 import $ from &#39;jquery&#39; 这种JS语法，需要使用 webpack 进行处理，webpack 默认会把这种高级的语法转换为低级的浏览器能识别的语法： 12345678&lt;ul id="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;!-- 直接引入会报错 --&gt;&lt;script src="./main.js"&gt;&lt;/script&gt; 运行 webpack 入口文件路径 模式 运行 main.js 入口文件： 123webpack src/main.js --mode development # 开发环境或者webpack src/main.js --mode production # 生产环境 不过每次都要输入这个命令，非常麻烦，我们可以在package.json的scripts中加入两个指令成员： 1234"scripts": &#123; "dev": "webpack src/main.js --mode development", "build": "webpack src/main.js --mode production"&#125;, 以后只需要在命令行执行 npm run dev 便相当于执行 webpack --mode development ，执行 npm run build 便相当于执行 webpack --mode production。 使用配置文件简化打包命令 在项目根目录中创建 webpack.config.js 由于运行 webpack 命令的时候，webpack 需要指定入口文件和输出文件的路径，所以我们需要在 webpack.config.js 中配置这两个路径： 1234567891011121314151617// 导入处理路径的模块const path = require('path')// 导出一个配置对象，将来 webpack 在启动的时候，// 会默认来查找 webpack.config.js ，// 并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; // 配置入口文件，表示要使用 webpack 打包哪个文件 // 若不配置 webpack 将自动查找 src 目录下的 index.js 文件 entry: &#123; main: path.join(__dirname, './src/main.js') &#125;, output: &#123; filename: "[name].bundle.[hash].js", //输出文件名，[name]表示入口文件js名，[hash]会在后面生成随机hash值 path: path.join(__dirname, "./dist") //输出文件路径 &#125;&#125; 由于此时已经配置了入口文件，package.json 中的脚本命令就可简化为： 12"dev": "webpack --mode development","build": "webpack --mode production" 实现 webpack 实时打包构建webpack 提供了一个可选的本地开发服务器，这个本地服务器基于 node.js 构建，它是一个单独的插件，叫做 webpack-dev-server ，在 webpack 中进行配置之前需要单独安装它作为项目依赖。 devServer 作为 webpack 配置选项中的一项，以下是它的一些配置选项: contentBase ：设置服务器所读取文件的目录，当前我们设置为”./dist” port ：设置端口号，如果省略，默认为8080 inline ：设置为true，当源文件改变时会自动刷新页面 historyApiFallback ：设置为true，所有的跳转将指向index.html 由于每次重新修改代码之后，都需要手动运行 webpack 打包的命令，比较麻烦，所以使用 webpack-dev-server 来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行 npm i webpack-dev-server -D 安装到开发依赖 安装完成之后，修改之前在 package.json 中添加的 dev 指令： 1"dev": "webpack-dev-server --mode development" 运行指令 npm run dev ，发现可以进行实时打包，但是 dist 目录下并没有生成 main.bundle.js 文件，这是因为 webpack-dev-server 将打包好的文件放在了内存中。 把 bundle.js 放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 这个时候访问 webpack-dev-server 启动的 http://localhost:8080/ 网站，发现是一个文件夹的面板，需要点击到 src 目录下，才能打开我们的 index 首页，此时引用不到 main.bundle.js 文件，需要修改 index.html 中 script 的 src 属性为:&lt;script src=&quot;../main.bundle.js&quot;&gt;&lt;/script&gt; 为了能在访问 http://localhost:8080/ 的时候直接访问到 index 首页，可以使用 --contentBase src 指令来修改dev指令，指定启动的根目录： 1"dev": "webpack-dev-server --mode development --contentBase src", 插件（Plugins）插件（Plugins）是用来拓展 webpack 功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders 和 Plugins 常常被弄混，但是它们其实是完全不同的东西，可以这么来说，loaders 是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。 使用 html-webpack-plugin 插件配置启动页面由于使用 --contentBase 指令的过程比较繁琐，需要指定启动的目录，同时还需要修改 index.html 中 script 标签的 src 属性，所以推荐使用 html-webpack-plugin 插件配置启动页面。 运行 npm i html-webpack-plugin -D 安装到开发依赖 修改 webpack.config.js 配置文件如下： 123456789101112131415161718192021222324252627282930// 导入处理路径的模块const path = require('path')// 导入自动生成HTMl文件的插件const htmlWebpackPlugin = require('html-webpack-plugin')// 导出一个配置对象，将来 webpack 在启动的时候，// 会默认来查找 webpack.config.js ，// 并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; // 配置入口文件，表示要使用 webpack 打包哪个文件 // 若不配置 webpack 将自动查找 src 目录下的 index.js 文件 entry: &#123; main: path.join(__dirname, './src/main.js') &#125;, output: &#123; filename: "[name].bundle.js", //输出文件名，[name]表示入口文件js名 path: path.join(__dirname, "./dist") //输出文件路径 &#125;, plugins: [ // 添加plugins节点配置插件 new htmlWebpackPlugin(&#123; template: path.join(__dirname, './src/index.html'), //模板路径 filename: 'index.html', //自动生成的HTML文件的名称 minify: &#123; // 压缩HTML文件 removeComments: true, // 移除HTML中的注释 collapseWhitespace: true, // 删除空白符与换行符 minifyCSS: true // 压缩内联css &#125;, &#125;) ]&#125; 撤销 package.json 中 script 节点中的 dev 指令为：dev&quot;: &quot;webpack-dev-server --mode development&quot; 将 index.html 中 script 标签注释掉，因为 html-webpack-plugin 插件会自动把 main.bundle.js 注入到 index.html 页面中。 实现自动打开浏览器、热更新和配置浏览器的默认端口号方式1：修改 package.json 的 script 节点如下，其中 --open 表示自动打开浏览器， --port 4321 表示打开的端口号为 4321 ，--hot 表示启用浏览器热更新： 1"dev": "webpack-dev-server --open --port 4321 --hot --mode development", 方式2：(个人推荐) 修改 webpack.config.js 文件，新增 devServer 节点如下： 123456789devServer: &#123; inline: true, //打包后加入一个 websocket 客户端 hot: true, // 启用热更新 的 第1步 open: true, // 自动打开浏览器 contentBase: path.resolve(__dirname, 'dist'), // 指定托管的根目录，不注释的话，无法访问 src 以外的资源，比如 node_modules host: 'localhost', // 主机地址 port: 4321, // 设置启动时候的运行端口 compress: true // 开发服务器是否启动gzip等压缩 &#125;, 在头部引入 webpack 模块： 12// 启用热更新的 第2步const webpack = require('webpack') 在 plugins 节点下新增： 12// 启用热更新的第 3 步new webpack.HotModuleReplacementPlugin() Loadersloaders 是 webpack 最强大的功能之一，通过不同的 loader ，webpack 有能力调用外部的脚本或工具，实现对不同格式的文件的处理，例如把 scss 转为 css ，将 ES6 、ES7 等语法转化为当前浏览器能识别的语法，将 JSX 转化为 js 等多项功能。 loaders 需要单独安装并且需要在 webpack.config.js 中的 modules 配置项下进行配置，Loaders的配置包括以下几方面： test：一个用以匹配 loaders 所处理文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； options：为loaders提供额外的设置选项（可选） 打包 css 文件 运行npm i style-loader css-loader --D 修改 webpack.config.js 这个配置文件： 12345678module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125; //处理css文件的规则 ]&#125;, 注意：use 表示使用哪些模块来处理 test 所匹配到的文件；use 中相关 loader 模块的调用顺序是从后向前调用的。 打包 less 文件 如果你习惯使用 less ，可以执行命令 npm i less-loader less -D 来安装 less-loader 。 修改 webpack.config.js 配置文件： 1234&#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader']&#125;, //配置处理 .less 文件的第三方 loader 规则 打包 sass 文件 例如我平常习惯用 scss，所以会安装 sass-loader ：执行命令 npm i sass-loader node-sass --D 在 webpack.config.js 中添加处理 sass 文件的 loader 模块： 12345&#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader']&#125;,// 配置处理 .scss 文件的 第三方 loader 规则（npm i sass-loader后还需要 npm i node-sass，否则编译报错） 处理 css 中的图片路径 预备工作： 在 src/css/index.css 文件中给 body 添加：background-image: url(“../images/temp.png”); 此时保存会编译报错，因为 webpack 无法处理 css 中的路径（此案例中为——图片资源） 运行 npm i url-loader file-loader --D 在 webpack.config.js 中添加处理 url 路径的 loader 模块： 12345678910111213&#123; test: /\.(jpg|png|bmp|gif|jpeg)$/, use:[&#123; loader:'url-loader', options:&#123; outputPath:'images/',//输出到images文件夹 //是把小于500B的文件打成 Base64 的格式，写入JS // 如果不小于，url-loader 就会使用 file-loader 处理图片 // 所以必须安装file-loader limit:500 &#125; &#125;]&#125;, // 配置图片路径 处理 Bootstrap 字体的加载重要(更新)：webpack4后的 bootstrap 字体加载已经不能使用下面该方法，如何使用可以参考这篇博客：webpack 4.X版本的简单使用(处理js/css/less/scss/url(图片)/字体文件) 预备工作： index.html 写入 来展示字体图片 main.js 导入 import ‘bootstrap/dist/css/bootstrap.css’ 此时报错 在 webpack.config.js 中添加处理字体文件的 loader 模块： 1234&#123; test: /\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader'&#125;, // 处理 字体文件的 loader 提取css文件（插件！）先安装 mini-css-extract-plugin 包： 1npm install mini-css-extract-plugin -D 然后在 webpack.config.js 中修改对css文件处理的配置： 123456789101112131415161718// 提取cssvar MiniCssExtractPlugin = require("mini-css-extract-plugin")rules: [ &#123; test: /\.css$/, use: [ process.env.NODE_ENV === 'development' ? 'style-loader' : MiniCssExtractPlugin.loader, 'css-loader'] //处理css &#125;, ...]plugins: [ new MiniCssExtractPlugin(&#123; filename: 'style.css' &#125;), ...] 添加浏览器css前缀首先下载 loader ： 1npm i postcss-loader autoprefixer -D 然后根目录添加 postcss.config.js 1234567module.exports = &#123; plugins: &#123; 'autoprefixer': &#123; browsers: 'last 5 version' // 代表意思为每个主流浏览器的最后5个版本 &#125; &#125;&#125; 最后在 webpack.config.js 中添加配置： 12345678910111213141516rules: [ &#123; test: /\.css$/, use: [ process.env.NODE_ENV === 'development' ? 'style-loader' : MiniCssExtractPlugin.loader, &#123; loader: 'css-loader', options: &#123; importLoaders: 1 &#125; &#125;, "postcss-loader" ] //处理css &#125;, ...] 使用 babel 处理高级 JS 语法 在 main.js 文件中添加 ES6 代码： 123456789101112131415// class 关键字，是ES6中提供的新语法，是用来 实现 ES6 中面向对象编程的方式class Person &#123; // 使用 static 关键字，可以定义静态属性 // 所谓的静态属性，就是 可以直接通过 类名， 直接访问的属性 // 实例属性： 只能通过类的实例，来访问的属性，叫做实例属性 static info = &#123; name: 'zs', age: 20 &#125;&#125;// 访问 Person 类身上的 info 静态属性console.log(Person.info)// 在 webpack 中，默认只能处理 一部分 ES6 的新语法，一些更高级的ES6语法或者 ES7 语法，webpack 是处理不了的；这时候，就需要 借助于第三方的 loader，来帮助webpack 处理这些高级的语法，当第三方loader 把 高级语法转为 低级的语法之后，会把结果交给 webpack 去打包到 bundle.js 中// 通过 Babel ，可以帮我们将 高级的语法转换为 低级的语法 运行如下两套命令，安装两套包，去安装 Babel 相关的loader功能： 123456// 【相当于转换工具】npm i -D @babel/core babel-loader @babel/plugin-transform-runtime @babel/runtime @babel/plugin-proposal-class-properties// 【相当于字典】npm i -D @babel/preset-env// =====&gt; 「转换工具」根据「字典」将 es6 转换 打开 webpack 的配置文件，在 module 节点下的 rules 数组中，添加一个新的匹配规则： 12345&#123; test: /\.js$/, use: 'babel-loader', exclude: /node_modules/&#125; // 配置 Babel 来转换高级的ES语法 2.2 注意： 在配置 babel 的 loader 规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉：原因有俩： 2.2.1 如果 不排除 node_modules， 则Babel 会把 node_modules 中所有的 第三方 JS 文件，都打包编译，这样，会非常消耗CPU，同时，打包速度非常慢； 2.2.2 哪怕，最终，Babel 把 所有 node_modules 中的JS转换完毕了，但是，项目也无法正常运行！ 在项目的根目录中，新建一个叫做 .babelrc 的 Babel 配置文件，这个配置文件，属于 JSON 格式，所以，在写 .babelrc 配置的时候，必须符合 JSON 语法规范： 不能写注释，字符串必须用双引号： 123456789101112131415&#123; "presets": [ ["@babel/preset-env", &#123; "modules": false, "targets": &#123; "browsers": ["&gt; 1%", "last 2 versions", "not ie &lt;= 8"] &#125;, "useBuiltIns": "usage" &#125;] ], "plugins": [ "@babel/plugin-transform-runtime", "@babel/plugin-proposal-class-properties" ]&#125; webpack.config.js配置遇到Error: Cannot find module ‘@babel/core’问题 官方默认babel-loader | babel 对应的版本需要一致: 即babel-loader需要搭配最新版本babel 两种解决方案: 回退低版本 1npm install -D babel-loader@7 babel-core babel-preset-env 更新到最高版本: 1npm install -D babel-loader @babel/core @babel/preset-env webpack 压缩和优化css文件下载 optimize-css-assets-webpack-plugin 插件： 1npm i optimize-css-assets-webpack-plugin -D 在 webpack.config.js 中引入插件并添加配置： 12345678910111213141516// 压缩cssconst OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin')plugins: [ new OptimizeCssAssetsPlugin(&#123; assetNameRegExp: /\.css$/g, //一个正则表达式，指示应优化/最小化的资产的名称。提供的正则表达式针对配置中ExtractTextPlugin实例导出的文件的文件名运行，而不是源CSS文件的文件名。默认为/\.css$/g cssProcessor: require('cssnano'), //用于优化\最小化CSS的CSS处理器，默认为cssnano cssProcessorOptions: &#123; safe: true, discardComments: &#123; removeAll: true &#125; &#125;, //传递给cssProcessor的选项，默认为&#123;&#125; canPrint: true //一个布尔值，指示插件是否可以将消息打印到控制台，默认为true &#125;),] 压缩和优化js文件123456789101112131415161718yarn add webpack-parallel-uglify-plugin -Dconst WebpackParallelUglifyPlugin = require('webpack-parallel-uglify-plugin')plugins: [new WebpackParallelUglifyPlugin(&#123; uglifyJS: &#123; output: &#123; beautify: false, //不需要格式化 comments: false //不保留注释 &#125;, compress: &#123; warnings: false, // 在UglifyJs删除没有用到的代码时不输出警告 drop_console: true, // 删除所有的 `console` 语句，可以兼容ie浏览器 collapse_vars: true, // 内嵌定义了但是只用到一次的变量 reduce_vars: true // 提取出出现多次但是没有定义成变量去引用的静态值 &#125; &#125; &#125;)] 提取公共文件我们可看到 src/js/a.js 和 src/main.js 都引入了 src/js/b.js 文件，为什么要提取公共代码，简单来说，就是减少代码冗余，提高加载速度。和之前的 webpack 配置不一样： 1234567891011121314151617181920212223242526//之前配置// new webpack.optimize.SplitChunksPlugin(&#123;// name: 'common', // 如果还要提取公共代码,在新建一个实例// minChunks: 2, //重复两次之后就提取出来// chunks: ['index', 'a'] // 指定提取范围// &#125;),//现在配置optimization: &#123; splitChunks: &#123; cacheGroups: &#123; commons: &#123; // 抽离自己写的公共代码 chunks: "initial", name: "common", // 打包后的文件名，任意命名 minChunks: 2,//最小引用2次 minSize: 0 // 只要超出0字节就生成一个新包 &#125;, vendor: &#123; // 抽离第三方插件 test: /node_modules/, // 指定是node_modules下的第三方包 chunks: 'initial', name: 'vendor', // 打包后的文件名，任意命名 // 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包 priority: 10 &#125;, &#125; &#125;&#125;, Source Maps 调试配置作为开发，代码调试当然少不了，那么问题来了，经过打包后的文件，你是不容易找到出错的地方的，Source Map就是用来解决这个问题的。 通过如下配置，我们会在打包时生成对应于打包文件的 .map 文件，使得编译后的代码可读性更高，更易于调试。 123456// webpack.config.js...module.exports = &#123; ... devtool: 'source-map' // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度&#125; 配置好后，我们再次运行 npm run build 进行打包，这时我们会发现在 dist 文件夹中多出了一个 bundle.js.map 如果我们的代码有 bug ，在浏览器的调试工具中会提示错误出现的位置，这就是 devtool: &#39;source-map&#39; 配置项的作用。 开发环境 VS 生产环境npm run devnpm run dev 是我们开发环境下打包的文件，当然由于 devServer 帮我们把文件放到内存中了，所以并不会输出打包后的 dist 文件夹。 npm run build通过 npm run build 之后会生成一个dist目录文件夹，里面有我们打包后的文件。 清理/dist文件夹(CleanwebpackPlugin)你可能已经注意到，在我们删掉 /dist 文件夹之前，由于前面的代码示例遗留，导致我们的 /dist 文件夹比较杂乱。webpack 会生成文件，然后将这些文件放置在 /dist 文件夹中，但是 webpack 无法追踪到哪些文件是实际在项目中用到的。 通常，在每次构建前清理 /dist 文件夹，是比较推荐的做法，因此只会生成用到的文件，这时候就用到 CleanWebpackPlugin 插件了。 123456789101112npm i clean-webpack-plugin -D// webpack.config.js...const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;); // 引入CleanWebpackPlugin插件module.exports = &#123; ... plugins: [ ... new CleanWebpackPlugin(), // 以前括号里面要传入数组([dist])来指定要删除的目录，新版 CleanWebpackPlugin 不需要传任何参数了 ]&#125; 插件的使用方法都是一样的，首先引入，然后new一个实例，实例可传入参数。 现在我们运行 npm run build 后就会发现，webpack 会先将 /dist 文件夹删除，然后再生产新的 /dist 文件夹。 webpack4.x 相关资源 webpack4.x最详细入门讲解 webpack3 与 webpack4 使用差异 webpack4.x开发环境配置]]></content>
      <categories>
        <category>前端</category>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie与session区别]]></title>
    <url>%2Fposts%2F63891%2F</url>
    <content type="text"><![CDATA[保存状态cookie 是通过在客户端记录信息确定用户身份的，而 session 则通过在服务器端记录信息来确定用户身份。下面是网上找到的两张图，能够对 cookie 以及 session 在客户端与服务端传递的过程有个较清晰的认识： 使用方式cookie机制： 默认情况下，cookie 保存在内存中，浏览器关闭就没了；设置过期时间后，cookie 保存在硬盘上，关闭浏览器仍然存在，直到过期时间结束才消失。 cookie 以文本形式保存在客户端，每次请求时都带上它。 session机制： 每次请求，服务器会检查是否有 sessionid 有，服务器根据 id 返回对应 session 对象 无，服务器创建新的 session 对象，并把 sessionid 在本次响应中返回给客户端。 通常使用 cookie 方式存储 sessionid 到客户端 用户禁用 cookie 时，则服务端可以使用URL重写，可以通过 response.encodeURL(url) 进行实现 存储方式 cookie 只能保存字符串类型，以文本的方式 session 能支持任何类型的对象 存储大小 cookie单个不超过4kb session没限制]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记]]></title>
    <url>%2Fposts%2F51696%2F</url>
    <content type="text"><![CDATA[前言之前对算法和数据结构没有一个系统的学习，从今天开始抽空啃啃书吧。就从这本程杰老师的《大话数据结构》起步。 p.s. 原笔记是存放在幕布上的，文字版看着不舒服可以 点击这里 看思维导图版。 数据结构绪论 基本概念和术语 数据 定义：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的集合符号。 总结：数据即符号，必备条件： 可以输入到计算机中 能被计算机程序处理 举例： MP3是声音数据 图片是图像数据 #数据对象 定义：是性质相同的数据元素的集合，是数据的子集 举例： 人（都有姓名、生日等相同的数据项） #数据元素 定义：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被成为记录。 举例： 人类中的人 畜类中的牛马羊 #数据项 定义：一个数据元素可以由若干个数据项组成 举例： 人的姓名、年龄、性别 数据结构 定义：是相互之间存在一种或多种特定关系的数据元素的集合 #逻辑结构 定义：指数据对象中数据元素之间的相互关系 类型 #集合结构 同属于一个集合的数据元素 #线性结构 数据元素之间是一对一的关系 #树形结构 数据元素之间存在一对多的层次关系 #图形结构 数据元素是多对多的关系 用示意图表示数据逻辑结构时的注意点： 每个数据元素是一个结点，用圆圈表示 元素之间的逻辑关系用连线表示，如果此关系是有方向的，那么用箭头连线表示 #物理结构 定义：是指数据的逻辑结构在计算机中的存储形式 #顺序存储结构 定义：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的 #链式存储结构 定义：是把数据元素存放在任意的存储单元里，这组存储单元可以使连续的，也可以是不连续的。 注意：数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置 算法 基本特性：输入、输出、有穷性、确定性和可行性 设计要求：正确性、可读性、健壮性、高效和低存储量 度量方法：事后统计（不科学、不准确）、事前分析估算 ✅ 时间复杂度 概念 计算公式：T(n) = O(f(n)) T(n)： 语句总的执行次数 n： 问题规模 f(n)： 问题规模 n 的某个函数 表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同 大O记法 定义：用大写O()来体现时间复杂度，简称为大O记法 推导大O阶方法： \1. 用常数 1 取代运行时间中的所有加法常数 \2. 在修改后的运行次数函数中，只保留最高阶项 \3. 如果最高阶项存在且不是 1，则去除与这个项相乘的常数 \4. 得到的结果就是大 O 阶 常数阶 举例：高斯算法 此算法运行次数函数是 f(n)=3 推导：把常数项 3 改为 1 =&gt; 它没有最高阶 =&gt; 复杂度：O(1) 线性阶 推导：循环体中代码需要执行 n 次 =&gt; 复杂度：O(n) 对数阶 推导：每次 count 乘以 2 后，就距离 n 更近一分。换句话说，有多少个 2 相乘后大于 n，则会退出循环。由 2^x=n 得到 x=log(2)n。所以此循环复杂度：O(logn) 平方阶 举例1 推导：两层循环，每层循环 n 次 =&gt; 复杂度：O(n^2) 如果把外层 n 改为 m，则复杂度：O(m✘n) 举例2 复杂度：O(n^2) 常见时间复杂度 常见时间复杂度所耗费的时间从小到大： 空间复杂度 概念 计算公式：S(n) = O(f(n)) S(n)：计算算法所耗的存储空间 n： 问题规模 f(n)： 问题规模 n 所占存储空间的函数 当不用限定词地使用“复杂度”时，指的都是时间复杂度 心得 明白算法的时间复杂度估算很重要，不要以“CPU越来越快，不用考虑算法优劣”为借口。愚公移山固然可敬，但发明炸药和推土机更加实在和聪明 线性表 定义：零个或多个数据元素的有限序列 关键点： 是一个有顺序的序列 若元素存在多个，则第一个无前驱，最后一个无后继，中间部分都有且只有一个前驱和后继 线性表是有限的 举例： 幼儿园小朋友按次序排队，各自都知道他前面人是谁，方便清点人数，知道谁不在 一年的星座列表 顺序存储结构 定义：用一段地址连续的存储单元一次存储线性表的数据元素 三个重要属性： 存储空间的起始位置 线性表的最大存储容量 线性表的当前长度 数据长度与线性表长度区别 数据长度：（例如一个数组的长度）是存放线性表的存储空间的长度，一般不变 线性表长度：是线性表中数据元素的个数，随着插入与删除，这个量是可变的 在任意时刻，线性表长度应该 小于等于 数据长度 时间复杂度： 插入或删除最后一个元素为 O(1) 插入或删除第一个元素为O(n) 优缺点 优点： 无需为了表示表中元素之间的逻辑关系而增加额外的存储空间 可以快速地存取表中任意位置的元素 缺点： 插入和删除操作需要移动大量元素 当线性表长度变化较大时，难以确定存储空间的容量 造成存储空间的“碎片” 链式存储结构 定义：是把数据元素存放在任意的存储单元里，这组存储单元可以使连续的，也可以是不连续的。 与顺序结构不同，在链式结构中，除了要存储数据信息外，还要存储它后继元素的存储地址 单链表 定义：一个链式结构的，每个结点中只包含一个指针域的链表叫做单链表 单链表结构与顺序存储结构的优缺点 对比： 存储分配方式： 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素 时间性能： 查找： 顺序存储结构 O(1) 单链表 O(n) 插入与删除： 顺序存储结构需要移动表长一半的元素，时间为 O(n) 单链表在找出某位置的指针后，插入和删除时间仅为 O(1) 空间性能： 顺序存储结构需要预分配存储空间，分大了浪费，分小了容易溢出 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制 结论： 若线性表需要频繁查找，很少进行插入和删除操作，宜采用顺序存储结构 若需要频繁插入和删除，宜采用单链表结构 当线性表中的元素个数变化较大或根本不知道多大时，宜采用单链表结构，这样不用考虑存储空间的大小问题。 若事先知道大致长度，比如一年12个月，一周7天，宜采用顺序存储结构 实际应用： 用户注册的个人信息，除了注册时插入数据外，绝大多数情况都是读取，所以宜采用顺序存储结构 游戏中玩家的武器装备列表，随着游戏推进，玩家可能随时增加或删除，所以宜采用单链表结构 静态链表 背景：有些编程高级语言（e.g. Basic, Fortran）没有指针，这样链表结构就没法实现。 解决方案：用数组来代替指针，来描述单链表 实现：让数组元素都由两个数据域组成，data和cur。data用来存储数据元素，cur（游标）相当于单链表中的next指针，存放该元素的后继在数组中的下标。 定义：这种用数组描述的链表叫做静态链表。这种描述方法起名为游标实现法。 举例： 将 “甲乙丙丁戊己庚”存入静态链表： 优缺点： 优点： 再插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。 缺点： 没有解决连续存储分配带来的表长难以确定的问题 失去了顺序存储结构随机存储的特性 循环链表 定义：将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。 双向链表 定义：双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。 栈与队列 栈 定义：栈是限定仅在表尾进行插入和删除操作的线性表 描述：我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈又称为后进先出（Last In First Out）的线性表，简称 LIFO 结构。 举例：浏览器的前进后退，Photoshop 的前进撤销。 栈的顺序存储结构 操作： 栈的插入操作（push 压），叫作进栈，也称压栈、入栈。类似子弹入弹夹。 栈的删除操作（pop 弹），叫作出栈，也称弹栈。类似子弹出夹。 两栈共享空间 理解：两个相同类型的栈，为它们各自开辟了数组空间，极有可能第一个栈满，再进栈就溢出了，而另一个栈还有很多存储空间空闲。所以我们完全可以用一个数组来存储两个栈。 做法：数组的两个端点，让一个栈的栈底为数组的始端（下标0），另一个栈为栈的末端（n-1）。两栈如果增加元素，就是两端向中间延伸。 关键思路： \1. 两个top是数组两端的栈顶指针，只要它俩不见面，两个栈就都可以一直使用。 \2. 栈1为空时，就是top1等于-1时；当top2等于n时，即是栈2为空时。 \3. 何时栈满：top1等于n-1时栈1满；top2等于0时，栈2满，所以推导出，top1+1==top2为栈满 栈的链式存储结构 栈顶存放位置： 由于单链表有头指针，而栈顶指针也是必须的，所以把它俩合二为一，将栈顶放在单链表的头部。 不需要头结点： 都已经有了栈顶在头部，所以单链表的头结点也失去了意义，所以不需要头结点。 示意图： 栈的应用 #递归 #四则运算表达式求值 队列 定义：队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表 描述：队列是一种先进先出（First In First Out）的线性表，简称 FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。 举例：键盘的输入，记事本上的输出。 队列的顺序存储结构 缺点： 由于从队头出，导致后面元素都得向前移动，时间复杂度 O(n) 解决： 循环队列 让头尾相接 队列的链式存储结构 顺序存储和链式存储的选择 可以确定队列长度最大值时，建议循环队列 无法预估队列长度时，使用链队列 串 定义：是由零个或多个字符组成的有限序列，又名字符串 算法 朴素的模式匹配算法 从头开始依次往后比较【不推荐】 KMP模式匹配算法 数 定义： 树是 n(n&gt;=0) 个结点的有限集。n=0 时称为空树。在任意一棵非空树中： \1. 有且仅有一个特定的称为根（Root）的结点 \2. 当 n &gt; 1 时，其余结点可分为 m(m &gt; 0) 个互不相交的有限集 T1、T2 … 、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree） 结点分类 定义：结点拥有的子树数称为结点的度。度为 0 的结点称为叶结点或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根结点外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。下面树结点的度的最大值是结点 D 的度，为 3，所以树的度也为 3 。 结点间关系 树的其他相关概念 结点的层次 从根开始定义起，根为第一层。 树中结点的最大层次称为树的深度或高度，下图树深度为 4 树与线性表结构的对比 阿萨德 二叉树 定义：二叉树是 n(n&gt;=0)个结点的有限集合，该集合或为空集（称为空二叉树），或由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。 特点： 每个结点最多有两棵子树 左子树和右子树是有顺序的，次序不能任意颠倒 即使树中某结点只有一棵树，也要区分左右子树 特殊二叉树 #斜树 定义： 所有结点都在左子树的二叉树叫左斜树 所有结点都在右子树的二叉树叫右斜树 这种特殊树和线性表结构一样，所以线性表结构可以理解为是树的一种特殊形式 #满二叉树 #完全二叉树 定义：对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i (i &lt;= i &lt;= n) 的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中的位置完全相同，则这课二叉树称为完全二叉树。 如何判定：在看树时，心中默默给每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空挡，就说明不是完全二叉树，否则就是。 下面几个都不是： 9跟11之间有空挡 5跟8，9之间有空挡 9跟12之间有空挡 存储结构 二叉树顺序存储结构（适用于完全二叉树） 二叉链表 遍历二叉树 #二叉树遍历方法 前序遍历 遍历顺序：ABDGHCEIF 中序遍历 遍历顺序：GDHBAEICF 后序遍历 遍历顺序：GHDBIEFCA 层序遍历 遍历顺序：ABCDEFGHI 图]]></content>
      <categories>
        <category>后端</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决0.1+0.2不等于0.3的问题]]></title>
    <url>%2Fposts%2F21245%2F</url>
    <content type="text"><![CDATA[为何会出现此问题？总结一句话：这是因为二进制模拟十进制进行运算时的精度问题。 具体可查看 0.1 + 0.2不等于0.3？为什么JavaScript有这种“骚”操作？ 这篇掘金文章。 如何解决Number.EPSILON第一种方法是利用 Number.EPSILON ，这个值无限接近于0。0.1+0.2的精度误差在这个值的范围内：12345function numbersEqual(a,b)&#123; return Math.abs(a-b)&lt;Number.EPSILON;&#125;var a=0.1+0.2， b=0.3;console.log(numbersEqual(a,b)); //true 内置函数toFixed利用 parseFloat + 内置函数toFixed：123456function formatNum(num, fixed = 10) &#123; // a.toFixed(fixed) 先转为小数点10位的字符串 "0.3000000000" return parseFloat(a.toFixed(fixed)) // 然后通过parseFloat转为浮点数&#125;var a = 0.1 + 0.2;console.log(formatNum(a)); //0.3 内置函数toPrecision我平常用此函数来计算精度，具体可参考 Number.prototype.toPrecision() | MDN：123// 内置函数toPrecision(中文：精确，精度)// 参数是精度.比如5.1234，传2返回5.1，传1返回5；0.2+0.1传2返回0.30(0.1 + 0.2).toPrecision(10) == 0.3 // true]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise用法]]></title>
    <url>%2Fposts%2F7878%2F</url>
    <content type="text"><![CDATA[Promise是什么Promise 是一种异步编程的解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。 诞生的原因异步网络请求的回调地狱，而且我们还得对每次请求的结果进行一些处理，代码会更加臃肿。一张图完美诠释：不够？再加一张： Promise的三种状态 pedding 等待（默认状态。异步代码执行完毕后会转换为以下两种状态） resolve 成功 reject 失败 基本用法语法 Promise: 构造函数 接受一个参数：callback，我们把要执行的异步任务放置在这个callback中 then: Promise对象下的一个方法：该方法在Promise对象的状态发生改变的时候触发then的回调 12345678910111213//defined Promise async functionfunction asyncFun()&#123; return new Promise((resolve, reject) =&gt; &#123; if (resolve) &#123; resolve(/*resolve parameter*/); &#125;else&#123; reject(new Error(/*Error*/)); &#125; &#125;)&#125;//use Promise&amp;thenasyncFun().then(/*function*/).then(/*function*/)... Promise特性立即执行12345678910111213141516let p = new Promise((resolve, reject) =&gt; &#123; // 当Promise被实例化的时候，callback的异步任务就会被执行 console.log("一个Promise对象被创建出来"); resolve("success");&#125;);console.log("flag");p.then((data) =&gt; &#123; console.log(data);&#125;);// 执行结果：// 一个Promise对象被创建出来// flag// success 状态不可逆1234567891011let p = new Promise((resolve, reject) =&gt; &#123; resolve("success"); reject("reject");&#125;);p.then((data) =&gt; &#123; console.log(data);&#125;);// 执行结果：// success 链式调用12345678910111213141516171819let p = new Promise((resolve, reject) =&gt; &#123; // 通过传入的resolve, reject，去改变当前Promise任务的状态 // resolve, reject 是两个函数，调用 resolve ，会把状态改成 resolved ，调用 reject 函数会把状态改成 rejected setTimeout(() =&gt; &#123; console.log(1); reject(); &#125;, 1000);&#125;);// then接受两个参数：这两个参数都是回调，当对应的 promise 对象的状态变成了resolved，那么 then 的第一个 callback 就会被执行，如果状态变成了 rejected ，那么 then 的第二个 callback 就会被执行p.then(() =&gt; &#123; console.log('成功');&#125;, () =&gt; &#123; console.log('失败');&#125; );// 执行结果：// 1// 失败 then的回调异步性1234567891011121314151617let p = new Promise((resolve, reject) =&gt; &#123; console.log("我是Promise的callback中的代码"); setTimeout(() =&gt; &#123; resolve("我1s后才会被执行"); &#125;, 1000);&#125;);p.then((data) =&gt; &#123; console.log(data);&#125;);console.log("我是主线程中的同步代码");// 执行结果：// 我是Promise的callback中的代码// 我是主线程中的同步代码// 我1s后才会被执行 解释：Promise 的 callback 回调函数中的代码是立即执行的（setTimeout 这个定时器也是立即执行的，只是函数内的 resolve 被延迟1s执行，跟 Promise 本身的立即执行没关系），但 then 方法中的回调函数执行则是异步的，因此，&quot;我1s后才会被执行&quot; 会在最后输出。 异常的捕获Promise的异常有两种方法可以捕获，一种是 then 的第二个回调；一种 .catch() 来捕获前一个 Promise 抛出的错误。 123456789101112let p = new Promise((resolve, reject) =&gt; &#123; reject("error");&#125;);p.then(data =&gt; &#123; console.log("success")&#125;, error =&gt; &#123; console.log(error);&#125;);// 执行结果：// error 123456789101112let p = new Promise((resolve, reject) =&gt; &#123; reject("error");&#125;);p.then(data =&gt; &#123; console.log("success")&#125;).catch(error =&gt; &#123; console.log("catch:" + error);&#125;);// 执行结果：// catch:error Promise.all 和 Promise.racePromise.allPromise.all 接收一个参数，它必须是可以迭代的，例如数组。它通常用来处理一些并发的异步操作，即它们的结果互不干扰，但是又需要异步执行。当所有 Promise 都成功的时候，整个 Promise.all 才成功。成功调用后返回一个数组，数组的值是有序的，顺序就是传入参数的数组顺序： 成功的情况 123456789101112let arr = [1, 2, 3];let tasks = arr.map(num =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(num * 5); &#125;);&#125;);Promise.all(tasks).then(data =&gt; &#123; // 有序输出 console.log(arr); // [1, 2, 3] console.log(data); // [5, 10, 15]&#125;); 失败的情况 1234567891011121314151617let arr = [1, 2, 3];let tasks = arr.map(num =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; if (num === 3) &#123; reject('rejected'); &#125; resolve(num * 5); &#125;);&#125;);Promise.all(tasks).then(data =&gt; &#123; // 这里不会执行 console.log(arr); console.log(data);&#125;).catch(err =&gt; &#123; console.log(err); // rejected&#125;); Promise.racePromise.race 和 Promise.all 类似，都接收一个可以迭代的参数，但是不同之处是 Promise.race 的状态变化不是全部受参数内的状态影响，一旦参数内有一个值的状态发生的改变，那么该 Promise 的状态就是改变的状态。就跟 race 单词的字面意思一样，谁跑的快谁赢。 12345678910111213141516171819let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 300, 'p1 doned');&#125;);var p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 50, 'p2 doned');&#125;);var p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(reject, 100, 'p3 rejected');&#125;);Promise.race([p1, p2, p3]).then(data =&gt; &#123; // 显然p2更快，所以状态变成了fulfilled // 如果p3更快，那么状态就会变成rejected console.log(data); // p2 doned&#125;).catch(function(err) &#123; console.log(err); // 不执行&#125;);]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let和const和var的区别]]></title>
    <url>%2Fposts%2F37021%2F</url>
    <content type="text"><![CDATA[const 和 let 异同不同点 let 定义变量可以只声明不赋值 const 定义常量声明时必须赋值，一旦定义不可轻易改变 相同点解决 var 没有块作用域,、变量提升、可以重复声明的问题。 let 和 const 有自己的块作用域, 不存在变量提升问题, 同一块作用域中不可重复声明（会报错）。 let/const 和 var 区别 var 有变量提升，let/const 没有 let/const 的作用域是块，而 var 的作用域是函数 let/const 有暂时性死区，只要 let/const 声明的变量，在未声明之前使用或者赋值都会报错（ReferenceError） let/const 不能被重复定义]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数中的rest参数]]></title>
    <url>%2Fposts%2F29820%2F</url>
    <content type="text"><![CDATA[什么是 REST 参数REST参数翻译过来就是剩余参数，MDN上的定义是： 剩余参数语法允许我们将一个不定数量的参数表示为一个数组。 示例说明123456789101112131415161718192021function sum(...theArgs) &#123; return theArgs.reduce((previous, current) =&gt; &#123; return previous + current; &#125;);&#125;console.log(sum(1, 2, 3));// expected output: 6console.log(sum(1, 2, 3, 4));// expected output: 10// 下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们function multiply(multiplier, ...theArgs) &#123; return theArgs.map(function (element) &#123; return multiplier * element; &#125;);&#125;var arr = multiply(2, 1, 2, 3); console.log(arr); // [2, 4, 6] rest 参数和 arguments 对象的区别剩余参数和 arguments对象之间的区别主要有三个： 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。 arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。 arguments对象还有一些附加的属性 （如callee属性）。 arguments.callee 属性包含当前正在执行的函数。]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中如何实现继承]]></title>
    <url>%2Fposts%2F2751%2F</url>
    <content type="text"><![CDATA[组合继承（原型链 + 借用构造函数）12345678910111213141516171819202122232425262728// 组合继承:原型继承+借用（调用）构造函数继承function Person(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex;&#125;Person.prototype.sayHi = function () &#123; console.log("Hello world");&#125;;function Student(name, age, sex, score) &#123; // 借用构造函数 Person.call(this,name,age,sex); this.score = score;&#125;// 改变原型指向----继承// 我们让 Student.prototype 指向一个Person的实例对象// 这个对象的__proto__指向的是Person.prototype// 所以我们就可以借助这个实例对象拿到sayHi方法，实现继承Student.prototype=new Person();Student.prototype.eat = function () &#123; console.log("吃东西");&#125;;var stu = new Student("Lance", 20, "男", "100分");stu.sayHi();var stu2 = new Student("Jerry", 19, "男", "101分");stu2.eat();//属性和方法都被继承了 寄生组合继承（组合继承升级版）123456789101112131415161718192021222324252627282930function object(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); // 创建了父类原型的浅复制 prototype.constructor = subType; // 修正原型的构造函数 subType.prototype = prototype; // 将子类的原型替换为这个原型&#125; function SuperType(name)&#123; this.name = name; this.colors = ["red", "blue", "green"];&#125; SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;; function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;// 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; alert(this.age);&#125; ES6继承写法12345678910class Person &#123; constructor(name, age) &#123;this.name=name;this.age=age&#125; sayHi() &#123;&#125;&#125;class Student extends Person &#123; constructor(name, age, weight) &#123; super(name, age); this.weight = weight; &#125; run() &#123;&#125;&#125; 在原型链继承时，为什么不直接 Student.prototype = Person.prototype ？因为对象的赋值只是引用的赋值, 上面两者都指向同一个内存地址，只要随便通过1个途径就能修改该内存地址的对象，这样子类就无法单独扩展方法，而且会影响父类。 组合继承的缺点缺点就是调用了两次父类的构造函数。第一次给子类的原型添加了父类构造函数中的属性方法；第二次又给子类的构造函数添加了父类的构造函数的属性方法，从而覆盖了子类原型中的同名参数。这种被覆盖的情况造成了性能上的浪费：1234567891011121314function SuperType() &#123; this.name = 'parent'; this.arr = [1, 2, 3];&#125; SuperType.prototype.say = function() &#123; console.log('this is parent')&#125; function SubType() &#123; SuperType.call(this) // 第二次调用SuperType&#125; SubType.prototype = new SuperType() // 第一次调用SuperType]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对this指向的判定]]></title>
    <url>%2Fposts%2F33207%2F</url>
    <content type="text"><![CDATA[对 this 的理解对于this指向的判定，时刻记住下面两点就好： 普通函数的 this 指向是在函数的执行期间绑定的，换句话说 this 总是指向函数的直接调用者 箭头函数的 this 指向是在函数创建期间就绑定好了的，指向的是创建该箭头函数所在的作用域对象 普通函数中的this这里直接引用 You-Dont-Know-JS 中对 this 的判定步骤： 函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。var bar = new foo() 函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。var bar = foo.call( obj2 ) 函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。var bar = obj1.foo() 否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。var bar = foo() 常见this指向 普通函数中this ——&gt; window 构造函数中this ——&gt; new出来的实例对象 方法中的this ——&gt; 实例对象 原型中的方法中的this ——&gt; 实例对象 定时器中的this ——&gt; window]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的遍历方法]]></title>
    <url>%2Fposts%2F64478%2F</url>
    <content type="text"><![CDATA[下面是总结的数组遍历的常见方法 for循环 标准for循环 forEach((当前值, 当前索引, 当前数组) =&gt; {…}, [, 绑定的this])` 无法中途退出循环，只能用 return 退出本次回调，进行下一次回调 它总是返回 undefined 值，即使你 return 了一个值 for…in（不推荐）会把继承链的对象属性都会遍历一遍，而且数组遍历不一定按次序 for-in 循环返回的是所有能通过对象访问的、可枚举的属性 for (variable of iterable)（ES6）可迭代Array，Map，Set，String等（迭代的是值value） 在 for..of 中如果遍历中途要退出，可以使用 break 退出循环 ES5 map (不改变原数组) 会给原数组中的每个元素都按顺序调用一次 callback 函数 reduce (不改变原数组) 数组中的前项和后项做某种计算,并累计最终值。 123456789// 语法：// arr.reduce(function(total, currentValue, currentIndex, arr), initialValue)// callback 参数// (累积器, 当前元素, 当前元素索引, 当前数组)// initialValue:指定第一次回调 的第一个参数var wallets = [4, 7.8, 3]var totalMoney = wallets.reduce(function (countedMoney, curMoney) &#123; return countedMoney + curMoney;&#125;, 0) filter (不改变原数组) 1234var arr = [2, 3, 4, 5, 6]var morearr = arr.filter(function (number) &#123; return number &gt; 3&#125;) // [4,5,6] every (不改变原数组) 测试数组的所有元素是否都通过了指定函数的测试 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测 如果所有元素都满足条件，则返回 true 1234var arr = [1,2,3,4,5]var result = arr.every(function (item, index) &#123; return item &gt; 2&#125;) // false some (不改变原数组) 测试是否至少有一个元素通过 callback 中的条件。对于放在空数组上的任何条件，此方法返回 false 如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测 如果没有满足条件的元素，则返回false 12345678// some(callback, thisArg)// callback:// (当前元素, 当前索引, 调用some的数组)var arr = [1,2,3,4,5]var result = arr.some(function (item,index) &#123; return item &gt; 3&#125;) // true ES6 find() &amp; findIndex() 根据条件找到数组成员 find 定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回 undefined findIndex 定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 123456789101112// 语法let new_array = arr.find(function(currentValue, index, arr), thisArg)let new_array = arr.findIndex(function(currentValue, index, arr), thisArg)// 这两个方法都可以识别NaN,弥补了indexOf的不足// findlet a = [1, 4, -5, 10].find((n) =&gt; n &lt; 0); // 返回元素-5let b = [1, 4, -5, 10,NaN].find((n) =&gt; Object.is(NaN, n)); // 返回元素NaN// findIndexlet a = [1, 4, -5, 10].findIndex((n) =&gt; n &lt; 0); // 返回索引2let b = [1, 4, -5, 10,NaN].findIndex((n) =&gt; Object.is(NaN, n)); // 返回索引4 keys() &amp; values() &amp; entries() 遍历键名、遍历键值、遍历键名+键值 三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值 1234567891011121314151617181920// 语法array.keys() array.values() array.entries()for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b"]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[null 和 undefined 的区别]]></title>
    <url>%2Fposts%2F63928%2F</url>
    <content type="text"><![CDATA[含义 null 表示一个对象是“没有值”的值，也就是值为“空” undefined 表示一个变量声明了没有初始化(赋值) 类型 undefined 的类型(typeof)是 undefined null 的类型(typeof)是 object 双等三等另外，在验证 null 时，一定要使用 === ，因为 == 无法分辨 null 和 undefined ：12null == undefined // true null === undefined // false 总结undefined 变量提升：只声明未定义默认值就是 undefined 严格模式下：没有明确的执行主体，this 就是 undefined 对象没有这个属性名，属性值是 undefined 函数定义形参不传值，默认就是 undefined 函数没有返回值（没有 return 或者 return; ），默认返回的就是 undefined 数组越界取值也是 undefined （arr=[1,2]; arr[10] =&gt; undefined） … null 手动设置变量的值或者对象某个属性值为null（此时不赋值，后面会赋值） 在 JS 的 DOM 元素获取中，如果没有获取到指定的元素对象，结果一般都是null Object.prototype.proto 的值也是 null 正则捕获的时候，如果没有捕获到结果，默认也是null … 其他Javascript会将未赋值的变量默认值设为undefined；Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对闭包的理解]]></title>
    <url>%2Fposts%2F29980%2F</url>
    <content type="text"><![CDATA[什么是闭包我一直认为，MDN是前端学习的在线指南。只要有不懂的语法，或者不懂的概念，查找资料的首选就应该是它。虽然早些年做iOS开发的时候就就接触过闭包，但如今已经忘得一干二净，所以在想要了解闭包的时候，第一件事就是在MDN中搜索。其中给到了一个闭包的例子： 12345678910function makeFunc() &#123; var name = "Mozilla"; // name 是一个被 init 创建的局部变量 function displayName() &#123; // displayName() 是内部函数,一个闭包 alert(name); // 使用了父函数中声明的变量 &#125; return displayName; // 返回 displayName 这个函数&#125;var myFunc = makeFunc();myFunc(); // 当执行myFunc时，其实调用了displayName，会弹窗显示"Mozilla" 在上面这个例子中，一个函数套了一个函数，且这个内部函数使用到了外部函数中的变量，这个时候就形成了闭包。有什么用呢？其中一个用处就如上面代码所示，能够让 makeFunc 函数外面也能访问 name 这个局部变量。换句话说，闭包缓存了数据，延长了作用域链。 Kyle Simpson编写的You-Dont-Know-JS中对闭包的总结我觉得很精髓： 闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。 闭包的特性 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 闭包的用途缓存数据，延长作用域链一个经典的例子，给 ul&gt;li 下面的每个 li 节点添加点击事件，让其弹出当前 li 元素的索引：1234567891011121314&lt;ul id="testUL"&gt; &lt;li&gt; index = 0&lt;/li&gt; &lt;li&gt; index = 1&lt;/li&gt; &lt;li&gt; index = 2&lt;/li&gt; &lt;li&gt; index = 3&lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var nodes = document.getElementsByTagName("li"); for (var i = 0; i &lt; nodes.length; i += 1) &#123; nodes[i].onclick = function () &#123; console.log(i); &#125; &#125;&lt;/script&gt; 运行上述代码后就会发现，每次打印的结果都显示为4，而不是真正的索引值。这是因为点击事件的匿名函数发生在for循环之后，而for循环执行完毕时 i 的值就为4，所以点谁都是同样的结果。那么这个时候就能通过立即执行函数 + 闭包的方法解决此问题：1234567891011&lt;script type="text/javascript"&gt; var nodes = document.getElementsByTagName("li"); for (var i = 0; i &lt; nodes.length; i += 1) &#123; nodes[i].onclick = (function (i) &#123; // 1. IIFE创建一个函数作用域 return function () &#123; // 4. 返回这个匿名函数，延长作用域链 // 3. 内部嵌套的匿名函数使用到了IIFE的参数i，形成闭包 console.log(i); &#125; &#125;)(i); // 2. 给IIFE传递每次for循环的i &#125;&lt;/script&gt; 这个时候触发click事件，打印的值就是li元素的索引了。 用闭包模拟私有变量和方法使用闭包定义能访问私有函数和私有变量的公有函数（也叫做模块模式） 123456789101112131415161718192021222324var counter = (function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125;; &#125;)(); // 立即执行函数console.log(counter.value()); // logs 0counter.increment();counter.increment();console.log(counter.value()); // logs 2counter.decrement();console.log(counter.value()); // logs 1 环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。它俩都无法在匿名函数外部直接访问。必须通过匿名包装器返回的对象的三个公共函数访问。 内存泄漏其实闭包并不会造成内存泄漏，现在的垃圾回收机制已经很成熟了。但早期的IE（ie4-ie6）版本里，对宿主对象（也就是document对象）采用是引用计数的垃圾回收机制，闭包导致内存泄漏的一个原因就是这个算法的一个缺陷。循环引用会导致没法回收，这个循环引用只限定于有宿主对象参与的循环引用，而js对象之间即使形成循环引用，也不会产生内存泄漏，因为对js对象的回收算法不是计数的方式：12345678910111213141516171819202122232425function closure()&#123; var oDiv = document.getElementById('oDiv');//oDiv用完之后一直驻留在内存中 oDiv.onclick = function () &#123; alert('oDiv.innerHTML');//这里用oDiv导致内存泄露 &#125;;&#125;// 以上代码创建了一个作为 div 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。// 由于匿名函数保存了一个对closure()的活动对象的引用，因此就会导致无法减少 div 的引用数。// 只要匿名函数存在，element 的引用数至少也是1，因此它所占用的内存就永远不会被回收closure();//最后应将oDiv解除引用来避免内存泄露function closure()&#123; var oDiv = document.getElementById('oDiv'); var test = oDiv.innerHTML; oDiv.onclick = function () &#123; alert(test); &#125;; oDiv = null;&#125;// 解决办法: 把 oDiv.innerHTML 的一个副本保存在一个变量中，// 从而消除闭包中该变量的循环引用,同时将 oDiv 变量设为null。]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组有哪些常用方法]]></title>
    <url>%2Fposts%2F21501%2F</url>
    <content type="text"><![CDATA[改变原数组的方法splice() 添加/删除数组元素 splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目 array.splice(index,howmany,item1,…..,itemX) index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX： 可选。向数组添加的新项目。 返回值: 如果有元素被删除,返回包含被删除项目的新数组。 删除元素1234567// 从数组下标0开始，删除3个元素let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0, 3); // [1,2,3]console.log(a); // [4,5,6,7]// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7let item = a.splice(-1, 3); // [7] 删除并添加123456789// 从数组下标0开始，删除3个元素，并添加元素'添加'let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0,3,'添加'); // [1,2,3]console.log(a); // ['添加',4,5,6,7]// 从数组最后第二个元素开始，删除3个元素，并添加两个元素'添加1'、'添加2'let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-2,3,'添加1','添加2'); // [6,7]console.log(b); // [1,2,3,4,5,'添加1','添加2'] 不删除只添加1234567let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0,0,'添加1','添加2'); // [] 没有删除元素，返回空数组console.log(a); // ['添加1','添加2',1,2,3,4,5,6,7]let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-1,0,'添加1','添加2'); // [] 没有删除元素，返回空数组console.log(b); // [1,2,3,4,5,6,'添加1','添加2',7] 在最后一个元素的前面添加两个元素 sort() 数组排序 定义: sort()方法对数组元素进行排序，并返回这个数组。 参数可选: 规定排序顺序的比较函数。 默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用toString()方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。 不传参1234567// 字符串排列 看起来很正常var a = ["Banana", "Orange", "Apple", "Mango"];a.sort(); // ["Apple","Banana","Mango","Orange"]// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的var a = [10, 1, 3, 20,25,8];console.log(a.sort()) // [1,10,20,25,3,8]; 比较函数的两个参数： sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素： 若比较函数返回值&lt;0，那么a将排到b的前面; 若比较函数返回值=0，那么a 和 b 相对位置不变； 若比较函数返回值&gt;0，那么b 排在a 将的前面； 数字升降序12345678910var array = [10, 1, 3, 4, 20, 4, 25, 8]; array.sort(function(a,b)&#123; return a-b;&#125;);console.log(array); // [1,3,4,4,8,10,20,25];array.sort(function(a,b)&#123; return b-a;&#125;);console.log(array); // [25,20,10,8,4,4,3,1]; pop() 删除一个数组中的最后的一个元素 定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。 123let a = [1,2,3];let item = a.pop(); // 3console.log(a); // [1,2] shift() 删除数组的第一个元素 定义: shift()方法删除数组的第一个元素，并返回这个元素。 123let a = [1,2,3];let item = a.shift(); // 1console.log(a); // [2,3] push() 向数组的末尾添加元素 定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 参数: item1, item2, …, itemX ,要添加到数组末尾的元素 123let a = [1,2,3];let item = a.push('末尾', '233'); // 5console.log(a); // [1,2,3,'末尾', '233'] unshift() 定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。 参数: item1, item2, …, itemX ,要添加到数组开头的元素 123let a = [1, 2, 3];let item = a.unshift('开头', '开头2'); // 5console.log(a); // [ '开头', '开头2', 1, 2, 3 ] reverse() 颠倒数组中元素的顺序 定义: reverse() 方法用于颠倒数组中元素的顺序。 123let a = [1,2,3];a.reverse(); console.log(a); // [3,2,1] 不改变原数组的方法slice() 浅拷贝数组的元素 定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。 语法：array.slice(begin, end); 12345678910111213let a= ['hello','world'];let b=a.slice(0,1); // ['hello']// 新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。// 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。a[0]='改变原数组';console.log(a,b); // ['改变原数组','world'] ['hello']let a= [&#123;name:'OBKoro1'&#125;];let b=a.slice();console.log(b,a); // [&#123;"name":"OBKoro1"&#125;] [&#123;"name":"OBKoro1"&#125;]// a[0].name='改变原数组';// console.log(b,a); // [&#123;"name":"改变原数组"&#125;] [&#123;"name":"改变原数组"&#125;] join() 数组转字符串 定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。 语法: array.join(str) 12345678910111213let a= ['hello','world'];let str=a.join(); // 'hello,world'let str2=a.join('+'); // 'hello+world'let a= [['OBKoro1','23'],'test'];let str1=a.join(); // OBKoro1,23,testlet b= [&#123;name:'OBKoro1',age:'23'&#125;,'test'];let str2 = b.join(); // [object Object],test// 对象转字符串推荐JSON.stringify(obj);// 结论：// join()/toString()方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),// 如果是对象的话，对象会被转为[object Object]字符串。 join() 数组转字符串 定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。 语法: array.join(str) 12345678910111213let a= ['hello','world'];let str=a.join(); // 'hello,world'let str2=a.join('+'); // 'hello+world'let a= [['OBKoro1','23'],'test'];let str1=a.join(); // OBKoro1,23,testlet b= [&#123;name:'OBKoro1',age:'23'&#125;,'test'];let str2 = b.join(); // [object Object],test// 对象转字符串推荐JSON.stringify(obj);// 结论：// join()/toString()方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),// 如果是对象的话，对象会被转为[object Object]字符串。 concat 定义： 方法用于合并两个或多个数组，返回一个新数组。 语法：var newArr =oldArray.concat(arrayX,arrayX,……,arrayX) 参数：arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。 1234567891011121314let a = [1, 2, 3];let b = [4, 5, 6];//连接两个数组let newVal=a.concat(b); // [1,2,3,4,5,6]// 连接三个数组let c = [7, 8, 9]let newVal2 = a.concat(b, c); // [1,2,3,4,5,6,7,8,9]// 添加元素let newVal3 = a.concat('添加元素',b, c,'再加一个'); // [1,2,3,"添加元素",4,5,6,7,8,9,"再加一个"]// 合并嵌套数组 会浅拷贝嵌套数组let d = [1,2 ];let f = [3,[4]];let newVal4 = d.concat(f); // [1,2,3,[4]] ES6扩展运算符...合并数组123let a = [2, 3, 4, 5]let b = [ 4,...a, 4, 4]console.log(a,b); // [2, 3, 4, 5] [4,2,3,4,5,4,4] indexOf() 查找数组是否存在某个元素，返回下标 定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 p.s. 字符串也有此方法，要注意当 ‘lance’.indexOf(‘’) 一个空字符串时，返回0而不是-1 语法：array.indexOf(searchElement,fromIndex) 参数： searchElement(必须):被查找的元素 fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。 严格相等的搜索: 数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等===搜索元素，即数组元素要完全匹配才能搜索成功。 注意：indexOf()不能识别NaN 1234let a=['啦啦',2,4,24,NaN]console.log(a.indexOf('啦')); // -1 console.log(a.indexOf('NaN')); // -1 console.log(a.indexOf('啦啦')); // 0 lastIndexOf() 查找指定元素在数组中的最后一个位置 定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找） 语法：arr.lastIndexOf(searchElement,fromIndex) 参数: searchElement(必须): 被查找的元素 fromIndex(可选): 逆向查找开始位置，默认值数组的 长度-1，即查找整个数组。 关于fromIndex有三个规则: 正值。如果该值大于或等于数组的长度，则整个数组会被查找。 负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找) 负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 12345let a=['OB',4,'Koro1',1,2,'Koro1',3,4,5,'Koro1']; // 数组长度为10// let b=a.lastIndexOf('Koro1',4); // 从下标4开始往前找 返回下标2// let b=a.lastIndexOf('Koro1',100); // 大于或数组的长度 查找整个数组 返回9// let b=a.lastIndexOf('Koro1',-11); // -1 数组不会被查找let b=a.lastIndexOf('Koro1',-9); // 从第二个元素4往前查找，没有找到 返回-1 ES7 includes() 查找数组是否包含某个元素 返回布尔 定义： 返回一个布尔值，表示某个数组是否包含给定的值 语法：array.includes(searchElement,fromIndex=0) 参数： searchElement(必须):被查找的元素 fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。 includes方法是为了弥补indexOf方法的缺陷而出现的: indexOf方法不能识别NaN indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观 12345let a=['OB','Koro1',1,NaN];// let b=a.includes(NaN); // true 识别NaN// let b=a.includes('Koro1',100); // false 超过数组长度 不搜索// let b=a.includes('Koro1',-3); // true 从倒数第三个元素开始搜索 // let b=a.includes('Koro1',-100); // true 负值绝对值超过数组长度，搜索整个数组]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去除图片上下左右间隙]]></title>
    <url>%2Fposts%2F31251%2F</url>
    <content type="text"><![CDATA[情景当在定宽父容器下有多张图片顺序排列时，图片的上下左右之间都有间隙： See the Pen KEBmRP by JingW (@JingW) on CodePen. 原因 左右：因为 img 是 inline-block 元素，元素代码之间有『换行（回车），空格，tab』时会产生左右间隙。 上下：行内元素默认与父容器基线对齐，而基线与父容器底部有一定间隙，所以上下图片间有间隙。 解决方案 移除上下间隙： img本身设置 display: block; 父元素设置 font-size: 0; （基线与字体大小有关，字体为零，基线间就没距离了） img本身设置 vertical-align: bottom;（让inline-block 的 img 与每行的底部对齐） 移除左右间距： 行内元素间不要有换行，连成一行写消除间隙（阅读性差，不推荐） 第一行img结尾写上 &lt;!-- ，第二行img开头跟上 --&gt; 。即利用注释消除间距 父元素 font-size: 0]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何清除浮动]]></title>
    <url>%2Fposts%2F12906%2F</url>
    <content type="text"><![CDATA[为什么要清除浮动其实浮动（e.g. float: left;）本质上是用来做文字混排的，但却被我们拿来做布局，这个时候虽然实现了某些效果，但也带来了不少副作用。 由于浮动元素不再占有原文档流的位置，所以它会对后续元素的排版带来影响（无视浮动元素，就当它不存在过）。因此我们很多时候要做的，就是消除浮动元素造成的影响。清除浮动的本质主要是为了解决父元素因为子元素浮动造成的内部高度为0的问题。 clear清除浮动的核心css属性是 clear ，基本语法如下： 123选择器: &#123; clear: 属性值;&#125; 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 清除浮动常见方案额外标记法在浮动元素后面添加一个空标签，例如： 12&lt;div style="float: left;"&gt;&lt;/div&gt;&lt;div style="clear: both;"&gt;&lt;/div&gt; 优点：通俗易懂，书写方便缺点：加入了过多的没有实际含义的额外标签，结构化差。 父元素添加overflow通过触发BFC达到清除浮动的效果。（p.s. 对bfc不了解可以看这篇文章） 123.parent &#123; overflow: hidden;&#125; 优点：代码简洁缺点：超出的内容会被隐藏 before和after双伪元素方案1234567891011.clearfix:before,.clearfix:after &#123; content:""; display: table; /* 触发BFC清除浮动 */&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 优点：代码简洁缺点：IE6-7不支持:after，需要使用 zoom: 1 触发 hasLayout 使用after伪元素（我平常使用的）1234567891011.clearfix::after &#123; content: "."; display: block; height: 0; visibility: hidden; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; /* IE6、7 专有 */ 使用方式：给浮动元素的父元素添加一个class类：clearfix优点：一次书写多处使用，并且符合闭合浮动思想，结构语义化正确缺点：IE6-7不支持:after，需要使用 zoom: 1 触发 hasLayout注意：content:&quot;.&quot; 内容尽量不为空，可以跟一个小点，否则在firefox 7.0前的版本会生成空格 :after 和 ::after 的区别:before、:after 在旧版本里是伪元素，CSS3的规范里 “:” 用来表示伪类，”::” 用来表示伪元素，但是在高版本浏览器下 :before、:after 会被自动识别为 ::before、::after ，这样做的目的是用来做兼容处理。 相同点伪类对象，用来设置对象前的内容:before 和 ::before 写法是等效的 不同点:before 是 css2 的写法，::before 是 css3 的写法:before 兼容性比 ::before要好 注意伪类元素必须要配合 content 属性一起使用，否则无效伪类元素是css渲染层加入的，不能通过js来操作]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>清除浮动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC的理解与应用]]></title>
    <url>%2Fposts%2F9722%2F</url>
    <content type="text"><![CDATA[定义先上MDN上对 BFC 的定义： 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 ———— BFC | MDN 不知道别人看完这段定义有何感受，反正我是懵逼的。不过我在这儿还是建议各位认真阅读上面给出的MDN链接至少两遍，这能让你对一个陌生的概念有一个基本的认知。 理解这里谈下我对BFC的理解：BFC其实是一个独立的，与外界隔离了的容器，容器里面的子元素不会影响到外面的元素，外面的也同样不会影响到容器内部的元素。我们可以利用这个特性，来解决一些布局上的问题。 BFC触发条件BFC的触发条件有很多，想要知道所有细节可以移步上面给出的 MDN 链接。这里我只列出一些常见触发条件： 根元素（HTML元素） 浮动元素（float不为none） 绝对定位元素（position 为 absolute 或 fixed） display 为 block, inline-block, flex, inline-flex, list-item, table overflow 值不为 visible 的块元素 BFC布局特性对于一个BFC容器来说： 内部相邻的两个元素垂直方向上的 margin 会发生重叠 不会与外界的浮动元素产生交集，而是紧贴浮动元素的边缘 元素从容器的顶端开始垂直地一个接一个地排列 每一个元素的左外边缘（margin-left）会触碰到容器的左边缘（border-left）（如果设置了容器内部的元素从右到左的格式排布，则触碰的是右边缘） 在计算它的高度时，还会检测内部浮动或者定位元素的高度 实际应用清除浮动利用BFC “在计算它的高度时，还会检测内部浮动或者定位元素的高度” 这条特性，我们可以触发父元素的BFC来清除子元素浮动带来的影响。常见的用法是给父元素设置 overflow: hidden 样式（如果考虑IE6版本，还需设置 zoom: 1，因为IE6不支持 overflow: hidden 来清除浮动）： See the Pen 利用BFC清除浮动 by JingW (@JingW) on CodePen. 解决外边距合并问题如果看上面标题不知道在说什么，请很戳这里了解详情。由于属于同一个BFC的两个相邻盒子的垂直margin会发生重叠，那么我们可以隔离开这两个元素，让它们不属于同一个BFC，这样就不会发生margin重叠了。 See the Pen 解决外边距合并问题 by JingW (@JingW) on CodePen. 两栏布局，右边宽度自适应我们常常在开发中有这样类似的需求：两栏布局，左边定宽，右边自适应。这时我们就可以利用BFC特性来实现需求：左边设置定宽+左浮动；右边给自己加上 overflow: hidden 。原理就是：给元素设置BFC后，为了和浮动元素不产生任何交集，它会顺着浮动元素的边缘形成自己的封闭上下文。直接上代码看效果： See the Pen 利用BFC实现两栏布局 by JingW (@JingW) on CodePen. 以上是我对BFC的一些理解以及实际应用，希望能够帮助大家了解BFC这个听起来摸不着头脑的东西。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三栏布局方案(圣杯+双飞翼)]]></title>
    <url>%2Fposts%2F55613%2F</url>
    <content type="text"><![CDATA[圣杯布局步骤一 - HTML框架搭建 &amp; 初始化CSS首先把基本框架搭起来（注意中间部分放最前面）： 12345&lt;div class="container"&gt; &lt;div class="center"&gt;我是中间&lt;/div&gt; &lt;div class="left"&gt;我是左边&lt;/div&gt; &lt;div class="right"&gt;我是右边&lt;/div&gt;&lt;/div&gt; 接下来是初始化样式。left, right宽度分别设置为100px和200px；然后设置container的 padding-left: 100px + padding-right: 200px 来占据两侧填充；center宽度设为100%，这样能够自适应剩下的宽度。再让所有子元素左浮动。代码如下： 12345678910111213141516171819202122232425.container &#123; padding: 0 200px 0 100px; /* 左边100， 右边200*/ background-color: #e1e1e1; height: 300px; /* 为了看效果，给个300px把高度撑起来 */&#125;.left, .center, .right &#123; float: left; height: 100%;&#125;.center &#123; width: 100%; /* 占据父元素剩下的宽度*/ background-color: lightblue;&#125;.left &#123; width: 100px; background-color: pink;&#125;.right &#123; width: 200px; background-color: yellow;&#125; 此时的页面效果： 步骤二 - 让left占据最左列为了让left能越过center，我们先给它设置一个 -100% 的左边距。这个100%是在container中的宽度，也就是center的宽度： 123456.left &#123; margin-left: -100%; width: 100px; /*为了看left和center的重叠效果，暂时bgc设为半透明*/ background-color: rgba(255,204,204,.6);&#125; 页面效果： 此时，我们已经让left从“第二行”升到了“第一行”，为了让它靠到最左侧，不与center重叠，可以给它设置相对定位，然后给个 left: -100px ，让它定位到container最左侧： 123456789.left &#123; /* 设置相对定位 */ position: relative; /* 靠到最左侧 */ left: -100px; margin-left: -100%; width: 100px; background-color: pink;&#125; 页面效果： 步骤三 - 让right占据最右列定位好了left，也是时候让right呆在最右边来填充位置了，我们继续使用负margin： 12345.right &#123; width: 200px; margin-right: -200px; background-color: yellow;&#125; 页面效果： 步骤四 - 给container设置min-width看起来已经实现了不是吗？但我们还差最后一步，给container设置一个 min-width: 100px （就是左列的宽度），否则当浏览器缩小到一定程度时，这个布局可能会被破坏。原因简单来讲就是：“由于设置了相对定位，所以当left原来的位置和right的位置产生重叠时，由于浮动的原因一行放不下就会换行”。所以布局就被打乱了。 123456.container &#123; min-width: 100px; background-color: #e1e1e1; padding: 0 200px 0 100px; height: 300px;&#125; 完整代码 + 最终效果这样，我们就实现了圣杯布局，完整代码和效果见下： See the Pen 三栏布局 - 圣杯布局 by JingW (@JingW) on CodePen. 双飞翼布局如果上面圣杯布局你已经理解并自己实践了一遍，那么这里的双飞翼布局你也应该不再话下。跟着我一起撸一遍代码吧。 步骤一 - HTML框架搭建 &amp; 初始化CSS首先搭建html，仔细观察下方代码你会发现，双飞翼布局在html上面有一点和圣杯布局有差别，那就是双飞翼在center里又套了一个div。到后面你就会知道这样设置的目的。 12345&lt;div class="container"&gt; &lt;div class="center"&gt;&lt;div&gt;我是中间&lt;/div&gt;&lt;/div&gt; &lt;div class="left"&gt;我是左边&lt;/div&gt; &lt;div class="right"&gt;我是右边&lt;/div&gt;&lt;/div&gt; 然后编写初始样式。left定宽100；right定宽200；left, right, center全部设置左浮动。其他例如设置颜色高度等等直接看下方代码： 1234567891011121314151617181920212223.container &#123; background-color: #e1e1e1; height: 300px;&#125;.center &#123; background-color: lightblue;&#125;.left &#123; width: 100px; background-color: pink;&#125;.right &#123; width: 200px; background-color: yellow;&#125;.left, .center, .right &#123; float: left; height: 100%;&#125; 效果如下： 步骤二 - 设置center为100%宽将center的宽度设为100%，这样会把left，right“挤”到第二行： 1234.center &#123; width: 100%; background-color: lightblue;&#125; 效果如下： 步骤三 - 分别让left,right回到最左边和最右边接着，给left设置 margin-left: -100% 回到最左边，给right设置 margin-left: -200px 回到最右边。此时center和left,right都有重叠区域，为了看效果，设置了半透明背景颜色。 1234567891011.left &#123; width: 100px; margin-left: -100%; background-color: pink;&#125;.right &#123; width: 200px; margin-left: -200px; background-color: yellow;&#125; 效果如下： 步骤四 - 给center的子div设置左右margin其实上面的效果图已经实现了三栏布局中间自适应。但有个问题是center左右部分区域会被遮挡，这个时候在步骤一提到的center子div的作用就体现出来了，我们可以给它设置一个左右的margin值，分别等于left的宽和right的宽，消除掉重叠的副作用。 1234.center div &#123; /* 左margin100，右margin200 */ margin: 0 200px 0 100px;&#125; 效果如下： 步骤五 - 给container设置min-width最后，给container设置一个min-width，让container最小宽度不小于left宽+right宽 12345.container &#123; min-width: 300px; background-color: #e1e1e1; height: 300px;&#125; 大功告成~ 完整代码 + 最终效果 See the Pen 三栏布局 - 双飞翼布局 by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两栏布局方案汇总]]></title>
    <url>%2Fposts%2F44541%2F</url>
    <content type="text"><![CDATA[记录下常见的两栏布局方式。 左边定宽，右边自适应模拟table父元素 display: table ，子元素左右 table-cell ，左边定宽。 See the Pen 两栏布局（左定右自适应）模拟table by JingW (@JingW) on CodePen. 左浮 + 右Margin子元素的左边浮动脱标，右边设置 margin-left: 左边元素宽度 See the Pen 两栏布局（左定右自适应）子元素绝对定位 by JingW (@JingW) on CodePen. 左浮 + 右BFC子元素左边设置浮动+定宽，右边子元素设置 overflow: hidden 触发自身BFC See the Pen 两栏布局（左定右自适应）左浮 + 右BFC by JingW (@JingW) on CodePen. 子绝父相子绝父相，左边 top, left: 0，右边 top, right: 0，left等于左边宽度。 See the Pen 两栏布局（左定右自适应）子绝父相 by JingW (@JingW) on CodePen. flex布局父元素 display: flex ，左边定宽，右边 flex: 1。 See the Pen 两栏布局（左定右自适应）flex by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垂直居中方案汇总]]></title>
    <url>%2Fposts%2F12733%2F</url>
    <content type="text"><![CDATA[这里汇总了常见的元素居中方案。 水平居中行内元素水平居中核心：给父元素添加 text-align: center See the Pen 行内元素水平居中 by JingW (@JingW) on CodePen. 块级元素水平居中核心：子元素自身 margin: 0 auto; See the Pen 块元素水平居中 by JingW (@JingW) on CodePen. 多个div水平居中传统方案核心：父元素设置 text-align: center ，子元素设置 inline-block See the Pen 多个div水平居中 - 传统方案 by JingW (@JingW) on CodePen. Flex方案核心：父元素 display: flex + justify-content: center + align-items: center See the Pen 多个div水平居中-flex by JingW (@JingW) on CodePen. 水平垂直居中table自带水平垂直居中核心：使用 table&gt;tr&gt;td 布局 See the Pen div水平垂直居中 - table by JingW (@JingW) on CodePen. 模拟table核心：父元素 display: table ，子元素 display: table-cell + vertical-align: middle See the Pen div水平垂直居中 - 模拟table by JingW (@JingW) on CodePen. 子绝父相 + 子元素 margin:auto核心：子元素相对于父元素绝对定位，top、right、bottom、left 都设为0，margi设为auto See the Pen div水平垂直居中 - 子绝父相 + Margin Auto by JingW (@JingW) on CodePen. 子绝父相 + 负margin核心：子元素相对于父元素绝对定位，top、left设为50%，margin相对自身宽/高一半 See the Pen div水平垂直居中 - 子绝父相 + 负Margin by JingW (@JingW) on CodePen. 子绝父相 + translate核心：子元素相对于父元素绝对定位，top、left设为50%，此时子元素左上角在父元素中心，然后让子元素向左上角位移自身宽度的一半 See the Pen div水平垂直居中 - 子绝父相 + translate by JingW (@JingW) on CodePen. Flex布局父元素 display: flex，justify-content 和 align-items 都设为 center 实现垂直居中 See the Pen div水平垂直居中 - flex by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对HTML语义化的理解]]></title>
    <url>%2Fposts%2F2906%2F</url>
    <content type="text"><![CDATA[对HTML语义化的理解核心：用正确的标签做正确的事情 利与开发：方便代码的阅读和维护 利于SEO：方便爬虫根据 语义标签 确定 页面结构 和 关键字 的权重 常见语义化标签一图胜千言： 元素细节： &lt;main&gt; 存放每个页面独有的内容。每个页面上只能用一次 &lt;main&gt;，且直位于 &lt;body&gt;中。最好不要把它嵌套进其它元素。 &lt;article&gt; 包围的内容即一篇文章，与页面其它部分无关（比如一篇博文）。 &lt;section&gt; 与 &lt;article&gt; 类似，但 &lt;section&gt; 更适用于组织页面使其按功能（比如迷你地图、一组文章标题和摘要）分块。一般的最佳用法是：以 标题 作为开头；也可以把一篇 &lt;article&gt; 分成若干部分并分别置于不同的 &lt;section&gt; 中，也可以把一个区段 &lt;section&gt; 分成若干部分并分别置于不同的 &lt;article&gt; 中，取决于上下文。 &lt;aside&gt; 包含一些间接信息（术语条目、作者简介、相关链接，等等）。 &lt;header&gt; 是简介形式的内容。如果它是 &lt;body&gt; 的子元素，那么就是网站的全局页眉。如果它是 &lt;article&gt; 或&lt;section&gt; 的子元素，那么它是这些部分特有的页眉（此 &lt;header&gt; 非彼 标题）。 &lt;nav&gt; 包含页面主导航功能。其中不应包含二级链接等内容。 &lt;footer&gt; 包含了页面的页脚部分。 来源：文档与网站架构]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>语义化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo搭建个人博客]]></title>
    <url>%2Fposts%2F43303%2F</url>
    <content type="text"><![CDATA[介绍利用 Hexo 在 GitHub 上搭建个人博客。 准备工作你的电脑需要安装下面两个应用程序： NodeJS 如何安装 Git 如何安装 重要步骤安装Hexo安装文档 插件安装 hexo-abbrlink 介绍 &amp;&amp; 此插件诞生原因 hexo-deployer-git 将本地博客部署到GitHub 如何安装和使用 hexo-server npm install hexo-server –save 服务器模块。在启动期间，Hexo 会监视文件变动并自动更新 使用第三方主题 Next Yilia 创建分类功能运行： 1hexo new page &quot;categories&quot; p.s. 命名为categories原因是 categories 在next主题中是一个关键词对应着分类。 在主站根目录下,也就是你hexo的目录下找到 /source/categories/index.md，打开后的效果类似下方代码： 123456---title: categories #本页标题date: 2019-03-13 23:02:50 #创建日期type: "categories" #分类属于comments: false #如果有启用多说 或者 Disqus评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false--- 接着在 themes 主题文件夹下找到 next 文件夹，修改 _config.yml 文件： 123456menu: home: / || home # 地址路径 | 导航栏对应的图标 about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 然后在命令行输入添加文章命令： 1hexo new '你想要创建的文章名称' 根目录(主站目录下)/source/_posts/上一步创建的文章名称.md，双击打开： 123456---title: 文章标题date: 2019-03-13 23:13:23tags: html #属于哪个标签categories: interview #属于哪个分类--- 参考：分类和标签p.s. 如果想要实现父子分类，可以查看上方链接的评论 创建标签功能打开命令行，进入博客所在文件夹。执行命令：1hexo new page tags 成功后会有一个路径提示1INFO Created: ~/Documents/blog/source/tags/index.md 找到对应的文件打开1234---title: 标签date: 2019-03-14 00:02:05--- 添加type: “tags”到内容中，添加后是这样的：12345---title: 标签date: 2019-03-14 00:03:52type: 'tags'--- 打开你的文章页面：123456---title: jQuery对表单的操作及更多应用date: 2019-03-14 00:03:55categories: 前端 tags: jQuery #如果想要多个标签可以 tags: [jQuery, 表格, 表单验证]--- 不蒜子统计功能NexT主题集成了不蒜子统计功能，在NexT配置文件中找到关键词 busuanzi_count: ，把 enable 设置为 true p.s. 除此之外，如果设置为true后仍然无效，且打开控制台显示js报错。有可能是不蒜子链接失效的原因，需要在Next主题配置文件位置：1themes\next\layout\_third-party\analytics\busuanzi-counter.swig 修改script链接为：1&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 评论功能使用 Valine 参考： 评论系统从Disqus到Valine Valine - 一款快速、简洁且高效的无后端评论系统。 常用配置 Hexo瞎折腾系列(4) - 站点首页不显示文章全文 常用命令12345678910111213141516171819// npm全局安装Hexonpm install -g hexo-cli // 新建Hexo项目hexo init &lt;folder&gt;cd &lt;folder&gt;npm install// 新建文章hexo new '文章名'// 启动服务器hexo server -p 5000// 生成静态文件hexo generate --watch// 部署hexo clean &amp;&amp; hexo deploy 相关配置及资源 Hexo+NexT 打造一个炫酷博客 这应该是最全的hexo博客搭建以及next美化教程 给hexo添加Valine评论功能 hexo next 解决unpkg.com加载慢 LeanCloud Hexo搭建GitHub博客—打造炫酷的NexT主题–高级(四) Hexo NexT主题代码块添加复制功能]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
