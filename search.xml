<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML5的自定义属性]]></title>
    <url>%2Fposts%2F39974%2F</url>
    <content type="text"><![CDATA[在 HTML5 中我们可以自定义属性，其格式为 data-*=&quot;&quot; 1234567891011121314&lt;div id="demo" data-my-name="sw" data-age="10"&gt;&lt;script&gt;/* Node.dataset 是以对象形式存在的，当我们为同一个 DOM 节点指定了多个自定义属性时， Node.dataset 则存储了所有的自定义属性的值。 */var demo = document.querySelector("#demo");//获取//注：当我们如下格式设置时，则需要以驼峰格式才能正确获取var name = demo.dataset['myName'];var age = demo.dataset['age'];//设置demo.dataset['name'] = 'web developer';&lt;script/&gt; 资源mdn - data-*]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何使用webpack4]]></title>
    <url>%2Fposts%2F47462%2F</url>
    <content type="text"><![CDATA[为什么要使用 webpack网页中引用的常见静态资源 类型 静态资源 JS .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS .css .less .sass .scss Images .jpg .png .gif .bmp .svg 字体文件（Fonts） .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 引入过多静态资源有什么问题？ 网页加载速度慢， 因此我们要发起很多的二次请求 还要处理错综复杂的依赖关系 如何解决上述两个问题 合并、压缩、精灵图、图片的 Base64 编码 可以使用 requireJS、也可以使用 webpack 来解决各个包之间的复杂依赖关系 如何完美实现上述的2种解决方案 使用 Gulp， 基于 task 任务 使用 webpack， 基于整个项目进行构建 借助于 webpack 这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能 简介webpack 是基于 Node.js 开发出来的一个前端项目打包工具。 安装 &amp; 初步使用 如果第一次安装，需要全局安装 『 webpack &amp;&amp; webpack-cli 』: 1npm install -g webpack webpack-cli 运行 npm init -y 初始化项目 创建项目目录结构 123456789101112├── dist├── package-lock.json├── package.json└── src ├── css │ └── index.css ├── images │ └── cheer.gif（各位自行更换） ├── index.html ├── js │ └── index.js └── main.js 项目根文件夹下 npm i webpack webpack-cli -D 使用 npm i jquery -D 安装 jQuery 类库 index.js 中包含的元素： 123456&lt;ul id="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt; 创建 main.js 并书写隔行变色的代码逻辑： 1234567// 导入jquery类库import $ from 'jquery'// 设置偶数行背景色，索引从0开始，0是偶数$('#list li:even').css('backgroundColor','lightblue');// 设置奇数行背景色$('#list li:odd').css('backgroundColor','pink'); 直接在页面上引用 main.js 会报错，因为浏览器不认识 import 这种高级的JS语法，需要使用 webpack 进行处理，webpack 默认会把这种高级的语法转换为低级的浏览器能识别的语法 运行 webpack 入口文件路径 模式 对 main.js 进行处理： 123webpack src/main.js --mode development或者webpack src/main.js --mode production 不过每次都要输入这个命令，非常麻烦，我们可以在package.json的scripts中加入两个指令成员： 12"dev": "webpack src/main.js --mode development","build": "webpack src/main.js --mode production" 以后只需要在命令行执行npm run dev便相当于执行webpack --mode development，执行npm run build便相当于执行webpack --mode production。 使用配置文件简化打包命令 在项目根目录中创建webpack.config.js 由于运行 webpack 命令的时候，webpack 需要指定入口文件和输出文件的路径，所以我们需要在 webpack.config.js 中配置这两个路径： 1234567891011121314// 导入处理路径的模块const path = require('path')// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; // 入口，表示，要使用 webpack 打包哪个文件 entry: path.join(__dirname, './src/main.js'), output: &#123; // 指定 打包好的文件，输出到哪个目录中去 path: path.join(__dirname, './dist/'), // 输出的文件的名称 filename: 'bundle.js', &#125;&#125; 由于此时已经配置了入口文件，package.json 中的dev以及build可简化为： 12"dev": "webpack --mode development","build": "webpack --mode production" 实现 webpack 实时打包构建webpack 提供了一个可选的本地开发服务器，这个本地服务器基于 node.js 构建，它是一个单独的组件，在 webpack 中进行配置之前需要单独安装它作为项目依赖： 1npm i webpack-dev-server -D devServer 作为 webpack 配置选项中的一项，以下是它的一些配置选项: contentBase ：设置服务器所读取文件的目录，当前我们设置为”./dist” port ：设置端口号，如果省略，默认为8080 inline ：设置为true，当源文件改变时会自动刷新页面 historyApiFallback ：设置为true，所有的跳转将指向index.html 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用 webpack-dev-server 来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行 npm i webpack-dev-server -D 安装到开发依赖 安装完成之后，修改之前在 package.json 中添加的dev指令： 1"dev": "webpack-dev-server" 在 webpack.config.js 中配置mode为development： 1234module.exports = &#123; ..., mode: 'development'&#125; 运行指令 webpack-dev-server ，发现可以进行实时打包，但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中。 把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 这个时候访问webpack-dev-server启动的 http://localhost:8080/ 网站，发现是一个文件夹的面板，需要点击到 src 目录下，才能打开我们的 index 首页，此时引用不到 bundle.js 文件，需要修改 index.html 中 script 的 src 属性为:&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 为了能在访问 http://localhost:8080/ 的时候直接访问到 index 首页，可以使用 --contentBase src 指令来修改dev指令，指定启动的根目录： 1"dev": "webpack-dev-server --contentBase src", 插件（Plugins）插件（Plugins）是用来拓展 webpack 功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders 和 Plugins 常常被弄混，但是它们其实是完全不同的东西，可以这么来说，loaders 是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。 使用 html-webpack-plugin 插件配置启动页面由于使用 --contentBase 指令的过程比较繁琐，需要指定启动的目录，同时还需要修改 index.html 中 script 标签的 src 属性，所以推荐使用 html-webpack-plugin 插件配置启动页面。 运行 npm i html-webpack-plugin -D 安装到开发依赖 修改 webpack.config.js 配置文件如下： 1234567891011121314151617181920212223// 导入处理路径的模块const path = require('path')// 导入自动生成HTMl文件的插件const htmlwebpackPlugin = require('html-webpack-plugin');// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; // 入口，表示，要使用 webpack 打包哪个文件 entry: path.join(__dirname, './src/main.js'), output: &#123; // 指定 打包好的文件，输出到哪个目录中去 path: path.join(__dirname, './dist/'), // 输出的文件的名称 filename: 'bundle.js', &#125;, plugins: [ // 添加plugins节点配置插件 new htmlwebpackPlugin(&#123; template: path.join(__dirname, './src/index.html'), //模板路径 filename: 'index.html' //自动生成的HTML文件的名称 &#125;) ], mode: 'development'&#125; 修改 package.json 中 script 节点中的dev指令如下：dev&quot;: &quot;webpack-dev-server&quot; 将 index.html 中 script 标签注释掉，因为 html-webpack-plugin 插件会自动把 bundle.js 注入到 index.html 页面中。 实现自动打开浏览器、热更新和配置浏览器的默认端口号方式1：修改 package.json 的 script 节点如下，其中 --open 表示自动打开浏览器， --port 4321 表示打开的端口号为 4321 ，--hot 表示启用浏览器热更新： 1"dev": "webpack-dev-server --open --port 4321 --hot", 方式2：(个人推荐) 修改webpack.config.js文件，新增devServer节点如下： 123456devServer: &#123; hot: true, // 启用热更新 的 第1步 open: true, // 自动打开浏览器 port: 4321, // 设置启动时候的运行端口 // contentBase: 'src', // 指定托管的根目录，不注释的话，无法访问src以外的资源，比如node_modules&#125;, 在头部引入webpack模块： 12// 启用热更新的 第2步const webpack = require('webpack') 在 plugins 节点下新增： 12// 启用热更新的第 3 步new webpack.HotModuleReplacementPlugin() Loadersloaders 是 webpack 最强大的功能之一，通过不同的 loader ，webpack 有能力调用外部的脚本或工具，实现对不同格式的文件的处理，例如把 scss 转为 css ，将 ES6 、ES7 等语法转化为当前浏览器能识别的语法，将 JSX 转化为 js 等多项功能。 loaders 需要单独安装并且需要在 webpack.config.js 中的 modules 配置项下进行配置，Loaders的配置包括以下几方面： test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； options：为loaders提供额外的设置选项（可选） 使用 webpack 打包 css 文件 运行npm i style-loader css-loader --D 修改webpack.config.js这个配置文件： 12345678module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125; //处理css文件的规则 ]&#125;, 注意：use 表示使用哪些模块来处理 test 所匹配到的文件；use 中相关 loader 模块的调用顺序是从后向前调用的； 使用 webpack 打包 less 文件 运行npm i less-loader less -D 修改webpack.config.js配置文件： 1234&#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader']&#125;, //配置处理 .less 文件的第三方 loader 规则 使用 webpack 打包 sass 文件 运行 npm i sass-loader node-sass --D 在 webpack.config.js 中添加处理 sass 文件的 loader 模块： 12345&#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader']&#125;, // 配置处理 .scss 文件的 第三方 loader 规则（npm i sass-loader后还需要 npm i node-sass，否则编译报错） 使用 webpack 处理 css 中的路径 预备工作： 在 index.html 文件中 添加： 在 index.css 文件中 添加： .second { width: 300px; height: 150px; background-image: url(‘../images/你的图片文件’); background-size: cover; } 此时保存会编译报错，因为webpack无法处理css中的路径（此案例中为——图片资源） 运行 npm i url-loader --D (p.s. 不需要装 file-loader ，因为 url-loader 内置了它) 在 webpack.config.js 中添加处理 url 路径的 loader 模块： 1234&#123; test: /\.(jpg|png|bmp|gif|jpeg)$/, use: 'url-loader'&#125;, // 配置图片路径 可以通过 limit 指定进行 base64 编码的图片大小；只有小于指定字节（byte）的图片才会进行 base64 编码： 12345&#123; test: /\.(jpg|png|bmp|gif|jpeg)$/, use: 'url-loader?limit=7631&amp;name=[hash:8]-[name].[ext]' &#125;, // 配置图片路径 // limit 给定的值，是图片的大小，单位是 byte， 如果我们引用的 图片，大于或等于给定的 limit值，则不会被转为base64格式的字符串， 如果 图片小于给定的 limit 值，则会被转为 base64的字符串 使用 webpack 处理 boostrap 字体的加载重要(更新)：webpack4后的bootstrap字体加载已经不能使用下面该方法，如何使用可以参考这篇博客：webpack 4.X版本的简单使用(处理js/css/less/scss/url(图片)/字体文件) 预备工作： index.html 写入 来展示字体图片 main.js 导入 import ‘bootstrap/dist/css/bootstrap.css’ 此时报错 在 webpack.config.js 中添加处理字体文件的 loader 模块： 1234&#123; test: /\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader'&#125;, // 处理 字体文件的 loader 使用 babel 处理高级 JS 语法 在 main.js 文件中添加 ES6 代码： 123456789101112131415// class 关键字，是ES6中提供的新语法，是用来 实现 ES6 中面向对象编程的方式class Person &#123; // 使用 static 关键字，可以定义静态属性 // 所谓的静态属性，就是 可以直接通过 类名， 直接访问的属性 // 实例属性： 只能通过类的实例，来访问的属性，叫做实例属性 static info = &#123; name: 'zs', age: 20 &#125;&#125;// 访问 Person 类身上的 info 静态属性console.log(Person.info)// 在 webpack 中，默认只能处理 一部分 ES6 的新语法，一些更高级的ES6语法或者 ES7 语法，webpack 是处理不了的；这时候，就需要 借助于第三方的 loader，来帮助webpack 处理这些高级的语法，当第三方loader 把 高级语法转为 低级的语法之后，会把结果交给 webpack 去打包到 bundle.js 中// 通过 Babel ，可以帮我们将 高级的语法转换为 低级的语法 运行如下两套命令，安装两套包，去安装 Babel 相关的loader功能： 123456// 【相当于转换工具】npm i -D @babel/core babel-loader @babel/plugin-transform-runtime @babel/runtime @babel/plugin-proposal-class-properties// 【相当于字典】npm i -D @babel/preset-env// =====&gt; 「转换工具」根据「字典」将 es6 转换 打开 webpack 的配置文件，在 module 节点下的 rules 数组中，添加一个新的匹配规则： 12345&#123; test: /\.js$/, use: 'babel-loader', exclude: /node_modules/&#125; // 配置 Babel 来转换高级的ES语法 2.2 注意： 在配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉：原因有俩： 2.2.1 如果 不排除 node_modules， 则Babel 会把 node_modules 中所有的 第三方 JS 文件，都打包编译，这样，会非常消耗CPU，同时，打包速度非常慢； 2.2.2 哪怕，最终，Babel 把 所有 node_modules 中的JS转换完毕了，但是，项目也无法正常运行！ 在项目的根目录中，新建一个叫做 .babelrc 的 Babel 配置文件，这个配置文件，属于 JSON 格式，所以，在写 .babelrc 配置的时候，必须符合 JSON 语法规范： 不能写注释，字符串必须用双引号： 123456789101112131415&#123; "presets": [ ["@babel/preset-env", &#123; "modules": false, "targets": &#123; "browsers": ["&gt; 1%", "last 2 versions", "not ie &lt;= 8"] &#125;, "useBuiltIns": "usage" &#125;] ], "plugins": [ "@babel/plugin-transform-runtime", "@babel/plugin-proposal-class-properties" ]&#125; webpack.config.js配置遇到Error: Cannot find module ‘@babel/core’问题 官方默认babel-loader | babel 对应的版本需要一致: 即babel-loader需要搭配最新版本babel 两种解决方案: 回退低版本 1npm install -D babel-loader@7 babel-core babel-preset-env 更新到最高版本: 1npm install -D babel-loader @babel/core @babel/preset-env webpack Source Maps 调试配置作为开发，代码调试当然少不了，那么问题来了，经过打包后的文件，你是不容易找到出错的地方的，Source Map就是用来解决这个问题的。 通过如下配置，我们会在打包时生成对应于打包文件的 .map 文件，使得编译后的代码可读性更高，更易于调试。 123456// webpack.config.js...module.exports = &#123; ... devtool: &apos;source-map&apos; // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度&#125; 配置好后，我们再次运行 npm run build 进行打包，这时我们会发现在 dist 文件夹中多出了一个 bundle.js.map 如果我们的代码有 bug ，在浏览器的调试工具中会提示错误出现的位置，这就是 devtool: &#39;source-map&#39; 配置项的作用。 开发环境 VS 生产环境npm run devnpm run dev 是我们开发环境下打包的文件，当然由于 devServer 帮我们把文件放到内存中了，所以并不会输出打包后的 dist 文件夹。 npm run build通过 npm run build 之后会生成一个dist目录文件夹，里面有我们打包后的文件。 清理/dist文件夹(CleanwebpackPlugin)你可能已经注意到，在我们删掉/dist文件夹之前，由于前面的代码示例遗留，导致我们的 /dist 文件夹比较杂乱。webpack 会生成文件，然后将这些文件放置在 /dist 文件夹中，但是 webpack 无法追踪到哪些文件是实际在项目中用到的。 通常，在每次构建前清理 /dist 文件夹，是比较推荐的做法，因此只会生成用到的文件，这时候就用到 CleanwebpackPlugin 插件了。 123456789101112npm i clean-webpack-plugin -D// webpack.config.js...const CleanwebpackPlugin = require(&apos;clean-webpack-plugin&apos;); // 引入CleanwebpackPlugin插件module.exports = &#123; ... plugins: [ ... new CleanwebpackPlugin([&apos;dist&apos;]), // 所要清理的文件夹名称 ]&#125; 插件的使用方法都是一样的，首先引入，然后new一个实例，实例可传入参数。 现在我们运行 npm run build 后就会发现，webpack 会先将 /dist 文件夹删除，然后再生产新的 /dist 文件夹。 webpack4.x相关资源 webpack4.x最详细入门讲解 webpack3与webpack4使用差异 webpack4.x开发环境配置]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie与session区别]]></title>
    <url>%2Fposts%2F63891%2F</url>
    <content type="text"><![CDATA[保存状态cookie 是通过在客户端记录信息确定用户身份的，而 session 则通过在服务器端记录信息来确定用户身份。下面是网上找到的两张图，能够对 cookie 以及 session 在客户端与服务端传递的过程有个较清晰的认识： 使用方式cookie机制： 默认情况下，cookie 保存在内存中，浏览器关闭就没了；设置过期时间后，cookie 保存在硬盘上，关闭浏览器仍然存在，直到过期时间结束才消失。 cookie 以文本形式保存在客户端，每次请求时都带上它。 session机制： 每次请求，服务器会检查是否有 sessionid 有，服务器根据 id 返回对应 session 对象 无，服务器创建新的 session 对象，并把 sessionid 在本次响应中返回给客户端。 通常使用 cookie 方式存储 sessionid 到客户端 用户禁用 cookie 时，则服务端可以使用URL重写，可以通过 response.encodeURL(url) 进行实现 存储方式 cookie 只能保存字符串类型，以文本的方式 session 能支持任何类型的对象 存储大小 cookie单个不超过4kb session没限制]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决0.1+0.2不等于0.3的问题]]></title>
    <url>%2Fposts%2F21245%2F</url>
    <content type="text"><![CDATA[为何会出现此问题？总结一句话：这是因为二进制模拟十进制进行运算时的精度问题。 具体可查看 0.1 + 0.2不等于0.3？为什么JavaScript有这种“骚”操作？ 这篇掘金文章。 如何解决Number.EPSILON第一种方法是利用 Number.EPSILON ，这个值无限接近于0。0.1+0.2的精度误差在这个值的范围内：12345function numbersEqual(a,b)&#123; return Math.abs(a-b)&lt;Number.EPSILON;&#125;var a=0.1+0.2， b=0.3;console.log(numbersEqual(a,b)); //true 内置函数toFixed利用 parseFloat + 内置函数toFixed：123456function formatNum(num, fixed = 10) &#123; // a.toFixed(fixed) 先转为小数点10位的字符串 "0.3000000000" return parseFloat(a.toFixed(fixed)) // 然后通过parseFloat转为浮点数&#125;var a = 0.1 + 0.2;console.log(formatNum(a)); //0.3 内置函数toPrecision我平常用此函数来计算精度，具体可参考 Number.prototype.toPrecision() | MDN：123// 内置函数toPrecision(中文：精确，精度)// 参数是精度.比如5.1234，传2返回5.1，传1返回5；0.2+0.1传2返回0.30(0.1 + 0.2).toPrecision(10) == 0.3 // true]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise用法]]></title>
    <url>%2Fposts%2F7878%2F</url>
    <content type="text"><![CDATA[Promise是什么Promise 是一种异步编程的解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。 诞生的原因异步网络请求的回调地狱，而且我们还得对每次请求的结果进行一些处理，代码会更加臃肿。一张图完美诠释：不够？再加一张： Promise的三种状态 pedding 等待（默认状态。异步代码执行完毕后会转换为以下两种状态） resolve 成功 reject 失败 基本用法语法 Promise: 构造函数 接受一个参数：callback，我们把要执行的异步任务放置在这个callback中 then: Promise对象下的一个方法：该方法在Promise对象的状态发生改变的时候触发then的回调 12345678910111213//defined Promise async functionfunction asyncFun()&#123; return new Promise((resolve, reject) =&gt; &#123; if (resolve) &#123; resolve(/*resolve parameter*/); &#125;else&#123; reject(new Error(/*Error*/)); &#125; &#125;)&#125;//use Promise&amp;thenasyncFun().then(/*function*/).then(/*function*/)... Promise特性立即执行12345678910111213141516let p = new Promise((resolve, reject) =&gt; &#123; // 当Promise被实例化的时候，callback的异步任务就会被执行 console.log("一个Promise对象被创建出来"); resolve("success");&#125;);console.log("flag");p.then((data) =&gt; &#123; console.log(data);&#125;);// 执行结果：// 一个Promise对象被创建出来// flag// success 状态不可逆1234567891011let p = new Promise((resolve, reject) =&gt; &#123; resolve("success"); reject("reject");&#125;);p.then((data) =&gt; &#123; console.log(data);&#125;);// 执行结果：// success 链式调用12345678910111213141516171819let p = new Promise((resolve, reject) =&gt; &#123; // 通过传入的resolve, reject，去改变当前Promise任务的状态 // resolve, reject 是两个函数，调用 resolve ，会把状态改成 resolved ，调用 reject 函数会把状态改成 rejected setTimeout(() =&gt; &#123; console.log(1); reject(); &#125;, 1000);&#125;);// then接受两个参数：这两个参数都是回调，当对应的 promise 对象的状态变成了resolved，那么 then 的第一个 callback 就会被执行，如果状态变成了 rejected ，那么 then 的第二个 callback 就会被执行p.then(() =&gt; &#123; console.log('成功');&#125;, () =&gt; &#123; console.log('失败');&#125; );// 执行结果：// 1// 失败 then的回调异步性1234567891011121314151617let p = new Promise((resolve, reject) =&gt; &#123; console.log("我是Promise的callback中的代码"); setTimeout(() =&gt; &#123; resolve("我1s后才会被执行"); &#125;, 1000);&#125;);p.then((data) =&gt; &#123; console.log(data);&#125;);console.log("我是主线程中的同步代码");// 执行结果：// 我是Promise的callback中的代码// 我是主线程中的同步代码// 我1s后才会被执行 解释：Promise 的 callback 回调函数中的代码是立即执行的（setTimeout 这个定时器也是立即执行的，只是函数内的 resolve 被延迟1s执行，跟 Promise 本身的立即执行没关系），但 then 方法中的回调函数执行则是异步的，因此，&quot;我1s后才会被执行&quot; 会在最后输出。 异常的捕获Promise的异常有两种方法可以捕获，一种是 then 的第二个回调；一种 .catch() 来捕获前一个 Promise 抛出的错误。 123456789101112let p = new Promise((resolve, reject) =&gt; &#123; reject("error");&#125;);p.then(data =&gt; &#123; console.log("success")&#125;, error =&gt; &#123; console.log(error);&#125;);// 执行结果：// error 123456789101112let p = new Promise((resolve, reject) =&gt; &#123; reject("error");&#125;);p.then(data =&gt; &#123; console.log("success")&#125;).catch(error =&gt; &#123; console.log("catch:" + error);&#125;);// 执行结果：// catch:error Promise.all 和 Promise.racePromise.allPromise.all 接收一个参数，它必须是可以迭代的，例如数组。它通常用来处理一些并发的异步操作，即它们的结果互不干扰，但是又需要异步执行。当所有 Promise 都成功的时候，整个 Promise.all 才成功。成功调用后返回一个数组，数组的值是有序的，顺序就是传入参数的数组顺序： 成功的情况 123456789101112let arr = [1, 2, 3];let tasks = arr.map(num =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(num * 5); &#125;);&#125;);Promise.all(tasks).then(data =&gt; &#123; // 有序输出 console.log(arr); // [1, 2, 3] console.log(data); // [5, 10, 15]&#125;); 失败的情况 1234567891011121314151617let arr = [1, 2, 3];let tasks = arr.map(num =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; if (num === 3) &#123; reject('rejected'); &#125; resolve(num * 5); &#125;);&#125;);Promise.all(tasks).then(data =&gt; &#123; // 这里不会执行 console.log(arr); console.log(data);&#125;).catch(err =&gt; &#123; console.log(err); // rejected&#125;); Promise.racePromise.race 和 Promise.all 类似，都接收一个可以迭代的参数，但是不同之处是 Promise.race 的状态变化不是全部受参数内的状态影响，一旦参数内有一个值的状态发生的改变，那么该 Promise 的状态就是改变的状态。就跟 race 单词的字面意思一样，谁跑的快谁赢。 12345678910111213141516171819let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 300, 'p1 doned');&#125;);var p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 50, 'p2 doned');&#125;);var p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(reject, 100, 'p3 rejected');&#125;);Promise.race([p1, p2, p3]).then(data =&gt; &#123; // 显然p2更快，所以状态变成了fulfilled // 如果p3更快，那么状态就会变成rejected console.log(data); // p2 doned&#125;).catch(function(err) &#123; console.log(err); // 不执行&#125;);]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let和const和var的区别]]></title>
    <url>%2Fposts%2F37021%2F</url>
    <content type="text"><![CDATA[const 和 let 异同不同点 let 定义变量可以只声明不赋值 const 定义常量声明时必须赋值，一旦定义不可轻易改变 相同点解决 var 没有块作用域,、变量提升、可以重复声明的问题。 let 和 const 有自己的块作用域, 不存在变量提升问题, 同一块作用域中不可重复声明（会报错）。 let/const 和 var 区别 var 有变量提升，let/const 没有 let/const 的作用域是块，而 var 的作用域是函数 let/const 有暂时性死区，只要 let/const 声明的变量，在未声明之前使用或者赋值都会报错（ReferenceError） let/const 不能被重复定义]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数中的rest参数]]></title>
    <url>%2Fposts%2F29820%2F</url>
    <content type="text"><![CDATA[什么是 REST 参数REST参数翻译过来就是剩余参数，MDN上的定义是： 剩余参数语法允许我们将一个不定数量的参数表示为一个数组。 示例说明123456789101112131415161718192021function sum(...theArgs) &#123; return theArgs.reduce((previous, current) =&gt; &#123; return previous + current; &#125;);&#125;console.log(sum(1, 2, 3));// expected output: 6console.log(sum(1, 2, 3, 4));// expected output: 10// 下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们function multiply(multiplier, ...theArgs) &#123; return theArgs.map(function (element) &#123; return multiplier * element; &#125;);&#125;var arr = multiply(2, 1, 2, 3); console.log(arr); // [2, 4, 6] rest 参数和 arguments 对象的区别剩余参数和 arguments对象之间的区别主要有三个： 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。 arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。 arguments对象还有一些附加的属性 （如callee属性）。 arguments.callee 属性包含当前正在执行的函数。]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中如何实现继承]]></title>
    <url>%2Fposts%2F2751%2F</url>
    <content type="text"><![CDATA[组合继承（原型链 + 借用构造函数）12345678910111213141516171819202122232425262728// 组合继承:原型继承+借用（调用）构造函数继承function Person(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex;&#125;Person.prototype.sayHi = function () &#123; console.log("Hello world");&#125;;function Student(name, age, sex, score) &#123; // 借用构造函数 Person.call(this,name,age,sex); this.score = score;&#125;// 改变原型指向----继承// 我们让 Student.prototype 指向一个Person的实例对象// 这个对象的__proto__指向的是Person.prototype// 所以我们就可以借助这个实例对象拿到sayHi方法，实现继承Student.prototype=new Person();Student.prototype.eat = function () &#123; console.log("吃东西");&#125;;var stu = new Student("Lance", 20, "男", "100分");stu.sayHi();var stu2 = new Student("Jerry", 19, "男", "101分");stu2.eat();//属性和方法都被继承了 寄生组合继承（组合继承升级版）123456789101112131415161718192021222324252627282930function object(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); // 创建了父类原型的浅复制 prototype.constructor = subType; // 修正原型的构造函数 subType.prototype = prototype; // 将子类的原型替换为这个原型&#125; function SuperType(name)&#123; this.name = name; this.colors = ["red", "blue", "green"];&#125; SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;; function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;// 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; alert(this.age);&#125; ES6继承写法12345678910class Person &#123; constructor(name, age) &#123;this.name=name;this.age=age&#125; sayHi() &#123;&#125;&#125;class Student extends Person &#123; constructor(name, age, weight) &#123; super(name, age); this.weight = weight; &#125; run() &#123;&#125;&#125; 在原型链继承时，为什么不直接 Student.prototype = Person.prototype ？因为对象的赋值只是引用的赋值, 上面两者都指向同一个内存地址，只要随便通过1个途径就能修改该内存地址的对象，这样子类就无法单独扩展方法，而且会影响父类。 组合继承的缺点缺点就是调用了两次父类的构造函数。第一次给子类的原型添加了父类构造函数中的属性方法；第二次又给子类的构造函数添加了父类的构造函数的属性方法，从而覆盖了子类原型中的同名参数。这种被覆盖的情况造成了性能上的浪费：1234567891011121314function SuperType() &#123; this.name = 'parent'; this.arr = [1, 2, 3];&#125; SuperType.prototype.say = function() &#123; console.log('this is parent')&#125; function SubType() &#123; SuperType.call(this) // 第二次调用SuperType&#125; SubType.prototype = new SuperType() // 第一次调用SuperType]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对this指向的判定]]></title>
    <url>%2Fposts%2F33207%2F</url>
    <content type="text"><![CDATA[对 this 的理解对于this指向的判定，时刻记住下面两点就好： 普通函数的 this 指向是在函数的执行期间绑定的，换句话说 this 总是指向函数的直接调用者 箭头函数的 this 指向是在函数创建期间就绑定好了的，指向的是创建该箭头函数所在的作用域对象 普通函数中的this这里直接引用 You-Dont-Know-JS 中对 this 的判定步骤： 函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。var bar = new foo() 函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。var bar = foo.call( obj2 ) 函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。var bar = obj1.foo() 否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。var bar = foo() 常见this指向 普通函数中this ——&gt; window 构造函数中this ——&gt; new出来的实例对象 方法中的this ——&gt; 实例对象 原型中的方法中的this ——&gt; 实例对象 定时器中的this ——&gt; window]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的遍历方法]]></title>
    <url>%2Fposts%2F64478%2F</url>
    <content type="text"><![CDATA[下面是总结的数组遍历的常见方法 for循环 标准for循环 forEach((当前值, 当前索引, 当前数组) =&gt; {…}, [, 绑定的this])` 无法中途退出循环，只能用 return 退出本次回调，进行下一次回调 它总是返回 undefined 值，即使你 return 了一个值 for…in（不推荐）会把继承链的对象属性都会遍历一遍，而且数组遍历不一定按次序 for-in 循环返回的是所有能通过对象访问的、可枚举的属性 for (variable of iterable)（ES6）可迭代Array，Map，Set，String等（迭代的是值value） 在 for..of 中如果遍历中途要退出，可以使用 break 退出循环 ES5 map (不改变原数组) 会给原数组中的每个元素都按顺序调用一次 callback 函数 reduce (不改变原数组) 数组中的前项和后项做某种计算,并累计最终值。 123456789// 语法：// arr.reduce(function(total, currentValue, currentIndex, arr), initialValue)// callback 参数// (累积器, 当前元素, 当前元素索引, 当前数组)// initialValue:指定第一次回调 的第一个参数var wallets = [4, 7.8, 3]var totalMoney = wallets.reduce(function (countedMoney, curMoney) &#123; return countedMoney + curMoney;&#125;, 0) filter (不改变原数组) 1234var arr = [2, 3, 4, 5, 6]var morearr = arr.filter(function (number) &#123; return number &gt; 3&#125;) // [4,5,6] every (不改变原数组) 测试数组的所有元素是否都通过了指定函数的测试 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测 如果所有元素都满足条件，则返回 true 1234var arr = [1,2,3,4,5]var result = arr.every(function (item, index) &#123; return item &gt; 2&#125;) // false some (不改变原数组) 测试是否至少有一个元素通过 callback 中的条件。对于放在空数组上的任何条件，此方法返回 false 如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测 如果没有满足条件的元素，则返回false 12345678// some(callback, thisArg)// callback:// (当前元素, 当前索引, 调用some的数组)var arr = [1,2,3,4,5]var result = arr.some(function (item,index) &#123; return item &gt; 3&#125;) // true ES6 find() &amp; findIndex() 根据条件找到数组成员 find 定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回 undefined findIndex 定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 123456789101112// 语法let new_array = arr.find(function(currentValue, index, arr), thisArg)let new_array = arr.findIndex(function(currentValue, index, arr), thisArg)// 这两个方法都可以识别NaN,弥补了indexOf的不足// findlet a = [1, 4, -5, 10].find((n) =&gt; n &lt; 0); // 返回元素-5let b = [1, 4, -5, 10,NaN].find((n) =&gt; Object.is(NaN, n)); // 返回元素NaN// findIndexlet a = [1, 4, -5, 10].findIndex((n) =&gt; n &lt; 0); // 返回索引2let b = [1, 4, -5, 10,NaN].findIndex((n) =&gt; Object.is(NaN, n)); // 返回索引4 keys() &amp; values() &amp; entries() 遍历键名、遍历键值、遍历键名+键值 三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值 1234567891011121314151617181920// 语法array.keys() array.values() array.entries()for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b"]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[null 和 undefined 的区别]]></title>
    <url>%2Fposts%2F63928%2F</url>
    <content type="text"><![CDATA[含义 null 表示一个对象是“没有值”的值，也就是值为“空” undefined 表示一个变量声明了没有初始化(赋值) 类型 undefined 的类型(typeof)是 undefined null 的类型(typeof)是 object 其他Javascript会将未赋值的变量默认值设为undefined；Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。 另外，在验证 null 时，一定要使用 === ，因为 == 无法分辨 null 和 undefined ：12null == undefined // true null === undefined // false]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对闭包的理解]]></title>
    <url>%2Fposts%2F29980%2F</url>
    <content type="text"><![CDATA[什么是闭包我一直认为，MDN是前端学习的在线指南。只要有不懂的语法，或者不懂的概念，查找资料的首选就应该是它。虽然早些年做iOS开发的时候就就接触过闭包，但如今已经忘得一干二净，所以在想要了解闭包的时候，第一件事就是在MDN中搜索。其中给到了一个闭包的例子： 12345678910function makeFunc() &#123; var name = "Mozilla"; // name 是一个被 init 创建的局部变量 function displayName() &#123; // displayName() 是内部函数,一个闭包 alert(name); // 使用了父函数中声明的变量 &#125; return displayName; // 返回 displayName 这个函数&#125;var myFunc = makeFunc();myFunc(); // 当执行myFunc时，其实调用了displayName，会弹窗显示"Mozilla" 在上面这个例子中，一个函数套了一个函数，且这个内部函数使用到了外部函数中的变量，这个时候就形成了闭包。有什么用呢？其中一个用处就如上面代码所示，能够让 makeFunc 函数外面也能访问 name 这个局部变量。换句话说，闭包缓存了数据，延长了作用域链。 Kyle Simpson编写的You-Dont-Know-JS中对闭包的总结我觉得很精髓： 闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。 闭包的特性 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 闭包的用途缓存数据，延长作用域链一个经典的例子，给 ul&gt;li 下面的每个 li 节点添加点击事件，让其弹出当前 li 元素的索引：1234567891011121314&lt;ul id="testUL"&gt; &lt;li&gt; index = 0&lt;/li&gt; &lt;li&gt; index = 1&lt;/li&gt; &lt;li&gt; index = 2&lt;/li&gt; &lt;li&gt; index = 3&lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var nodes = document.getElementsByTagName("li"); for (var i = 0; i &lt; nodes.length; i += 1) &#123; nodes[i].onclick = function () &#123; console.log(i); &#125; &#125;&lt;/script&gt; 运行上述代码后就会发现，每次打印的结果都显示为4，而不是真正的索引值。这是因为点击事件的匿名函数发生在for循环之后，而for循环执行完毕时 i 的值就为4，所以点谁都是同样的结果。那么这个时候就能通过立即执行函数 + 闭包的方法解决此问题：1234567891011&lt;script type="text/javascript"&gt; var nodes = document.getElementsByTagName("li"); for (var i = 0; i &lt; nodes.length; i += 1) &#123; nodes[i].onclick = (function (i) &#123; // 1. IIFE创建一个函数作用域 return function () &#123; // 4. 返回这个匿名函数，延长作用域链 // 3. 内部嵌套的匿名函数使用到了IIFE的参数i，形成闭包 console.log(i); &#125; &#125;)(i); // 2. 给IIFE传递每次for循环的i &#125;&lt;/script&gt; 这个时候触发click事件，打印的值就是li元素的索引了。 用闭包模拟私有变量和方法使用闭包定义能访问私有函数和私有变量的公有函数（也叫做模块模式） 123456789101112131415161718192021222324var counter = (function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125;; &#125;)(); // 立即执行函数console.log(counter.value()); // logs 0counter.increment();counter.increment();console.log(counter.value()); // logs 2counter.decrement();console.log(counter.value()); // logs 1 环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。它俩都无法在匿名函数外部直接访问。必须通过匿名包装器返回的对象的三个公共函数访问。 内存泄漏其实闭包并不会造成内存泄漏，现在的垃圾回收机制已经很成熟了。但早期的IE（ie4-ie6）版本里，对宿主对象（也就是document对象）采用是引用计数的垃圾回收机制，闭包导致内存泄漏的一个原因就是这个算法的一个缺陷。循环引用会导致没法回收，这个循环引用只限定于有宿主对象参与的循环引用，而js对象之间即使形成循环引用，也不会产生内存泄漏，因为对js对象的回收算法不是计数的方式：12345678910111213141516171819202122232425function closure()&#123; var oDiv = document.getElementById('oDiv');//oDiv用完之后一直驻留在内存中 oDiv.onclick = function () &#123; alert('oDiv.innerHTML');//这里用oDiv导致内存泄露 &#125;;&#125;// 以上代码创建了一个作为 div 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。// 由于匿名函数保存了一个对closure()的活动对象的引用，因此就会导致无法减少 div 的引用数。// 只要匿名函数存在，element 的引用数至少也是1，因此它所占用的内存就永远不会被回收closure();//最后应将oDiv解除引用来避免内存泄露function closure()&#123; var oDiv = document.getElementById('oDiv'); var test = oDiv.innerHTML; oDiv.onclick = function () &#123; alert(test); &#125;; oDiv = null;&#125;// 解决办法: 把 oDiv.innerHTML 的一个副本保存在一个变量中，// 从而消除闭包中该变量的循环引用,同时将 oDiv 变量设为null。]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组有哪些常用方法]]></title>
    <url>%2Fposts%2F21501%2F</url>
    <content type="text"><![CDATA[改变原数组的方法splice() 添加/删除数组元素 splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目 array.splice(index,howmany,item1,…..,itemX) index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX： 可选。向数组添加的新项目。 返回值: 如果有元素被删除,返回包含被删除项目的新数组。 删除元素1234567// 从数组下标0开始，删除3个元素let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0, 3); // [1,2,3]console.log(a); // [4,5,6,7]// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7let item = a.splice(-1, 3); // [7] 删除并添加123456789// 从数组下标0开始，删除3个元素，并添加元素'添加'let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0,3,'添加'); // [1,2,3]console.log(a); // ['添加',4,5,6,7]// 从数组最后第二个元素开始，删除3个元素，并添加两个元素'添加1'、'添加2'let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-2,3,'添加1','添加2'); // [6,7]console.log(b); // [1,2,3,4,5,'添加1','添加2'] 不删除只添加1234567let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0,0,'添加1','添加2'); // [] 没有删除元素，返回空数组console.log(a); // ['添加1','添加2',1,2,3,4,5,6,7]let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-1,0,'添加1','添加2'); // [] 没有删除元素，返回空数组console.log(b); // [1,2,3,4,5,6,'添加1','添加2',7] 在最后一个元素的前面添加两个元素 sort() 数组排序 定义: sort()方法对数组元素进行排序，并返回这个数组。 参数可选: 规定排序顺序的比较函数。 默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用toString()方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。 不传参1234567// 字符串排列 看起来很正常var a = ["Banana", "Orange", "Apple", "Mango"];a.sort(); // ["Apple","Banana","Mango","Orange"]// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的var a = [10, 1, 3, 20,25,8];console.log(a.sort()) // [1,10,20,25,3,8]; 比较函数的两个参数： sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素： 若比较函数返回值&lt;0，那么a将排到b的前面; 若比较函数返回值=0，那么a 和 b 相对位置不变； 若比较函数返回值&gt;0，那么b 排在a 将的前面； 数字升降序12345678910var array = [10, 1, 3, 4, 20, 4, 25, 8]; array.sort(function(a,b)&#123; return a-b;&#125;);console.log(array); // [1,3,4,4,8,10,20,25];array.sort(function(a,b)&#123; return b-a;&#125;);console.log(array); // [25,20,10,8,4,4,3,1]; pop() 删除一个数组中的最后的一个元素 定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。 123let a = [1,2,3];let item = a.pop(); // 3console.log(a); // [1,2] shift() 删除数组的第一个元素 定义: shift()方法删除数组的第一个元素，并返回这个元素。 123let a = [1,2,3];let item = a.shift(); // 1console.log(a); // [2,3] push() 向数组的末尾添加元素 定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 参数: item1, item2, …, itemX ,要添加到数组末尾的元素 123let a = [1,2,3];let item = a.push('末尾', '233'); // 5console.log(a); // [1,2,3,'末尾', '233'] unshift() 定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。 参数: item1, item2, …, itemX ,要添加到数组开头的元素 123let a = [1, 2, 3];let item = a.unshift('开头', '开头2'); // 5console.log(a); // [ '开头', '开头2', 1, 2, 3 ] reverse() 颠倒数组中元素的顺序 定义: reverse() 方法用于颠倒数组中元素的顺序。 123let a = [1,2,3];a.reverse(); console.log(a); // [3,2,1] 不改变原数组的方法slice() 浅拷贝数组的元素 定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。 语法：array.slice(begin, end); 12345678910111213let a= ['hello','world'];let b=a.slice(0,1); // ['hello']// 新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。// 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。a[0]='改变原数组';console.log(a,b); // ['改变原数组','world'] ['hello']let a= [&#123;name:'OBKoro1'&#125;];let b=a.slice();console.log(b,a); // [&#123;"name":"OBKoro1"&#125;] [&#123;"name":"OBKoro1"&#125;]// a[0].name='改变原数组';// console.log(b,a); // [&#123;"name":"改变原数组"&#125;] [&#123;"name":"改变原数组"&#125;] join() 数组转字符串 定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。 语法: array.join(str) 12345678910111213let a= ['hello','world'];let str=a.join(); // 'hello,world'let str2=a.join('+'); // 'hello+world'let a= [['OBKoro1','23'],'test'];let str1=a.join(); // OBKoro1,23,testlet b= [&#123;name:'OBKoro1',age:'23'&#125;,'test'];let str2 = b.join(); // [object Object],test// 对象转字符串推荐JSON.stringify(obj);// 结论：// join()/toString()方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),// 如果是对象的话，对象会被转为[object Object]字符串。 join() 数组转字符串 定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。 语法: array.join(str) 12345678910111213let a= ['hello','world'];let str=a.join(); // 'hello,world'let str2=a.join('+'); // 'hello+world'let a= [['OBKoro1','23'],'test'];let str1=a.join(); // OBKoro1,23,testlet b= [&#123;name:'OBKoro1',age:'23'&#125;,'test'];let str2 = b.join(); // [object Object],test// 对象转字符串推荐JSON.stringify(obj);// 结论：// join()/toString()方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),// 如果是对象的话，对象会被转为[object Object]字符串。 concat 定义： 方法用于合并两个或多个数组，返回一个新数组。 语法：var newArr =oldArray.concat(arrayX,arrayX,……,arrayX) 参数：arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。 1234567891011121314let a = [1, 2, 3];let b = [4, 5, 6];//连接两个数组let newVal=a.concat(b); // [1,2,3,4,5,6]// 连接三个数组let c = [7, 8, 9]let newVal2 = a.concat(b, c); // [1,2,3,4,5,6,7,8,9]// 添加元素let newVal3 = a.concat('添加元素',b, c,'再加一个'); // [1,2,3,"添加元素",4,5,6,7,8,9,"再加一个"]// 合并嵌套数组 会浅拷贝嵌套数组let d = [1,2 ];let f = [3,[4]];let newVal4 = d.concat(f); // [1,2,3,[4]] ES6扩展运算符...合并数组123let a = [2, 3, 4, 5]let b = [ 4,...a, 4, 4]console.log(a,b); // [2, 3, 4, 5] [4,2,3,4,5,4,4] indexOf() 查找数组是否存在某个元素，返回下标 定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 p.s. 字符串也有此方法，要注意当 ‘lance’.indexOf(‘’) 一个空字符串时，返回0而不是-1 语法：array.indexOf(searchElement,fromIndex) 参数： searchElement(必须):被查找的元素 fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。 严格相等的搜索: 数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等===搜索元素，即数组元素要完全匹配才能搜索成功。 注意：indexOf()不能识别NaN 1234let a=['啦啦',2,4,24,NaN]console.log(a.indexOf('啦')); // -1 console.log(a.indexOf('NaN')); // -1 console.log(a.indexOf('啦啦')); // 0 lastIndexOf() 查找指定元素在数组中的最后一个位置 定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找） 语法：arr.lastIndexOf(searchElement,fromIndex) 参数: searchElement(必须): 被查找的元素 fromIndex(可选): 逆向查找开始位置，默认值数组的 长度-1，即查找整个数组。 关于fromIndex有三个规则: 正值。如果该值大于或等于数组的长度，则整个数组会被查找。 负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找) 负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 12345let a=['OB',4,'Koro1',1,2,'Koro1',3,4,5,'Koro1']; // 数组长度为10// let b=a.lastIndexOf('Koro1',4); // 从下标4开始往前找 返回下标2// let b=a.lastIndexOf('Koro1',100); // 大于或数组的长度 查找整个数组 返回9// let b=a.lastIndexOf('Koro1',-11); // -1 数组不会被查找let b=a.lastIndexOf('Koro1',-9); // 从第二个元素4往前查找，没有找到 返回-1 ES7 includes() 查找数组是否包含某个元素 返回布尔 定义： 返回一个布尔值，表示某个数组是否包含给定的值 语法：array.includes(searchElement,fromIndex=0) 参数： searchElement(必须):被查找的元素 fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。 includes方法是为了弥补indexOf方法的缺陷而出现的: indexOf方法不能识别NaN indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观 12345let a=['OB','Koro1',1,NaN];// let b=a.includes(NaN); // true 识别NaN// let b=a.includes('Koro1',100); // false 超过数组长度 不搜索// let b=a.includes('Koro1',-3); // true 从倒数第三个元素开始搜索 // let b=a.includes('Koro1',-100); // true 负值绝对值超过数组长度，搜索整个数组]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去除图片上下左右间隙]]></title>
    <url>%2Fposts%2F31251%2F</url>
    <content type="text"><![CDATA[情景当在定宽父容器下有多张图片顺序排列时，图片的上下左右之间都有间隙： See the Pen KEBmRP by JingW (@JingW) on CodePen. 原因 左右：因为 img 是 inline-block 元素，元素代码之间有『换行（回车），空格，tab』时会产生左右间隙。 上下：行内元素默认与父容器基线对齐，而基线与父容器底部有一定间隙，所以上下图片间有间隙。 解决方案 移除上下间隙： img本身设置 display: block; 父元素设置 font-size: 0; （基线与字体大小有关，字体为零，基线间就没距离了） img本身设置 vertical-align: bottom;（让inline-block 的 img 与每行的底部对齐） 移除左右间距： 行内元素间不要有换行，连成一行写消除间隙（阅读性差，不推荐） 第一行img结尾写上 &lt;!-- ，第二行img开头跟上 --&gt; 。即利用注释消除间距 父元素 font-size: 0]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何清除浮动]]></title>
    <url>%2Fposts%2F12906%2F</url>
    <content type="text"><![CDATA[为什么要清除浮动其实浮动（e.g. float: left;）本质上是用来做文字混排的，但却被我们拿来做布局，这个时候虽然实现了某些效果，但也带来了不少副作用。 由于浮动元素不再占有原文档流的位置，所以它会对后续元素的排版带来影响（无视浮动元素，就当它不存在过）。因此我们很多时候要做的，就是消除浮动元素造成的影响。清除浮动的本质主要是为了解决父元素因为子元素浮动造成的内部高度为0的问题。 clear清除浮动的核心css属性是 clear ，基本语法如下： 123选择器: &#123; clear: 属性值;&#125; 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 清除浮动常见方案额外标记法在浮动元素后面添加一个空标签，例如： 12&lt;div style="float: left;"&gt;&lt;/div&gt;&lt;div style="clear: both;"&gt;&lt;/div&gt; 优点：通俗易懂，书写方便缺点：加入了过多的没有实际含义的额外标签，结构化差。 父元素添加overflow通过触发BFC达到清除浮动的效果。（p.s. 对bfc不了解可以看这篇文章） 123.parent &#123; overflow: hidden;&#125; 优点：代码简洁缺点：超出的内容会被隐藏 before和after双伪元素方案1234567891011.clearfix:before,.clearfix:after &#123; content:""; display: table; /* 触发BFC清除浮动 */&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 优点：代码简洁缺点：IE6-7不支持:after，需要使用 zoom: 1 触发 hasLayout 使用after伪元素（我平常使用的）1234567891011.clearfix::after &#123; content: "."; display: block; height: 0; visibility: hidden; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; /* IE6、7 专有 */ 使用方式：给浮动元素的父元素添加一个class类：clearfix优点：一次书写多处使用，并且符合闭合浮动思想，结构语义化正确缺点：IE6-7不支持:after，需要使用 zoom: 1 触发 hasLayout注意：content:&quot;.&quot; 内容尽量不为空，可以跟一个小点，否则在firefox 7.0前的版本会生成空格 :after 和 ::after 的区别:before、:after 在旧版本里是伪元素，CSS3的规范里 “:” 用来表示伪类，”::” 用来表示伪元素，但是在高版本浏览器下 :before、:after 会被自动识别为 ::before、::after ，这样做的目的是用来做兼容处理。 相同点伪类对象，用来设置对象前的内容:before 和 ::before 写法是等效的 不同点:before 是 css2 的写法，::before 是 css3 的写法:before 兼容性比 ::before要好 注意伪类元素必须要配合 content 属性一起使用，否则无效伪类元素是css渲染层加入的，不能通过js来操作]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>清除浮动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC的理解与应用]]></title>
    <url>%2Fposts%2F9722%2F</url>
    <content type="text"><![CDATA[定义先上MDN上对 BFC 的定义： 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 ———— BFC | MDN 不知道别人看完这段定义有何感受，反正我是懵逼的。不过我在这儿还是建议各位认真阅读上面给出的MDN链接至少两遍，这能让你对一个陌生的概念有一个基本的认知。 理解这里谈下我对BFC的理解：BFC其实是一个独立的，与外界隔离了的容器，容器里面的子元素不会影响到外面的元素，外面的也同样不会影响到容器内部的元素。我们可以利用这个特性，来解决一些布局上的问题。 BFC触发条件BFC的触发条件有很多，想要知道所有细节可以移步上面给出的 MDN 链接。这里我只列出一些常见触发条件： 根元素（HTML元素） 浮动元素（float不为none） 绝对定位元素（position 为 absolute 或 fixed） display 为 block, inline-block, flex, inline-flex, list-item, table overflow 值不为 visible 的块元素 BFC布局特性对于一个BFC容器来说： 内部相邻的两个元素垂直方向上的 margin 会发生重叠 不会与外界的浮动元素产生交集，而是紧贴浮动元素的边缘 元素从容器的顶端开始垂直地一个接一个地排列 每一个元素的左外边缘（margin-left）会触碰到容器的左边缘（border-left）（如果设置了容器内部的元素从右到左的格式排布，则触碰的是右边缘） 在计算它的高度时，还会检测内部浮动或者定位元素的高度 实际应用清除浮动利用BFC “在计算它的高度时，还会检测内部浮动或者定位元素的高度” 这条特性，我们可以触发父元素的BFC来清除子元素浮动带来的影响。常见的用法是给父元素设置 overflow: hidden 样式（如果考虑IE6版本，还需设置 zoom: 1，因为IE6不支持 overflow: hidden 来清除浮动）： See the Pen 利用BFC清除浮动 by JingW (@JingW) on CodePen. 解决外边距合并问题如果看上面标题不知道在说什么，请很戳这里了解详情。由于属于同一个BFC的两个相邻盒子的垂直margin会发生重叠，那么我们可以隔离开这两个元素，让它们不属于同一个BFC，这样就不会发生margin重叠了。 See the Pen 解决外边距合并问题 by JingW (@JingW) on CodePen. 两栏布局，右边宽度自适应我们常常在开发中有这样类似的需求：两栏布局，左边定宽，右边自适应。这时我们就可以利用BFC特性来实现需求：左边设置定宽+左浮动；右边给自己加上 overflow: hidden 。原理就是：给元素设置BFC后，为了和浮动元素不产生任何交集，它会顺着浮动元素的边缘形成自己的封闭上下文。直接上代码看效果： See the Pen 利用BFC实现两栏布局 by JingW (@JingW) on CodePen. 以上是我对BFC的一些理解以及实际应用，希望能够帮助大家了解BFC这个听起来摸不着头脑的东西。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三栏布局方案(圣杯+双飞翼)]]></title>
    <url>%2Fposts%2F55613%2F</url>
    <content type="text"><![CDATA[圣杯布局步骤一 - HTML框架搭建 &amp; 初始化CSS首先把基本框架搭起来（注意中间部分放最前面）： 12345&lt;div class="container"&gt; &lt;div class="center"&gt;我是中间&lt;/div&gt; &lt;div class="left"&gt;我是左边&lt;/div&gt; &lt;div class="right"&gt;我是右边&lt;/div&gt;&lt;/div&gt; 接下来是初始化样式。left, right宽度分别设置为100px和200px；然后设置container的 padding-left: 100px + padding-right: 200px 来占据两侧填充；center宽度设为100%，这样能够自适应剩下的宽度。再让所有子元素左浮动。代码如下： 12345678910111213141516171819202122232425.container &#123; padding: 0 200px 0 100px; /* 左边100， 右边200*/ background-color: #e1e1e1; height: 300px; /* 为了看效果，给个300px把高度撑起来 */&#125;.left, .center, .right &#123; float: left; height: 100%;&#125;.center &#123; width: 100%; /* 占据父元素剩下的宽度*/ background-color: lightblue;&#125;.left &#123; width: 100px; background-color: pink;&#125;.right &#123; width: 200px; background-color: yellow;&#125; 此时的页面效果： 步骤二 - 让left占据最左列为了让left能越过center，我们先给它设置一个 -100% 的左边距。这个100%是在container中的宽度，也就是center的宽度： 123456.left &#123; margin-left: -100%; width: 100px; /*为了看left和center的重叠效果，暂时bgc设为半透明*/ background-color: rgba(255,204,204,.6);&#125; 页面效果： 此时，我们已经让left从“第二行”升到了“第一行”，为了让它靠到最左侧，不与center重叠，可以给它设置相对定位，然后给个 left: -100px ，让它定位到container最左侧： 123456789.left &#123; /* 设置相对定位 */ position: relative; /* 靠到最左侧 */ left: -100px; margin-left: -100%; width: 100px; background-color: pink;&#125; 页面效果： 步骤三 - 让right占据最右列定位好了left，也是时候让right呆在最右边来填充位置了，我们继续使用负margin： 12345.right &#123; width: 200px; margin-right: -200px; background-color: yellow;&#125; 页面效果： 步骤四 - 给container设置min-width看起来已经实现了不是吗？但我们还差最后一步，给container设置一个 min-width: 100px （就是左列的宽度），否则当浏览器缩小到一定程度时，这个布局可能会被破坏。原因简单来讲就是：“由于设置了相对定位，所以当left原来的位置和right的位置产生重叠时，由于浮动的原因一行放不下就会换行”。所以布局就被打乱了。 123456.container &#123; min-width: 100px; background-color: #e1e1e1; padding: 0 200px 0 100px; height: 300px;&#125; 完整代码 + 最终效果这样，我们就实现了圣杯布局，完整代码和效果见下： See the Pen 三栏布局 - 圣杯布局 by JingW (@JingW) on CodePen. 双飞翼布局如果上面圣杯布局你已经理解并自己实践了一遍，那么这里的双飞翼布局你也应该不再话下。跟着我一起撸一遍代码吧。 步骤一 - HTML框架搭建 &amp; 初始化CSS首先搭建html，仔细观察下方代码你会发现，双飞翼布局在html上面有一点和圣杯布局有差别，那就是双飞翼在center里又套了一个div。到后面你就会知道这样设置的目的。 12345&lt;div class="container"&gt; &lt;div class="center"&gt;&lt;div&gt;我是中间&lt;/div&gt;&lt;/div&gt; &lt;div class="left"&gt;我是左边&lt;/div&gt; &lt;div class="right"&gt;我是右边&lt;/div&gt;&lt;/div&gt; 然后编写初始样式。left定宽100；right定宽200；left, right, center全部设置左浮动。其他例如设置颜色高度等等直接看下方代码： 1234567891011121314151617181920212223.container &#123; background-color: #e1e1e1; height: 300px;&#125;.center &#123; background-color: lightblue;&#125;.left &#123; width: 100px; background-color: pink;&#125;.right &#123; width: 200px; background-color: yellow;&#125;.left, .center, .right &#123; float: left; height: 100%;&#125; 效果如下： 步骤二 - 设置center为100%宽将center的宽度设为100%，这样会把left，right“挤”到第二行： 1234.center &#123; width: 100%; background-color: lightblue;&#125; 效果如下： 步骤三 - 分别让left,right回到最左边和最右边接着，给left设置 margin-left: -100% 回到最左边，给right设置 margin-left: -200px 回到最右边。此时center和left,right都有重叠区域，为了看效果，设置了半透明背景颜色。 1234567891011.left &#123; width: 100px; margin-left: -100%; background-color: pink;&#125;.right &#123; width: 200px; margin-left: -200px; background-color: yellow;&#125; 效果如下： 步骤四 - 给center的子div设置左右margin其实上面的效果图已经实现了三栏布局中间自适应。但有个问题是center左右部分区域会被遮挡，这个时候在步骤一提到的center子div的作用就体现出来了，我们可以给它设置一个左右的margin值，分别等于left的宽和right的宽，消除掉重叠的副作用。 1234.center div &#123; /* 左margin100，右margin200 */ margin: 0 200px 0 100px;&#125; 效果如下： 步骤五 - 给container设置min-width最后，给container设置一个min-width，让container最小宽度不小于left宽+right宽 12345.container &#123; min-width: 300px; background-color: #e1e1e1; height: 300px;&#125; 大功告成~ 完整代码 + 最终效果 See the Pen 三栏布局 - 双飞翼布局 by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两栏布局方案汇总]]></title>
    <url>%2Fposts%2F44541%2F</url>
    <content type="text"><![CDATA[记录下常见的两栏布局方式。 左边定宽，右边自适应模拟table父元素 display: table ，子元素左右 table-cell ，左边定宽。 See the Pen 两栏布局（左定右自适应）模拟table by JingW (@JingW) on CodePen. 左浮 + 右Margin子元素的左边浮动脱标，右边设置 margin-left: 左边元素宽度 See the Pen 两栏布局（左定右自适应）子元素绝对定位 by JingW (@JingW) on CodePen. 左浮 + 右BFC子元素左边设置浮动+定宽，右边子元素设置 overflow: hidden 触发自身BFC See the Pen 两栏布局（左定右自适应）左浮 + 右BFC by JingW (@JingW) on CodePen. 子绝父相子绝父相，左边 top, left: 0，右边 top, right: 0，left等于左边宽度。 See the Pen 两栏布局（左定右自适应）子绝父相 by JingW (@JingW) on CodePen. flex布局父元素 display: flex ，左边定宽，右边 flex: 1。 See the Pen 两栏布局（左定右自适应）flex by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垂直居中方案汇总]]></title>
    <url>%2Fposts%2F12733%2F</url>
    <content type="text"><![CDATA[这里汇总了常见的元素居中方案。 水平居中行内元素水平居中核心：给父元素添加 text-align: center See the Pen 行内元素水平居中 by JingW (@JingW) on CodePen. 块级元素水平居中核心：子元素自身 margin: 0 auto; See the Pen 块元素水平居中 by JingW (@JingW) on CodePen. 多个div水平居中传统方案核心：父元素设置 text-align: center ，子元素设置 inline-block See the Pen 多个div水平居中 - 传统方案 by JingW (@JingW) on CodePen. Flex方案核心：父元素 display: flex + justify-content: center + align-items: center See the Pen 多个div水平居中-flex by JingW (@JingW) on CodePen. 水平垂直居中table自带水平垂直居中核心：使用 table&gt;tr&gt;td 布局 See the Pen div水平垂直居中 - table by JingW (@JingW) on CodePen. 模拟table核心：父元素 display: table ，子元素 display: table-cell + vertical-align: middle See the Pen div水平垂直居中 - 模拟table by JingW (@JingW) on CodePen. 子绝父相 + 子元素 margin:auto核心：子元素相对于父元素绝对定位，top、right、bottom、left 都设为0，margi设为auto See the Pen div水平垂直居中 - 子绝父相 + Margin Auto by JingW (@JingW) on CodePen. 子绝父相 + 负margin核心：子元素相对于父元素绝对定位，top、left设为50%，margin相对自身宽/高一半 See the Pen div水平垂直居中 - 子绝父相 + 负Margin by JingW (@JingW) on CodePen. 子绝父相 + translate核心：子元素相对于父元素绝对定位，top、left设为50%，此时子元素左上角在父元素中心，然后让子元素向左上角位移自身宽度的一半 See the Pen div水平垂直居中 - 子绝父相 + translate by JingW (@JingW) on CodePen. Flex布局父元素 display: flex，justify-content 和 align-items 都设为 center 实现垂直居中 See the Pen div水平垂直居中 - flex by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对HTML语义化的理解]]></title>
    <url>%2Fposts%2F2906%2F</url>
    <content type="text"><![CDATA[对HTML语义化的理解核心：用正确的标签做正确的事情 利与开发：方便代码的阅读和维护 利于SEO：方便爬虫根据 语义标签 确定 页面结构 和 关键字 的权重 常见语义化标签一图胜千言： 元素细节： &lt;main&gt; 存放每个页面独有的内容。每个页面上只能用一次 &lt;main&gt;，且直位于 &lt;body&gt;中。最好不要把它嵌套进其它元素。 &lt;article&gt; 包围的内容即一篇文章，与页面其它部分无关（比如一篇博文）。 &lt;section&gt; 与 &lt;article&gt; 类似，但 &lt;section&gt; 更适用于组织页面使其按功能（比如迷你地图、一组文章标题和摘要）分块。一般的最佳用法是：以 标题 作为开头；也可以把一篇 &lt;article&gt; 分成若干部分并分别置于不同的 &lt;section&gt; 中，也可以把一个区段 &lt;section&gt; 分成若干部分并分别置于不同的 &lt;article&gt; 中，取决于上下文。 &lt;aside&gt; 包含一些间接信息（术语条目、作者简介、相关链接，等等）。 &lt;header&gt; 是简介形式的内容。如果它是 &lt;body&gt; 的子元素，那么就是网站的全局页眉。如果它是 &lt;article&gt; 或&lt;section&gt; 的子元素，那么它是这些部分特有的页眉（此 &lt;header&gt; 非彼 标题）。 &lt;nav&gt; 包含页面主导航功能。其中不应包含二级链接等内容。 &lt;footer&gt; 包含了页面的页脚部分。 来源：文档与网站架构]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>语义化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo搭建个人博客]]></title>
    <url>%2Fposts%2F43303%2F</url>
    <content type="text"><![CDATA[介绍利用 Hexo 在 GitHub 上搭建个人博客。 准备工作你的电脑需要安装下面两个应用程序： NodeJS 如何安装 Git 如何安装 重要步骤安装Hexo安装文档 插件安装 hexo-abbrlink 介绍 &amp;&amp; 此插件诞生原因 hexo-deployer-git 将本地博客部署到GitHub 如何安装和使用 hexo-server npm install hexo-server –save 服务器模块。在启动期间，Hexo 会监视文件变动并自动更新 使用第三方主题 Next Yilia 创建分类功能运行： 1hexo new page &quot;categories&quot; p.s. 命名为categories原因是 categories 在next主题中是一个关键词对应着分类。 在主站根目录下,也就是你hexo的目录下找到 /source/categories/index.md，打开后的效果类似下方代码： 123456---title: categories #本页标题date: 2019-03-13 23:02:50 #创建日期type: "categories" #分类属于comments: false #如果有启用多说 或者 Disqus评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false--- 接着在 themes 主题文件夹下找到 next 文件夹，修改 _config.yml 文件： 123456menu: home: / || home # 地址路径 | 导航栏对应的图标 about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 然后在命令行输入添加文章命令： 1hexo new '你想要创建的文章名称' 根目录(主站目录下)/source/_posts/上一步创建的文章名称.md，双击打开： 123456---title: 文章标题date: 2019-03-13 23:13:23tags: html #属于哪个标签categories: interview #属于哪个分类--- 参考：分类和标签p.s. 如果想要实现父子分类，可以查看上方链接的评论 创建标签功能打开命令行，进入博客所在文件夹。执行命令：1hexo new page tags 成功后会有一个路径提示1INFO Created: ~/Documents/blog/source/tags/index.md 找到对应的文件打开1234---title: 标签date: 2019-03-14 00:02:05--- 添加type: “tags”到内容中，添加后是这样的：12345---title: 标签date: 2019-03-14 00:03:52type: 'tags'--- 打开你的文章页面：123456---title: jQuery对表单的操作及更多应用date: 2019-03-14 00:03:55categories: 前端 tags: jQuery #如果想要多个标签可以 tags: [jQuery, 表格, 表单验证]--- 不蒜子统计功能NexT主题集成了不蒜子统计功能，在NexT配置文件中找到关键词 busuanzi_count: ，把 enable 设置为 true p.s. 除此之外，如果设置为true后仍然无效，且打开控制台显示js报错。有可能是不蒜子链接失效的原因，需要在Next主题配置文件位置：1themes\next\layout\_third-party\analytics\busuanzi-counter.swig 修改script链接为：1&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 评论功能使用 Valine 参考： 评论系统从Disqus到Valine Valine - 一款快速、简洁且高效的无后端评论系统。 常用配置 Hexo瞎折腾系列(4) - 站点首页不显示文章全文 常用命令12345678910111213141516171819// npm全局安装Hexonpm install -g hexo-cli // 新建Hexo项目hexo init &lt;folder&gt;cd &lt;folder&gt;npm install// 新建文章hexo new '文章名'// 启动服务器hexo server -p 5000// 生成静态文件hexo generate --watch// 部署hexo clean &amp;&amp; hexo deploy 相关配置及资源 Hexo+NexT 打造一个炫酷博客 这应该是最全的hexo博客搭建以及next美化教程 给hexo添加Valine评论功能 LeanCloud Hexo搭建GitHub博客—打造炫酷的NexT主题–高级(四)]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
