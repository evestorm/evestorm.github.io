<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BFC的理解与应用</title>
    <url>/posts/9722/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>先上MDN上对 BFC 的定义：</p>
<blockquote>
<p>块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>
</blockquote>
<p>———— <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">BFC | MDN</a></p>
<p>不知道别人看完这段定义有何感受，反正我是懵逼的。不过我在这儿还是建议各位认真阅读上面给出的MDN链接至少两遍，这能让你对一个陌生的概念有一个基本的认知。</p>
<a id="more"></a>

<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>这里谈下我对BFC的理解：BFC其实是一个独立的，与外界隔离了的容器，容器里面的子元素不会影响到外面的元素，外面的也同样不会影响到容器内部的元素。我们可以利用这个特性，来解决一些布局上的问题。</p>
<h2 id="BFC触发条件"><a href="#BFC触发条件" class="headerlink" title="BFC触发条件"></a>BFC触发条件</h2><p>BFC的触发条件有很多，想要知道所有细节可以移步上面给出的 MDN 链接。这里我只列出一些常见触发条件：</p>
<ul>
<li>根元素（HTML元素）</li>
<li>浮动元素（float不为none）</li>
<li>绝对定位元素（position 为 absolute 或 fixed）</li>
<li>display 为 block, inline-block, flex, inline-flex, list-item, table</li>
<li>overflow 值不为 visible 的块元素</li>
</ul>
<h2 id="BFC布局特性"><a href="#BFC布局特性" class="headerlink" title="BFC布局特性"></a>BFC布局特性</h2><p>对于一个BFC容器来说：</p>
<ul>
<li>内部相邻的两个元素垂直方向上的 margin 会发生重叠</li>
<li>不会与外界的浮动元素产生交集，而是紧贴浮动元素的边缘</li>
<li>元素从容器的顶端开始垂直地一个接一个地排列</li>
<li>每一个元素的左外边缘（margin-left）会触碰到容器的左边缘（border-left）（如果设置了容器内部的元素从右到左的格式排布，则触碰的是右边缘）</li>
<li>在计算它的高度时，还会检测内部浮动或者定位元素的高度</li>
</ul>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>利用BFC “在计算它的高度时，还会检测内部浮动或者定位元素的高度” 这条特性，我们可以触发父元素的BFC来清除子元素浮动带来的影响。常见的用法是给父元素设置 <code>overflow: hidden</code> 样式（如果考虑IE6版本，还需设置 <code>zoom: 1</code>，因为IE6不支持 <code>overflow: hidden</code> 来清除浮动）：</p>
<iframe height="265" scrolling="no" title="利用BFC清除浮动" src="https://codepen.io/JingW/embed/BbxEGP/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="解决外边距合并问题"><a href="#解决外边距合并问题" class="headerlink" title="解决外边距合并问题"></a>解决外边距合并问题</h3><p>如果看上面标题不知道在说什么，请很戳<a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp">这里</a>了解详情。由于属于同一个BFC的两个相邻盒子的垂直margin会发生重叠，那么我们可以隔离开这两个元素，让它们不属于同一个BFC，这样就不会发生margin重叠了。</p>
<iframe height="265" scrolling="no" title="解决外边距合并问题" src="https://codepen.io/JingW/embed/YgLbzY/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="两栏布局，右边宽度自适应"><a href="#两栏布局，右边宽度自适应" class="headerlink" title="两栏布局，右边宽度自适应"></a>两栏布局，右边宽度自适应</h3><p>我们常常在开发中有这样类似的需求：两栏布局，左边定宽，右边自适应。<br>这时我们就可以利用BFC特性来实现需求：左边设置定宽+左浮动；右边给自己加上 <code>overflow: hidden</code> 。<br>原理就是：给元素设置BFC后，为了和浮动元素不产生任何交集，它会顺着浮动元素的边缘形成自己的封闭上下文。直接上代码看效果：</p>
<iframe height="265" scrolling="no" title="利用BFC实现两栏布局" src="https://codepen.io/JingW/embed/MxGdEe/?height=265&amp;theme-id=0&amp;default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<p>以上是我对BFC的一些理解以及实际应用，希望能够帮助大家了解BFC这个听起来摸不着头脑的东西。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中如何实现继承</title>
    <url>/posts/2751/</url>
    <content><![CDATA[<h2 id="组合继承（原型链-借用构造函数）"><a href="#组合继承（原型链-借用构造函数）" class="headerlink" title="组合继承（原型链 + 借用构造函数）"></a>组合继承（原型链 + 借用构造函数）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组合继承:原型继承+借用（调用）构造函数继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex, score</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 借用构造函数</span></span><br><span class="line">  Person.call(<span class="built_in">this</span>,name,age,sex);</span><br><span class="line">  <span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改变原型指向----继承</span></span><br><span class="line"><span class="comment">// 我们让 Student.prototype 指向一个Person的实例对象</span></span><br><span class="line"><span class="comment">// 这个对象的__proto__指向的是Person.prototype</span></span><br><span class="line"><span class="comment">// 所以我们就可以借助这个实例对象拿到sayHi方法，实现继承</span></span><br><span class="line">Student.prototype=<span class="keyword">new</span> Person();</span><br><span class="line">Student.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">&quot;Lance&quot;</span>, <span class="number">20</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;100分&quot;</span>);</span><br><span class="line">stu.sayHi();</span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> Student(<span class="string">&quot;Jerry&quot;</span>, <span class="number">19</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;101分&quot;</span>);</span><br><span class="line">stu2.eat();</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性和方法都被继承了</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="寄生组合继承（组合继承升级版）"><a href="#寄生组合继承（组合继承升级版）" class="headerlink" title="寄生组合继承（组合继承升级版）"></a>寄生组合继承（组合继承升级版）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">// 创建了父类原型的浅复制</span></span><br><span class="line">    prototype.constructor = subType;             <span class="comment">// 修正原型的构造函数</span></span><br><span class="line">    subType.prototype = prototype;               <span class="comment">// 将子类的原型替换为这个原型</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费</span></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ES6继承写法"><a href="#ES6继承写法" class="headerlink" title="ES6继承写法"></a>ES6继承写法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;<span class="built_in">this</span>.name=name;<span class="built_in">this</span>.age=age&#125;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age, weight</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age); <span class="built_in">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在原型链继承时，为什么不直接-Student-prototype-Person-prototype-？"><a href="#在原型链继承时，为什么不直接-Student-prototype-Person-prototype-？" class="headerlink" title="在原型链继承时，为什么不直接 Student.prototype = Person.prototype ？"></a>在原型链继承时，为什么不直接 <code>Student.prototype = Person.prototype</code> ？</h2><p>因为对象的赋值只是引用的赋值, 上面两者都指向同一个内存地址，只要随便通过1个途径就能修改该内存地址的对象，这样子类就无法单独扩展方法，而且会影响父类。</p>
<h2 id="组合继承的缺点"><a href="#组合继承的缺点" class="headerlink" title="组合继承的缺点"></a>组合继承的缺点</h2><p>缺点就是调用了两次父类的构造函数。<br>第一次给子类的原型添加了父类构造函数中的属性方法；第二次又给子类的构造函数添加了父类的构造函数的属性方法，从而覆盖了子类原型中的同名参数。这种被覆盖的情况造成了性能上的浪费：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SuperType.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is parent&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="built_in">this</span>) <span class="comment">// 第二次调用SuperType</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType() <span class="comment">// 第一次调用SuperType</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>JS数组有哪些常用方法</title>
    <url>/posts/21501/</url>
    <content><![CDATA[<h2 id="改变原数组的方法"><a href="#改变原数组的方法" class="headerlink" title="改变原数组的方法"></a>改变原数组的方法</h2><h3 id="splice-添加-删除数组元素"><a href="#splice-添加-删除数组元素" class="headerlink" title="splice() 添加/删除数组元素"></a>splice() 添加/删除数组元素</h3><blockquote>
<p>splice() 方法<strong>向/从数组中添加/删除</strong>项目，然后返回被删除的项目</p>
<p>array.splice(index,howmany,item1,…..,itemX)</p>
<ol>
<li>index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</li>
<li>howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。</li>
<li>item1, …, itemX： 可选。向数组添加的新项目。</li>
</ol>
<p>返回值: 如果有元素被删除,返回包含被删除项目的新数组。</p>
</blockquote>
<a id="more"></a>

<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组下标0开始，删除3个元素</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7</span></span><br><span class="line"><span class="keyword">let</span> item = a.splice(-<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// [7]</span></span><br></pre></td></tr></table></figure>

<h4 id="删除并添加"><a href="#删除并添加" class="headerlink" title="删除并添加"></a>删除并添加</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组下标0开始，删除3个元素，并添加元素&#x27;添加&#x27;</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;添加&#x27;</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [&#x27;添加&#x27;,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组最后第二个元素开始，删除3个元素，并添加两个元素&#x27;添加1&#x27;、&#x27;添加2&#x27;</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = b.splice(-<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;添加1&#x27;</span>,<span class="string">&#x27;添加2&#x27;</span>); <span class="comment">// [6,7]</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [1,2,3,4,5,&#x27;添加1&#x27;,&#x27;添加2&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="不删除只添加"><a href="#不删除只添加" class="headerlink" title="不删除只添加"></a>不删除只添加</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;添加1&#x27;</span>,<span class="string">&#x27;添加2&#x27;</span>); <span class="comment">// [] 没有删除元素，返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [&#x27;添加1&#x27;,&#x27;添加2&#x27;,1,2,3,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = b.splice(-<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;添加1&#x27;</span>,<span class="string">&#x27;添加2&#x27;</span>); <span class="comment">// [] 没有删除元素，返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [1,2,3,4,5,6,&#x27;添加1&#x27;,&#x27;添加2&#x27;,7] 在最后一个元素的前面添加两个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="sort-数组排序"><a href="#sort-数组排序" class="headerlink" title="sort() 数组排序"></a>sort() 数组排序</h3><blockquote>
<p>定义: sort()方法对数组元素进行排序，并返回这个数组。</p>
<p>参数可选: 规定排序顺序的比较函数。</p>
<p>默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用<code>toString()</code>方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。</p>
</blockquote>
<h4 id="不传参"><a href="#不传参" class="headerlink" title="不传参"></a>不传参</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串排列 看起来很正常</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>];</span><br><span class="line">a.sort(); <span class="comment">// [&quot;Apple&quot;,&quot;Banana&quot;,&quot;Mango&quot;,&quot;Orange&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>,<span class="number">25</span>,<span class="number">8</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a.sort()) <span class="comment">// [1,10,20,25,3,8];</span></span><br></pre></td></tr></table></figure>

<p><strong>比较函数的两个参数：</strong></p>
<p>sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：</p>
<ul>
<li>若比较函数返回值&lt;0，那么a将排到b的前面;</li>
<li>若比较函数返回值=0，那么a 和 b 相对位置不变；</li>
<li>若比较函数返回值&gt;0，那么b 排在a 将的前面；</li>
</ul>
<h4 id="数字升降序"><a href="#数字升降序" class="headerlink" title="数字升降序"></a>数字升降序</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array =  [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">4</span>, <span class="number">25</span>, <span class="number">8</span>];  </span><br><span class="line">array.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [1,3,4,4,8,10,20,25];</span></span><br><span class="line"></span><br><span class="line">array.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b-a;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [25,20,10,8,4,4,3,1];</span></span><br></pre></td></tr></table></figure>

<h3 id="pop-删除一个数组中的最后的一个元素"><a href="#pop-删除一个数组中的最后的一个元素" class="headerlink" title="pop() 删除一个数组中的最后的一个元素"></a>pop() 删除一个数组中的最后的一个元素</h3><blockquote>
<p>定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.pop();  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure>

<h3 id="shift-删除数组的第一个元素"><a href="#shift-删除数组的第一个元素" class="headerlink" title="shift() 删除数组的第一个元素"></a>shift() 删除数组的第一个元素</h3><blockquote>
<p>定义: shift()方法删除数组的第一个元素，并返回这个元素。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.shift();  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [2,3]</span></span><br></pre></td></tr></table></figure>

<h3 id="push-向数组的末尾添加元素"><a href="#push-向数组的末尾添加元素" class="headerlink" title="push() 向数组的末尾添加元素"></a>push() 向数组的末尾添加元素</h3><blockquote>
<p>定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p>
<p>参数: item1, item2, …, itemX ,要添加到数组末尾的元素</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.push(<span class="string">&#x27;末尾&#x27;</span>, <span class="string">&#x27;233&#x27;</span>);  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [1,2,3,&#x27;末尾&#x27;, &#x27;233&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><blockquote>
<p>定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</p>
<p>参数: item1, item2, …, itemX ,要添加到数组开头的元素</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.unshift(<span class="string">&#x27;开头&#x27;</span>, <span class="string">&#x27;开头2&#x27;</span>);  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [ &#x27;开头&#x27;, &#x27;开头2&#x27;, 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="reverse-颠倒数组中元素的顺序"><a href="#reverse-颠倒数组中元素的顺序" class="headerlink" title="reverse() 颠倒数组中元素的顺序"></a>reverse() 颠倒数组中元素的顺序</h3><blockquote>
<p>定义: reverse() 方法用于颠倒数组中元素的顺序。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.reverse();  </span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [3,2,1]</span></span><br></pre></td></tr></table></figure>

<h2 id="不改变原数组的方法"><a href="#不改变原数组的方法" class="headerlink" title="不改变原数组的方法"></a>不改变原数组的方法</h2><h3 id="slice-浅拷贝数组的元素"><a href="#slice-浅拷贝数组的元素" class="headerlink" title="slice() 浅拷贝数组的元素"></a>slice() 浅拷贝数组的元素</h3><blockquote>
<p>定义： 方法返回一个从开始到结束（<strong>不包括结束</strong>）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。</p>
<p>语法：array.slice(begin, end);</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a= [<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> b=a.slice(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// [&#x27;hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。</span></span><br><span class="line"><span class="comment">// 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="string">&#x27;改变原数组&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b); <span class="comment">// [&#x27;改变原数组&#x27;,&#x27;world&#x27;] [&#x27;hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a= [&#123;<span class="attr">name</span>:<span class="string">&#x27;OBKoro1&#x27;</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> b=a.slice();</span><br><span class="line"><span class="built_in">console</span>.log(b,a); <span class="comment">// [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;]  [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;]</span></span><br><span class="line"><span class="comment">// a[0].name=&#x27;改变原数组&#x27;;</span></span><br><span class="line"><span class="comment">// console.log(b,a); // [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;] [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;]</span></span><br></pre></td></tr></table></figure>

<h3 id="join-数组转字符串"><a href="#join-数组转字符串" class="headerlink" title="join() 数组转字符串"></a>join() 数组转字符串</h3><blockquote>
<p>定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。</p>
<p>语法: array.join(str)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a= [<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str=a.join(); <span class="comment">// &#x27;hello,world&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2=a.join(<span class="string">&#x27;+&#x27;</span>); <span class="comment">// &#x27;hello+world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a= [[<span class="string">&#x27;OBKoro1&#x27;</span>,<span class="string">&#x27;23&#x27;</span>],<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str1=a.join(); <span class="comment">// OBKoro1,23,test</span></span><br><span class="line"><span class="keyword">let</span> b= [&#123;<span class="attr">name</span>:<span class="string">&#x27;OBKoro1&#x27;</span>,<span class="attr">age</span>:<span class="string">&#x27;23&#x27;</span>&#125;,<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str2 = b.join(); <span class="comment">// [object Object],test</span></span><br><span class="line"><span class="comment">// 对象转字符串推荐JSON.stringify(obj);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结论：</span></span><br><span class="line"><span class="comment">// join()/toString()方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),</span></span><br><span class="line"><span class="comment">// 如果是对象的话，对象会被转为[object Object]字符串。</span></span><br></pre></td></tr></table></figure>

<h3 id="join-数组转字符串-1"><a href="#join-数组转字符串-1" class="headerlink" title="join() 数组转字符串"></a>join() 数组转字符串</h3><blockquote>
<p>定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。</p>
<p>语法: array.join(str)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a= [<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str=a.join(); <span class="comment">// &#x27;hello,world&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2=a.join(<span class="string">&#x27;+&#x27;</span>); <span class="comment">// &#x27;hello+world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a= [[<span class="string">&#x27;OBKoro1&#x27;</span>,<span class="string">&#x27;23&#x27;</span>],<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str1=a.join(); <span class="comment">// OBKoro1,23,test</span></span><br><span class="line"><span class="keyword">let</span> b= [&#123;<span class="attr">name</span>:<span class="string">&#x27;OBKoro1&#x27;</span>,<span class="attr">age</span>:<span class="string">&#x27;23&#x27;</span>&#125;,<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str2 = b.join(); <span class="comment">// [object Object],test</span></span><br><span class="line"><span class="comment">// 对象转字符串推荐JSON.stringify(obj);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结论：</span></span><br><span class="line"><span class="comment">// join()/toString()方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),</span></span><br><span class="line"><span class="comment">// 如果是对象的话，对象会被转为[object Object]字符串。</span></span><br></pre></td></tr></table></figure>

<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><blockquote>
<p>定义： 方法用于合并两个或多个数组，返回一个新数组。</p>
<p>语法：var newArr =oldArray.concat(arrayX,arrayX,……,arrayX)</p>
<p>参数：arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">//连接两个数组</span></span><br><span class="line"><span class="keyword">let</span> newVal=a.concat(b); <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment">// 连接三个数组</span></span><br><span class="line"><span class="keyword">let</span> c = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> newVal2 = a.concat(b, c); <span class="comment">// [1,2,3,4,5,6,7,8,9]</span></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="keyword">let</span> newVal3 = a.concat(<span class="string">&#x27;添加元素&#x27;</span>,b, c,<span class="string">&#x27;再加一个&#x27;</span>); </span><br><span class="line"><span class="comment">// [1,2,3,&quot;添加元素&quot;,4,5,6,7,8,9,&quot;再加一个&quot;]</span></span><br><span class="line"><span class="comment">// 合并嵌套数组  会浅拷贝嵌套数组</span></span><br><span class="line"><span class="keyword">let</span> d = [<span class="number">1</span>,<span class="number">2</span> ];</span><br><span class="line"><span class="keyword">let</span> f = [<span class="number">3</span>,[<span class="number">4</span>]];</span><br><span class="line"><span class="keyword">let</span> newVal4 = d.concat(f); <span class="comment">// [1,2,3,[4]]</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6扩展运算符-合并数组"><a href="#ES6扩展运算符-合并数组" class="headerlink" title="ES6扩展运算符...合并数组"></a>ES6扩展运算符<code>...</code>合并数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> b = [ <span class="number">4</span>,...a, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a,b); <span class="comment">//  [2, 3, 4, 5] [4,2,3,4,5,4,4]</span></span><br></pre></td></tr></table></figure>

<h3 id="indexOf-查找数组是否存在某个元素，返回下标"><a href="#indexOf-查找数组是否存在某个元素，返回下标" class="headerlink" title="indexOf() 查找数组是否存在某个元素，返回下标"></a>indexOf() 查找数组是否存在某个元素，返回下标</h3><blockquote>
<p>定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p>
<p>p.s. 字符串也有此方法，要注意当 ‘lance’.indexOf(‘’) 一个空字符串时，返回0而不是-1</p>
<p>语法：array.indexOf(searchElement,fromIndex)</p>
<p>参数：</p>
<p>searchElement(必须):被查找的元素</p>
<p>fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。</p>
<p>严格相等的搜索:</p>
<p>数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等<code>===</code>搜索元素，即<strong>数组元素要完全匹配</strong>才能搜索成功。</p>
<p><strong>注意</strong>：indexOf()不能识别<code>NaN</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="string">&#x27;啦啦&#x27;</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">24</span>,<span class="literal">NaN</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">&#x27;啦&#x27;</span>));  <span class="comment">// -1 </span></span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">&#x27;NaN&#x27;</span>));  <span class="comment">// -1 </span></span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">&#x27;啦啦&#x27;</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="lastIndexOf-查找指定元素在数组中的最后一个位置"><a href="#lastIndexOf-查找指定元素在数组中的最后一个位置" class="headerlink" title="lastIndexOf() 查找指定元素在数组中的最后一个位置"></a>lastIndexOf() 查找指定元素在数组中的最后一个位置</h3><blockquote>
<p>定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）</p>
<p>语法：arr.lastIndexOf(searchElement,fromIndex)</p>
<p>参数:</p>
<p>searchElement(必须): 被查找的元素</p>
<p>fromIndex(可选): 逆向查找开始位置，默认值数组的 <code>长度-1</code>，即查找整个数组。</p>
<p>关于fromIndex有三个规则:</p>
<ol>
<li>正值。如果该值大于或等于数组的长度，则整个数组会被查找。</li>
<li>负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)</li>
<li>负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="string">&#x27;OB&#x27;</span>,<span class="number">4</span>,<span class="string">&#x27;Koro1&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;Koro1&#x27;</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;Koro1&#x27;</span>]; <span class="comment">// 数组长度为10</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,4); // 从下标4开始往前找 返回下标2</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,100); //  大于或数组的长度 查找整个数组 返回9</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,-11); // -1 数组不会被查找</span></span><br><span class="line"><span class="keyword">let</span> b=a.lastIndexOf(<span class="string">&#x27;Koro1&#x27;</span>,-<span class="number">9</span>); <span class="comment">// 从第二个元素4往前查找，没有找到 返回-1</span></span><br></pre></td></tr></table></figure>

<h3 id="ES7-includes-查找数组是否包含某个元素-返回布尔"><a href="#ES7-includes-查找数组是否包含某个元素-返回布尔" class="headerlink" title="ES7 includes() 查找数组是否包含某个元素 返回布尔"></a>ES7 includes() 查找数组是否包含某个元素 返回布尔</h3><blockquote>
<p>定义： 返回一个布尔值，表示某个数组是否包含给定的值</p>
<p>语法：array.includes(searchElement,fromIndex=0)</p>
<p>参数：</p>
<p>searchElement(必须):被查找的元素</p>
<p>fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。</p>
<p><strong>includes方法是为了弥补indexOf方法的缺陷而出现的:</strong></p>
<ol>
<li>indexOf方法不能识别<code>NaN</code></li>
<li>indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于<code>-1</code>，表达不够直观</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="string">&#x27;OB&#x27;</span>,<span class="string">&#x27;Koro1&#x27;</span>,<span class="number">1</span>,<span class="literal">NaN</span>];</span><br><span class="line"><span class="comment">// let b=a.includes(NaN); // true 识别NaN</span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,100); // false 超过数组长度 不搜索</span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,-3);  // true 从倒数第三个元素开始搜索 </span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,-100);  // true 负值绝对值超过数组长度，搜索整个数组</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>Promise用法</title>
    <url>/posts/7878/</url>
    <content><![CDATA[<h2 id="Promise是什么"><a href="#Promise是什么" class="headerlink" title="Promise是什么"></a>Promise是什么</h2><p>Promise 是一种异步编程的解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。</p>
<h2 id="诞生的原因"><a href="#诞生的原因" class="headerlink" title="诞生的原因"></a>诞生的原因</h2><p>异步网络请求的<strong>回调地狱</strong>，而且我们还得对每次请求的结果进行一些处理，代码会更加臃肿。一张图完美诠释：</p>
<img src="/posts/undefined/call-back-hello.jpg" class="" title="回调地狱">

<p>不够？再加一张：</p>
<img src="/posts/undefined/8144ca8cgw1f2wc9ed35zj218g0p0tey.jpg" class="" title="行为艺术">

<h2 id="Promise的三种状态"><a href="#Promise的三种状态" class="headerlink" title="Promise的三种状态"></a>Promise的三种状态</h2><ul>
<li>pedding 等待（默认状态。异步代码执行完毕后会转换为以下两种状态）</li>
<li>resolve 成功</li>
<li>reject 失败</li>
</ul>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li>Promise:<ul>
<li>构造函数</li>
<li>接受一个参数：callback，我们把要执行的异步任务放置在这个callback中</li>
</ul>
</li>
<li>then:<ul>
<li>Promise对象下的一个方法：该方法在Promise对象的状态发生改变的时候触发then的回调</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//defined Promise async function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolve(<span class="comment">/*resolve parameter*/</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="comment">/*Error*/</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//use Promise&amp;then</span></span><br><span class="line">asyncFun().then(<span class="comment">/*function*/</span>).then(<span class="comment">/*function*/</span>)...</span><br></pre></td></tr></table></figure>

<h2 id="Promise特性"><a href="#Promise特性" class="headerlink" title="Promise特性"></a>Promise特性</h2><h3 id="立即执行"><a href="#立即执行" class="headerlink" title="立即执行"></a>立即执行</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当Promise被实例化的时候，callback的异步任务就会被执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;一个Promise对象被创建出来&quot;</span>);</span><br><span class="line">    resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 一个Promise对象被创建出来</span></span><br><span class="line"><span class="comment">// flag</span></span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure>

<h3 id="状态不可逆"><a href="#状态不可逆" class="headerlink" title="状态不可逆"></a>状态不可逆</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    reject(<span class="string">&quot;reject&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure>

<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过传入的resolve, reject，去改变当前Promise任务的状态</span></span><br><span class="line">    <span class="comment">// resolve, reject 是两个函数，调用 resolve ，会把状态改成 resolved ，调用 reject 函数会把状态改成 rejected</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        reject();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// then接受两个参数：这两个参数都是回调，当对应的 promise 对象的状态变成了resolved，那么 then 的第一个 callback 就会被执行，如果状态变成了 rejected ，那么 then 的第二个 callback 就会被执行</span></span><br><span class="line">p.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 失败</span></span><br></pre></td></tr></table></figure>

<h3 id="then的回调异步性"><a href="#then的回调异步性" class="headerlink" title="then的回调异步性"></a>then的回调异步性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是Promise的callback中的代码&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;我1s后才会被执行&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;我是主线程中的同步代码&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 我是Promise的callback中的代码</span></span><br><span class="line"><span class="comment">// 我是主线程中的同步代码</span></span><br><span class="line"><span class="comment">// 我1s后才会被执行</span></span><br></pre></td></tr></table></figure>

<p>解释：Promise 的 callback 回调函数中的代码是立即执行的（setTimeout 这个定时器也是立即执行的，只是函数内的 resolve 被延迟1s执行，跟 Promise 本身的立即执行没关系），但 then 方法中的回调函数执行则是异步的，因此，<code>&quot;我1s后才会被执行&quot;</code> 会在最后输出。</p>
<h3 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h3><p>Promise的异常有两种方法可以捕获，一种是 then 的第二个回调；一种 <code>.catch()</code> 来捕获前一个 Promise 抛出的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;catch:&quot;</span> + error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// catch:error</span></span><br></pre></td></tr></table></figure>

<h2 id="Promise-all-和-Promise-race"><a href="#Promise-all-和-Promise-race" class="headerlink" title="Promise.all 和 Promise.race"></a>Promise.all 和 Promise.race</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all 接收一个参数，它必须是可以迭代的，例如数组。<br>它通常用来处理一些并发的异步操作，即它们的结果互不干扰，但是又需要异步执行。当所有 Promise 都成功的时候，整个 Promise.all 才成功。成功调用后返回一个数组，数组的值是有序的，顺序就是传入参数的数组顺序：</p>
<blockquote>
<p>成功的情况</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> tasks = arr.map(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(num * <span class="number">5</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 有序输出</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// [5, 10, 15]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>失败的情况</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> tasks = arr.map(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num === <span class="number">3</span>) &#123;</span><br><span class="line">            reject(<span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(num * <span class="number">5</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里不会执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// rejected</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race 和 Promise.all 类似，都接收一个可以迭代的参数，但是不同之处是 Promise.race 的状态变化不是全部受参数内的状态影响，一旦参数内有一个值的状态发生的改变，那么该 Promise 的状态就是改变的状态。就跟 race 单词的字面意思一样，谁跑的快谁赢。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">300</span>, <span class="string">&#x27;p1 doned&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">50</span>, <span class="string">&#x27;p2 doned&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(reject, <span class="number">100</span>, <span class="string">&#x27;p3 rejected&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2, p3]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 显然p2更快，所以状态变成了fulfilled</span></span><br><span class="line">    <span class="comment">// 如果p3更快，那么状态就会变成rejected</span></span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// p2 doned</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 不执行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>let和const和var的区别</title>
    <url>/posts/37021/</url>
    <content><![CDATA[<h2 id="const-和-let-异同"><a href="#const-和-let-异同" class="headerlink" title="const 和 let 异同"></a>const 和 let 异同</h2><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul>
<li>let 定义变量可以只声明不赋值</li>
<li>const 定义常量声明时必须赋值，一旦定义不可轻易改变</li>
</ul>
<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>解决 var 没有块作用域,、变量提升、可以重复声明的问题。 let 和 const 有自己的块作用域, 不存在变量提升问题, 同一块作用域中不可重复声明（会报错）。</p>
<h2 id="let-const-和-var-区别"><a href="#let-const-和-var-区别" class="headerlink" title="let/const 和 var 区别"></a>let/const 和 var 区别</h2><ul>
<li>var 有变量提升，let/const 没有</li>
<li>let/const 的作用域是块，而 var 的作用域是函数</li>
<li>let/const 有暂时性死区，只要 let/const 声明的变量，在未声明之前使用或者赋值都会报错（ReferenceError）</li>
<li>let/const 不能被重复定义</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>null 和 undefined 的区别</title>
    <url>/posts/63928/</url>
    <content><![CDATA[<h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><ul>
<li>null 表示一个对象是“没有值”的值，也就是值为“空”</li>
<li>undefined 表示一个变量声明了没有初始化(赋值)</li>
</ul>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul>
<li>undefined 的类型(typeof)是 undefined</li>
<li>null 的类型(typeof)是 object</li>
</ul>
<a id="more"></a>

<h2 id="双等三等"><a href="#双等三等" class="headerlink" title="双等三等"></a>双等三等</h2><p>另外，在验证 null 时，一定要使用 <code>===</code> ，因为 <code>==</code> 无法分辨 null 和 undefined ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copynull &#x3D;&#x3D; undefined &#x2F;&#x2F; true </span><br><span class="line">null &#x3D;&#x3D;&#x3D; undefined &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><ol>
<li>变量提升：只声明未定义默认值就是 undefined</li>
<li>严格模式下：没有明确的执行主体，this 就是 undefined</li>
<li>对象没有这个属性名，属性值是 undefined</li>
<li>函数定义形参不传值，默认就是 undefined</li>
<li>函数没有返回值（没有 return 或者 return; ），默认返回的就是 undefined</li>
<li>数组越界取值也是 undefined （arr=[1,2]; arr[10] =&gt; undefined）</li>
<li>…</li>
</ol>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><ol>
<li>手动设置变量的值或者对象某个属性值为null（此时不赋值，后面会赋值）</li>
<li>在 JS 的 DOM 元素获取中，如果没有获取到指定的元素对象，结果一般都是null</li>
<li>Object.prototype.<strong>proto</strong> 的值也是 null</li>
<li>正则捕获的时候，如果没有捕获到结果，默认也是null</li>
<li>…</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Javascript会将未赋值的变量默认值设为undefined；Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>三栏布局方案(圣杯_双飞翼)</title>
    <url>/posts/10370/</url>
    <content><![CDATA[<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><h3 id="步骤一-HTML框架搭建-amp-初始化CSS"><a href="#步骤一-HTML框架搭建-amp-初始化CSS" class="headerlink" title="步骤一 - HTML框架搭建 &amp; 初始化CSS"></a>步骤一 - HTML框架搭建 &amp; 初始化CSS</h3><p>首先把基本框架搭起来（注意中间部分放最前面）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>我是中间<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>我是左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>我是右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>接下来是初始化样式。left, right宽度分别设置为100px和200px；然后设置container的 <code>padding-left: 100px</code> + <code>padding-right: 200px</code> 来占据两侧填充；center宽度设为100%，这样能够自适应剩下的宽度。再让所有子元素左浮动。代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">100px</span>; <span class="comment">/* 左边100， 右边200*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e1e1e1</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>; <span class="comment">/* 为了看效果，给个300px把高度撑起来 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.center</span>, <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>; <span class="comment">/* 占据父元素剩下的宽度*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的页面效果：</p>
<img src="/posts/10370/%E5%9C%A3%E6%9D%AFstep1.png" class="" title="圣杯step1">

<h3 id="步骤二-让left占据最左列"><a href="#步骤二-让left占据最左列" class="headerlink" title="步骤二 - 让left占据最左列"></a>步骤二 - 让left占据最左列</h3><p>为了让left能越过center，我们先给它设置一个 -100% 的左边距。这个100%是在container中的宽度，也就是center的宽度：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="comment">/*为了看left和center的重叠效果，暂时bgc设为半透明*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">204</span>,<span class="number">204</span>,.<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页面效果：</p>
<img src="/posts/10370/%E5%9C%A3%E6%9D%AFstep2.png" class="" title="圣杯step2">

<p>此时，我们已经让left从“第二行”升到了“第一行”，为了让它靠到最左侧，不与center重叠，可以给它设置相对定位，然后给个 <code>left: -100px</code> ，让它定位到container最左侧：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="comment">/* 设置相对定位 */</span> </span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="comment">/* 靠到最左侧 */</span></span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页面效果：</p>
<img src="/posts/10370/%E5%9C%A3%E6%9D%AFstep3.png" class="" title="圣杯step3">

<h3 id="步骤三-让right占据最右列"><a href="#步骤三-让right占据最右列" class="headerlink" title="步骤三 - 让right占据最右列"></a>步骤三 - 让right占据最右列</h3><p>定位好了left，也是时候让right呆在最右边来填充位置了，我们继续使用负margin：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: -<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页面效果：</p>
<img src="/posts/10370/%E5%9C%A3%E6%9D%AFstep4.png" class="" title="圣杯step4">

<h3 id="步骤四-给container设置min-width"><a href="#步骤四-给container设置min-width" class="headerlink" title="步骤四 - 给container设置min-width"></a>步骤四 - 给container设置min-width</h3><p>看起来已经实现了不是吗？但我们还差最后一步，给container设置一个 <code>min-width: 100px</code> （就是左列的宽度），否则当浏览器缩小到一定程度时，这个布局可能会被破坏。原因简单来讲就是：“由于设置了相对定位，所以当left原来的位置和right的位置产生重叠时，由于浮动的原因一行放不下就会换行”。所以布局就被打乱了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e1e1e1</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码-最终效果"><a href="#完整代码-最终效果" class="headerlink" title="完整代码 + 最终效果"></a>完整代码 + 最终效果</h3><p>这样，我们就实现了圣杯布局，完整代码和效果见下：</p>
<iframe height="265" scrolling="no" title="三栏布局 - 圣杯布局" src="https://codepen.io/JingW/embed/VRXYmz/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p>如果上面圣杯布局你已经理解并自己实践了一遍，那么这里的双飞翼布局你也应该不再话下。跟着我一起撸一遍代码吧。</p>
<h3 id="步骤一-HTML框架搭建-amp-初始化CSS-1"><a href="#步骤一-HTML框架搭建-amp-初始化CSS-1" class="headerlink" title="步骤一 - HTML框架搭建 &amp; 初始化CSS"></a>步骤一 - HTML框架搭建 &amp; 初始化CSS</h3><p>首先搭建html，仔细观察下方代码你会发现，双飞翼布局在html上面有一点和圣杯布局有差别，那就是双飞翼在center里又套了一个div。到后面你就会知道这样设置的目的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是中间<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>我是左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>我是右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后编写初始样式。left定宽100；right定宽200；left, right, center全部设置左浮动。其他例如设置颜色高度等等直接看下方代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e1e1e1</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.center</span>, <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/posts/10370/%E5%8F%8C%E9%A3%9E%E7%BF%BCstep1.png" class="" title="双飞翼step1">

<h3 id="步骤二-设置center为100-宽"><a href="#步骤二-设置center为100-宽" class="headerlink" title="步骤二 - 设置center为100%宽"></a>步骤二 - 设置center为100%宽</h3><p>将center的宽度设为100%，这样会把left，right“挤”到第二行：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/posts/10370/%E5%8F%8C%E9%A3%9E%E7%BF%BCstep2.png" class="" title="双飞翼step2">

<h3 id="步骤三-分别让left-right回到最左边和最右边"><a href="#步骤三-分别让left-right回到最左边和最右边" class="headerlink" title="步骤三 - 分别让left,right回到最左边和最右边"></a>步骤三 - 分别让left,right回到最左边和最右边</h3><p>接着，给left设置 <code>margin-left: -100%</code> 回到最左边，给right设置 <code>margin-left: -200px</code> 回到最右边。此时center和left,right都有重叠区域，为了看效果，设置了半透明背景颜色。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/posts/10370/%E5%8F%8C%E9%A3%9E%E7%BF%BCstep3.png" class="" title="双飞翼step3">

<h3 id="步骤四-给center的子div设置左右margin"><a href="#步骤四-给center的子div设置左右margin" class="headerlink" title="步骤四 - 给center的子div设置左右margin"></a>步骤四 - 给center的子div设置左右margin</h3><p>其实上面的效果图已经实现了三栏布局中间自适应。但有个问题是center左右部分区域会被遮挡，这个时候在步骤一提到的center子div的作用就体现出来了，我们可以给它设置一个左右的margin值，分别等于left的宽和right的宽，消除掉重叠的副作用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 左margin100，右margin200 */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/posts/10370/%E5%8F%8C%E9%A3%9E%E7%BF%BCstep4.png" class="" title="双飞翼step4">

<h3 id="步骤五-给container设置min-width"><a href="#步骤五-给container设置min-width" class="headerlink" title="步骤五 - 给container设置min-width"></a>步骤五 - 给container设置min-width</h3><p>最后，给container设置一个min-width，让container最小宽度不小于left宽+right宽</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e1e1e1</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大功告成~</p>
<h3 id="完整代码-最终效果-1"><a href="#完整代码-最终效果-1" class="headerlink" title="完整代码 + 最终效果"></a>完整代码 + 最终效果</h3><iframe height="265" scrolling="no" title="三栏布局 - 双飞翼布局" src="https://codepen.io/JingW/embed/wOmBoY/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>两栏布局方案汇总</title>
    <url>/posts/44541/</url>
    <content><![CDATA[<p>记录下常见的两栏布局方式。</p>
<h2 id="左边定宽，右边自适应"><a href="#左边定宽，右边自适应" class="headerlink" title="左边定宽，右边自适应"></a>左边定宽，右边自适应</h2><h3 id="模拟table"><a href="#模拟table" class="headerlink" title="模拟table"></a>模拟table</h3><p>父元素 <code>display: table</code> ，子元素左右 <code>table-cell</code> ，左边定宽。</p>
<iframe height="460" scrolling="no" title="两栏布局（左定右自适应）模拟table" src="https://codepen.io/JingW/embed/zbWYMO/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<a id="more"></a>

<h3 id="左浮-右Margin"><a href="#左浮-右Margin" class="headerlink" title="左浮 + 右Margin"></a>左浮 + 右Margin</h3><p>子元素的左边浮动脱标，右边设置 <code>margin-left: 左边元素宽度</code></p>
<iframe height="460" scrolling="no" title="两栏布局（左定右自适应）子元素绝对定位" src="https://codepen.io/JingW/embed/bZvGRY/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="左浮-右BFC"><a href="#左浮-右BFC" class="headerlink" title="左浮 + 右BFC"></a>左浮 + 右BFC</h3><p>子元素左边设置浮动+定宽，右边子元素设置 <code>overflow: hidden</code> 触发自身BFC</p>
<iframe height="460" scrolling="no" title="两栏布局（左定右自适应）左浮 + 右BFC" src="https://codepen.io/JingW/embed/rRdNYR/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="子绝父相"><a href="#子绝父相" class="headerlink" title="子绝父相"></a>子绝父相</h3><p>子绝父相，左边 <code>top, left: 0</code>，右边 <code>top, right: 0</code>，left等于左边宽度。</p>
<iframe height="460" scrolling="no" title="两栏布局（左定右自适应）子绝父相" src="https://codepen.io/JingW/embed/gEeONo/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>父元素 <code>display: flex</code> ，左边定宽，右边 <code>flex: 1</code>。</p>
<iframe height="460" scrolling="no" title="两栏布局（左定右自适应）flex" src="https://codepen.io/JingW/embed/bZvNGx/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Jekyll搭建GitHubPages博客</title>
    <url>/posts/63074/</url>
    <content><![CDATA[<h2 id="安装-Jekyll"><a href="#安装-Jekyll" class="headerlink" title="安装 Jekyll"></a>安装 Jekyll</h2><p>来源：<a href="https://jekyllrb.com/docs/installation/">https://jekyllrb.com/docs/installation/</a></p>
<h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>终端运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<p>安装 Ruby：</p>
<p>Jekyll 依赖 Ruby v2.5.0+，如果你的 macOS 版本为 Catalina 10.15 或以上，则不需要再手动安装，因为系统自带 Ruby 2.6.3 。</p>
<a id="more"></a>

<blockquote>
<p>查看本地 Ruby 版本：<code>ruby -v</code></p>
<p>如果你的版本低于 10.15 则需要下载或更新你的 Ruby</p>
<p>具体下载or更新方案可查看：<a href="https://jekyllrb.com/docs/installation/macos/#install-ruby">https://jekyllrb.com/docs/installation/macos/#install-ruby</a></p>
</blockquote>
<p>安装 Jekyll：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gem install --user-install bundler jekyll</span><br></pre></td></tr></table></figure>

<p>选择你要安装博客的目录下运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jekyll new 你博客名(随意，反正最后要全部移动到你的githubpages repo下)</span><br></pre></td></tr></table></figure>

<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>windows安装不再赘述，可查看官网文档安装：<a href="https://jekyllrb.com/docs/installation/windows/">https://jekyllrb.com/docs/installation/windows/</a></p>
<h2 id="安装-minimal-mistakes-jekyll-主题"><a href="#安装-minimal-mistakes-jekyll-主题" class="headerlink" title="安装 minimal-mistakes-jekyll 主题"></a>安装 minimal-mistakes-jekyll 主题</h2><p>github 链接：<a href="https://github.com/mmistakes/minimal-mistakes">https://github.com/mmistakes/minimal-mistakes</a></p>
<h3 id="编辑-Gemfile"><a href="#编辑-Gemfile" class="headerlink" title="编辑 Gemfile"></a>编辑 Gemfile</h3><p>替换你的 <code>Gemfile</code> 文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">source &quot;https://rubygems.org&quot;</span><br><span class="line"></span><br><span class="line"># Hello! This is where you manage which Jekyll version is used to run.</span><br><span class="line"># When you want to use a different version, change it below, save the</span><br><span class="line"># file and run `bundle install`. Run Jekyll with `bundle exec`, like so:</span><br><span class="line">#</span><br><span class="line">#     bundle exec jekyll serve</span><br><span class="line">#</span><br><span class="line"># This will help ensure the proper Jekyll version is running.</span><br><span class="line"># Happy Jekylling!</span><br><span class="line"></span><br><span class="line"># gem &quot;github-pages&quot;, group: :jekyll_plugins</span><br><span class="line"></span><br><span class="line"># To upgrade, run `bundle update`.</span><br><span class="line"></span><br><span class="line">gem &quot;github-pages&quot;, group: :jekyll_plugins</span><br><span class="line">gem &quot;minimal-mistakes-jekyll&quot;, :github =&gt; &quot;mmistakes/minimal-mistakes&quot;</span><br><span class="line"></span><br><span class="line"># The following plugins are automatically loaded by the theme-gem:</span><br><span class="line">#   gem &quot;jekyll-paginate&quot;</span><br><span class="line">#   gem &quot;jekyll-sitemap&quot;</span><br><span class="line">#   gem &quot;jekyll-gist&quot;</span><br><span class="line">#   gem &quot;jekyll-feed&quot;</span><br><span class="line">#   gem &quot;jekyll-include-cache&quot;</span><br><span class="line">#</span><br><span class="line"># If you have any other plugins, put them here!</span><br><span class="line">group :jekyll_plugins do</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>运行 <code>bundle install</code> 安装依赖。</p>
<h3 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置 _config.yml"></a>配置 _config.yml</h3><p>找到 <code>_config.yml</code> 文件并替换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Welcome to Jekyll!</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># This config file is meant for settings that affect your whole blog, values</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">which</span> you are expected to <span class="built_in">set</span> up once and rarely edit after that. If you find</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yourself editing this file very often, consider using Jekyll<span class="string">&#x27;s data files</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> feature <span class="keyword">for</span> the data you need to update frequently.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># For technical reasons, this file is *NOT* reloaded automatically when you use</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&#x27;bundle exec jekyll serve&#x27;</span>. If you change this file, please restart the server process.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># If you need help with YAML syntax, here are some quick references for you:</span></span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> https://learn-the-web.algonquindesign.ca/topics/markdown-yaml-cheat-sheet/<span class="comment">#yaml</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://learnxinyminutes.com/docs/yaml/</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Site settings</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> These are used to personalize your new site. If you look <span class="keyword">in</span> the HTML files,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> you will see them accessed via &#123;&#123; site.title &#125;&#125;, &#123;&#123; site.email &#125;&#125;, and so on.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You can create any custom variable you would like, and they will be accessible</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> the templates via &#123;&#123; site.myvariable &#125;&#125;.</span></span><br><span class="line"></span><br><span class="line">title: Your awesome title</span><br><span class="line">email: your-email@example.com</span><br><span class="line">description: &gt;- # this means to ignore newlines until &quot;baseurl:&quot;</span><br><span class="line">  Write an awesome description for your new site here. You can edit this</span><br><span class="line">  line in _config.yml. It will appear in your document head meta (for</span><br><span class="line">  Google search results) and in your feed.xml site description.</span><br><span class="line">baseurl: &quot;&quot; # the subpath of your site, e.g. /blog</span><br><span class="line">url: &quot;https://evestorm.github.io&quot; # the base hostname &amp; protocol for your site, e.g. http://example.com</span><br><span class="line">repository: &quot;&#123;github_username&#125;/&#123;github_username&#125;.github.io&quot; # 把 &#123;github_username&#125; 替换成你github的username</span><br><span class="line">twitter_username: jekyllrb</span><br><span class="line">github_username:  lance # 你的username，随便填</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Build settings</span></span><br><span class="line">theme: minimal-mistakes-jekyll</span><br><span class="line">plugins:</span><br><span class="line">  - jekyll-feed</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Exclude from processing.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The following items will not be processed, by default.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Any item listed under the `exclude:` key here will be automatically added to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the internal <span class="string">&quot;default list&quot;</span>.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Excluded items can be processed by explicitly listing the directories or</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> their entries<span class="string">&#x27; file path in the `include:` list.</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># exclude:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - .sass-cache/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - .jekyll-cache/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - gemfiles/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - Gemfile</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - Gemfile.lock</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - node_modules/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - vendor/bundle/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - vendor/cache/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - vendor/gems/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - vendor/ruby/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后执行 <code>bundle update</code>。</p>
<h3 id="替换和更改"><a href="#替换和更改" class="headerlink" title="替换和更改"></a>替换和更改</h3><ul>
<li><p>替换根目录下 <code>index.markdown</code> 为 <code>index.html</code>  ：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: home</span><br><span class="line">author_profile: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到 <code>_posts/0000-00-00-welcome-to-jekyll.md</code> 并替换 <code>layout: single</code></p>
</li>
<li><p>删除 <code>about.md</code> 文件</p>
</li>
</ul>
<p>最后执行： <code>bundle exec jekyll serve</code> 本地运行博客。</p>
]]></content>
      <categories>
        <category>教程</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo搭建个人博客</title>
    <url>/posts/43303/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>利用 <a href="https://hexo.io/zh-cn/">Hexo</a> 在 <a href="https://baike.baidu.com/item/github/10145341?fr=aladdin">GitHub</a> 上搭建个人博客。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>你的电脑需要安装下面两个应用程序：</p>
<ul>
<li>NodeJS <a href="http://www.runoob.com/nodejs/nodejs-install-setup.html">如何安装</a></li>
<li>Git <a href="http://www.runoob.com/git/git-install-setup.html">如何安装</a></li>
</ul>
<p>或者直接查看hexo的<a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85%E5%89%8D%E6%8F%90">官方文档</a>查看安装教程。</p>
<a id="more"></a>

<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><blockquote>
<p><a href="https://hexo.io/zh-cn/docs/">安装文档</a></p>
</blockquote>
<p>终端全局安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init 你的站点文件夹</span><br><span class="line">cd 你的站点文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>下方是三个常见命令，可以先执行前俩看看效果，最后一个部署命令待会再执行。</p>
<ul>
<li><code>hexo server -p 5000</code> 本地启动服务器，5000端口</li>
<li><code>hexo new &#39;你想要创建的文章名称&#39;</code> 创建文章</li>
<li><code>hexo clean &amp;&amp; hexo deploy</code> 部署网站</li>
</ul>
<h3 id="使用第三方主题"><a href="#使用第三方主题" class="headerlink" title="使用第三方主题"></a>使用第三方主题</h3><ul>
<li><a href="https://github.com/iissnan/hexo-theme-next">Next</a> 【推荐】</li>
<li><a href="https://github.com/litten/hexo-theme-yilia">Yilia</a></li>
</ul>
<h4 id="安装Next主题"><a href="#安装Next主题" class="headerlink" title="安装Next主题"></a>安装Next主题</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 你的站点目录</span><br><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="创建分类和标签"><a href="#创建分类和标签" class="headerlink" title="创建分类和标签"></a>创建分类和标签</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>

<p>p.s. 命名为 <code>categories</code> 原因是 <code>categories</code> 在next主题中是一个关键词对应着分类。</p>
<p>在主站根目录下,也就是你hexo的目录下找到 <code>/source/categories/index.md</code>，打开后的效果类似下方代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories  #本页标题</span><br><span class="line">date: 2018-03-13 23:02:50  #创建日期</span><br><span class="line">type: &quot;categories&quot; 	#分类属于</span><br><span class="line">comments: false  #如果有启用多说 或者 Disqus评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>接着在 themes 主题文件夹下找到 next 文件夹，修改 _config.yml 文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br></pre></td></tr></table></figure>

<p>然后在命令行输入添加文章命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &#39;你想要创建的文章名称&#39;</span><br></pre></td></tr></table></figure>

<p>根目录(主站目录下)/source/_posts/&lt;刚创建的文章名称&gt;.md，双击打开：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 2018-03-13 23:13:23</span><br><span class="line">tags: html    #属于哪个标签</span><br><span class="line">categories: interview   #属于哪个分类</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>打开命令行，进入博客所在文件夹。执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>成功后会有一个路径提示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO Created: ~/Documents/blog/source/tags/index.md</span><br></pre></td></tr></table></figure>

<p>找到对应的文件打开</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2018-03-14 00:02:05</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>添加type: “tags”到内容中，添加后是这样的：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-03-14 00:03:52</span><br><span class="line">type: &#x27;tags&#x27;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>打开你的文章页面：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: jQuery对表单的操作及更多应用</span><br><span class="line">date: 2019-03-14 00:03:55</span><br><span class="line">categories: 前端</span><br><span class="line">tags: jQuery  #如果想要多个标签可以 tags: [jQuery, 表格, 表单验证] or</span><br><span class="line"><span class="bullet">-</span> jQuery</span><br><span class="line"><span class="bullet">-</span> 表格</span><br><span class="line"><span class="bullet">-</span> 表单验证</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>p.s. 如果想要实现父子分类，也和标签一样的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- IDE</span><br><span class="line">- VSCode</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://hexo.io/zh-cn/docs/front-matter.html#%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE">分类和标签</a></p>
<h3 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h3><p>把头像放在站点根目录的 <code>source/uploads/</code> 下，然后在 <code>theme/next/_config.yml</code> 下修改配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/uploads/avatar.png</span></span><br></pre></td></tr></table></figure>

<h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><h4 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h4><p>在 <code>theme/next/_config.yml</code> 下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="comment">#about: /about/ || fa fa-user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || fa fa-tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || fa fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>

<h4 id="社交"><a href="#社交" class="headerlink" title="社交"></a>社交</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:yourname@gmail.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line">  <span class="attr">Weibo:</span> <span class="string">https://weibo.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-weibo</span></span><br><span class="line">  <span class="attr">Google:</span> <span class="string">https://plus.google.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-google</span></span><br><span class="line">  <span class="attr">Twitter:</span> <span class="string">https://twitter.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-twitter</span></span><br><span class="line">  <span class="attr">FB Page:</span> <span class="string">https://www.facebook.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-facebook</span></span><br><span class="line">  <span class="attr">StackOverflow:</span> <span class="string">https://stackoverflow.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-stack-overflow</span></span><br><span class="line">  <span class="attr">YouTube:</span> <span class="string">https://youtube.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-youtube</span></span><br><span class="line">  <span class="attr">Instagram:</span> <span class="string">https://instagram.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-instagram</span></span><br><span class="line">  <span class="attr">Skype:</span> <span class="string">skype:yourname?call|chat</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-skype</span></span><br></pre></td></tr></table></figure>

<h3 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h3><p>在文章想要截断的地方添加 <code>&lt;!-- more --&gt;</code> ，这样在文章列表中就会只展示到截断位置为止。</p>
<h2 id="第三方插件"><a href="#第三方插件" class="headerlink" title="第三方插件"></a>第三方插件</h2><h3 id="永久URL生成：hexo-abbrlink"><a href="#永久URL生成：hexo-abbrlink" class="headerlink" title="永久URL生成：hexo-abbrlink"></a>永久URL生成：hexo-abbrlink</h3><ul>
<li>用来生成每篇博客永久URL链接的</li>
<li>Repo: <a href="https://github.com/rozbo/hexo-abbrlink">https://github.com/rozbo/hexo-abbrlink</a></li>
<li>执行： <code>npm install hexo-abbrlink --save</code></li>
</ul>
<h3 id="部署到GitHub：hexo-deployer-git"><a href="#部署到GitHub：hexo-deployer-git" class="headerlink" title="部署到GitHub：hexo-deployer-git"></a>部署到GitHub：hexo-deployer-git</h3><ul>
<li>将本地博客部署到GitHub</li>
<li>Repo: <a href="https://hexo.io/zh-cn/docs/one-command-deployment">https://hexo.io/zh-cn/docs/one-command-deployment</a>)</li>
<li>执行： <code>npm install hexo-deployer-git --save</code></li>
</ul>
<p><strong>如何部署</strong></p>
<p>在 <code>_config.yml</code> 下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&quot;https://github.com/evestorm/evestorm.github.io&quot;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">&quot;gh-pages&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后在你的githubpages的repo下新建 <code>gh-pages</code> 分支，最后执行：<code>hexo clean &amp;&amp; hexo deploy</code> 即可部署。</p>
<h3 id="本地热更新：hexo-server"><a href="#本地热更新：hexo-server" class="headerlink" title="本地热更新：hexo-server"></a>本地热更新：hexo-server</h3><ul>
<li>服务器模块。在启动期间，Hexo 会监视文件变动并自动更新</li>
<li>Repo: <a href="https://github.com/hexojs/hexo-server">https://github.com/hexojs/hexo-server</a>)</li>
<li>执行： <code>npm install hexo-server –save</code></li>
</ul>
<h3 id="关键词搜索：LocalSearch"><a href="#关键词搜索：LocalSearch" class="headerlink" title="关键词搜索：LocalSearch"></a>关键词搜索：LocalSearch</h3><ul>
<li>本地搜索</li>
<li>Repo: <a href="https://github.com/theme-next/hexo-generator-searchdb">https://github.com/theme-next/hexo-generator-searchdb</a></li>
<li>执行：<code>npm install hexo-generator-searchdb --save</code></li>
</ul>
<p><strong>配置博客</strong></p>
<p>安装完成，编辑博客配置文件：<code>hexo/_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br></pre></td></tr></table></figure>

<p><strong>配置主题</strong></p>
<p>Next 主题自带搜索设置，编辑主题配置文件：<code>_config.yml</code></p>
<p>找到文件中 Local search 的相关配置，设为 <code>true</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>最后记得 hexo 重新部署。</p>
<h3 id="统计分析：busuanzi-count"><a href="#统计分析：busuanzi-count" class="headerlink" title="统计分析：busuanzi_count"></a>统计分析：busuanzi_count</h3><p>NexT 主题集成了不蒜子（busuanzi_count）统计功能，在 NexT 配置文件中找到关键词 <code>busuanzi_count:</code> ，把 enable 设置为 true</p>
<p>p.s. 除此之外，如果设置为true后仍然无效，且打开控制台显示js报错。有可能是不蒜子链接失效的原因，需要在Next主题配置文件位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">themes\next\layout\_third-party\analytics\busuanzi-counter.swig</span><br></pre></td></tr></table></figure>

<p>修改script链接为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="评论功能：ChangYan"><a href="#评论功能：ChangYan" class="headerlink" title="评论功能：ChangYan"></a>评论功能：ChangYan</h3><p>文档地址：<a href="https://theme-next.js.org/docs/third-party-services/comments.html#Changyan-China">https://theme-next.js.org/docs/third-party-services/comments.html#Changyan-China</a></p>
<ul>
<li><p>注册登录：<a href="https://changyan.kuaizhan.com/">https://changyan.kuaizhan.com/</a></p>
</li>
<li><p>获取 APP ID 和 APP KEY</p>
</li>
<li><p>设置 changyan enable: true:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># changyan</span></span><br><span class="line"><span class="attr">changyan:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span></span><br><span class="line">  <span class="attr">appkey:</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p><a href="https://blog.csdn.net/lewky_liu/article/details/81277337">Hexo瞎折腾系列(4) - 站点首页不显示文章全文</a></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// npm全局安装Hexo</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">// 新建Hexo项目</span><br><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">// 新建文章</span><br><span class="line">hexo new &#x27;文章名&#x27;</span><br><span class="line"></span><br><span class="line">// 启动服务器</span><br><span class="line">hexo server -p 5000</span><br><span class="line"></span><br><span class="line">// 生成静态文件</span><br><span class="line">hexo generate --watch</span><br><span class="line"></span><br><span class="line">// 部署</span><br><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>

<h2 id="相关配置及资源"><a href="#相关配置及资源" class="headerlink" title="相关配置及资源"></a>相关配置及资源</h2><ul>
<li><a href="https://juejin.im/post/5bcd2d395188255c3b7dc1db#heading-42">Hexo+NexT 打造一个炫酷博客</a></li>
<li><a href="https://me.idealli.com/post/e8d13fc.html">这应该是最全的hexo博客搭建以及next美化教程</a></li>
<li><a href="https://leancloud.cn/">LeanCloud</a></li>
<li><a href="https://eirunye.github.io/2018/09/15/Hexo%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2%E2%80%94%E6%89%93%E9%80%A0%E7%82%AB%E9%85%B7%E7%9A%84NexT%E4%B8%BB%E9%A2%98%E2%80%94%E9%AB%98%E7%BA%A7%E2%80%94%E5%9B%9B/">Hexo搭建GitHub博客—打造炫酷的NexT主题–高级(四)</a></li>
<li><a href="http://www.missfli.com/2018/06/19/github-hexo-next-08.html">Hexo NexT主题代码块添加复制功能</a></li>
<li><a href="https://ihaoming.top/archives/9a935f57.html">修改hexo博客next主题文章页面宽度</a></li>
<li><a href="https://hexo.io/zh-cn/docs/asset-folders.html">在Hexo中使用资源文件夹添加图片</a></li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>函数中的rest参数</title>
    <url>/posts/29820/</url>
    <content><![CDATA[<h2 id="什么是-REST-参数"><a href="#什么是-REST-参数" class="headerlink" title="什么是 REST 参数"></a>什么是 REST 参数</h2><p>REST参数翻译过来就是剩余参数，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters">MDN</a>上的定义是：</p>
<blockquote>
<p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组。</p>
</blockquote>
<a id="more"></a>

<h2 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.reduce(<span class="function">(<span class="params">previous, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> previous + current;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// expected output: 6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// expected output: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">multiplier, ...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.map(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> multiplier * element;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = multiply(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<h2 id="rest-参数和-arguments-对象的区别"><a href="#rest-参数和-arguments-对象的区别" class="headerlink" title="rest 参数和 arguments 对象的区别"></a>rest 参数和 arguments 对象的区别</h2><p>剩余参数和 <code>arguments</code>对象之间的区别主要有三个：</p>
<ul>
<li><p>剩余参数只包含那些没有对应形参的实参，而 <code>arguments</code> 对象包含了传给函数的所有实参。</p>
</li>
<li><p><code>arguments</code>对象不是一个真正的数组，而剩余参数是真正的 <code>Array</code>实例，也就是说你能够在它上面直接使用所有的数组方法，比如 <code>sort</code>，<code>map</code>，<code>forEach</code>或<code>pop</code>。</p>
</li>
<li><pre><code>arguments
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">对象还有一些附加的属性 （如</span><br><span class="line"></span><br></pre></td></tr></table></figure>
callee</code></pre>
<p>属性）。</p>
<ul>
<li>arguments.callee 属性包含当前正在执行的函数。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>前端vscode插件配置</title>
    <url>/posts/11039/</url>
    <content><![CDATA[<h3 id="外观配置"><a href="#外观配置" class="headerlink" title="外观配置"></a>外观配置</h3><ul>
<li><strong>主题</strong>：<a href="https://marketplace.visualstudio.com/items?itemName=chriseckenrode.vscode-chester-atom">Chester Atom</a></li>
<li><strong>图标</strong>：<a href="https://marketplace.visualstudio.com/items?itemName=emmanuelbeziat.vscode-great-icons">VSCode Great Icons</a></li>
<li><strong>字体</strong>：<a href="https://github.com/tonsky/FiraCode/wiki">Fira Code</a></li>
</ul>
<a id="more"></a>

<h4 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h4><img src="/posts/11039/163001_02d3ddb2_1203301.png" class="" title="UI-Show">


<h4 id="用户设置（User-Settings）"><a href="#用户设置（User-Settings）" class="headerlink" title="用户设置（User Settings）"></a>用户设置（User Settings）</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;editor.fontSize&quot;</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="attr">&quot;workbench.colorTheme&quot;</span>: <span class="string">&quot;Chester Atom&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;editor.fontFamily&quot;</span>: <span class="string">&quot;Fira Code&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;emmet.triggerExpansionOnTab&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;editor.fontLigatures&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="风格检查"><a href="#风格检查" class="headerlink" title="风格检查"></a>风格检查</h3><ul>
<li><strong><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">ESLint</a></strong></li>
<li><strong><a href="https://marketplace.visualstudio.com/items?itemName=shinnn.stylelint">StyleLint</a></strong></li>
<li><strong><a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint">MarkdownLint</a></strong></li>
<li><strong><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">Prettier</a></strong></li>
</ul>
<h3 id="编码效率"><a href="#编码效率" class="headerlink" title="编码效率"></a>编码效率</h3><h4 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h4><ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=abusaidm.html-snippets">HTML Snippets</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippets">Javascript (ES6) Code Snippets</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=nikhilkumar80.js-patterns-snippets">Javascript Patterns Snippets</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=joelday.docthis">Document This</a>，一键给代码中的类、函数加上注释，支持函数声明、函数表达式、箭头函数等；</li>
</ul>
<h4 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h4><ul>
<li><a href="https://link.juejin.im/?target=https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag">Auto Close Tag</a>，在打开标签并且键入 <code>&lt;/</code> 的时候，能自动补全要闭合的标签；</li>
<li><a href="https://link.juejin.im/?target=https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag">Auto Rename Tag</a>，在修改标签名时，能在你修改开始（结束）标签的时候修改对应的结束（开始）标签。</li>
<li><a href="https://link.juejin.im/?target=https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense">Path Intellisense</a>，文件路径补全，在你用任何方式引入文件系统中的路径时提供智能提示和自动完成。</li>
<li><a href="https://link.juejin.im/?target=https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense">NPM Intellisense</a>，NPM 依赖补全，在你引入任何 node_modules 里面的依赖包时提供智能提示和自动完成。</li>
<li><a href="https://link.juejin.im/?target=https://marketplace.visualstudio.com/items?itemName=Zignd.html-css-class-completion">IntelliSense for CSS class names</a>，CSS 类名补全，会自动扫描整个项目里面的 CSS 类名并在你输入类名时做智能提示。</li>
<li><a href="https://link.juejin.im/?target=https://emmet.io">Emmet</a>，VSCode 已经内置，官方介绍文档<a href="https://link.juejin.im/?target=https://code.visualstudio.com/docs/editor/emmet">参见</a>。</li>
</ul>
<h4 id="代码补全"><a href="#代码补全" class="headerlink" title="代码补全"></a>代码补全</h4><ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner">Code Runner</a><!-- [![Code Runner](前端vscode插件配置/162c15a64b468fd8.gif)](https://user-gold-cdn.xitu.io/2018/4/14/162c15a64b468fd8?imageslim) -->
<img src="/posts/11039/162c15a64b468fd8.gif" class="" title="Code-Runner">

</li>
</ul>
<h3 id="功能增强"><a href="#功能增强" class="headerlink" title="功能增强"></a>功能增强</h3><ul>
<li><a href="https://link.juejin.im/?target=https://marketplace.visualstudio.com/items?itemName=naumovs.color-highlight">Color Highlight</a>，识别代码中的颜色，包括各种颜色格式。</li>
<li><a href="https://link.juejin.im/?target=https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer">Bracket Pair Colorizer</a>，识别代码中的各种括号，并且标记上不同的颜色，方便你扫视到匹配的括号。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync">Settings Sync</a>，基于 Gist 实现 VSCode 用户配置、快捷键配置、已安装插件列表等的备份和恢复功能，配置过程有详细精确的操作步骤文档。生成的备份 Gist 默认是私密的，如果你想设置为共享的，也可以一键切换。</li>
</ul>
<h3 id="外观增强"><a href="#外观增强" class="headerlink" title="外观增强"></a>外观增强</h3><ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=wayou.vscode-todo-highlight">TODO Highlight</a><br>维护时间稍长的代码仓库免不了会有各种 TODO、FIXME、HACK 之类的标记，TODO Highlight 能够帮我们把这些关键词高亮出来，在你翻阅代码时非常醒目，就像是在大声提醒你尽快把他解决掉。支持自定义配置需要高亮的关键词，实际使用比较坑的地方是，TODO、FIXME 之类的后面必须加上冒号，否则无法高亮。<!-- [![TODO Highlight](前端vscode插件配置/1)](https://user-gold-cdn.xitu.io/2018/4/14/162c1592cecf92d8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) -->
<img src="/posts/11039/1.png" class="" title="TODO-Highlight"></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>去除图片上下左右间隙</title>
    <url>/posts/31251/</url>
    <content><![CDATA[<h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>当在定宽父容器下有多张图片顺序排列时，图片的上下左右之间都有间隙：</p>
<iframe height="265" scrolling="no" title="KEBmRP" src="https://codepen.io/JingW/embed/KEBmRP/?height=265&amp;theme-id=0&amp;default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<a id="more"></a>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul>
<li>左右：因为 img 是 inline-block 元素，元素代码之间有『换行（回车），空格，tab』时会产生左右间隙。</li>
<li>上下：行内元素默认与父容器基线对齐，而基线与父容器底部有一定间隙，所以上下图片间有间隙。</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>移除上下间隙：<ul>
<li>img本身设置 <code>display: block;</code></li>
<li>父元素设置 <code>font-size: 0;</code> （基线与字体大小有关，字体为零，基线间就没距离了）</li>
<li>img本身设置 <code>vertical-align: bottom;</code>（让inline-block 的 img 与每行的底部对齐）</li>
</ul>
</li>
<li>移除左右间距：<ul>
<li>行内元素间不要有换行，连成一行写消除间隙（阅读性差，不推荐）</li>
<li>第一行img结尾写上 <code>&lt;!--</code> ，第二行img开头跟上 <code>--&gt;</code> 。即利用注释消除间距</li>
<li>父元素 <code>font-size: 0</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>垂直居中方案汇总</title>
    <url>/posts/12733/</url>
    <content><![CDATA[<p>这里汇总了常见的元素居中方案。</p>
<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h3 id="行内元素水平居中"><a href="#行内元素水平居中" class="headerlink" title="行内元素水平居中"></a>行内元素水平居中</h3><p>核心：给父元素添加 <code>text-align: center</code></p>
<iframe height="265" scrolling="no" title="行内元素水平居中" src="https://codepen.io/JingW/embed/mvaNXw/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<a id="more"></a>

<h3 id="块级元素水平居中"><a href="#块级元素水平居中" class="headerlink" title="块级元素水平居中"></a>块级元素水平居中</h3><p>核心：子元素自身 <code>margin: 0 auto;</code></p>
<iframe height="291" scrolling="no" title="块元素水平居中" src="https://codepen.io/JingW/embed/moxbxb/?height=291&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="多个div水平居中"><a href="#多个div水平居中" class="headerlink" title="多个div水平居中"></a>多个div水平居中</h3><h4 id="传统方案"><a href="#传统方案" class="headerlink" title="传统方案"></a>传统方案</h4><p>核心：父元素设置 <code>text-align: center</code> ，子元素设置 <code>inline-block</code></p>
<iframe height="265" scrolling="no" title="多个div水平居中 - 传统方案" src="https://codepen.io/JingW/embed/KEoPGq/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h4 id="Flex方案"><a href="#Flex方案" class="headerlink" title="Flex方案"></a>Flex方案</h4><p>核心：父元素 <code>display: flex</code> + <code>justify-content: center</code> + <code>align-items: center</code></p>
<iframe height="265" scrolling="no" title="多个div水平居中-flex" src="https://codepen.io/JingW/embed/XGEroY/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><h3 id="table自带水平垂直居中"><a href="#table自带水平垂直居中" class="headerlink" title="table自带水平垂直居中"></a>table自带水平垂直居中</h3><p>核心：使用 <code>table&gt;tr&gt;td</code> 布局</p>
<iframe height="460" scrolling="no" title="div水平垂直居中 - table" src="https://codepen.io/JingW/embed/xBWxwe/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="模拟table"><a href="#模拟table" class="headerlink" title="模拟table"></a>模拟table</h3><p>核心：父元素 <code>display: table</code> ，子元素 <code>display: table-cell</code> + <code>vertical-align: middle</code></p>
<iframe height="460" scrolling="no" title="div水平垂直居中 - 模拟table" src="https://codepen.io/JingW/embed/aMYbZx/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="子绝父相-子元素-margin-auto"><a href="#子绝父相-子元素-margin-auto" class="headerlink" title="子绝父相 + 子元素 margin:auto"></a>子绝父相 + 子元素 margin:auto</h3><p>核心：子元素相对于父元素绝对定位，<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 都设为0，margi设为auto</p>
<iframe height="460" scrolling="no" title="div水平垂直居中 - 子绝父相 + Margin Auto" src="https://codepen.io/JingW/embed/PLRYrz/?height=460&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="子绝父相-负margin"><a href="#子绝父相-负margin" class="headerlink" title="子绝父相 + 负margin"></a>子绝父相 + 负margin</h3><p>核心：子元素相对于父元素绝对定位，<code>top</code>、<code>left</code>设为50%，margin相对自身宽/高一半</p>
<iframe height="460" scrolling="no" title="div水平垂直居中 - 子绝父相 + 负Margin" src="https://codepen.io/JingW/embed/oVqNvK/?height=460&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="子绝父相-translate"><a href="#子绝父相-translate" class="headerlink" title="子绝父相 + translate"></a>子绝父相 + translate</h3><p>核心：子元素相对于父元素绝对定位，<code>top</code>、<code>left</code>设为50%，此时子元素左上角在父元素中心，然后让子元素向左上角位移自身宽度的一半</p>
<iframe height="460" scrolling="no" title="div水平垂直居中 - 子绝父相 + translate" src="https://codepen.io/JingW/embed/EMExjr/?height=456&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h3><p>父元素 <code>display: flex</code>，<code>justify-content</code> 和 <code>align-items</code> 都设为 center 实现垂直居中</p>
<iframe height="460" scrolling="no" title="div水平垂直居中 - flex" src="https://codepen.io/JingW/embed/rRdNyo/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>如何清除浮动</title>
    <url>/posts/12906/</url>
    <content><![CDATA[<h2 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h2><p>其实浮动（e.g. <code>float: left;</code>）本质上是用来做文字混排的，但却被我们拿来做布局，这个时候虽然实现了某些效果，但也带来了不少副作用。</p>
<p>由于浮动元素不再占有原文档流的位置，所以它会对后续元素的排版带来影响（无视浮动元素，就当它不存在过）。因此我们很多时候要做的，就是消除浮动元素造成的影响。清除浮动的本质主要是为了解决父元素因为子元素浮动造成的内部高度为0的问题。</p>
<a id="more"></a>

<h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>清除浮动的核心css属性是 clear ，基本语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器: &#123;</span><br><span class="line">    <span class="attribute">clear</span>: 属性值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">属性值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">left</td>
<td align="left">不允许左侧有浮动元素（清除左侧浮动的影响）</td>
</tr>
<tr>
<td align="left">right</td>
<td align="left">不允许右侧有浮动元素（清除右侧浮动的影响）</td>
</tr>
<tr>
<td align="left">both</td>
<td align="left">同时清除左右两侧浮动的影响</td>
</tr>
</tbody></table>
<h2 id="清除浮动常见方案"><a href="#清除浮动常见方案" class="headerlink" title="清除浮动常见方案"></a>清除浮动常见方案</h2><h3 id="额外标记法"><a href="#额外标记法" class="headerlink" title="额外标记法"></a>额外标记法</h3><p>在浮动元素后面添加一个空标签，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>优点：通俗易懂，书写方便<br>缺点：加入了过多的没有实际含义的额外标签，结构化差。</p>
<h3 id="父元素添加overflow"><a href="#父元素添加overflow" class="headerlink" title="父元素添加overflow"></a>父元素添加overflow</h3><p>通过触发BFC达到清除浮动的效果。（p.s. 对bfc不了解可以看<a href="https://evestorm.github.io/posts/9722/">这篇</a>文章）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：代码简洁<br>缺点：超出的内容会被隐藏</p>
<h3 id="before和after双伪元素方案"><a href="#before和after双伪元素方案" class="headerlink" title="before和after双伪元素方案"></a>before和after双伪元素方案</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;  <span class="comment">/* 触发BFC清除浮动 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    <span class="attribute">*zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：代码简洁<br>缺点：IE6-7不支持:after，需要使用 <code>zoom: 1</code> 触发 <code>hasLayout</code></p>
<h3 id="使用after伪元素（我平常使用的）"><a href="#使用after伪元素（我平常使用的）" class="headerlink" title="使用after伪元素（我平常使用的）"></a>使用after伪元素（我平常使用的）</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;  </span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    <span class="attribute">*zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;   <span class="comment">/* IE6、7 专有 */</span></span><br></pre></td></tr></table></figure>

<p>使用方式：给浮动元素的父元素添加一个class类：<code>clearfix</code><br>优点：一次书写多处使用，并且符合闭合浮动思想，结构语义化正确<br>缺点：IE6-7不支持:after，需要使用 <code>zoom: 1</code> 触发 <code>hasLayout</code><br>注意：<code>content:&quot;.&quot;</code> 内容尽量不为空，可以跟一个小点，否则在firefox 7.0前的版本会生成空格</p>
<h2 id="after-和-after-的区别"><a href="#after-和-after-的区别" class="headerlink" title=":after 和 ::after 的区别"></a>:after 和 ::after 的区别</h2><p>:before、:after 在旧版本里是伪元素，CSS3的规范里 “:” 用来表示伪类，”::” 用来表示伪元素，但是在高版本浏览器下 :before、:after 会被自动识别为 ::before、::after ，这样做的目的是用来做兼容处理。</p>
<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>伪类对象，用来设置对象前的内容<br>:before 和 ::before 写法是等效的</p>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>:before 是 css2 的写法，::before 是 css3 的写法<br>:before 兼容性比 ::before要好</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>伪类元素必须要配合 content 属性一起使用，否则无效<br>伪类元素是css渲染层加入的，不能通过js来操作</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>对HTML语义化的理解</title>
    <url>/posts/2906/</url>
    <content><![CDATA[<h2 id="对HTML语义化的理解"><a href="#对HTML语义化的理解" class="headerlink" title="对HTML语义化的理解"></a>对HTML语义化的理解</h2><p>核心：用正确的标签做正确的事情</p>
<ol>
<li>利与开发：方便代码的阅读和维护</li>
<li>利于SEO：方便爬虫根据 语义标签 确定 页面结构 和 关键字 的权重</li>
</ol>
<a id="more"></a>

<h2 id="常见语义化标签"><a href="#常见语义化标签" class="headerlink" title="常见语义化标签"></a>常见语义化标签</h2><p>一图胜千言：</p>
<img src="/posts/2906/f8442d9e-e30d-11e6-85aa-3e3fb75f9695.jpg" class="" title="语义化demo">


<p>元素细节：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/main">main</a> 存放每个页面独有的内容。每个页面上只能用一次 <code>&lt;main&gt;</code>，且直位于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body">``</a>中。最好不要把它嵌套进其它元素。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article">article</a> 包围的内容即一篇文章，与页面其它部分无关（比如一篇博文）。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section">section</a> 与 <code>&lt;article&gt;</code> 类似，但 <code>&lt;section&gt;</code> 更适用于组织页面使其按功能（比如迷你地图、一组文章标题和摘要）分块。一般的最佳用法是：以 <a href="https://developer.mozilla.org/en-US/Learn/HTML/Howto/Set_up_a_proper_title_hierarchy">标题</a> 作为开头；也可以把一篇 <code>&lt;article&gt;</code> 分成若干部分并分别置于不同的 <code>&lt;section&gt;</code> 中，也可以把一个区段 <code>&lt;section&gt;</code> 分成若干部分并分别置于不同的 <code>&lt;article&gt;</code> 中，取决于上下文。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/aside">aside</a> 包含一些间接信息（术语条目、作者简介、相关链接，等等）。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/header">header</a> 是简介形式的内容。如果它是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body">body</a> 的子元素，那么就是网站的全局页眉。如果它是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article">article</a> 或<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section">section</a> 的子元素，那么它是这些部分特有的页眉（此 <code>&lt;header&gt;</code> 非彼 <a href="https://developer.mozilla.org/zh-CN/docs/learn/HTML/Introduction_to_HTML/The_head_metadata_in_HTML#%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%A0%87%E9%A2%98">标题</a>）。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/nav">nav</a> 包含页面主导航功能。其中不应包含二级链接等内容。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/footer">footer</a> 包含了页面的页脚部分。</li>
</ul>
<p>来源：<a href="https://developer.mozilla.org/zh-CN/docs/learn/HTML/Introduction_to_HTML/%E6%96%87%E4%BB%B6%E5%92%8C%E7%BD%91%E7%AB%99%E7%BB%93%E6%9E%84">文档与网站架构</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>对this指向的判定</title>
    <url>/posts/33207/</url>
    <content><![CDATA[<h2 id="对-this-的理解"><a href="#对-this-的理解" class="headerlink" title="对 this 的理解"></a>对 this 的理解</h2><p>对于this指向的判定，时刻记住下面两点就好：</p>
<ul>
<li>普通函数的 this 指向是在函数的执行期间绑定的，换句话说 this 总是指向函数的<strong>直接</strong>调用者</li>
<li>箭头函数的 this 指向是在函数创建期间就绑定好了的，指向的是创建该箭头函数所在的作用域对象</li>
</ul>
<a id="more"></a>

<h2 id="普通函数中的this"><a href="#普通函数中的this" class="headerlink" title="普通函数中的this"></a>普通函数中的this</h2><p>这里直接引用 <a href="https://github.com/getify/You-Dont-Know-JS">You-Dont-Know-JS</a> 中对 this 的判定步骤：</p>
<ol>
<li>函数是通过 <code>new</code> 被调用的吗（<strong>new 绑定</strong>）？如果是，<code>this</code> 就是新构建的对象。<br><code>var bar = new foo()</code></li>
<li>函数是通过 <code>call</code> 或 <code>apply</code> 被调用（<strong>明确绑定</strong>），甚至是隐藏在 <code>bind</code> <em>硬绑定</em> 之中吗？如果是，<code>this</code> 就是那个被明确指定的对象。<br><code>var bar = foo.call( obj2 )</code></li>
<li>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（<strong>隐含绑定</strong>）？如果是，<code>this</code> 就是那个环境对象。<br><code>var bar = obj1.foo()</code></li>
<li>否则，使用默认的 <code>this</code>（<strong>默认绑定</strong>）。如果在 <code>strict mode</code> 下，就是 <code>undefined</code>，否则是 <code>global</code> 对象。<br><code>var bar = foo()</code></li>
</ol>
<h2 id="常见this指向"><a href="#常见this指向" class="headerlink" title="常见this指向"></a>常见this指向</h2><ul>
<li>普通函数中this ——&gt; window</li>
<li>构造函数中this ——&gt; new出来的实例对象</li>
<li>方法中的this ——&gt; 实例对象</li>
<li>原型中的方法中的this ——&gt; 实例对象</li>
<li>定时器中的this ——&gt; window</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>对闭包的理解</title>
    <url>/posts/29980/</url>
    <content><![CDATA[<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>我一直认为，MDN是前端学习的在线指南。只要有不懂的语法，或者不懂的概念，查找资料的首选就应该是它。虽然早些年做iOS开发的时候就就接触过闭包，但如今已经忘得一干二净，所以在想要了解闭包的时候，第一件事就是在MDN中搜索。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">其中</a>给到了一个闭包的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>;    <span class="comment">// name 是一个被 init 创建的局部变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123; <span class="comment">// displayName() 是内部函数,一个闭包</span></span><br><span class="line">        alert(name);         <span class="comment">// 使用了父函数中声明的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> displayName;      <span class="comment">// 返回 displayName 这个函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunc = makeFunc();</span><br><span class="line">myFunc(); <span class="comment">// 当执行myFunc时，其实调用了displayName，会弹窗显示&quot;Mozilla&quot;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>在上面这个例子中，一个函数套了一个函数，且这个内部函数使用到了外部函数中的变量，这个时候就形成了闭包。有什么用呢？其中一个用处就如上面代码所示，能够让 makeFunc 函数外面也能访问 name 这个局部变量。换句话说，闭包缓存了数据，延长了作用域链。</p>
<p>Kyle Simpson编写的<a href="https://github.com/getify/You-Dont-Know-JS">You-Dont-Know-JS</a>中对闭包的总结我觉得很精髓：</p>
<blockquote>
<p>闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。</p>
</blockquote>
<h2 id="闭包的特性"><a href="#闭包的特性" class="headerlink" title="闭包的特性"></a>闭包的特性</h2><ol>
<li>函数内再嵌套函数</li>
<li>内部函数可以引用外层的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ol>
<h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><h3 id="读取正确的值"><a href="#读取正确的值" class="headerlink" title="读取正确的值"></a>读取正确的值</h3><p>一个经典的例子，给 ul&gt;li 下面的每个 li 节点添加点击事件，让其弹出当前 li 元素的索引：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;testUL&quot;</span>&gt;</span><br><span class="line">    &lt;li&gt; index = <span class="number">0</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt; index = <span class="number">1</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt; index = <span class="number">2</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt; index = <span class="number">3</span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> nodes = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        nodes[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>运行上述代码后就会发现，每次打印的结果都显示为4，而不是真正的索引值。这是因为点击事件的匿名函数发生在for循环之后，而for循环执行完毕时 i 的值就为4，所以点谁都是同样的结果。那么这个时候就能通过<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">立即执行函数</a> + <strong>闭包</strong>的方法解决此问题：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> nodes = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i += <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">        nodes[i].onclick = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123; <span class="comment">// 1. IIFE创建一个函数作用域</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 4. 返回这个匿名函数，延长作用域链</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 3. 内部嵌套的匿名函数使用到了IIFE的参数i，形成闭包</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(i);</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">        &#125;)(i); <span class="comment">// 2. 给IIFE传递每次for循环的i</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个时候触发click事件，打印的值就是li元素的索引了。</p>
<h3 id="高级排他"><a href="#高级排他" class="headerlink" title="高级排他"></a>高级排他</h3><p>这个例子有点像上面的，现在我们要个需求：在一个 <code>ul li</code> 列表中，鼠标移入时高亮当前li标签，移除之前li标签的高亮状态。</p>
<p>常规写法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设给li添加active类可以让标签高亮</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> list = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">    <span class="comment">// 遍历每个标签</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> li = list[i]</span><br><span class="line">      li.onmouseover = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// mouseover触发后遍历整个列表，将所有标签class设为空</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; list.length; j++) &#123;</span><br><span class="line">          list[j].className = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后给当前li标签添加active</span></span><br><span class="line">        <span class="built_in">this</span>.className = <span class="string">&#x27;active&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码能够实现功能，然而一旦列表非常长性能就不高，所以可以利用闭包来缓存li标签的索引，使其与标签一一对应：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> list = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">  <span class="comment">// 记录上一次选中的li标签的对应索引</span></span><br><span class="line">  <span class="keyword">let</span> preActiveIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> li = list[i]</span><br><span class="line">      li.onmouseover = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 清除上次li标签的高亮</span></span><br><span class="line">        list[preActiveIndex].className = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">// 设置当前位高亮</span></span><br><span class="line">        <span class="built_in">this</span>.className = <span class="string">&#x27;active&#x27;</span></span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        preActiveIndex = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h3><p>在团队开发中，为了避免命名冲突通常不同成员会把自己的代码单独封装起来，最后return一个对象出去，挂载到window上。这样其他人也可以使用，而且能在一定程度上避免命名冲突：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">w</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> money = <span class="number">1000</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    money *= <span class="number">10</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;赚了一笔钱，总资产：&quot;</span> + money + <span class="string">&quot;元&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    money--</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;花了一笔钱，总资产：&quot;</span> + money + <span class="string">&quot;元&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向外暴露对象</span></span><br><span class="line">  w.myTools = &#123;</span><br><span class="line">    get,</span><br><span class="line">    set</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>

<h3 id="函数节流防抖"><a href="#函数节流防抖" class="headerlink" title="函数节流防抖"></a>函数节流防抖</h3><p>在日常开发中，我们也经常用到函数节流与防抖，通常我们会将它们封装为函数，这样可以在需要的地方直接调用使用，还不会污染全局：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>防抖节流<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 函数防抖 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> timer = <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ctx = <span class="built_in">this</span>,</span></span><br><span class="line"><span class="javascript">            args = <span class="built_in">arguments</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (timer) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">window</span>.clearTimeout(timer)</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">          fn.apply(ctx, args)</span><br><span class="line"><span class="javascript">          timer = <span class="literal">null</span></span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">// 搜索框做函数防抖避免用户高频输入内容</span></span></span><br><span class="line"><span class="javascript">    input.addEventListener(<span class="string">&#x27;input&#x27;</span>, debounce(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.target.value)</span></span><br><span class="line">    &#125;, 500))</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 函数节流 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> canUse = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ctx = <span class="built_in">this</span>,</span></span><br><span class="line"><span class="javascript">            args = <span class="built_in">arguments</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (canUse) &#123;</span></span><br><span class="line">          fn.apply(ctx, args)</span><br><span class="line"><span class="javascript">          canUse = <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            canUse = <span class="literal">true</span></span></span><br><span class="line">          &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">// 对于像onresize这样的高频事件，可以使用函数节流让其回调函数中的代码隔一段时间再次执行</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onresize = throttle(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      input.value = <span class="built_in">Math</span>.random() * <span class="number">100</span></span></span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>其实闭包并不会造成内存泄漏，现在的垃圾回收机制已经很成熟了。但早期的IE（ie4-ie6）版本里，对宿主对象（也就是document对象）采用是引用计数的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">垃圾回收机制</a>，闭包导致内存泄漏的一个原因就是这个算法的一个缺陷。循环引用会导致没法回收，这个循环引用只限定于有宿主对象参与的循环引用，而js对象之间即使形成循环引用，也不会产生内存泄漏，因为对js对象的回收算法不是计数的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closure</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;oDiv&#x27;</span>);<span class="comment">//oDiv用完之后一直驻留在内存中</span></span><br><span class="line">    oDiv.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">&#x27;oDiv.innerHTML&#x27;</span>);<span class="comment">//这里用oDiv导致内存泄露</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码创建了一个作为 div 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。</span></span><br><span class="line"><span class="comment">// 由于匿名函数保存了一个对closure()的活动对象的引用，因此就会导致无法减少 div 的引用数。</span></span><br><span class="line"><span class="comment">// 只要匿名函数存在，element 的引用数至少也是1，因此它所占用的内存就永远不会被回收</span></span><br><span class="line"></span><br><span class="line">closure();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后应将oDiv解除引用来避免内存泄露</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closure</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;oDiv&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> test = oDiv.innerHTML;</span><br><span class="line">    oDiv.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(test);</span><br><span class="line">    &#125;;</span><br><span class="line">    oDiv = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解决办法: 把 oDiv.innerHTML 的一个副本保存在一个变量中，</span></span><br><span class="line"><span class="comment">// 从而消除闭包中该变量的循环引用,同时将 oDiv 变量设为null。</span></span><br></pre></td></tr></table></figure>

<p>所以我们要保持良好的编程习惯，在使用完闭包后记得释放内存：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">9999999999999</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn1()</span><br><span class="line">f() <span class="comment">// 调用完后没有释放，arr就会一直在内存中占着，导致内存泄漏</span></span><br><span class="line"><span class="comment">// 记得释放</span></span><br><span class="line">f = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的遍历方法</title>
    <url>/posts/64478/</url>
    <content><![CDATA[<p>下面是总结的数组遍历的常见方法</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><ul>
<li>标准for循环</li>
<li>forEach((当前值, 当前索引, 当前数组) =&gt; {…}, [, 绑定的this])`<ul>
<li>无法中途退出循环，只能用 return 退出本次回调，进行下一次回调</li>
<li>它总是返回 undefined 值，即使你 return 了一个值</li>
</ul>
</li>
<li>for…in（不推荐）会把继承链的对象属性都会遍历一遍，而且数组遍历不一定按次序<ul>
<li>for-in 循环返回的是所有能通过对象访问的、可枚举的属性</li>
</ul>
</li>
<li>for (variable of iterable)（ES6）可迭代Array，Map，Set，String等（迭代的是值value）<ul>
<li>在 for..of 中如果遍历中途要退出，可以使用 break 退出循环</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h2><ul>
<li><p>map (不改变原数组) 会给原数组中的每个元素都按顺序调用一次 callback 函数</p>
</li>
<li><p>reduce (不改变原数组) 数组中的前项和后项做某种计算,并累计最终值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="comment">// arr.reduce(function(total, currentValue, currentIndex, arr), initialValue)</span></span><br><span class="line"><span class="comment">// callback 参数</span></span><br><span class="line"><span class="comment">// (累积器, 当前元素, 当前元素索引, 当前数组)</span></span><br><span class="line"><span class="comment">// initialValue:指定第一次回调 的第一个参数</span></span><br><span class="line"><span class="keyword">var</span> wallets = [<span class="number">4</span>, <span class="number">7.8</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> totalMoney = wallets.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">countedMoney, curMoney</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> countedMoney + curMoney;</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>filter (不改变原数组)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> morearr = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number &gt; <span class="number">3</span></span><br><span class="line">&#125;) <span class="comment">// [4,5,6]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>every (不改变原数组) 测试数组的所有元素是否都通过了指定函数的测试</p>
<ul>
<li>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测</li>
<li>如果所有元素都满足条件，则返回 true</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> result = arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>some (不改变原数组) 测试是否至少有一个元素通过 callback 中的条件。对于放在空数组上的任何条件，此方法返回 false</p>
<ul>
<li>如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测</li>
<li>如果没有满足条件的元素，则返回false</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// some(callback, thisArg)</span></span><br><span class="line"><span class="comment">// callback:</span></span><br><span class="line"><span class="comment">//    (当前元素, 当前索引, 调用some的数组)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> result = arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">item,index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">&#125;) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ul>
<li><p>find() &amp; findIndex() 根据条件找到数组成员</p>
<ul>
<li>find 定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回 undefined</li>
<li>findIndex 定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">let</span> new_array = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisArg</span>)</span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">new_array</span> = <span class="title">arr</span>.<span class="title">findIndex</span>(<span class="params"><span class="keyword">function</span>(currentValue, index, arr), thisArg</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 这两个方法都可以识别<span class="title">NaN</span>,弥补了<span class="title">indexOf</span>的不足</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">find</span></span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">a</span> = [1, 4, -5, 10].<span class="title">find</span>(<span class="params">(n) =&gt; n &lt; <span class="number">0</span></span>)</span>; <span class="comment">// 返回元素-5</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>,<span class="literal">NaN</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, n));  <span class="comment">// 返回元素NaN</span></span><br><span class="line"><span class="comment">// findIndex</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].findIndex(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// 返回索引2</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>,<span class="literal">NaN</span>].findIndex(<span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, n));  <span class="comment">// 返回索引4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>keys() &amp; values() &amp; entries() 遍历键名、遍历键值、遍历键名+键值</p>
<ul>
<li>三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">array.keys()   array.values()   array.entries()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
</search>
