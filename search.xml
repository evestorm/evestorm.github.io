<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[uniapp吸顶效果]]></title>
    <url>%2Fposts%2F7733%2F</url>
    <content type="text"><![CDATA[场景 案例 See the Pen 列表标题吸顶效果 by JingW (@JingW) on CodePen. uni-app 写法 template 结构 1234567891011121314151617181920212223242526&lt;!-- 运营概况 --&gt;&lt;view class="main"&gt; &lt;view class="main-title" ref="operationRef" data-id="operationRef"&gt; &lt;text class="left"&gt;运营概况&lt;/text&gt; &lt;view class="right"&gt; &lt;view&gt;我的&lt;/view&gt;&lt;view&gt;全店&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- ================== 主体内容 =================== --&gt; &lt;view class="overview-com"&gt; ... &lt;/view&gt;&lt;/view&gt;&lt;!-- 运营概况 --&gt;&lt;view class="main"&gt; &lt;view class="main-title" ref="operationRef" data-id="operationRef"&gt; &lt;text class="left"&gt;宴会概况&lt;/text&gt; &lt;view class="right"&gt; &lt;view&gt;我的&lt;/view&gt;&lt;view&gt;全店&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- ================== 主体内容 =================== --&gt; &lt;view class="overview-com"&gt; ... &lt;/view&gt;&lt;/view&gt; js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export default &#123; data() &#123; return &#123; ..., mainTitleEles: [], // 所有mainTitle标题对象集合 mainEles: [], // 所有板块对象集合 ot: [], //存储每个标题的offsetTop len: 0, // 标题的个数 searchBottomY: 0, // 搜索view底部距离页面顶部的距离 selectorQuery: &#123;&#125;, // Uniapp SelectorQuery 对象实例 &#125; &#125;, mounted() &#123; // 获取 SelectorQuery 对象实例。可以在这个实例上使用 select 等方法选择节点 this.selectorQuery = uni.createSelectorQuery().in(this); this.initFixedTop(); &#125;, methods: &#123; // --------------- 监听 mescroll 页面滚动 ------------------------ // 初始化吸顶标题的工作 initFixedTop() &#123; // 获取所有需要吸顶效果的标题 this.mainTitle = this.selectorQuery.selectAll('.main-title'); uni.createSelectorQuery().selectAll('.main-title').fields(&#123; rect: true, dataset: true &#125;, res =&gt; &#123; this.mainTitleEles = res; // 标题的个数 this.len = this.mainTitleEles.length; for (let i = 0; i &lt; this.len; i++) &#123; this.ot.push(this.mainTitleEles[i].top); //获取每个标题的offsetTop &#125; // 获取所有需要吸顶的板块 uni.createSelectorQuery().selectAll('.main').fields(&#123; rect: true, dataset: true, size: true &#125;, res =&gt; &#123; this.mainEles = res; // 存储每个标题的offsetTop（只读属性，返回当前元素相对于其 offsetParent 元素的顶部内边距的距离） // 加上 最后一个吸顶板块的高度. 解决滚动到最后一个标题（i）时，无法获取（i+1）的offsetTop this.ot.push(this.mainEles[this.len - 1].top + this.mainEles[this.len - 1].height); &#125;).exec(); &#125;).exec(); &#125;, onScroll(mescroll) &#123; // 获取滚动的高度 const st = mescroll.scrollTop; for (let i = 0; i &lt; this.len; i++) &#123; // 滚动时监听位置，为标题的吸顶设置一个显示范围 if (st &gt; this.ot[i] &amp;&amp; st &lt; this.ot[i + 1]) &#123; this.$refs[this.mainTitleEles[i].dataset.id].$el.className = 'main-title fixed'; &#125; else &#123; this.$refs[this.mainTitleEles[i].dataset.id].$el.className = 'main-title'; &#125; &#125; &#125;, &#125;&#125;; uni-app 思路和案例demo一样，所以就不贴代码的样式了，唯一要注意的一点就是dom属性的获取是通过 uni-app 相关 API 实现的： 参考 uni-app获取dom元素到顶部的距离以及操作dom元素的一些样式 uni.createSelectorQuery() 实现多个标题的吸顶效果]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转载]常见正则表达式合集]]></title>
    <url>%2Fposts%2F53612%2F</url>
    <content type="text"><![CDATA[转载来源：常见正则表达式合集 为了避免用户胡乱输入就通过验证，很多时候我们都会采用正则表达式来验证一下用户输入的信息是否符合规范。这部分的内容基本上是在网上收集来的，这里跟大家一起分享一下，有需要的可以记在自己的有道云笔记里面。 如何验证？验证的方式当然是很多了，这里推荐采用test()方法来验证。 1234567let isTrue = RegExpObject.test(string);// RegExpObject为正则 string是要检测的字符串// 如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false。if (isTrue)&#123; //验证成功 do something&#125;elseP&#123; //验证失败&#125; 身份证号码正则表达式：第一代身份证只有 15 位数，第二代身份证有 18 位数，各位按照需求来选择表达式。 1234//第二代身份证号码正则let isTrue = /^[1-9]\d&#123;5&#125;(18|19|20)\d&#123;2&#125;((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$/;//第一代身份证正则表达式(15位)let isTrue = /^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$/; 手机号码正则表达式：时间截止为：2018 年 1 月 11 日 移动号段：134 135 136 137 138 139 147 148 150 151 152 157 158 159 172 178 182 183 184 187 188 198 联通号段：130 131 132 145 146 155 156 166 171 175 176 185 186 电信号段：133 149 153 173 174 177 180 181 189 199 虚拟运营商：170 1let isTrue = /^(13[0-9]|14[5-9]|15[012356789]|166|17[0-8]|18[0-9]|19[8-9])[0-9]&#123;8&#125;$/; 邮箱正则表达式：1let isTrue = /^([A-Za-z0-9_\-\.\u4e00-\u9fa5])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]&#123;2,8&#125;)$/; 用户名正则:12////用户名正则，4到16位（字母，数字，下划线，减号）let isTrue = /^[a-zA-Z0-9_-]&#123;4,16&#125;$/; 密码正则:密码正则，以字母开头，长度在 6~18 之间，只能包含字母、数字和下划线 1let isTrue =^[a-zA-Z]\w&#123;5,17&#125;$; 强密码正则，最少 6 位，包括至少 1 个大写字母，1 个小写字母，1 个数字，1 个特殊字符 1let isTrue = /^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/; QQ 号码正则:1let isTrue = /^[1-9][0-9]&#123;4,10&#125;$/; 微信号码正则:12//微信号正则，6至20位，以字母开头，字母，数字，减号，下划线let isTrue = /^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$/; 特殊字符检测正则:1let isTrue = /["'&lt;&gt;%;)(&amp;+]+-!！@#$~/; 域名正则:1let isTrue=[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?; 车牌号码正则:1let isTrue = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]&#123;1&#125;[A-Z]&#123;1&#125;[A-Z0-9]&#123;4&#125;[A-Z0-9挂学警港澳]&#123;1&#125;$/; 包含中文正则:12let isTrue = /[\u4E00-\u9FA5]/;//这个可以用于验证用户的真实姓名。 护照正则:1let isTrue = /^(P\d&#123;7&#125;|G\d&#123;7,8&#125;|TH\d&#123;7,8&#125;|S\d&#123;7,8&#125;|A\d&#123;7,8&#125;|L\d&#123;7,8&#125;|\d&#123;9&#125;|D\d+|1[4,5]\d&#123;7&#125;)$/; 固定电话正则：1let isTrue=(\(\d&#123;3,4&#125;\)|\d&#123;3,4&#125;-|\s)?\d&#123;8&#125;; IP 地址正则:1let isTrue=\d+\.\d+\.\d+\.\d+; 邮政编码正则:1let isTrue=[1-9]&#123;1&#125;(\d+)&#123;5&#125;; 经纬度正则:1234//经度正则let isTrue = /^(\-|\+)?(((\d|[1-9]\d|1[0-7]\d|0&#123;1,3&#125;)\.\d&#123;0,6&#125;)|(\d|[1-9]\d|1[0-7]\d|0&#123;1,3&#125;)|180\.0&#123;0,6&#125;|180)$/;//纬度正则let isTrue = /^(\-|\+)?([0-8]?\d&#123;1&#125;\.\d&#123;0,6&#125;|90\.0&#123;0,6&#125;|[0-8]?\d&#123;1&#125;|90)$/;]]></content>
      <categories>
        <category>前端</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>转载</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数防抖&函数节流]]></title>
    <url>%2Fposts%2F40572%2F</url>
    <content type="text"><![CDATA[什么是节流和防抖 debounce（防抖）的作用是在让在用户动作停止后延迟x ms再执行回调。 throttle（节流）的作用是在用户动作期间每隔一定时间（如200ms）执行一次回调。 如何理解防抖如果有人进电梯（触发事件），那电梯将在 10 秒钟后出发（执行事件），这时如果又有人进电梯了（在 10 秒内再次触发该事件），我们又得等 10 秒再出发（重新计时）。 节流游戏中人物的技能CD，当技能处于闲置状态时，按下技能键（触发事件）能立马生效（执行事件）。生效后有技能冷却时间，期间不管你按多少下技能键（触发事件），就算把键盘按爆，都无法再次触发技能，直到冷却完毕。 P.S. CD时间：Cool Down Time 应用场景防抖 表单提交按钮的连续点击，防止重复提交。比如重复发送一篇文章。 搜索查询（连续输入文字后发送 AJAX 请求进行验证，（停止输入后）验证一次就好） 滚动事件scroll（只需执行触发的最后一次滚动事件的处理程序） 节流 自动保存草稿功能，当用户在输入的时候(一直触发事件),单位时间内只保存一次草稿。 上拉加载更多，防止用户暴力快速上滑。隔一段时间才能触发一次 滚动事件scroll，（只要页面滚动就会间隔一段时间判断一次） 代码实现防抖1234567891011121314151617/** * @description: 防抖函数：函数被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时 * @param &#123;Function&#125; fn 要执行的函数 * @param &#123;Number&#125; delay delay毫秒后执行回调 */function debounce(fn, delay = 500) &#123; let timer = null; // 为了封装，这里使用了闭包来保存局部变量=&gt;tip: 闭包保护的变量会一直保存在内存中但又不会 “污染” 全局的变量 return function() &#123; const context = this; if (timer) clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(context, arguments); timer = null; &#125;, delay); &#125;;&#125; 节流123456789101112131415/** * @description: 节流函数：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行 * @param &#123;Function&#125; fn 要执行的函数 * @param &#123;Number&#125; gapTime 单位时间 */function throttle(fn, gapTime = 500) &#123; let canUse = true; return function() &#123; if (canUse) &#123; fn.apply(this, arguments); canUse = false; setTimeout(() =&gt; (canUse = true), gapTime); &#125; &#125;;&#125; 示例 See the Pen 函数防抖&amp;函数节流 by JingW (@JingW) on CodePen. 参考来源 防抖函数&amp;节流函数 JS函数节流和函数防抖]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用padding-bottom特性实现height随width变化保持比例不变]]></title>
    <url>%2Fposts%2F2610%2F</url>
    <content type="text"><![CDATA[起因希望每个网格高度等于宽度，而宽度已被设为33.333%： 解决方案示例 See the Pen padding-bottom 高度自适应 by JingW (@JingW) on CodePen. 说明 一个元素的 padding，如果值是一个百分比，那这个百分比是相对于其父元素的宽度而言的，padding-bottom 也是如此。 使用 padding-bottom 代替 height 来实现高度与宽度成比例的效果，将 padding-bottom 设置为想要实现的 height 的值。同时将其 height 设置为 0 以使元素的「高度」等于 padding-bottom 的值，从而实现需要的效果。 参考来源 css保持div等高宽比]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序Image图片实现宽度100%，高度自适应]]></title>
    <url>%2Fposts%2F1126%2F</url>
    <content type="text"><![CDATA[做法如下： 样式设置宽度100%： 123.img &#123; width: 100%;&#125; 添加属性 mode=”widthFix”： 1&lt;image class="img" src="/static/images/hello.png" mode="widthFix"&gt;&lt;/image&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>uni-app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信web开发者工具input，button按钮偏移]]></title>
    <url>%2Fposts%2F40884%2F</url>
    <content type="text"><![CDATA[使用微信web开发者工具开发时有时会发现如图，明明input框和button框在下面，但只有点击箭头位置时才能有效果 解决方法： 在排除样式上的错误的情况下：这是因为高分屏win10的显示设置默认是125%，只需调整为100%即可：]]></content>
      <categories>
        <category>前端</category>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome调试技巧-汇总]]></title>
    <url>%2Fposts%2F63676%2F</url>
    <content type="text"><![CDATA[温馨提醒：遇到文章中打不开的图片，右键新标签打开链接就能正常看到了~ 打印console.table使用 console.table() 可以将传入的对象，或数组以表格形式输出。适合排列整齐的元素： 让日志更易读即使 console.log 一个简单变量，你都可能会忘记（或混淆）哪一个是那个。当你有不同的变量需要打印的时候，阅读起来会更费劲。 “嗯？哪一个值对应哪一个变量来着？” 为了让它变得更加易读，你可以打印一个对象 - 只需将所有console.log 的参数包装在大括号中。感谢 ECMAScript 2015 中引入了 enhanced object literal(增强对象文字面量) ，所以这（加了个括号）就是你需要做的全部了： 触发伪类右键单击 Elements 面板中的目标元素节点并选择「force state」。或者在 Styles 子窗格中单击「:hov」图标。可以触发元素上的伪类来研究元素在悬停时的效果和样式： ALT+单击可以展开所有子节点在Elements面板中,使用Alt+单击可以展开该Dom节点下的所有Dom子节点： copy拷贝资源你可以通过全局的方法 copy() 在 console 里 copy 任何你能拿到的资源，例如： 拷贝 HTML (最快的方式)可能你知道右击或者点击在 html 元素边上的省略号(…)就能将它 copy 到操作系统剪贴板中 但你同样可以用非常古老的 [ctrl] + [c] + [ctrl] + [v] 大法来实现同样的效果！ snippet代码块作用：Chrome开发者工具的Snippets提供了在Chrome里保存及运行或者调试一段js代码的功能入口：Chrome开发者工具-Sources面板-Snippets面板 直达：你不知道的 Chrome 调试工具技巧 第二十一天：Snippets(代码块) 参考来源 Javascript调试命令——你只会Console.log() ? 【译】你不知道的 Chrome 调试工具技巧 第二十一天：Snippets(代码块) 20个Chrome DevTools调试技巧（译）]]></content>
      <categories>
        <category>效率</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】20个ChromeDevTools调试技巧]]></title>
    <url>%2Fposts%2F709%2F</url>
    <content type="text"><![CDATA[译者按： Chrome DevTools很强大，甚至可以替代IDE了！ 原文: Art of debugging with Chrome DevTools 译者: Fundebug 为了保证可读性，本文采用意译而非直译。另外，本文版权归原作者所有，翻译仅用于学习。 小编推荐：Fundebug专注于JavaScript、微信小程序、微信小游戏，Node.js和Java线上bug实时监控。真的是一个很好用的bug监控服务，众多大佬公司都在使用。 谷歌开发者工具提供了一系列的功能来帮助开发者高效Debug网页应用，让他们可以更快地查找和修复bug。在谷歌的开发者工具中，有非常多有用的小工具，但是很多开发者并不知道。通过这篇文章，我把我常用的那些高效Debug的Chrome开发者工具的功能分享给大家。 简洁起见，接下来我会使用开发者工具来指代谷歌开发者工具。 在我们开始之前，你需要做一些准备工作。 使用金丝雀版如果你想使用谷歌最新的版本和开发者工具，你可以下载金丝雀版本，甚至把它设置为开发默认打开的浏览器。金丝雀版本旨在为早期接受者提供最新的更新。它可能不稳定，但是大多数时候是没问题的。你要习惯去使用最新最强的谷歌浏览器。 1. 开启开发者工具的实验性功能 你可以到chrome://flags页面，然后开启Developer Tools experiments选项。 当开启后，在开发者工具的设置页面，可以发现多了一个Experiments选项。如果我使用的一些功能你没有看到，那么请到Experiments窗口打开。 2.超级实验性功能 如果我使用到的功能在Experiments列表没有，那么它可能是一个WIP功能(WIP指working in progress)。你可以这样开启：页面处在Experiments界面，连续敲击shift键6次来开启WIP功能。 Console当Debug的时候，我们绝大部分时间是在和Console打交道。我们往往在代码中插入很多Console logs，通过打印变量值来debug。鉴于Console对于我们这么重要，很有必要了解所有开发者工具提供的相关的APIs和快捷键。 3. 总是打印对象 我的第一个建议其实和开发者工具没有关系，而是我一直使用的一个技巧。在使用console.log();的时候，不仅仅打印变量，而是要打印对象，用大括号({})将变量包围起来。这样的优点是不仅会把变量的值打印，同时还会将变量名打印出来。 4. 使用console.table来打印多条目数据 如果你要打印的变量是一个数组，每一个元素都是一个对象。我建议你使用console.table来打印，其表格化的呈现更加美观易读。 5. 给log加点颜色 log有时候变得非常多，包含你自己的、一些第三方扩展或者浏览器的logs。除了使用过滤器(filter)以外，你还可以使用颜色来更好地区分。 6. $ 和 $$ 如果你在console下没有任何库使用$和$$，那么你可以使用它们分别作为document.querySelector() 和 document.querySelectorAll()的快捷键。 除了提供了一个更加快捷的方式外，还有一个好处，$$返回一个数组，而不是array-like的NodeList. 所以你可以直接使用map, reduce和filter 函数。 你可以使用$$检查页面中的无效链接： 12345678Promise .all( $$('a') .map(link =&gt; link.href) .map(href =&gt; fetch(href)) ) .then(() =&gt; console.log('All links working')) .catch(() =&gt; console.error('Some links are broken')); 7. $0 如果你想引用某个DOM元素，使用$0。$0指向你当前在Element中选中的元素。如果指定了$0，$1指向之前选中的元素。以此类推，直到$4都可以使用。 8. $_ $_记录了最后一次在Console计算的表达式。 9. getEventListeners() getEventListeners(domElement) 返回在DOM元素上注册的所有的事件。请看下面的例子： 你也许注意到了，当我在console里输入表达式的时候，其结果立即被计算出来了。你可以看到我并没有敲击Enter键，而结果已经显示出来。这个是金丝雀版本的一个新功能，叫做”Eager Evaluation”。 10. debug(fn) 在上面的例子中，如果你想在点击按钮后的执行过程中暂停，你可以使用debug函数。debug(fn)接收一个函数作为参数，当每次该函数被调用时，Debugger就会在该函数的第一行中断执行。 想象一下你要debug一个按钮的问题，但是你不知道这个按钮对应的事件函数在代码中什么位置。除了去大量的源代码中慢慢寻找之外，还有一个巧妙的方法。使用getEventListeners函数，然后将debug方法注入进去。这样，当你点击按钮的时候，就会在该函数的第一行停下来。 11. copy(obj) copy(anything) 是一个很有用的工具函数方便你将任何东西拷贝到系统的粘贴板暂存。 给copy函数传入一个没有格式的JSON，会返回格式化的结果： 12. Top-level await async/await 使得异步操作变得更加容易和可读。唯一的问题在于await需要在async函数中使用。如果我们要在DevTools的控制台使用，需要一些特殊的处理，使用Immediately Invoked Async Function Expression (IIAFE). 一点都不方便。好在DevTools已经支持直接使用await了。 Debugging in the Sources panel在source面板，使用breakpoints，stepping-into, stepping-over等方式，你可以很好地掌控程序的执行状态，来发现代码问题。接下里我不会介绍大家都知道的基础内容，而是一些我经常使用的建议和技巧。 13. 开启 auto-pretty print 在金丝雀版本的实验模式下，你可以开启自动美化代码模式。 14. 使用条件断点在生产环境中注入console logs 断点是一个很棒的功能。但还有一个更棒的：条件断点。只有当设定的条件满足的时候，中断才会执行。也就是说DevTools并不会每次都中断程序的执行，而只是在你想要它中断的时候才中断。想了解更多：查看这里. 在生产环境下，因为不能修改源代码，我喜欢使用条件断点来注入console.log。如果我的断点仅仅是一个console.log，DevTools不会中断，因为console.log返回undefined,，是一个false的值。但是它会执行我注入的表达式，可以看到输出结果。 为什么不直接使用普通的断点，并且查看变量呢？有时候我并不想这样做。比如，当我在分析那些频繁执行的操作，例如触摸或则滑动。我并不想每一次都导致Debugger触发程序中断，但是我想看到程序输出的结果。 15. 暂停UI在Hover状态下的展示结果 我们很难去检查一个只有在Hover状态下展示的元素。比如，如何去检查一个tooltip？如果你右键并选择检查，元素已经消失了。那么有办法吗？ 我是这么操作的： 打开sources面板 显示tooltip 使用快捷键来暂停脚本执行(将鼠标停留在暂停的图标上查看快捷键) 回到Elements面板，然后像通常一样去检查元素 16. XHR breakpoints 如果想要理解一个请求是如何执行的，可以使用sources面板的XHR breakpoints。 17. 使用DevTools作为IDE DevTools的source面板可以说相当强大。你可以快速查找，跳转到某一行，某个函数，执行一段代码，使用多行光标等等。这些功能在这篇medium文章中有详细描述。 既然如此，为啥不把整个开发都搬到这里呢。这样就不需要浪费时间切换IDE和浏览器了。 如果你有一个使用create-react-app或则vue-cli构建的项目，你可以直接把整个文件夹拖到Sources面板下。DevTools会自动对所有文件做映射。所以，你可以在DevTools下修改文件并立即查看。这样，整个开发效率，特别是Debugging效率绝对提高了。 18. 使用network overrides来简单调试生产代码 如果你正在Debugging一个生产环境下面的bug，你可以使用network overrides来调试，而不用在本地搭建整个配置。 你可以很容易将任何远程的资源下载一份本地的版本，然后可以在DevTools下编辑，并且DevTools会更新展示你编辑后的文件。 在生产环境下，也可以很容易Debugging，并且做一些性能上的测试也变得容易。 19. Nodejs debugging如果你想使用DevTools的Debugger来debug Node.js应用，你可以使用--inspect-brk flag来开启： 1node --inspect-brk script.js 跳转到chrome://inspect页面，在Remote Target选项，可以看到Node程序。 并且，在DevTools中你会看到一个绿色的Node图标，点击图标会打开针对Node的Chrome Debugger。 如果你想要用DevTools Debugger来debug你的单元测试，你需要这样调用： 1node --inspect-brk ./node_modules/.bin/jest 不过这样做其实很麻烦，我们需要自己找到相应的路径。 GoogleChromeLabs 最近发布了一个新的工具非常好用，叫做：ndb。使用ndb，你只需要： 1ndb npx jest 如果你有一个自定义的脚本，你可以这样调用： 1ndb npm run unit 更妙的是，如果你在一个有配置package.json的项目下调用ndb，他甚至会自动分析package.json中的脚本，方便你直接使用DevTools。 20. 使用Snippets来辅助Debugging DevTools提供了一个可以创建和保存小段代码的工具，我很喜欢用它们来加速我的工作。比如lodashify — 可以快速给任何应用添加lodash。 12345678(function () &#123; 'use strict'; var element = document.createElement('script'); element.src = "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.15.0/lodash.min.js"; element.type = "text/javascript"; document.head.appendChild(element);&#125;)(); 另一个小的工具函数式用来增强对象的属性，每次被访问或则修改，它都会提供给我充分的信息，比如谁访问了，谁更改了它。在Debugging的时候，非常有用。 12345678910111213const traceProperty = (object, property) =&gt; &#123; let value = object[property]; Object.defineProperty(object, property, &#123; get () &#123; console.trace(`$&#123;property&#125; requested`); return value; &#125;, set (newValue) &#123; console.trace(`setting $&#123;property&#125; to `, newValue); value = newValue; &#125;, &#125;)&#125;; 还有很多非常有用的devtools代码片段，你可以直接拿去使用。 关于FundebugFundebug专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了6亿+错误事件，得到了Google、360、金山软件等众多知名用户的认可。欢迎免费试用！ 版权声明:转载时请注明作者Fundebug以及本文地址：https://blog.fundebug.com/2018/08/22/art-of-debugging-with-chrome-devtools/]]></content>
      <categories>
        <category>效率</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[input效果汇总]]></title>
    <url>%2Fposts%2F33862%2F</url>
    <content type="text"><![CDATA[text 文本框focus 时底部下划线展开动画 See the Pen Input Boxes by JingW (@JingW) on CodePen. search 搜索框聚焦时搜索框变宽动画 See the Pen Search Form with CSS3 by JingW (@JingW) on CodePen. radio 单选按钮自定义小圆点（带动画） See the Pen CSS radio buttons by JingW (@JingW) on CodePen. checkbox 多选按钮自定义小方框1 See the Pen Simple CSS Checkboxes with Font Awesome by JingW (@JingW) on CodePen. 自定义小方框2 See the Pen Pure CSS custom checkboxes by JingW (@JingW) on CodePen. select 下拉选项纯CSS的下拉列表 See the Pen Pure CSS Select by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>demo</category>
      </categories>
      <tags>
        <tag>input</tag>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序formId获取]]></title>
    <url>%2Fposts%2F35316%2F</url>
    <content type="text"><![CDATA[1. 什么是 formIdformId 是小程序可以向用户发送模板消息的通行证，简单而言，你只有获取到 formId，把它交给后台，后台同学才能向用户发送通知消息，而这个通行证的有效期只有七天。这是微信为了防止小程序滥用通知消息骚扰用户而提出的一种策略。 2. formId 的获取小程序的 模板消息文档 中说，获取 formId 有以下两种途径： 支付 提交表单 用户支付一次，能获取3个 formId，用户提交表单一次可得到一个 formId 。如果小程序中没有支付行为，但又有需要向用户发送消息的需求，这个时候就只能依靠提交表单了。 2. 1 下发条件说明以下摘自 模板消息文档 - 下发条件说明 2.1.1 支付当用户在小程序内完成过支付行为，可允许开发者向用户在7天内推送有限条数的模板消息（1次支付可下发3条，多次支付下发条数独立，互相不影响） 2.1.2 提交表单当用户在小程序内发生过提交表单行为且该表单声明为要发模板消息的，开发者需要向用户提供服务时，可允许开发者向用户在7天内推送有限条数的模板消息（1次提交表单可下发1条，多次提交下发条数独立，相互不影响） 2.2 代码示例获取 formId 必须使用小程序/uni-app 的 form 组件，它本身有个属性叫 report-submit ，当在标签中加入这个属性时，一旦表单提交，submit 回调中就可以拿到 formId 了。 html 12345678910&lt;!-- 微信小程序代码 --&gt;&lt;form bindsubmit="formSubmit" report-submit="true"&gt; ... &lt;button formType="submit"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;!-- uni-app 代码 --&gt;&lt;form @submit='formSubmit' :report-submit='true'&gt; &lt;button form-type="submit"&gt;提交表单&lt;/button&gt; // formSubmit 为提交事件触发的自定义方法&lt;/form&gt; js 1234567formSubmit: function (e) &#123; // 获取表单id const formId = e.detail.formId; // 非真机运行时 formId 应该为 'the formId is a mock one' console.log('表单id:', formId); // 获取后可通过异步请求将 formId 传递给后端&#125; 重要： 在微信开发者工具中运行获取的 formId 为 the formId is a mock one ，要获得真实有效的 formId 需要在真机上运行。 2.3 获取尽可能多的 formId从运营的角度而言，formId 肯定是越多越好。所以每一个页面上用户的每一次点击我们都巴不得触发一次表单提交。哪怕从界面上讲，这次点击可能是跳转，弹窗的功能，跟表单完全无关，都要把 button 放在一个 form 中。但是这样无疑增加了前端的工作量，因为需要为每个页面的 submit 事件绑定一个上传 formId 的方法。一个可行的方法是借助 vue 的 mixin，为每一个页面实例混入一个上传 formId 的方法： 12345678910// app.jsVue.mixin(&#123; methods: &#123; uploadFormId (e) &#123; this.req(&#123; url: '/api/v1/formid?formId=' + e.target.formId &#125;) &#125; &#125;&#125;) 另外一个方法： 1234567891011121314151617181920212223function _collectWeChatFormId(formId) &#123; let token = wx.getStorageSync("token_/cookies"), openId = wx.getStorageSync("openid_cookies"), orign = 1; console.log('formId',formId) if (formId == 'the formId is a mock one') &#123; console.log(`模拟器中运行！`) return false; &#125; if (formId.length == 0) &#123; console.log(`formId不能为空`) return false; &#125; let site = '你的收集接口', dates = &#123; token: token, openId: openId, formId: formId, orign: orign &#125;, md = 'token=' + token + '&amp;openId=' + openId + '&amp;formId=' + formId + '&amp;orign=' + orign; requestHttp(site, dates, md, function (res) &#123; console.log(res) console.log(res.data) &#125;)&#125; 3. 小程序模板消息接口更新请注意，小程序模板消息接口将于2020年1月10日下线，开发者可使用订阅消息功能]]></content>
      <categories>
        <category>前端</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>uni-app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css扩大元素点击区域]]></title>
    <url>%2Fposts%2F1303%2F</url>
    <content type="text"><![CDATA[问题描述项目中遇到使用滑动条的地方，但设计稿上的按钮面积非常小，用户在手机上由于不容易精确触摸到按钮导致拖动滚动条困难： 所以就想着扩大按钮的点击区域。通常情况下想要扩大点击区域有两种方案： 增加border 添加padding 然而由于此滑动条使用的是三方库，圆形按钮的位置使用的是绝对定位，不太好改它本身的大小，因为这样要调整的css样式太多。所以上面两种方案都被毙掉了，最后 Google 到下面方案。 解决方案使用伪元素扩大可点击区域 伪元素能为其父元素捕获鼠标交互动作，因此，只需通过伪元素扩大父元素的空间大小，就能扩大可点击区域。 代码如下： 1&lt;button class="extend-via-pseudo-elem"&gt;点击&lt;/button&gt; 123456789101112.extend-via-pseudo-elem &#123; position: relative;&#125;.extend-via-pseudo-elem::before &#123; content: ''; position: absolute; top: -20px; right: -20px; bottom: -20px; left: -20px;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[select标签样式调整技巧]]></title>
    <url>%2Fposts%2F46310%2F</url>
    <content type="text"><![CDATA[重置丑陋样式项目中使用到了 select 标签，但在 Android 和 iOS 上默认展示的效果都很丑而且不一致，网上搜到一个 css 样式可以重置效果，这里记下笔记： 12345678910111213141516171819select &#123; /*移除浏览器默认特殊样式*/ appearance: none; -moz-appearance: none; -webkit-appearance: none; -ms-appearance: none; /*移除轮廓样式*/ outline: none; /*移除点击元素时出现的高亮颜色*/ -webkit-tap-highlight-color: #fff; border: rem(1) solid #EBEBEB; border: none; width: rem(100); height: rem(50); line-height: rem(50); /*设置一个块元素首行文本内容之前的缩进量，防止紧紧靠在边上*/ text-indent: rem(4); background-color: transparent;&#125; 选中项右对齐1234select &#123; direction: rtl;&#125;/* 默认左对齐属性值为 ltr */ select默认选中项原生123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;body&gt; &lt;select name="framework" id="framework"&gt; &lt;option value="vue"&gt;VueJS&lt;/option&gt; &lt;option value="react" selected&gt;ReactJS&lt;/option&gt; &lt;option value="angular"&gt;AngularJS&lt;/option&gt; &lt;option value="jquery"&gt;jQuery&lt;/option&gt; &lt;/select&gt; &lt;script&gt; document.querySelector('#framework').addEventListener('change', function (e) &#123; console.log(e.target.value); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; vue template 1234567&lt;template&gt; &lt;div&gt; &lt;select v-model="selected" @change="selectChange" class="select"&gt; &lt;option v-for="(search, key) in searchList" :key="key" :value="search.id"&gt;&#123;&#123;search.name&#125;&#125;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt;&lt;/template&gt; js 12345678910111213141516data()&#123; return&#123; searchList:[ &#123; id:'1',name:'中国' &#125;, &#123; id:'2',name:'美国' &#125;, &#123; id:'3',name:'日本' &#125;, ], selected:'2' &#125;&#125; 在写 vue select 的时候应注意以下几点： v-model 是select 的指定显示文本，如果没有，当选中 option 中的内容时 select 标签将不会显示出文本。 @change 应尽量写在 select 标签上。 onchange 事件获取选中项的 value 和 text123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="num"&gt; &lt;select id="xuanze"&gt; &lt;option value="10"&gt;10&lt;/option&gt; &lt;option value="15"&gt;15&lt;/option&gt; &lt;option value="20"&gt;20&lt;/option&gt; &lt;option value="25"&gt;25&lt;/option&gt; &lt;option value="30"&gt;30&lt;/option&gt; &lt;option value="35"&gt;35&lt;/option&gt; &lt;option value="40"&gt;40&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var obj = document.getElementById('xuanze'); //定位id obj.addEventListener('change', () =&gt; &#123; var index = obj.selectedIndex; // 选中索引 var value = obj.options[index].value; // 选中值 var text = obj.options[index].text; // 选中展示的文字 console.log(index, value); &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端input类型为date的placeholder不显示]]></title>
    <url>%2Fposts%2F23431%2F</url>
    <content type="text"><![CDATA[起因在移动端项目开发中，DatetimePicker（时间选择器） 组件是非常常用的，并且市面上各大移动端UI框架也都帮我们封装了，然而绝大部分框架封装的该组件都是从底部弹出式滚动选择的（Android 和 iOS 真机上都如此），例如下面形式： 然而这仅针对 iOS 用户友好，但对于用惯了 Android 手机的用户来说，下面形式的时间选择才是他们熟悉的形式： 所以往往我们会放弃掉框架帮我们封装好的组件，自己用原始 input[type=date] 实现一个或者借助其他基于原始 input 标签封装的时间选择器。这里顺带提一个我感觉用起来还不错的库：flatpickr，github地址为：flatpickr/flatpickr 。 我在项目中就使用到了这个库，然而在开发中遇到了一个小问题，设计稿上要求，我们的时间选择器组件默认情况下显示一段 placeholder ，然而在真机上我发现，无论 iOS 还是 Android 下，input 始终为空，设置的 placeholder 无效。原本我以为这是 flatpickr 做了手脚，简单查看了源码后发现并不是它的锅。最后 Google 后才知道，这就是 input[type=date] 元素在手机端上的一个 feature ，不过我感觉就是个 bug ，我设置了你凭什么不给我显示？。 解决方案前面铺垫了这么多，其实解决方案涉及到的代码量并不多，原理就是使用 css 伪类给 input[type=date] 设置默认 content 为 placeholder ，再设置 input 状态为 focus 时移除这个 placeholder 属性，最后在触发 blur 时把 placeholder 添加回来。具体代码如下： html 1&lt;input class="text-date" type="date" placeholder="请选择日期"&gt; css 1234input[type="date"]:before &#123; content: attr(placeholder); color: #ccc;&#125; js 12345678$('text-date').focus(function() &#123; $(this).removeAttr('placeholder');&#125;);$('text-date').blur(function() &#123; if (this.value === '') &#123; $(this).attr('placeholder', '请选择日期'); &#125;&#125;)]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>兼容性</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用you-get下载网站视频]]></title>
    <url>%2Fposts%2F21487%2F</url>
    <content type="text"><![CDATA[介绍you-get 是 GitHub 上的一个开源项目，可以帮助我们下载大多主流网站上的视频、图片及音频。 GitHub Repo 地址： soimort/you-get 起因有时候希望能在 B 站下载在线视频到本地，然而 B 站只支持在手机端缓存。所以 Google 了下发现了一个插件：「bilibili哔哩哔哩下载助手」（点击左侧链接在google应用商店直接下载），下载完成后打开你要下载的 B站 视频链接，右下角就会出现一个按钮： 点击后就弹出下载详情，直接按下图配置点击合并下载即可： 扯远了，其实到目前为止一切都非常顺利，但这个助手插件有个问题就是有时候下载特别快有时候又特别慢，慢起来一个200M视频要下载1两个小时。所以我又开始了找工具征程。最后就发现了今天的主角————「you-get」。 安装首先你需要安装 python3 最新版。（没有 python 的需要前往 python 官方按照教程下载）。 然后在本地安装 you-get： Windows 用户按住键盘「win+R」打开运行窗口，输入 cmd 点确定，然后键入如下命名： 123pip3 install you-getpip3 install --upgrade you-getpython -m pip install --upgrade pip 执行完上面三步并没有报错就代表安装成功了。 Mac 用户mac这边更简单，快捷键「Ctrl+空格」输入 Terminal 回车启动，键入下方命名（和 Windows 一样，前提是安装最新版 python3.7+ ）： 1pip3 install you-get 使用安装完成后咱们就能愉快的下载视频了。示例如下： 1you-get https://www.bilibili.com/video/av8106130?p=2 下载目录视频下载后存储在本地的地址就是你执行下载命名时所在的目录。]]></content>
      <categories>
        <category>效率</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>you-get</tag>
        <tag>下载</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序canvas绘制的图片真机不显示]]></title>
    <url>%2Fposts%2F13054%2F</url>
    <content type="text"><![CDATA[问题描述公司小程序项目有个页面需要用 canvas 绘制图片保存，其中图片资源是从后端获取的网络图片。然而在测试中发现，模拟器上图片能正常绘制，但真机只有开了调试模式才能显示图片，一旦关闭调试模式后，canvas就空白一片，啥都看不见。 踩坑一开始简单 google 下，都说是因为图片得下载到本地，获取临时路径后才能绘制。然而我就是这么做的，所以此路不通。最后阅读 这篇文章 后才明白问题出在哪儿。 解决方案首先检查你的网络图片地址的域名在不在微信白名单内，这个可以在「微信公众平台-小程序」中配置，此处不表。重点是在绘制 canvas 时，得先下载这张网络图片到本地，所以还得在「微信公众平台-小程序」中的「服务器配置-downloadFile」合法域名中配置你网络图片的域名： 完…]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>uni-app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack4-Shimming(垫片)]]></title>
    <url>%2Fposts%2F29270%2F</url>
    <content type="text"><![CDATA[先举个栗子🌰假设我们一个用 webpack 打包的项目有以下场景 index.js 12345678import $ from 'jquery';import &#123; initUI &#125; from 'ui.js';const $div = $('&lt;div&gt;&lt;/div&gt;');$div.html('hello world!');$('body').append($div);initUI(); ui.js 123export function initUI() &#123; $('body').css('background', 'green');&#125; 此时我们直接打包代码是不能执行的，因为 ui.js 中没有引入 jquery，所以不能使用 $ 。 按照正常思路我们会想，不是在 index.js 中一开始就引入了 jquery 么？为什么还会报错？这是因为 webpack 是基于模块打包的，当前模块下的变量只能在当前文件中起作用。所以引入的其他模块中如果也使用了这个变量就失效了。 这种问题场景其实还不止是本地文件，有可能第三方库中也引用了jquery，但是我们直接去改库的代码是不太现实的。此时，就可以用shimming（垫片）来解决这个问题。 如何使用垫片插件首先要引入webpack模块，然后配置插件 webpack.config.js 123456789const webpack = require('webpack');...plugins: [ new webpack.ProvidePlugin(&#123; $: 'jquery' &#125;)] 当我们加上这段代码后，模块在打包的时候，发现你使用了 $ 就会在你模块顶部自动加入 import $ from &#39;jquery&#39; 。 官方文档 ProvidePlugin（官网） ProvidePlugin（中文）]]></content>
      <categories>
        <category>前端</category>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tree-Shaking性能优化实践(笔记)]]></title>
    <url>%2Fposts%2F64509%2F</url>
    <content type="text"><![CDATA[何为 Tree-Shaking Tree shaking 是一个通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code) 行为的术语。 它依赖于ES2015中的 import 和 export 语句，用来检测代码模块是否被导出、导入，且被 JavaScript 文件使用。 在现代 JavaScript 应用程序中，我们使用模块打包(如webpack或Rollup)将多个 JavaScript 文件打包为单个文件时自动删除未引用的代码。这对于准备预备发布代码的工作非常重要，这样可以使最终文件具有简洁的结构和最小化大小。 ——&gt; 来自 MDN Tree-Shaking性能优化实践 - 原理篇链接：掘金 - 百度外卖大前端技术团队 摇树优化实战链接：webpack4.29.x成神之路（十三） 摇树优化(tree shaking)]]></content>
      <categories>
        <category>前端</category>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uni-app踩坑日常]]></title>
    <url>%2Fposts%2F34936%2F</url>
    <content type="text"><![CDATA[图片路径问题在 .vue 文件中使用本地图片可以用绝对路径或者相对路径： 123&lt;image src="/static/images/logo.png"&gt;&lt;/image&gt;&lt;!-- or --&gt;&lt;image src="../../static/images/logo.png"&gt;&lt;/image&gt; 在 .css 样式文件中background 属性中，得使用下面写法引入本地图片： 1background: url('~@/static/images.logo.png'); 否则图片无法被正确加载。 自定义组件 image 的 src 路径自定义组件里面使用 &lt;image&gt;时，若 src 使用相对路径可能出现路径查找失败的情况，故建议使用绝对路径。 —— uni-app 文档 image 组件 错误示范 ❌ 123&lt;image src="../../static/icos/star-yellow.png"&gt;&lt;/image&gt; 正确示范 ✅ 123&lt;image src="/static/icos/star-yellow.png"&gt;&lt;/image&gt; Vue问题v-show 在小程序上不起作用场景再现 希望通过点击按钮来切换三行文字的显示隐藏： 代码非常简单，但有两个条件： style 标签添加上 scoped 装填文字的容器有自己的 display 属性 在此种情况下，H5的效果和预期一样，点击后三行文字都消失，再次点击三行文字都显示，如此往复。 但在微信小程序中第一行文字始终无法消失。 问题所在 在小程序中， .item.data-v-xxx 的样式覆盖掉了 view[hidden] 的样式： 所以本应该默认不显示的第一行文字显示了。 而在 H5 上，uni-app 的做法是给当前标签添加上行内样式的 display: none，优先级最高： 123&lt;view v-show="show"&gt; &lt;view class="item"&gt;谁特么买小米？！&lt;/view&gt;&lt;/view&gt; 解决办法 在外层包裹一个div，在上面设置 v-show 来控制元素的隐藏和显示： 组件相关uni-icon h5端不显示在项目中使用 uni-app 官方提供的 uniIcon 组件时，要注意现有项目中使用的是 uni-icon.vue 还是 uni-icons.vue ，前者是旧版组件，后者是新版，多了个 s 后缀。 如果使用的前者，注意在页面中导入 uni-icon 时不要起名为 uniIcon ： 1❌import uniIcon from '@/components/uni-icon/uni-icon.vue' 这样会导致 H5 端无法显示该图标。解决办法是起个别名，例如： 1✅import swIcon from '@/components/uni-icon/uni-icon.vue' 如果使用的后者，要注意使用 snippet 智能提示后，自动生成的代码 &lt;uni-icon type=&quot;&quot;&gt;&lt;/uni-icon&gt; 是有错误的，标签名最后少了个 s ，正确写法是： 1✅&lt;uni-icons class="apply" type="plusempty" size="20"&gt;&lt;/uni-icons&gt; 三种情况比较： 123&lt;uni-icon type="plusempty" size="20"&gt;&lt;/uni-icon&gt;&lt;sw-icon type="plusempty" size="20"&gt;&lt;/sw-icon&gt;&lt;uni-icons type="plusempty" size="20"&gt;&lt;/uni-icons&gt; 123import uniIcon from '@/components/uni-icon/uni-icon.vue'import swIcon from '@/components/uni-icon/uni-icon.vue'import uniIcons from '@/components/uni-icons/uni-icons.vue' 插件地址： https://ext.dcloud.net.cn/plugin?id=28 自定义modal弹窗uni-app 自带的 uni.showModal API的主体内容不支持添加标签，只能添加文字： 如果需要在弹窗中显示一个 input 控件或其他元素就无能为力了。 解决办法 在插件市场找到了一款自定义 modal 组件： 文档：https://ext.dcloud.net.cn/plugin?id=134 框架相关class数组对象形式绑定非H5端不支持Vue官方文档：Class 与 Style 绑定中的classObject和styleObject语法。 —— uni-app 文档 H5 WX小程序 showToast 不支持网络图片的 icon 官方文档中有这样一段说明： 示例 12345uni.showToast(&#123; title: '标题', duration: 2000, image: '/static/images/success.png',&#125;); tabBar相关自定义picker无法遮挡 tabBartabBar 的层级比自定义组件都高，这导致一切自定义组件都会被 tabBar 遮挡： 如果不希望 tabBar 遮挡自定义组件，可以在现实自定义组件时，手动调用下面方法隐藏 tabBar ，最后在使用完自定义组件后，将其重新显示： 1234// 手动隐藏uni.hideTabBar(OBJECT)// 手动显示uni.showTabBar(OBJECT) H5底部固定view被 tabBar 遮挡由于在H5端，不存在原生导航栏和tabBar，也是前端div模拟。如果设置了一个固定位置的居底view，在小程序和App端是在tabBar上方，但在H5端会与tabBar重叠。此时可使用--window-bottom，不管在哪个端，都是固定在tabBar上方。 1bottom: calc(var(--window-bottom) + 20px);]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>uni-app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue利用provide+inject实现页面重新渲染]]></title>
    <url>%2Fposts%2F57665%2F</url>
    <content type="text"><![CDATA[在vue中有时vuex或者computed的数据改变后数据并不会进行重新渲染，只有刷新后数据才会重新加载， 但如果为了让页面重新加载而采用window.reload()或者router.go(0)进行刷新那加载慢闪烁白屏等问题会让客户体验及其不好 这时就可以进行局部刷新，原理是使用provide+inject的组合来控制router-view的显示消失完成 provide+inject这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效 在app.vue中注册函数reload对属性isRouterAlive进行开关操作 然后在需要使用的组件中注入方法直接 this.reload()使用即可 补充：在reload中的this.$nextTick()是将回调延迟到下次DOM 更新循环之后执行，基本等价于settimeout(()=&gt;{},0) 能够让一些数据完成接收替换后再进行调用，也是能解决加载问题的方法之一]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue骨架屏]]></title>
    <url>%2Fposts%2F7260%2F</url>
    <content type="text"><![CDATA[什么是骨架屏骨架屏就是在页面尚未加载之前先给用户展示出页面的大致结构，直到页面请求数据后渲染页面。骨架屏和loading相比较还是骨架屏用户体验感更好。原理其实非常简单，就是在页面还没加载完成时展示一张图片（一般是Base64编码），类似下方效果： 安装骨架屏插件1npm install vue-skeleton-webpack-plugin Skeleton 组件在 src/components 下新建 Skeleton.vue 组件： 12345678910111213141516171819&lt;template&gt; &lt;div class="skeleton"&gt; &lt;!-- 我是首页骨架屏图片 --&gt; &lt;div class="home-skeleton"&gt; &lt;img src="../assets/skeleton.jpg" alt="skeleton"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt;&lt;style lang="css" scoped&gt;.home-skeleton &#123; width: 100%;&#125;&lt;/style&gt; 导出 js根目录下新建 skeleton.js 文件用来导出骨架组件 123456789import Vue from 'vue'import Skeleton from './components/Skeleton.vue'export default new Vue(&#123; components: &#123; Skeleton, &#125;, template: `&lt;Skeleton&gt;&lt;/Skeleton&gt;`&#125;) 单页骨架屏在根目录下新建 vue.config.js 配置骨架屏插件： 12345678910111213141516const SkeletonWebpackPlugin = require('vue-skeleton-webpack-plugin')const path = require('path')module.exports = &#123; configureWebpack: &#123; plugins: [ new SkeletonWebpackPlugin(&#123; webpackConfig: &#123; entry: &#123; app: path.resolve(__dirname, 'src/skeleton.js') &#125; &#125; &#125;) ] &#125;&#125; 搞定OK~ 多页骨架屏假如现在我们希望首页加载时出现骨架屏（上面单页的例子），还要在切换到 about 页面后也有个骨架屏。就需要再新建一个 Skeleton 组件了。 在 src/components/ 下新建 SkeletonAbout.vue 组件： 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class="skeleton-wrapper"&gt; &lt;header class="skeleton-header"&gt;&lt;/header&gt; &lt;section class="skeleton-block"&gt; &lt;img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTA4MCAyNjEiPjxkZWZzPjxwYXRoIGlkPSJiIiBkPSJNMCAwaDEwODB2MjYwSDB6Ii8+PGZpbHRlciBpZD0iYSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgeD0iLTUwJSIgeT0iLTUwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94Ij48ZmVPZmZzZXQgZHk9Ii0xIiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0T3V0ZXIxIi8+PGZlQ29sb3JNYXRyaXggaW49InNoYWRvd09mZnNldE91dGVyMSIgdmFsdWVzPSIwIDAgMCAwIDAuOTMzMzMzMzMzIDAgMCAwIDAgMC45MzMzMzMzMzMgMCAwIDAgMCAwLjkzMzMzMzMzMyAwIDAgMCAxIDAiLz48L2ZpbHRlcj48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDEpIj48dXNlIGZpbGw9IiMwMDAiIGZpbHRlcj0idXJsKCNhKSIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9IiNGRkYiIHhsaW5rOmhyZWY9IiNiIi8+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTIzMCA0NGg1MzN2NDZIMjMweiIvPjxyZWN0IHdpZHRoPSIxNzIiIGhlaWdodD0iMTcyIiB4PSIzMCIgeT0iNDQiIGZpbGw9IiNGNkY2RjYiIHJ4PSI0Ii8+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTIzMCAxMThoMzY5djMwSDIzMHpNMjMwIDE4MmgzMjN2MzBIMjMwek04MTIgMTE1aDIzOHYzOUg4MTJ6TTgwOCAxODRoMjQydjMwSDgwOHpNOTE3IDQ4aDEzM3YzN0g5MTd6Ii8+PC9nPjwvc3ZnPg=="&gt; &lt;img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTA4MCAyNjEiPjxkZWZzPjxwYXRoIGlkPSJiIiBkPSJNMCAwaDEwODB2MjYwSDB6Ii8+PGZpbHRlciBpZD0iYSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgeD0iLTUwJSIgeT0iLTUwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94Ij48ZmVPZmZzZXQgZHk9Ii0xIiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0T3V0ZXIxIi8+PGZlQ29sb3JNYXRyaXggaW49InNoYWRvd09mZnNldE91dGVyMSIgdmFsdWVzPSIwIDAgMCAwIDAuOTMzMzMzMzMzIDAgMCAwIDAgMC45MzMzMzMzMzMgMCAwIDAgMCAwLjkzMzMzMzMzMyAwIDAgMCAxIDAiLz48L2ZpbHRlcj48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDEpIj48dXNlIGZpbGw9IiMwMDAiIGZpbHRlcj0idXJsKCNhKSIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9IiNGRkYiIHhsaW5rOmhyZWY9IiNiIi8+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTIzMCA0NGg1MzN2NDZIMjMweiIvPjxyZWN0IHdpZHRoPSIxNzIiIGhlaWdodD0iMTcyIiB4PSIzMCIgeT0iNDQiIGZpbGw9IiNGNkY2RjYiIHJ4PSI0Ii8+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTIzMCAxMThoMzY5djMwSDIzMHpNMjMwIDE4MmgzMjN2MzBIMjMwek04MTIgMTE1aDIzOHYzOUg4MTJ6TTgwOCAxODRoMjQydjMwSDgwOHpNOTE3IDQ4aDEzM3YzN0g5MTd6Ii8+PC9nPjwvc3ZnPg=="&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt;&lt;style lang="css" scoped&gt;.skeleton-header &#123; height: 40px; background: #1976d2; padding:0; margin: 0; width: 100%; &#125; .skeleton-block &#123; display: flex; flex-direction: column; padding-top: 8px; &#125;&lt;/style&gt; 然后回到 src/skeleton.js 中进行改造： 12345678910111213141516import Vue from 'vue'import Skeleton from './components/Skeleton.vue'import SkeletonAbout from './components/SkeletonAbout.vue'export default new Vue(&#123; components: &#123; Skeleton, SkeletonAbout &#125;, // 默认都隐藏，通过在 vue.config.js 中的插件配置中根据id进行判断 template: `&lt;div&gt; &lt;Skeleton style="display: none;" id="skeleton-home"&gt;&lt;/Skeleton&gt; &lt;SkeletonAbout style="display: none;" id = "skeleton-about"&gt;&lt;/SkeletonAbout&gt; &lt;/div&gt; `&#125;) 修改 vue.config.js 中骨架屏配置： 12345678910111213141516171819202122232425262728const SkeletonWebpackPlugin = require('vue-skeleton-webpack-plugin')const path = require('path')module.exports = &#123; configureWebpack: &#123; // 给webpack新增配置 plugins: [ new SkeletonWebpackPlugin(&#123; webpackConfig: &#123; entry: &#123; app: path.resolve(__dirname, 'src/skeleton.js') &#125; &#125;, router: &#123; mode: 'history', routes: [&#123; path: '/', skeletonId: 'skeleton-home' &#125;, &#123; path: '/about', skeletonId: 'skeleton-about' &#125;, ] &#125;, &#125;) ] &#125;&#125; 现在刷新首页，就会先显示首页骨架屏，切换到about页面刷新，会首先显示about页面的骨架屏。 骨架屏插件原理骨架屏插件的原理也非常简单，我们只要在webpack的 html-webpack-plugin 插件处理html之前对app根节点下的内容进行替换就OK了，下面是一个简化版插件写法： vue.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const SkeletonWebpackPlugin = require('vue-skeleton-webpack-plugin')const path = require('path')// 骨架屏插件原理class MyPlugin &#123; apply(compiler) &#123; // compiler 表示当前整个webpack对象 compiler.plugin('compilation', (compilation) =&gt; &#123; // compilation 表示当前这次webpack打包的对象（也就是说多次打包会产生多个） compilation.plugin( // 当前webpack插件在html处理之前，把html替换 'html-webpack-plugin-before-html-processing', (data) =&gt; &#123; data.html = data.html.replace(`&lt;div id="app"&gt;&lt;/div&gt;`, ` &lt;div id="app"&gt; &lt;div id="home" style="display:none"&gt;首页骨架屏&lt;/div&gt; &lt;div id="about" style="display:none"&gt;about页骨架屏&lt;/div&gt; &lt;/div&gt; &lt;script&gt; if(window.hash == '#/about' || location.pathname=='/about')&#123; document.getElementById('about').style.display="block" &#125;else&#123; document.getElementById('home').style.display="block" &#125; &lt;/script&gt; `); return data; &#125; ) &#125;); &#125;&#125;module.exports = &#123; configureWebpack: &#123; // 给webpack新增配置 plugins: [ // 使用自己的插件 new MyPlugin() // new SkeletonWebpackPlugin(&#123; // webpackConfig: &#123; // entry: &#123; // app: path.resolve(__dirname, 'src/skeleton.js') // &#125; // &#125;, // router: &#123; // mode: 'history', // routes: [&#123; // path: '/', // skeletonId: 'skeleton-home' // &#125;, // &#123; // path: '/about', // skeletonId: 'skeleton-about' // &#125;, // ] // &#125;, // &#125;) ] &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[web性能优化-实践(转载)]]></title>
    <url>%2Fposts%2F47143%2F</url>
    <content type="text"><![CDATA[概括涉及到的分类 网络层面 构建层面 浏览器渲染层面 服务端层面 涉及到的功能点 资源的合并与压缩 图片编解码原理和类型选择 浏览器渲染机制 懒加载预加载 浏览器存储 缓存机制 PWA Vue-SSR 资源合并与压缩http请求的过程及潜在的性能优化点 理解减少http请求数量和减少请求资源大小两个优化要点 掌握压缩与合并的原理 掌握通过在线网站和fis3两种实现压缩与合并的方法 浏览器的一个请求从发送到返回都经历了什么动态的加载静态的资源 dns是否可以通过缓存减少dns查询时间 网络请求的过程走最近的网络环境 相同的静态资源是否可以缓存 能否减少http请求大小 能否减少http请求数量 服务端渲染 资源的合并与压缩设计到的性能点 减少http请求的数量 减少请求的大小 html压缩 HTML代码压缩就是压缩这些在文本文件中有意义，但是在HTML中不显示的字符，包括空格,制表符,换行符等，还有一些其他意义的字符，如HTML注释也可以被压缩 意义 大型网站意义比较大 如何进行html的压缩 使用在线网站进行压缩(走构建工具多，公司级在线网站手动压缩小) node.js提供了html-minifier工具 后端模板引擎渲染压缩 css及js压缩css的压缩 无效代码删除 注释、无效字符 css语义合并 css压缩的方式 使用在线网站进行压缩 使用html-minifier对html中的css进行压缩 使用clean-css对css进行压缩 js的压缩与混乱 无效字符的删除 空格、注释、回车等 剔除注释 代码语意的缩减和优化 变量名缩短(a,b)等 代码保护 前端代码是透明的，客户端代码用户是可以直接看到的，可以轻易被窥探到逻辑和漏洞 js压缩的方式 使用在线网站进行压缩 使用html-minifier对html中的js进行压缩 使用uglifyjs2对js进行压缩 不合并文件可能存在的问题 文件与文件有插入之间的上行请求，又增加了N-1个网络延迟 受丢包问题影响更严重 经过代理服务器时可能会被断开 文件合并缺点 首屏渲染问题 文件合并之后的js变大，如果首页的渲染依赖这个js的话，整个页面的渲染要等js请求完才能执行 如果首屏只依赖a.js，只要等a.js完成后就可执行 没有通过服务器端渲染，现在框架都需要等合并完的文件请求完才能执行，基本都需要等文件合并后的js 缓存失效问题 标记 js md5戳 合并之后的js,任何一个改动都会导致大面积的缓存失效 文件合并对应缺点的处理 公共库合并 不同页面js单独打包 见机行事，随机应变 文件合并对应方法 使用在线网站进行合并 构建阶段，使用nodejs进行文件合并 图片相关优化一张JPG的解析过程 jpg有损压缩：虽然损失一些信息，但是肉眼可见影响并不大 png8/png24/png32之间的区别 png8 —-256色 + 支持透明 png24 —-2^24 + 不支持透明 png32 —2^24 +支持透明 文件大小 + 色彩丰富程度 png32是在png24上支持了透明，针对不同的业务场景选择不同的图片格式很重要 不同的格式图片常用的业务场景不同格式图片的特点 jpg有损压缩，压缩率高，不支持透明 png支持透明，浏览器兼容性好 webp压缩程度更好，在ios webview中有兼容性问题 svg矢量图，代码内嵌，相对较小，图片样式相对简单的场景(尽量使用，绘制能力有限，图片简单用的比较多) 不同格式图片的使用场景 jpg：大部分不需要透明图片的业务场景 png：大部分需要透明图片的业务场景 webp：android全部(解码速度和压缩率高于jpg和png，但是ios safari还没支持) svg：图片样式相对简单的业务场景 图片压缩的几种情况 针对真实图片情况，舍弃一些相对无关紧要的色彩信息 CSS雪碧图：把你的网站用到的一些图片整合到一张单独的图片中 优点：减少HTTP请求的数量(通过backgroundPosition定位所需图片) 缺点：整合图片比较大时，加载比较慢(如果这张图片没有加载成功，整个页面会失去图片信息)facebook官网任然在用，主要pc用的比较多，相对性能比较强 Image-inline：将图片的内容嵌到html中(减少网站的HTTP请求) base64信息，减少网站的HTTP请求,如果图片比较小比较多，时间损耗主要在请求的骨干网络 使用矢量图 使用SVG进行矢量图的绘制 使用icon-font解决icon问题 在android下使用webp webp的优势主要体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量； 同时具备了无损和有损的压缩模式、Alpha透明以及动画的特性，在JPEG和PNG上的转化效果都非常优秀、稳定和统一 css和js的装载与执行HTML页面加载渲染的过程一个网站在浏览器端是如何进行渲染的 HTML渲染过程中的一些特点 顺序执行，并发加载 词法分析：从上到下依次解析 通过HTML生成Token对象（当前节点的所有子节点生成后，才会通过next token获取到当前节点的兄弟节点），最终生成Dom Tree 并发加载：资源请求是并发请求的 并发上限 浏览器中可以支持并发请求，不同浏览器所支持的并发数量不同（以域名划分），以Chrome为例，并发上限为6个 优化点： 把CDN资源分布在多个域名下 是否阻塞 css阻塞 css在head中通过link引入会阻塞页面的渲染 如果我们把css代码放在head中去引入的话，那么我们整个页面的渲染实际上就会等待head中css加载并生成css树，最终和DOM整合生成RanderTree之后才会进行渲染 为了浏览器的渲染，能让页面显示的时候视觉上更好。 避免某些情况，如：假设你放在页面最底部，用户打开页面时，有可能出现，页面先是显示一大堆文字或图片，自上而下，丝毫没有排版和样式可言。最后，页面又恢复所要的效果 css不阻塞js的加载，但阻塞js的执行 css不阻塞外部脚步的加载(webkit preloader 预资源加载器) js阻塞 直接通过&lt;script src&gt;引入会阻塞后面节点的渲染 html parse认为js会动态修改文档结构(document.write等方式)，没有进行后面文档的变化 async、defer(async放弃了依赖关系) defer属性（&lt;script defer&gt;&lt;/script&gt;） (这是延迟执行引入的js脚本（即脚本加载是不会导致解析停止，等到document全部解析完毕后，defer-script也加载完毕后，在执行所有的defer-script加载的js代码，再触发Domcontentloaded） async属性（&lt;script async&gt;&lt;/script&gt;） 这是异步执行引入的js脚本文件 与defer的区别是async会在加载完成后就执行，但是不会影响阻塞到解析和渲染。但是还是会阻塞load事件，所以async-script会可能在DOMcontentloaded触发前或后执行，但是一定会在load事件前触发。 懒加载与预加载懒加载 图片进入可视区域之后请求图片资源 对于电商等图片很多，页面很长的业务场景适用 减少无效资源的加载 并发加载的资源过多会会阻塞js的加载，影响网站的正常使用 img src被设置之后，webkit解析到之后才去请求这个资源。所以我们希望图片到达可视区域之后，img src才会被设置进来，没有到达可视区域前并不现实真正的src，而是类似一个1px的占位符。 场景：电商图片 预加载 图片等静态资源在使用之前的提前请求 资源使用到时能从缓存中加载，提升用户体验 页面展示的依赖关系维护 场景：抽奖 懒加载原生js和zepto.lazyload 原理 先将img标签中的src链接设为同一张图片（空白图片），将其真正的图片地址存储再img标签的自定义属性中（比如data-src）。当js监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到src属性中，达到懒加载的效果。 注意问题： 关注首屏处理,因为还没滑动，需要手动调用一次方法 占位，图片大小首先需要预设高度，如果没有设置的话，会全部显示出来 1234567891011121314151617181920212223242526var viewheight = document.documentElement.clientHeight //可视区域高度function lazyload()&#123; var eles = document.querySelectorAll('img[data-original][lazyload]') Array.prototype.forEach.call(eles,function(item,index)&#123; var rect; if(item.dataset.original === '') return; rect = item.getBoundingClientRect(); //返回元素的大小及其相对于视口的 if(rect.bottom &gt;= 0 &amp;&amp; rect.top &lt; viewheight)&#123; !function()&#123; var img = new Image(); img.src = item.dataset.url; img.onload = function()&#123; item.src = img.src &#125; item.removeAttribute('data-original'); item.removeAttribute('lazyload'); &#125;() &#125; &#125;)&#125;lazyload()document.addEventListener('scroll',lazyload) 预加载原生js和preloadJS实现预加载实现的几种方式 第一种方式：直接请求下来 1234&lt;img src="https://user-gold-cdn.xitu.io/2019/2/21/1690d1b216cbfa18" style="display: none"/&gt;&lt;img src="https://user-gold-cdn.xitu.io/2019/2/21/1690d1b21b70c8d2" style="display: none"/&gt;&lt;img src="https://user-gold-cdn.xitu.io/2019/2/21/1690d1b216e17e26" style="display: none"/&gt;&lt;img src="https://user-gold-cdn.xitu.io/2019/2/21/1690d1b217b3ae59" style="display: none"/&gt; 第二种方式：image对象 12var image = new Image();image.src = "www.pic26.com/dafdafd/safdas.jpg"； 第三种方式：XMLHttpRequest 缺点：存在跨域问题 优点：好控制 123456789101112131415161718192021222324var xmlhttprequest = new XMLHttpRequest();xmlhttprequest.onreadystatechange = callback;xmlhttprequest.onprogress = progressCallback;xmlhttprequest.open("GET","http:www.xxx.com",true);xmlhttprequest.send();function callback()&#123; if(xmlhttprequest.readyState == 4 &amp;&amp; xmlhttprequest.status == 200)&#123; var responseText = xmlhttprequest.responseText; &#125;else&#123; console.log("Request was unsuccessful:" + xmlhttprequest.status); &#125;&#125;function progressCallback()&#123; e = e || event; if(e.lengthComputable)&#123; console.log("Received"+e.loaded+"of"+e.total+"bytes") &#125;&#125; PreloadJS模块 本质：权衡浏览器加载能力，让它尽可能饱和利用起来 重绘与回流css性能让javascript变慢要把css相关的外部文件引入放进head中，加载css时，整个页面的渲染是阻塞的，同样的执行javascript代码的时候也是阻塞的，例如javascript死循环。 12一个线程 =&gt; javascript解析一个线程 =&gt; UI渲染 这两个线程是互斥的，当UI渲染的时候，javascript的代码被终止。当javascript代码执行，UI线程被冻结。所以css的性能让javascript变慢。 频繁触发重绘与回流，会导致UI频繁渲染，最终导致js变慢 什么是重绘和回流回流 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就成为回流(reflow) 当页面布局和几何属性改变时，就需要回流 重绘 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不影响布局，比如background-color。就称重绘 关系用到chrome 分析 performance 回流必将引起重绘，但是重绘不一定会引起回流 避免重绘、回流的两种方法触发页面重布局的一些css属性 盒子模型相关属性会触发重布局 width / height / min-height padding / margin display border-width / border 定位属性及浮动也会触发重布局 top / bottom / left / right position float clear 改变节点内部文字结构也会触发重布局 text-align / vertical-align overflow / overflow-y font-size / font-family / font-weight line-height white-space 优化点：使用不触发回流的方案替代触发回流的方案 只触发重绘不触发回流 color border-style、border-radius visibility text-decoration background、background-image、background-position、background-repeat、background-size outline、outline-color、outline-style、outline-width box-shadow 新建DOM的过程 获取DOM后分割为多个图层 对每个图层的节点计算样式结果(Recalculate style 样式重计算) 为每个节点生成图形和位置(Layout 回流和重布局) 将每个节点绘制填充到图层位图中(Paint Setup和Paint 重绘) 图层作为纹理上传至gpu 符合多个图层到页面上生成最终屏幕图像(Composite Layers 图层重组) 浏览器绘制DOM的过程是这样子的： 获取 DOM 并将其分割为多个层（layer），将每个层独立地绘制进位图（bitmap）中 将层作为纹理（texture）上传至 GPU，复合（composite）多个层来生成最终的屏幕图像 left/top/margin之类的属性会影响到元素在文档中的布局，当对布局（layout）进行动画时，该元素的布局改变可能会影响到其他元素在文档中的位置，就导致了所有被影响到的元素都要进行重新布局，浏览器需要为整个层进行重绘并重新上传到 GPU，造成了极大的性能开销。 transform 属于合成属性（composite property），对合成属性进行 transition/animation 动画将会创建一个合成层（composite layer），这使得被动画元素在一个独立的层中进行动画。 通常情况下，浏览器会将一个层的内容先绘制进一个位图中，然后再作为纹理（texture）上传到 GPU，只要该层的内容不发生改变，就没必要进行重绘（repaint），浏览器会通过重新复合（recomposite）来形成一个新的帧。 chrome创建图层的条件 将频繁重绘回流的DOM元素单独作为一个独立图层，那么这个DOM元素的重绘和回流的影响只会在这个图层中 3D或透视变换 CSS属性使用加速视频解码的 &lt;video&gt; 元素 拥有 3D (WebGL) 上下文或加速的 2D 上下文的 &lt;canvas&gt; 元素 复合插件(如 Flash) 进行 opacity/transform 动画的元素拥有加速 CSS filters 的元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里) 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染) 总结：对布局属性进行动画，浏览器需要为每一帧进行重绘并上传到 GPU 中对合成属性进行动画，浏览器会为元素创建一个独立的复合层，当元素内容没有发生改变，该层就不会被重绘，浏览器会通过重新复合来创建动画帧 gif图 总结 尽量避免使用触发回流、重绘的CSS属性 将重绘、回流的影响范围限制在单独的图层(layers)之内 图层合成过程中消耗很大页面性能，这时候需要平衡考虑重绘回流的性能消耗 实战优化点总结 用translate替代top属性 top会触发layout，但translate不会 用opacity代替visibility opacity不会触发重绘也不会触发回流，只是改变图层alpha值，但是必须要将这个图片独立出一个图层 visibility会触发重绘 不要一条一条的修改DOM的样式，预先定义好class，然后修改DOM的className 把DOM离线后修改，比如：先把DOM给display:none（有一次reflow），然后你修改100次，然后再把它显示出来 不要把DOM节点的属性值放在一个循环里当成循环的变量 offsetHeight、offsetWidth每次都要刷新缓冲区，缓冲机制被破坏 先用变量存储下来 不要使用table布局，可能很小的一个小改动会造成整个table的重新布局 div只会影响后续样式的布局 动画实现的速度的选择 选择合适的动画速度 根据performance量化性能优化 对于动画新建图层 启用gpu硬件加速(并行运算)，gpu加速意味着数据需要从cpu走总线到gpu传输，需要考虑传输损耗. transform:translateZ(0) transform:translate3D(0) 浏览器存储cookies多种浏览器存储方式并存，如何选择？ 因为http请求无状态，所以需要cookie去维持客户端状态 cookie的生成方式： http–&gt;response header–&gt;set-cookie js中可以通过document.cookie可以读写cookie cookie的使用用处： 用于浏览器端和服务器端的交互(用户状态) 客户端自身数据的存储 expire：过期时间 cookie的限制： 作为浏览器存储，大小4kb左右 需要设置过期时间 expire 重要属性：httponly 不支持js读写(防止收到模拟请求攻击) 不太作为存储方案而是用于维护客户关系 优化点：cookie中在相关域名下面 cdn的流量损耗 解决方案：cdn的域名和主站域名要分开 WebStoragelocalstorage HTML5设计出来专门用于浏览器存储的 大小为5M左右 仅在客户端使用，不和服务端进行通信 接口封装较好 浏览器本地缓存方案 sessionstorage 会话级别的浏览器存储 大小为5M左右 仅在客户端使用，不和服务器端进行通信 接口封装较好 对于表单信息的维护 indexedDB IndexedDB是一种低级API，用于客户端存储大量结构化数据。该API使用索引来实现对该数据的高性能搜索。虽然Web Storage对于存储叫少量的数据很管用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。 为应用创建离线版本 cdn域名不要带cookie localstorage存库、图片 cookie种在主站下，二级域名也会携带这个域名，造成流量的浪费 Service Worker 产生的意义PWA 与 Service Worker PWA(Progressive Web Apps)是一种Web App新模型，并不是具体指某一种前言的技术或者某一个单一的知识点，我们从英文缩写来看就能看出来，这是一个渐进式的Web App，是通过一系列新的Web特性，配合优秀的UI交互设计，逐步增强Web App的用户体验 chrome 插件 lighthouse 检测是不是一个渐进式web app 当前手机在弱网环境下能不能加载出来 离线环境下能不能加载出来 特点 可靠：没有网络的环境中也能提供基本的页面访问，而不会出现“未连接到互联网”的页面 快速：针对网页渲染及网络数据访问有较好的优化 融入(Engaging)：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性 service worker service worker是一个脚本，浏览器独立于当前页面，将其在后台运行，为实现一些不依赖页面的或者用户交互的特性打开了一扇大门。在未来这些特性将包括消息推送，背景后台同步，geofencing(地理围栏定位)，但他将推出的第一个首要的特性，就是拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。 案例分析Service Worker学习与实践 了解servie worker 12chrome://serviceworker-internals/chrome://inspect/#service-worker/ service worker网络拦截能力，存储Cache Storage，实现离线应用 indexedDB 12345callback &amp;&amp; callback()写法相当于if(callback)&#123; callback();&#125; cookie、session、localStorage、sessionStorage基本操作indexedDB基本操作object store:对象存储本身就是结构化存储 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function openDB(name, callback) &#123; //建立打开indexdb indexedDB.open var request = window.indexedDB.open(name) request.onerror = function(e) &#123; console.log('on indexedDB error') &#125; request.onsuccess = function(e) &#123; myDB.db = e.target.result callback &amp;&amp; callback() &#125; //from no database to first version,first version to second version... request.onupgradeneeded = function() &#123; console.log('created') var store = request.result.createObjectStore('books', &#123; keyPath: 'isbn' &#125;) console.log(store) var titleIndex = store.createIndex('by_title', 'title', &#123; unique: true &#125;) var authorIndex = store.createIndex('by_author', 'author') store.put(&#123; title: 'quarry memories', author: 'fred', isbn: 123456 &#125;) store.put(&#123; title: 'dafd memories', author: 'frdfaded', isbn: 12345 &#125;) store.put(&#123; title: 'dafd medafdadmories', author: 'frdfdsafdafded', isbn: 12345434 &#125;) &#125; &#125; var myDB = &#123; name: 'tesDB', version: '2.0.1', db: null &#125; function addData(db, storeName) &#123; &#125; openDB(myDB.name, function() &#123; // myDB.db = e.target.result // window.indexedDB.deleteDatabase(myDB.name) &#125;); //删除indexedDB indexDB事务transcation 与 object store建立关联关系来操作object store 建立之初可以配置 12345678910var transcation = db.transcation('books', 'readwrite')var store = transcation.objectStore('books')var data =store.get(34314)store.delete(2334)store.add(&#123; title: 'dafd medafdadmories', author: 'frdfdsafdafded', isbn: 12345434&#125;) Service Worker离线应用serviceworker需要https协议 如何实现ServiceWorker与主页面之间的通信lavas 缓存 期望大规模数据能自动化缓存，而不是手动进行缓存，需要浏览器端和服务器端协商一种缓存机制 Cache-Control所控制的缓存策略 last-modified 和 etag 以及整个服务端浏览器端的缓存流程 基于node实践以上缓存方式 httpheader可缓存性 public:表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。 private:表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。 no-cache:强制所有缓存了该响应的缓存用户，在使用已存储的缓存数据前，发送带验证器的请求到原始服务器 only-if-cached:表明如果缓存存在，只使用缓存，无论原始服务器数据是否有更新 到期 max-age=&lt;seconds&gt;:设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。 s-maxage=&lt;seconds&gt;:覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略。cdn缓存 max-stale[=&lt;seconds&gt;] 表明客户端愿意接收一个已经过期的资源。 可选的设置一个时间(单位秒)，表示响应不能超过的过时时间。 min-fresh=&lt;seconds&gt; 表示客户端希望在指定的时间内获取最新的响应。 重新验证 和 重新加载 重新验证 must-revalidate：缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。 proxy-revalidate：与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。 immutable ：表示响应正文不会随时间而改变。资源（如果未过期）在服务器上不发生改变，因此客户端不应发送重新验证请求头（例如If-None-Match或If-Modified-Since）来检查更新，即使用户显式地刷新页面。在Firefox中，immutable只能被用在 https:// transactions. 重新加载 no-store:缓存不应存储有关客户端请求或服务器响应的任何内容。 no-transform:不得对资源进行转换或转变。Content-Encoding,Content-Range, Content-Type等HTTP头不能由代理修改。例如，非透明代理可以对图像格式进行转换，以便节省缓存空间或者减少缓慢链路上的流量。 no-transform指令不允许这样做。 Expires 缓存过期时间，用来指定资源到期的时间，是服务器端的时间点 告诉浏览器在过期时间前浏览器可以直接从浏览器缓存中存取数据，而无需再次请求 expires是http1.0的时候的 http1.1时候，我们希望cache的管理统一进行，max-age优先级高于expires，当有max-age在的时候expires可能就会被忽略。 如果没有设置cache-control时候会使用expires Last-modified 和 If-Modified-since 基于客户端和服务器端协商的缓存机制 last-modified –&gt; response headerif-modified-since –&gt; request header 需要与cache-control共同使用 last-modified有什么缺点？ 某些服务端不能获取精确的修改时间 文件修改时间改了，但文件的内容却没有变 Etag 和 If-none-match 文件内容的hash值 etag –&gt;reponse headerif-none-match –&gt;request header 需要与cache-control共同使用 好处： 比if-modified-since更加准确 优先级比etage更高 流程图 ) 服务端性能优化服务端用的node.js因为和前端用的同一种语言，可以利用服务端运算能力来进行相关的运算而减少前端的运算 vue渲染遇到的问题 vue-ssr和原理和引用 vue渲染面临的问题123先加载vue.js=&gt; 执行vue.js代码=&gt; 生成html 以前没有前端框架时， 用jsp/php在服务端进行数据的填充，发送给客户端就是已经填充好数据的html 使用jQuery异步加载数据 使用React和Vue前端框架 代价：需要框架全部加载完，才能把页面渲染出来，页面的首屏性能不好 多层次的优化方案 构建层的模板编译。runtime,compile拆开,构建层做模板编译工作。webpack构建时候，统一，直接编译成runtime可以执行的代码 数据无关的prerender的方式 服务端渲染 文章来源 前端面试之路四(web性能优化篇)]]></content>
      <categories>
        <category>前端</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态路由+路由鉴权]]></title>
    <url>%2Fposts%2F48117%2F</url>
    <content type="text"><![CDATA[动态路由 + 路由鉴权路由鉴权介绍一般Vue的权限控制有两种方案： 路由元信息(meta) 动态加载菜单和路由(addRoutes) 路由元信息(meta)如果一个网站有不同的角色，比如管理员和普通用户，要求不同的角色能访问的页面是不一样的 这个时候我们就可以把所有的页面都放在路由表里，只要在访问的时候判断一下角色权限。如果有权限就让访问，没有权限的话就拒绝访问，跳转到404页面。 vue-router 在构建路由时提供了元信息 meta 配置接口，我们可以在元信息中添加路由对应的权限，然后在路由守卫中检查相关权限，控制其路由跳转。 可以在每一个路由的 meta 属性里，将能访问该路由的角色添加到 roles 里。用户每次登陆后，将用户的角色返回。然后在访问页面时，把路由的 meta 属性和用户的角色进行对比，如果用户的角色在路由的 roles 里，那就是能访问，如果不在就拒绝访问。 代码示例1： 路由信息： 123456789101112131415161718routes: [ &#123; path: '/login', name: 'login', meta: &#123; roles: ['admin', 'user'] &#125;, component: () =&gt; import('../components/Login.vue') &#125;, &#123; path: 'home', name: 'home', meta: &#123; roles: ['admin'] &#125;, component: () =&gt; import('../views/Home.vue') &#125;,] 页面控制： 1234567891011//假设有两种角色：admin 和 user //从后台获取的用户角色const role = 'user'//当进入一个页面是会触发导航守卫 router.beforeEach 事件router.beforeEach((to,from,next)=&gt;&#123; if(to.meta.roles.includes(role))&#123; next() //放行 &#125;esle&#123; next(&#123;path:"/404"&#125;) //跳到404页面 &#125;&#125;) 代码示例2 当然也可以用下面的一种方法： 12345678910111213141516171819202122232425262728// router.js// 路由表元信息[ &#123; path: '', redirect: '/home' &#125;, &#123; path: '/home', meta: &#123; title: 'Home', icon: 'home' &#125; &#125;, &#123; path: '/userCenter', meta: &#123; title: '个人中心', requireAuth: true // 在需要登录的路由的meta中添加响应的权限标识 &#125; &#125;]// 在守卫中访问元信息function gaurd (to, from, next) &#123; // to.matched.some(record =&gt; record.meta.requireAuth) // 可在此处&#125; 可以在多个路由下面添加这个权限标识，达到控制的目的 只要一切换页面，就需要看有没有这个权限，所以可以在最大的路由下 main.js 中配置 存储信息 一般的，用户登录后会在本地存储用户的认证信息，可以用 token、cookie 等,这里我们用 token。 将用户的token保存到localStorage里，而用户信息则存在内存store中。这样可以在vuex中存储一个标记用户登录状态的属性auth，方便权限控制。 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940// store.js&#123; state: &#123; token: window.localStorage.getItem('token'), auth: false, userInfo: &#123;&#125; &#125;, mutations: &#123; setToken (state, token) &#123; state.token = token window.localStorage.setItem('token', token) &#125;, clearToken (state) &#123; state.token = '' window.localStorage.setItem('token', '') &#125;, setUserInfo (state, userInfo) &#123; state.userInfo = userInfo state.auth = true // 获取到用户信息的同时将auth标记为true，当然也可以直接判断userInfo &#125; &#125;, actions: &#123; async getUserInfo (ctx, token) &#123; return fetchUserInfo(token).then(response =&gt; &#123; if (response.code === 200) &#123; ctx.commit('setUserInfo', response.data) &#125; return response &#125;) &#125;, async login (ctx, account) &#123; return login(account).then(response =&gt; &#123; if (response.code === 200) &#123; ctx.commit('setUserInfo', response.data.userInfo) ctx.commit('setToken', response.data.token) &#125; &#125;) &#125; &#125;&#125; 写好路由表和vuex之后，给所有路由设置一个全局守卫，在进入路由之前进行权限检查，并导航到对应的路由。 123456789101112131415161718192021222324252627282930// router.jsrouter.beforeEach(async (to, from, next) =&gt; &#123; if (to.matched.some(record =&gt; record.meta.requireAuth)) &#123; // 检查是否需要登录权限 if (!store.state.auth) &#123; // 检查是否已登录 if (store.state.token) &#123; // 未登录，但是有token，获取用户信息 try &#123; const data = await store.dispatch('getUserInfo', store.state.token) if (data.code === 200) &#123; next() &#125; else &#123; window.alert('请登录') store.commit('clearToken') next(&#123; name: 'Login' &#125;) &#125; &#125; catch (err) &#123; window.alert('请登录') store.commit('clearToken') next(&#123; name: 'Login' &#125;) &#125; &#125; else &#123; window.alert('请登录') next(&#123; name: 'Login' &#125;) &#125; &#125; else &#123; next() &#125; &#125; else &#123; next() &#125;&#125;) 上述的方法是基于jwt认证方式，本地不持久化用户信息，只保存token，当用户刷新或者重新打开网页时，进入需要登录的页面都会尝试去请求用户信息，该操作在整个访问过程中只进行一次，直到刷新或者重新打开，对于应用后期的开发维护和扩展支持都很好。 动态加载菜单和路由(addRoutes)有时候为了安全，我们需要根据用户权限或者是用户属性去动态的添加菜单和路由表，可以实现对用户的功能进行定制。vue-router提供了addRoutes()方法，可以动态注册路由，需要注意的是，动态添加路由是在路由表中push路由，由于路由是按顺序匹配的，因此需要将诸如404页面这样的路由放在动态添加的最后。 代码示例 1234567891011121314151617181920// store.js// 将需要动态注册的路由提取到vuex中const dynamicRoutes = [ &#123; path: '/manage', name: 'Manage', meta: &#123; requireAuth: true &#125;, component: () =&gt; import('./views/Manage') &#125;, &#123; path: '/userCenter', name: 'UserCenter', meta: &#123; requireAuth: true &#125;, component: () =&gt; import('./views/UserCenter') &#125;] 在vuex中添加userRoutes数组用于存储用户的定制菜单。在setUserInfo中根据后端返回的菜单生成用户的路由表。 12345678910// store.jssetUserInfo (state, userInfo) &#123; state.userInfo = userInfo state.auth = true // 获取到用户信息的同时将auth标记为true，当然也可以直接判断userInfo // 生成用户路由表 state.userRoutes = dynamicRoutes.filter(route =&gt; &#123; return userInfo.menus.some(menu =&gt; menu.name === route.name) &#125;) router.addRoutes(state.userRoutes) // 注册路由&#125; 修改菜单渲染 12345678// App.vue&lt;div id="nav"&gt; &lt;router-link to="/"&gt;主页&lt;/router-link&gt;| &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;template v-for="(menu, index) of $store.state.userInfo.menus"&gt; |&lt;router-link :to="&#123; name: menu.name &#125;" :key="index"&gt;&#123;&#123;menu.title&#125;&#125;&lt;/router-link&gt; &lt;/template&gt;&lt;/div&gt; 前面铺垫了这么多，终于到本篇博客的主题了，下面我们要自己实现一套「动态生成无限菜单+路由」的方案，也就是第二种路由鉴权。 最终实现的菜单列表123456个人中心 Profile.vue商店 Shop.vue购物车 Cart.vue └── 购物车列表 CartList.vue ├── 商品 Product.vue └── 彩票 Lottery.vue 基本思路 后端返回路由权限列表（带权限标识，假定为auth） 前端进行全局的路由拦截，判断自身有没有获取过后端返回的路由列表 如果没有则获取数据并保存到vuex中，动态的生成菜单和路由，然后进行next跳转 如果有则不再获取，直接next跳转 其中第三步是核心点，它还可以细分为下列步骤： 菜单栏往往有多级嵌套，所以得根据后端返回的数据进行转换，最终生成无限级菜单；并在转换过程中找到所有可以有权访问的路由名称清单（根据上文提到的auth标识寻找） 前端分别保存两种路由列表，第一种是不需要权限就能访问的，例如首页；第二种是需要等级权限才能访问的路由列表，例如新增admin管理员 动态生成路由列表（在第二种路由列表中，通过路由名称清单过滤） 后台返回的admin路由权限12345678[ &#123;pid:-1,path:'/cart',name:'购物车',id:1,auth:'cart'&#125;, &#123;pid:1,path:'/cart/cart-list',name:'购物车列表',id:4,auth:'cart-list'&#125;, &#123;pid:4,path:'/cart/cart-list/lottery',auth:'lottery',id:5,name:'彩票'&#125;, &#123;pid:4,path:'/cart/cart-list/product',auth:'product',id:6,name:'商品'&#125;, &#123;pid:-1,path:'/shop',name:'商店',id:2,auth:'shop'&#125;, &#123;pid:-1,path:'/profile',name:'个人中心',id:3,auth:'store'&#125;,]; 项目生成12345678vue create menu-auth? Check the features needed for your project: ◉ Babel ◉ Router ◉ Vuex history mode In dedicated config files Save this as a preset for future projects? (y/N) n 移除不必要的文件及其代码 components/HelloWorld.vue views/About.vue views/Home.vue 中 .home 标签下所有内容，有关 HelloWorld.vue 相关代码 App.vue 中 #app 下除 router-view 所有内容 router.js 下有关 About.vue 相关代码 后端生成根目录下创建 server.js 作为我们的服务端文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465let express = require('express');let app = express();// 在后端配置，让所有人都可以访问api接口 跨域问题app.use('*', function (req, res, next) &#123; res.header('Access-Control-Allow-Origin', '*'); // Access-Control-Allow-Headers ,可根据浏览器的F12查看,把对应的粘贴在这里就行 res.header('Access-Control-Allow-Headers', 'Content-Type'); res.header('Access-Control-Allow-Methods', '*'); res.header('Content-Type', 'application/json;charset=utf-8'); next();&#125;);// 前端请求的路由API路径app.get('/role', (req, res) =&gt; &#123; res.json(&#123; //假如这是后端给我们的JSON数据 menuList: [&#123; pid: -1, path: '/cart', name: '购物车', id: 1, auth: 'cart' &#125;, &#123; pid: 1, path: '/cart/cart-list', name: '购物车列表', id: 4, auth: 'cart-list' &#125;, &#123; pid: 4, path: '/cart/cart-list/lottery', auth: 'lottery', id: 5, name: '彩票' &#125;, &#123; pid: 4, path: '/cart/cart-list/product', auth: 'product', id: 6, name: '商品' &#125;, &#123; pid: -1, path: '/shop', name: '商店', id: 2, auth: 'shop' &#125;, &#123; pid: -1, path: '/profile', name: '个人中心', id: 3, auth: 'profile' &#125;, ], buttonAuth: &#123; edit: true, // 可编辑 &#125; &#125;)&#125;)//监听3000端口app.listen(3000) 终端 node server.js 启动，或者使用 nodemon server.js 热启动。 新建路由所需相关文件components/menu/ 文件下新建： cart-list.vue 12345678910111213&lt;template&gt; &lt;div&gt; cart-list &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; cart.vue 123456789101112131415&lt;template&gt; &lt;div&gt; cart &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'cart' &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; lottery.vue 123456789101112&lt;template&gt; &lt;div&gt; lottery &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; product.vue 123456789101112&lt;template&gt; &lt;div&gt; product &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; profile.vue 123456789101112&lt;template&gt; &lt;div&gt; profile &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; shop.vue 123456789101112&lt;template&gt; &lt;div&gt; shop &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 最后来一个 404 页面，放在 views/ 文件夹下： 123456789101112&lt;template&gt; &lt;div&gt; 404 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 配置路由来到 router.js 文件配置路由表： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import Vue from 'vue'import Router from 'vue-router'import Home from './views/Home.vue'Vue.use(Router)export default new Router(&#123; mode: 'history', base: process.env.BASE_URL, routes: [ &#123; //访问'/'时，重定向到home页面 path: '/', redirect: '/home' &#125;, &#123; path: '/home', name: 'home', component: Home &#125;, &#123; path: '/cart', name: 'cart', //使用懒加载，当使用这个组件的时候再加载资源，当组件资源较大时，不建议使用，可能会出现白屏现象 //而且最好使用绝对路径，@是绝对路径的意思,相当于src下 component: () =&gt; import('@/components/menu/cart.vue'), //配置子路由 children: [&#123; //当配置子路由时，最好不要在前面加'/',比如:'/cart-list' path: 'cart-list', name: 'cart-list', component: () =&gt; import('@/components/menu/cart-list.vue'), //配置子路由 children: [&#123; path: 'lottery', name: 'lottery', component: () =&gt; import('@/components/menu/lottery.vue') &#125;, &#123; path: 'product', name: 'product', component: () =&gt; import('@/components/menu/product.vue') &#125; ] &#125;] &#125;, &#123; path: '/profile', name: 'profile', component: () =&gt; import('@/components/menu/profile.vue') &#125;, &#123; path: '/shop', name: 'shop', component: () =&gt; import('@/components/menu/shop.vue') &#125;, &#123; path: '*', component: () =&gt; import('@/views/404.vue') &#125;, ]&#125;) 配置完成后 npm run serve 跑一下项目，分别进入几个路由路径，看是否能正确打开相应页面。 获取后端admin权限数据为了拿到后端返回的数据，我们需要利用 axios 发起异步请求，并把响应回来的数据存放到 vuex 中去，并且还需要对后端数据做一个转换，将其转换为下面格式： 123456789101112131415// 后端格式[ &#123;id: 1, name: 'a', pid: -1&#125;, &#123;id: 2, name: 'b', pid: -1&#125;, &#123;id: 3, name: 'c', pid: 1&#125;, &#123;id: 4, name: 'd', pid: 1&#125;]↓↓↓[ &#123;id: 1, name: 'a', pid: -1, children: [ &#123;id: 3, name: 'c', pid: 1, children: null&#125;, &#123;id: 4, name: 'd', pid: 1, children: null&#125; ]&#125;, &#123;id: 2, name: 'b', pid: -1, children: null&#125;] 安装 axios1npm install axios 在全局路由守卫中监听是否已获取过路由权限数据路由权限的数据，为了安全我们需要页面切换时就再次获取，所以可以用全局路由守卫帮助我们实现，逻辑如下： 123456789101112// 只要页面切换就执行的钩子router.beforeEach(async (to, from, next) =&gt; &#123; // 判断当前有没有获取过权限，如果获取过了，就不要再获取了 if (!store.state.hasRules) &#123; //获取权限，调用获取权限的接口，去action中获取数据 await store.dispatch('getMenuList') next(); &#125; else &#123; //如果已经获取了权限就可以访问页面了 next() &#125;&#125;) 编写 vuex + 数据转化（递归）根据上面钩子函数中的逻辑，在 vuex 中添加相应内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243import Vue from 'vue'import Vuex from 'vuex'import axios from 'axios'Vue.use(Vuex)// 后端数据转化let formatMenuList = (menuList) =&gt; &#123; function r(pid) &#123; //filter过滤数组，返回一个满足要求的数组 return menuList.filter(menu =&gt; &#123; //格式化菜单变成我们需要的结果 if (menu.pid === pid) &#123; let children = r(menu.id) menu.children = children.length ? children : null return true &#125; &#125;) &#125; return r(-1)&#125;export default new Vuex.Store(&#123; state: &#123; // 存放菜单权限数据 menuList: [], // 原本只要判断menuList.length是否不为空就能判定是否已经获取过menuList， // 但如果后台返回空数组咋办？所以此处还需要一个hasRules变量来标识是否已获取 // 做法就是，获取完毕后，把hasRules改为true hasRules: false, &#125;, mutations: &#123; &#125;, actions: &#123; async getMenuList() &#123; let &#123; data &#125; =await axios.get('http://localhost:3000/role') let menuList = data.menuList menuList = formatMenuList(menuList) console.log(menuList) &#125; &#125;&#125;) 但目前有个小问题，即我们在 router.js 中配置了所有路由，然后根据后端返回的权限来动态展示相应菜单，从而实现跳转。但如果用户猜出了不允许他访问的路由，直接修改url跳转怎么办？那他不是也能访问了吗？ 所以我们需要让后端在返回的数据中，给每个路由对象添加一个 最开始提到的 auth 标识： 1&#123; pid: -1, path: '/cart', name: '购物车', id: 1, auth: 'cart' &#125; 如果有 auth 标识，代表当前用户能够访问，如果没有，则表示当前用户不能访问，这样我们前端就能据此动态的删除掉不能访问的路由。 回到 src/store.js ，我们需要把后端这个 auth 属性都保存起来。首先在 state 中加上 authList 属性，用来存储哪些路由能有权限访问： 123state: &#123; authList: []&#125; 然后在 formatMenuList 方法中，提取权限： 12345678910111213141516let formatMenuList = (menuList) =&gt; &#123; let arr = [] // [cart, cart-list, profile, ...] function r(pid) &#123; //filter过滤数组，返回一个满足要求的数组 return menuList.filter(menu =&gt; &#123; //格式化菜单变成我们需要的结果 if (menu.pid === pid) &#123; arr.push(menu.auth) // 把后端返回的所有路径权限都放到数组中 let children = r(menu.id) menu.children = children.length ? children : null return true &#125; &#125;) &#125; return &#123; menuL: r(-1), authL: arr &#125;&#125; 这样改造后，formatMenuList 方法就返回一个对象了，该对象中包含路由菜单和路由权限两个数组。 相应的，我们还得改造使用了 formatMenuList 方法的action ——&gt; getMenuList ： 1234567async getMenuList(&#123; commit &#125;) &#123; let &#123; data &#125; =await axios.get('http://localhost:3000/role') let &#123; menuL, authL &#125; = formatMenuList(data.menuList) console.log(menuL, authL) commit('set_menuList', menuL) commit('set_authList', authL)&#125; 对应的，编写两个 mutation ： 1234567set_menuList(state, m) &#123; state.menuList = m&#125;,set_authList(state, a) &#123; state.authList = a state.hasRules = true&#125; 保存后 console.log 一下，menuList 和 authList 分别如下： 渲染无限菜单配置 element-ui安装： 1npm install element-ui main.js 中进行配置： 123import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'Vue.use(ElementUI) 在 Home.vue 页面中引入静态菜单123456789101112131415161718192021222324&lt;template&gt; &lt;div class="home"&gt; &lt;el-menu default-active="2" class="el-menu-vertical-demo"&gt; &lt;el-submenu index="1"&gt; &lt;template slot="title"&gt;导航一&lt;/template&gt; &lt;el-submenu index="1-1"&gt; &lt;template slot="title"&gt;选项1-1&lt;/template&gt; &lt;el-menu-item index="1-1-1"&gt;选项1-1-1&lt;/el-menu-item&gt; &lt;el-menu-item index="1-1-2"&gt;选项1-1-2&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;el-menu-item index="1-2"&gt;选项1-2&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;el-menu-item index="2"&gt; 导航二 &lt;/el-menu-item&gt; &lt;el-menu-item index="3"&gt; 导航三 &lt;/el-menu-item&gt; &lt;el-menu-item index="4"&gt; 导航四 &lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;/div&gt;&lt;/template&gt; 刷新页面后就能显示静态的Element菜单了。但点击某个菜单选项后浏览器无法跳转，所以我们还得给 &lt;el-menu&gt;&lt;/el-menu&gt; 标签设置个 router 属性为 true ，这样就能根据菜单的 index 属性进行路由跳转了： 123456789101112131415161718192021222324&lt;template&gt; &lt;div class="home"&gt; &lt;el-menu default-active="2" class="el-menu-vertical-demo" :router="true"&gt; &lt;el-submenu index="1"&gt; &lt;template slot="title"&gt;导航一&lt;/template&gt; &lt;el-submenu index="1-1"&gt; &lt;template slot="title"&gt;选项1-1&lt;/template&gt; &lt;el-menu-item index="1-1-1"&gt;选项1-1-1&lt;/el-menu-item&gt; &lt;el-menu-item index="1-1-2"&gt;选项1-1-2&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;el-menu-item index="1-2"&gt;选项1-2&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;el-menu-item index="2"&gt; 导航二 &lt;/el-menu-item&gt; &lt;el-menu-item index="3"&gt; 导航三 &lt;/el-menu-item&gt; &lt;el-menu-item index="4"&gt; 导航四 &lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;/div&gt;&lt;/template&gt; 静态转动态菜单最后利用后端获取的admin权限数据将静态菜单改为动态菜单： src/views/Home.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div class="home"&gt; &lt;el-menu default-active="2" class="el-menu-vertical-demo" :router="true"&gt; &lt;template v-for="m in menuList"&gt; &lt;el-submenu index="1-1" :key="m.auth" v-if="m.children"&gt; &lt;template slot="title"&gt;&#123;&#123;m.name&#125;&#125;&lt;/template&gt; &lt;el-menu-item index="1-1-1"&gt;选项1-1-1&lt;/el-menu-item&gt; &lt;el-menu-item index="1-1-2"&gt;选项1-1-2&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;el-menu-item index="1-2" :key="m.auth" v-else&gt;&#123;&#123;m.name&#125;&#125;&lt;/el-menu-item&gt; &lt;/template&gt; &lt;!-- &lt;el-submenu index="1"&gt; &lt;template slot="title"&gt;导航一&lt;/template&gt; &lt;el-submenu index="1-1"&gt; &lt;template slot="title"&gt;选项1-1&lt;/template&gt; &lt;el-menu-item index="1-1-1"&gt;选项1-1-1&lt;/el-menu-item&gt; &lt;el-menu-item index="1-1-2"&gt;选项1-1-2&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;el-menu-item index="1-2"&gt;选项1-2&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;el-menu-item index="2"&gt; 导航二 &lt;/el-menu-item&gt; &lt;el-menu-item index="3"&gt; 导航三 &lt;/el-menu-item&gt; &lt;el-menu-item index="4"&gt; 导航四 &lt;/el-menu-item&gt; --&gt; &lt;/el-menu&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; mapState &#125; from 'vuex' export default &#123; name: 'home', computed: &#123; ...mapState(['menuList']) &#125;, &#125;&lt;/script&gt; 无限菜单仔细观察上方的菜单格式，会发现下面这段代码会重复出现： 12345678&lt;!-- 带有子菜单的 --&gt;&lt;el-submenu index="1-1" :key="m.auth" v-if="m.children"&gt; &lt;template slot="title"&gt;&#123;&#123;m.name&#125;&#125;&lt;/template&gt; &lt;el-menu-item index="1-1-1"&gt;选项1-1-1&lt;/el-menu-item&gt; &lt;el-menu-item index="1-1-2"&gt;选项1-1-2&lt;/el-menu-item&gt;&lt;/el-submenu&gt;&lt;!-- 不带有子菜单的 --&gt;&lt;el-menu-item index="1-2" :key="m.auth" v-else&gt;&#123;&#123;m.name&#125;&#125;&lt;/el-menu-item&gt; 所以我们把它提取出去单独渲染，这样就能实现无限菜单了： 新建 src/views/ReSubMenu.vue 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;!-- 封装递归组件 --&gt; &lt;el-submenu :index="data.path"&gt; &lt;!-- 子菜单标题 --&gt; &lt;template slot="title"&gt; &lt;router-link :to="data.path"&gt;&#123;&#123;data.name&#125;&#125;&lt;/router-link&gt; &lt;/template&gt; &lt;template v-for="c in data.children"&gt; &lt;!-- 若子菜单还有children，继续递归自己 --&gt; &lt;ReSubMenu :key="c.auth" v-if="data.children" :data="c"&gt; &lt;/ReSubMenu&gt; &lt;!-- 没有则直接显示 --&gt; &lt;el-menu-item :key="c.auth" v-else :index="c.path"&gt; &#123;&#123;c.name&#125;&#125; &lt;/el-menu-item&gt; &lt;/template&gt; &lt;/el-submenu&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: "ReSubMenu", props: &#123; data: &#123; type: Object, default: () =&gt; (&#123;&#125;) &#125; &#125; &#125;&lt;/script&gt; 然后在父组件 Home.vue 中使用： 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;el-menu default-active="2" class="el-menu-vertical-demo" :router="true"&gt; &lt;template v-for="m in menuList"&gt; &lt;!-- 递归组件 --&gt; &lt;!-- 判断条件：有children的就是带有子菜单的，使用递归组件 --&gt; &lt;ReSubMenu :data="m" :key="m.auth" v-if="m.children"&gt;&lt;/ReSubMenu&gt; &lt;!-- 没有children的情况 --&gt; &lt;el-menu-item v-else :key="m.auth" :index="m.path"&gt;&#123;&#123;m.name&#125;&#125;&lt;/el-menu-item&gt; &lt;/template&gt; &lt;/el-menu&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; //导入vuex中的方法，具体参考我的文章 import &#123; mapState &#125; from "vuex"; import ReSubMenu from "./ReSubMenu"; export default &#123; name: "home", computed: &#123; //根据后端传过来的数据来渲染Home ...mapState(["menuList"]) &#125;, components: &#123; ReSubMenu &#125; &#125;;&lt;/script&gt; 根据权限动态添加路由实现了无限菜单后，我们接下来就要根据之前保存的 authList 实现动态路由了。 第一步就是把 router.js 中的路由列表分成两部分，一部分是不需要权限就能访问的，另一部分是需要根据权限列表动态生成的，我们首先来抽离之前在 routes 中的路由列表，拷贝一份后存到两个变量中，其中 authRoutes 需要 export 导出，等会 store.js 中匹配用户权限时需要使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 默认路由列表：不需要权限就能访问的let defaultRoutes = [&#123; path: '/', redirect: '/home' &#125;, &#123; path: '/home', name: 'home', component: Home &#125;, &#123; path: '*', component: () =&gt; import('@/views/404.vue') &#125;]// 需要权限才能访问的路由列表export let authRoutes = [&#123; path: '/cart', name: 'cart', //使用懒加载，当使用这个组件的时候再加载资源，当组件资源较大时，不建议使用，可能会出现白屏现象 //而且最好使用绝对路径，@是绝对路径的意思,相当于src下 component: () =&gt; import('@/components/menu/cart.vue'), //配置子路由 children: [&#123; //当配置子路由时，最好不要在前面加'/',比如:'/cart-list' path: 'cart-list', name: 'cart-list', component: () =&gt; import('@/components/menu/cart-list.vue'), //配置子路由 children: [&#123; path: 'lottery', name: 'lottery', component: () =&gt; import('@/components/menu/lottery.vue') &#125;, &#123; path: 'product', name: 'product', component: () =&gt; import('@/components/menu/product.vue') &#125; ] &#125;] &#125;, &#123; path: '/profile', name: 'profile', component: () =&gt; import('@/components/menu/profile.vue') &#125;, &#123; path: '/shop', name: 'shop', component: () =&gt; import('@/components/menu/shop.vue') &#125;] 然后把原本 routes 列表中的数组删除，改为 defaultRoutes： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import Vue from 'vue'import Router from 'vue-router'import Home from './views/Home.vue'Vue.use(Router)// 默认路由列表：不需要权限就能访问的let defaultRoutes = [&#123; path: '/', redirect: '/home' &#125;, &#123; path: '/home', name: 'home', component: Home &#125;, &#123; path: '*', component: () =&gt; import('@/views/404.vue') &#125;]// 需要权限才能访问的路由列表export let authRoutes = [&#123; path: '/cart', name: 'cart', //使用懒加载，当使用这个组件的时候再加载资源，当组件资源较大时，不建议使用，可能会出现白屏现象 //而且最好使用绝对路径，@是绝对路径的意思,相当于src下 component: () =&gt; import('@/components/menu/cart.vue'), //配置子路由 children: [&#123; //当配置子路由时，最好不要在前面加'/',比如:'/cart-list' path: 'cart-list', name: 'cart-list', component: () =&gt; import('@/components/menu/cart-list.vue'), //配置子路由 children: [&#123; path: 'lottery', name: 'lottery', component: () =&gt; import('@/components/menu/lottery.vue') &#125;, &#123; path: 'product', name: 'product', component: () =&gt; import('@/components/menu/product.vue') &#125; ] &#125;] &#125;, &#123; path: '/profile', name: 'profile', component: () =&gt; import('@/components/menu/profile.vue') &#125;, &#123; path: '/shop', name: 'shop', component: () =&gt; import('@/components/menu/shop.vue') &#125;]// 需要查看当前用户权限来动态添加路由export default new Router(&#123; mode: 'history', base: process.env.BASE_URL, // 默认所有用户可访问的路由，其他需要权限的动态在 main.js 中动态装载给当前router对象 routes: defaultRoutes&#125;) 再回到 main.js 中的全局钩子函数，我们需要创建一个 action 来动态生成需要权限才能访问的路由： 12345678910111213141516// 只要页面切换就执行的钩子router.beforeEach(async (to, from, next) =&gt; &#123; // 判断当前有没有获取过权限，如果获取过了，就不要再获取了 if (!store.state.hasRules) &#123; //获取权限，调用获取权限的接口，去action中获取数据 await store.dispatch('getMenuList') // 拿到动态生成的路由列表 let r = await store.dispatch('getAuthRoute') // 添加到当前路由中 router.addRoutes(r) next() &#125; else &#123; //如果已经获取了权限就可以访问页面了 next() &#125;&#125;) 最后在 store.js 中实现 getAuthRoute 这个 action： 1234567891011121314151617181920212223242526272829303132333435...// 首先导入router中完整的权限路由列表import &#123; authRoutes &#125; from './router'Vue.use(Vuex)...// 然后在router的所有权限列表中，匹配当前用户可以访问的权限列表// 生成动态路由let getNeedRoutes = (auth) =&gt; &#123; //['cart','cart-list'....] function r(authRoutes) &#123; return authRoutes.filter(route =&gt; &#123; if (auth.includes(route.name)) &#123; if (route.children) &#123; //如果有儿子 //找到儿子继续看子路由的权限 route.children = r(route.children) &#125; return true; //有权限就返回 &#125; &#125;) &#125; return r(authRoutes);&#125;export default new Vuex.Store(&#123; ... actions: &#123; .. async getAuthRoute(&#123; commit, state &#125;) &#123; // 最后把当前需要动态添加的路由返回出去 let r = getNeedRoutes(state.authList) return r &#125; &#125;&#125;) 到此为止就实现了一套 动态路由 + 路由鉴权 功能。 配套代码动态路由+路由鉴权]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件开发——无限菜单]]></title>
    <url>%2Fposts%2F23904%2F</url>
    <content type="text"><![CDATA[@vue/cli-service-global 插件介绍该npm包可以让你在零配置情况下，直接使用 vue serve 和 vue build 命令跑 *.vue 文件，并且可以把它编译打包成一个Vue插件。 全局安装1npm install -g @vue/cli-service-global 基本使用在任意文件夹下新建一个 .vue 文件，例如 App.vue ： 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; msg: 'Hello world' &#125; &#125;, &#125;&lt;/script&gt;&lt;style lang="scss" scoped&gt;&lt;/style&gt; 然后命令行中输入： 12cd 该.vue文件路径vue serve App.vue 最后打开浏览器输入 http://localhost:8080/ 就能看到刚建的 App.vue 组件了。 无限菜单组件开发文件结构 Menu 一级菜单 MenuItem 成员 SubMenu 含子菜单 ↓ 食品生鲜 -&gt; Menu 休闲食品 -&gt; SubMenu 零食大礼包 -&gt; Menu 肉松饼 -&gt; MenuItem 进口食品 -&gt; Menu 咖啡豆 -&gt; MenuItem 文件成员 App.vue 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div id="app"&gt; &lt;Menu&gt; &lt;MenuItem&gt;菜单1&lt;/MenuItem&gt; &lt;MenuItem&gt;菜单2&lt;/MenuItem&gt; &lt;MenuItem&gt;菜单3&lt;/MenuItem&gt; &lt;SubMenu&gt; &lt;!-- &lt;template v-slot:title&gt; 等于 &lt;template #title&gt; --&gt; &lt;template #title&gt; 菜单4 &lt;/template&gt; &lt;MenuItem&gt;菜单4-1&lt;/MenuItem&gt; &lt;MenuItem&gt;菜单4-2&lt;/MenuItem&gt; &lt;/SubMenu&gt; &lt;/Menu&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Menu from './Menu'import MenuItem from './MenuItem'import SubMenu from './SubMenu' export default &#123; data() &#123; return &#123; msg: 'Hello world' &#125; &#125;, components: &#123; Menu, MenuItem, SubMenu &#125;, &#125;&lt;/script&gt; Menu.vue 1234567891011&lt;template&gt; &lt;ul class="menu"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt; MenuItem.vue 123456789&lt;template&gt; &lt;li&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/li&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt; SubMenu.vue 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;div class="title" @click="change"&gt; &lt;slot name="title"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div v-show="flag"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; flag: false &#125; &#125;, methods: &#123; change() &#123; this.flag = !this.flag &#125; &#125; &#125;&lt;/script&gt; 这样一个基本的菜单结构就完成了，二级菜单默认被折叠，点击菜单名后可以展开菜单成员。 增加虚拟数据在 App.vue 下添加一个 menuList 数组来模拟多级菜单： 12345678910111213141516171819menuList: [&#123; title: '菜单1', children: [ &#123; title: '菜单1-1', children: [ &#123; title: '菜单1-1-1' &#125;, &#123; title: '菜单1-1-2' &#125;, &#123; title: '菜单1-1-3', children: [ &#123; title: '菜单1-1-3-1' &#125;, &#123; title: '菜单1-1-3-2' &#125;, ] &#125;] &#125;, &#123; title: '菜单1-2' &#125;, &#123; title: '菜单1-3' &#125;] &#125;, &#123; title: '菜单2' &#125;, &#123; title: '菜单3' &#125;] 仅有一层嵌套时的写法 App.vue 12345678910111213141516&lt;Menu&gt; &lt;template v-for="menu in menuList"&gt; &lt;!-- 没有子菜单 --&gt; &lt;MenuItem :key="menu.title" v-if="!menu.children"&gt; &#123;&#123;menu.title&#125;&#125; &lt;/MenuItem&gt; &lt;!-- 有子菜单 --&gt; &lt;SubMenu :key="menu.title" v-else&gt; &lt;template #title&gt; 菜单4 &lt;/template&gt; &lt;MenuItem&gt;菜单4-1&lt;/MenuItem&gt; &lt;!-- 如果子菜单还有子菜单 --&gt; &lt;/SubMenu&gt; &lt;/template&gt;&lt;/Menu&gt; 我们当然不能像上面这样硬编码，否则不得累死，要是碰上夸张点的十几层嵌套不死定了嘛。所以遇到这种重复的内容，就需要抽离出去。在上面代码中，重复的内容就是下面这一部分： 12345678&lt;!-- 有子菜单 --&gt;&lt;SubMenu :key="menu.title" v-else&gt; &lt;template #title&gt; 菜单4 &lt;/template&gt; &lt;MenuItem&gt;菜单4-1&lt;/MenuItem&gt; &lt;!-- 如果子菜单还有子菜单 --&gt;&lt;/SubMenu&gt; 所以我们新建一个 ReSubMenu.vue 来封装它： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;SubMenu&gt; &lt;template #title&gt; &#123;&#123;data.title&#125;&#125; &lt;/template&gt; &lt;template v-for="child in data.children"&gt; &lt;MenuItem :key="child.title" v-if="!child.children"&gt;&#123;&#123;child.title&#125;&#125;&lt;/MenuItem&gt; &lt;!-- 如果子菜单还有子菜单，就调用自己，并把当前对象传过去 --&gt; &lt;ReSub :key="child.title" :data="child" v-else&gt;&lt;/ReSub&gt; &lt;/template&gt; &lt;/SubMenu&gt;&lt;!-- &#123;title: '菜单1', children: [&#123;title: '菜单1-1'&#125;, &#123;title: '菜单1-2'&#125;, &#123;title: '菜单1-3'&#125;]&#125;, --&gt;&lt;/template&gt;&lt;script&gt;import SubMenu from './SubMenu'import MenuItem from './MenuItem' export default &#123; name: 'ReSub', // 起名字可以使用递归组件 props: &#123; data: &#123; type: Object, default: () =&gt; (&#123;&#125;) &#125; &#125;, components: &#123; SubMenu, MenuItem &#125;, &#125;&lt;/script&gt;&lt;style lang="css" scoped&gt;&lt;/style&gt; 这样一来我们就实现了无限菜单： 完整代码 App.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;template&gt; &lt;div id="app"&gt; &lt;Menu&gt; &lt;template v-for="menu in menuList"&gt; &lt;MenuItem :key="menu.title" v-if="!menu.children"&gt; &#123;&#123;menu.title&#125;&#125; &lt;/MenuItem&gt; &lt;!-- 把重复的内容，抽离出去 --&gt; &lt;ReSubMenu :key="menu.title" v-else :data="menu"&gt; &lt;/ReSubMenu&gt; &lt;/template&gt; &lt;!-- &lt;SubMenu&gt; &lt;template v-slot:title&gt; 等于 &lt;template #title&gt; &lt;template #title&gt; 菜单4 &lt;/template&gt; &lt;MenuItem&gt;菜单4-1&lt;/MenuItem&gt; &lt;MenuItem&gt;菜单4-2&lt;/MenuItem&gt; &lt;/SubMenu&gt; --&gt; &lt;/Menu&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Menu from './Menu' import MenuItem from './MenuItem' import SubMenu from './SubMenu' import ReSubMenu from './ReSubMenu' export default &#123; data() &#123; return &#123; menuList: [&#123; title: '菜单1', children: [ &#123; title: '菜单1-1', children: [ &#123; title: '菜单1-1-1' &#125;, &#123; title: '菜单1-1-2' &#125;, &#123; title: '菜单1-1-3', children: [ &#123; title: '菜单1-1-3-1' &#125;, &#123; title: '菜单1-1-3-2' &#125;, ] &#125;, ] &#125;, &#123; title: '菜单1-2' &#125;, &#123; title: '菜单1-3' &#125;, ] &#125;, &#123; title: '菜单2' &#125;, &#123; title: '菜单3' &#125; ] &#125; &#125;, components: &#123; Menu, MenuItem, SubMenu, ReSubMenu &#125;, &#125;&lt;/script&gt; Menu.vue 1234567891011&lt;template&gt; &lt;ul class="menu"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt; MenuItem.vue 123456789&lt;template&gt; &lt;li&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/li&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt; SubMenu.vue 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;div class="title" @click="change"&gt; &lt;slot name="title"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div v-show="flag" class="sub"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; flag: false &#125; &#125;, methods: &#123; change() &#123; this.flag = !this.flag &#125; &#125; &#125;&lt;/script&gt;&lt;style lang="css" scoped&gt;.sub &#123; padding-left: 20px;&#125;&lt;/style&gt; ReSubMenu.vue 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;SubMenu&gt; &lt;template #title&gt; &#123;&#123;data.title&#125;&#125; &lt;/template&gt; &lt;template v-for="child in data.children"&gt; &lt;MenuItem :key="child.title" v-if="!child.children"&gt;&#123;&#123;child.title&#125;&#125;&lt;/MenuItem&gt; &lt;ReSub :key="child.title" :data="child" v-else&gt;&lt;/ReSub&gt; &lt;/template&gt; &lt;/SubMenu&gt;&lt;!-- &#123;title: '菜单1', children: [&#123;title: '菜单1-1'&#125;, &#123;title: '菜单1-2'&#125;, &#123;title: '菜单1-3'&#125;]&#125;, --&gt;&lt;/template&gt;&lt;script&gt;import SubMenu from './SubMenu'import MenuItem from './MenuItem' export default &#123; name: 'ReSub', // 起名字可以使用递归组件 props: &#123; data: &#123; type: Object, default: () =&gt; (&#123;&#125;) &#125; &#125;, components: &#123; SubMenu, MenuItem &#125;, &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eruda-移动端项目调试工具]]></title>
    <url>%2Fposts%2F41294%2F</url>
    <content type="text"><![CDATA[起因之前移动端页面调试我都是手机插线连电脑用 Chrome 或者 Safari 搞定的，然而这种方式挺麻烦的，起码我这么觉得。（p.s. 如果不熟悉连线操作方式，可以查看掘金的这篇文章）后来就考虑搜索替代方案了，于是发现了 Eruda 这款调试工具。 介绍直接引用作者对这款插件的介绍：Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。 总结来讲，使用它的好处就是，手机在不连线的情况下访问页面，会在右下角生成一个按钮，点击会弹出一个调试窗口，能够在上面查看log日志等信息，方便调试。 截图 如何使用通过cdn12&lt;script src="//cdn.bootcss.com/eruda/1.5.2/eruda.min.js"&gt;&lt;/script&gt;&lt;script&gt;eruda.init();&lt;/script&gt; 通过 npm1npm i eruda -D 入口文件： 12345678910;(function () &#123; if (!/mdebug=true/.test(window.location.href)) return var script = document.createElement('script') script.src = "https://cdn.bootcss.com/eruda/1.5.2/eruda.min.js" script.async = true document.getElementsByTagName('head')[0].appendChild(script) script.onload = function () &#123; eruda.init() &#125;&#125;)() 在需要调试时，给地址栏末尾正价 mdebug=true就OK了。 资源 github - eruda 另一款调试工具 - vconsole]]></content>
      <categories>
        <category>调试工具</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下nginx基本使用]]></title>
    <url>%2Fposts%2F36876%2F</url>
    <content type="text"><![CDATA[安装 Nginx终端键入以下命令： 12sudo apt updatesudo apt install nginx 安装完成后查看版本： 1sudo nginx -v 输出： 1nginx version: nginx/1.14.0 (Ubuntu) 配置防火墙如果你服务器打开了防火墙，则还需要打开端口80和443。然后键入： 1sudo ufw allow 'Nginx Full' 你可以通过下面方式验证更改： 1sudo ufw status 如果出现： 12Nginx Full ALLOW Anywhere Nginx Full (v6) ALLOW Anywhere (v6) 就说明更改成功。 测试安装浏览器中打开 http://your_ip ，就能够看到默认的Nginx欢迎页面 使用systemctl管理Nginx服务你可以像任何其他 systemd 命令一样管理 Nginx 服务。 要停止 Nginx 服务，运行： 1sudo systemctl stop nginx 要再次启动，请键入： 1sudo systemctl start nginx 重新启动Nginx服务： 1sudo systemctl restart nginx 在进行一些配置更改后重新加载 Nginx 服务： 1sudo systemctl reload nginx 如果你想禁用 Nginx 服务在启动时启动： 1sudo systemctl disable nginx 并重新启用它： 1sudo systemctl enable nginx 以上参考来源：如何在Ubuntu 18.04上安装Nginx 配置404/etc/nginx/sites-enabled/default 中添加： 12345678910111213141516171819202122232425server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; . . . error_page 404 /custom_404.html; # 也可以跳转一个其他页面：http://www.baidu.com location = /custom_404.html &#123; root /usr/share/nginx/html; internal; allow 118.232.21.221; # 允许谁访问 deny 118.245.21.123; # 禁止这个 ip 访问 # 如果有 deny all 这样一个命令，且在 allow 代码的上方，那么即使写了 allow 也不会生效。 &#125; location = /img &#123; allow all; # 允许所有人访问(p.s. 当服务器根目录没有img文件夹时，会跳转404页面) &#125; location = /admin &#123; deny all; # 假如有个admin目录，不希望被人访问时设置。当有人访问时，报403禁止访问错误 &#125; location ~ \.php$ &#123; deny all; # 正则表达式匹配的方式禁止他人访问 .php 结尾的文件 &#125;&#125; 参考：使用Nginx的error_page指令自定义404 50x错误页面 关闭自启服务，比如打印机先安装一个类GUI软件，可以管理自启： 1sudo apt-get. install sysv-rc-conf 输入命令sysv-rc-conf，可以管理开机启动程序。带x的都是开机启动的 参考：如何关闭ubuntu不必要的开机启动程序 配置虚拟主机：p.s. 默认 nginx 网站根目录为 var/www/html 基于端口号的配置进入 etc/nginx/sites-available 目录下，新建一个配置，命名为 test ： 1vim test test 123456789101112131415# server配置server &#123; listen 8001; # 每行命令结束别忘了加 ; 分号 listen [::]:8001; server_name localhost; #你配置的对应的域名 root /var/www/html/html8001; #记得在该目录下新建这个文件夹以及默认index.html文件 # 你的默认index文件 index index.html #你的root文件所在的地址 location / &#123; try_files $uri $uri/ =404; &#125;&#125; 保存退出。 然后在终端停掉 nginx 再重开： 12nginx -s quitnginx ❗️注意：如果你开启了防火墙，记得把配置的8001端口开放出来： 1sudo ufw allow 8001/tcp 另外还需在阿里云的安全组规则中把 8001 端口开发出来。 基于IP的配置把上面 test 文件中的 server_name 改为你的其他IP就好。 基于域名的配置还是以上面的 test 文件为例，只需要把 server_name 改为你的域名就好。 除此之外，你还需要配置域名解析，例如你使用了阿里云ECS，那么你需要访问阿里云的域名解析添加记录： 在阿里云的控制台中找到域名管理，然后选择顶级域名 evelance.cn 后面的“解析”字样。在新打开的页面中我们可以看到一个提供域名解析的界面，选择解析类型为A类解析，然后输入 mall（我们想要的二级域名的头），然后在地址里面输入我们刚才查看到的ECS的公网ip，然后点击确认，之后我们的解析就会生效了。 使用 Nginx 反向代理仍然以 test 文件为例，示例配置如下： 12345678910server &#123; listen 8001; listen [::]:8001; server_name nginx.evelance.cn; location / &#123; proxy_pass http://www.bilibili.com; &#125;&#125; Nginx 适配PC和移动设备 在 /var/www/ 目录下新建两个文件夹，分别为：pc 和 mobile 目录： 123cd /var/wwwmkdir pcmkdir mobile 分别在两个目录下新建 index.html 文件并对应键入下面文字以示区分： 12&lt;h1&gt;我是PC&lt;/h1&gt;&lt;h1&gt;我是Mobile&lt;/h1&gt; 进入 /etc/nginx/sites-enabled/ 目录，还是以 test 文件作为示例： 1234567891011121314server &#123; listen 8001; listen [::]:8001; server_name nginx.evelance.cn; location / &#123; root /var/www/pc; if ($http_user_agent ~* '(Android|webOS|iPhone|iPod|BlackBerry)') &#123; root /var/www/mobile; &#125; index index.html; &#125;&#125; 重启 nginx ： 12nginx -s quitnginx 启用 gzip进入 /etc/nginx 目录，通过 vim 编辑 nginx.conf 文件： 12cd /etc/nginxvim nginx.conf 找到 Gzip Settings 项，发现 nginx 默认是开启 gzip 的： 1gzip on; 但我们发现 gzip_types 配置项是被注释了的，所以我们只需要解开注释就好： 1gzip_types text/plain text/css application/json application/javascript text/html application/xml text/javascript; 最后重启 nginx 12nginx -s quitnginx]]></content>
      <categories>
        <category>后端</category>
        <category>服务器</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下开启/关闭防火墙及端口的命令(笔记)]]></title>
    <url>%2Fposts%2F60660%2F</url>
    <content type="text"><![CDATA[开启防火墙1sudo ufw enable 关闭防火墙1sudo ufw disable 重启防火墙1sudo ufw reload 查看端口开启状态1sudo ufw status 开启某个端口1sudo ufw allow 8001/tcp 禁止外部某个端口1sudo ufw delete allow 8001/tcp 查看端口ip1netstat -ltn]]></content>
      <categories>
        <category>后端</category>
        <category>服务器</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云云服务器ECS购买与使用（笔记）]]></title>
    <url>%2Fposts%2F58410%2F</url>
    <content type="text"><![CDATA[购买进入阿里云下拉菜单选择 ecs ： 我购买的配置如下： 购买后实例就运行了，远程连接后安装一系列包和软件： 如何安装阿里云服务器ECS LAMP环境安装（Ubuntu）阿里云ECS云服务器外网IP无法访问 域名解析阿里云如何解析域名 Github Page 自定义域名 创建 Github Page 并设置自定义域名 添加 CNAME 文件到你的存储库中 Ubuntu 安装 nodejs https://blog.5udou.cn/blog/A-Li-Yun-UbuntuDa-Jian-NodeJsHuan-Jing-75 ubuntu 图形界面下无法用root登录解决办法先按照 这个教程 走，但最后不重启。然后转到 这个教程，执行第三步，也就是下面这段： 进入/etc/pam.d文件夹下，修改gdm-autologin和gdm-passwd文件内容(首先修改文件权限，参考步骤2的操作) gdm-autologin文件注释掉auth required pam_success_if.so user!=root quiet_success这一行 gdm-passwd文件注释掉auth required pam_success_if.so user!=root quiet_success这一行 做完后重启然后点击登录其他用户，输入root和密码root（这个密码在上面第一个教程中已经自己设置了）就好。 安装 LAMP 环境在ubuntu16.04中一键创建LAMP环境 编辑文件 退出 mysql 命令行：exit vi 编辑文件 按下 i 表示编辑 按下 esc 退出编辑模式 按下 :wq 保存退出 mysql 操作登录 mysql -u root -p -u 表示选择登陆的用户名， -p 表示登陆的用户密码，现在是mysql数据库是没有密码的，Enter password:处直接回车，就能够进入mysql数据库。 导入导出ubuntu下mysql数据库的导入导出 安装 图形化 mysql-workbench安装mysql服务，及安装图形化管理界面 打开mysql图形化后无法连接数据库Unbuntu 下 Mysql 连接 MysqlWorkBench 出现错误 在 ubuntu 下搭建 ftp 服务器 如何在Ubuntu 18.04上为用户目录设置vsftpd执行完上面操作后，会发现下面两个问题，按方法调整就好： 使用FileZilla FTP下载时提示“不安全的服务器，不支持FTPover TLS”,和“服务器不支持非ASCII字符” ftp连接错误——服务器发回了不可路由的地址。使用服务器地址代替。 介绍FTP是文件传输协议的缩写，是一种曾经广泛用于在客户端和服务器之间移动文件的网络协议。 它已被更快，更安全，更方便的文件传输方式所取代。 许多休闲互联网用户希望通过https直接从他们的网络浏览器下载，命令行用户更有可能使用安全协议，如scp或SFTP 。 FTP仍然用于支持具有特定需求的遗留应用程序和工作流。 如果您可以选择使用哪种协议，请考虑探索更现代的选项。 但是，当您确实需要FTP时，vsftpd是一个很好的选择。 vsftpd针对安全性，性能和稳定性进行了优化，可以很好地防范其他FTP服务器中存在的许多安全问题，并且是许多Linux发行版的默认设置。 在本教程中，您将配置vsftpd以允许用户使用具有SSL / TLS保护的登录凭据的FTP将文件上载到其主目录。 先决条件要学习本教程，您需要： Ubuntu 18.04服务器和具有sudo权限的非root用户 ：您可以在使用Ubuntu 18.04指南的初始服务器设置中了解有关如何使用这些权限设置用户的更多信息。 第1步 - 安装vsftpd让我们首先更新我们的包列表并安装vsftpd守护进程： 12sudo apt updatesudo apt install vsftpd 安装完成后，让我们复制配置文件，这样我们就可以从空白配置开始，将原件保存为备份： 1sudo cp /etc/vsftpd.conf /etc/vsftpd.conf.orig 通过备份配置，我们已准备好配置防火墙。 第2步 - 打开防火墙注意： 最后我们还得打开 80 和 8080 端口！！！ 让我们检查防火墙状态以查看它是否已启用。 如果是，我们将确保允许FTP流量，因此防火墙规则不会阻止我们的测试。 检查防火墙状态： 1sudo ufw status 在这种情况下，只允许SSH通过： 123456OutputStatus: activeTo Action From-- ------ ----OpenSSH ALLOW AnywhereOpenSSH (v6) ALLOW Anywhere (v6) 您可能有其他规则或根本没有防火墙规则。 由于在这种情况下只允许SSH流量，因此我们需要为FTP流量添加规则。 让我们打开端口20和21用于FTP，端口990用于启用TLS，端口40000-50000用于我们计划在配置文件中设置的被动端口范围： 12345sudo ufw allow 20/tcpsudo ufw allow 21/tcpsudo ufw allow 990/tcpsudo ufw allow 40000:50000/tcpsudo ufw status 我们的防火墙规则现在应如下所示： 1234567891011121314OutputStatus: activeTo Action From-- ------ ----OpenSSH ALLOW Anywhere990/tcp ALLOW Anywhere20/tcp ALLOW Anywhere21/tcp ALLOW Anywhere40000:50000/tcp ALLOW AnywhereOpenSSH (v6) ALLOW Anywhere (v6)20/tcp (v6) ALLOW Anywhere (v6)21/tcp (v6) ALLOW Anywhere (v6)990/tcp (v6) ALLOW Anywhere (v6)40000:50000/tcp (v6) ALLOW Anywhere (v6) p.s. 如何删除一个rule：sudo ufw delete allow 80/tcp 安装了vsftpd并打开了必要的端口后，我们继续创建一个专用的FTP用户。 第3步 - 准备用户目录我们将创建一个专用的FTP用户，但您可能已经有一个需要FTP访问的用户。 我们将注意保留现有用户对以下说明中的数据的访问权限。 即便如此，我们建议您在配置和测试设置之前先与新用户联系。 首先，添加一个测试用户： 1sudo adduser sammy 出现提示时分配密码。 随意通过其他提示按ENTER 。 当用户被限制在特定目录时，FTP通常更安全。 vsftpd用chroot jails完成了这个。 为本地用户启用chroot ，默认情况下它们仅限于其主目录。 但是，由于vsftpd保护目录的方式，用户不能写入。 这对于只应通过FTP连接的新用户来说很好，但如果现有用户也具有shell访问权限，则可能需要写入其主文件夹。 在这个例子中，不是从主目录中删除写权限，而是创建一个ftp目录作为chroot和一个可写files目录来保存实际文件。 创建ftp文件夹： 1sudo mkdir /home/sammy/ftp 设置所有权： 1sudo chown nobody:nogroup /home/sammy/ftp 删除写权限： 1sudo chmod a-w /home/sammy/ftp 验证权限： 1234sudo ls -la /home/sammy/ftpOutputtotal 84 dr-xr-xr-x 2 nobody nogroup 4096 Aug 24 21:29 .4 drwxr-xr-x 3 sammy sammy 4096 Aug 24 21:29 .. 接下来，让我们创建文件上传目录并为用户分配所有权： 12sudo mkdir /home/sammy/ftp/filessudo chown sammy:sammy /home/sammy/ftp/files 对ftp目录的权限检查应返回以下内容： 12345sudo ls -la /home/sammy/ftpOutputtotal 12dr-xr-xr-x 3 nobody nogroup 4096 Aug 26 14:01 .drwxr-xr-x 3 sammy sammy 4096 Aug 26 13:59 ..drwxr-xr-x 2 sammy sammy 4096 Aug 26 14:01 files 最后，让我们添加一个test.txt文件，以便在测试时使用： 1echo &quot;vsftpd test file&quot; | sudo tee /home/sammy/ftp/files/test.txt 现在我们已经保护了ftp目录并允许用户访问files目录，让我们修改我们的配置。 第4步 - 配置FTP访问我们计划允许具有本地shell帐户的单个用户与FTP连接。 这两个关键设置已在vsftpd.conf设置。 首先打开配置文件，验证配置中的设置是否与以下设置相匹配： 1sudo nano /etc/vsftpd.conf /etc/vsftpd.conf文件 1234567. . .# Allow anonymous FTP? (Disabled by default).anonymous_enable=NO## Uncomment this to allow local users to log in.local_enable=YES. . . 接下来，让我们通过取消注释write_enable设置来允许用户上传文件： /etc/vsftpd.conf文件 123. . .write_enable=YES. . . 我们还将取消注释chroot以防止FTP连接的用户访问目录树之外的任何文件或命令： /etc/vsftpd.conf文件 123. . .chroot_local_user=YES. . . 我们还添加一个user_sub_token以在local_root directory路径中插入用户名，这样我们的配置将适用于此用户和任何其他未来用户。 在文件中的任何位置添加这些设置： /etc/vsftpd.conf文件 123. . .user_sub_token=$USERlocal_root=/home/$USER/ftp 我们还限制了可用于被动FTP的端口范围，以确保有足够的连接可用： /etc/vsftpd.conf文件 123. . .pasv_min_port=40000pasv_max_port=50000 注意：在第2步中，我们打开了我们在此处为被动端口范围设置的端口。 如果更改值，请务必更新防火墙设置。 要根据具体情况允许FTP访问，让我们设置配置，以便用户只有在明确添加到列表时才能访问，而不是默认情况下： /etc/vsftpd.conf文件 1234. . .userlist_enable=YESuserlist_file=/etc/vsftpd.userlistuserlist_deny=NO userlist_deny切换逻辑：当它设置为YES ，列表中的用户被拒绝FTP访问。 当它设置为NO ，只允许列表中的用户访问。 完成更改后，保存文件并退出编辑器。 最后，让我们将用户添加到/etc/vsftpd.userlist 。 使用-a标志追加到文件： 1echo &quot;sammy&quot; | sudo tee -a /etc/vsftpd.userlist 检查它是否按预期添加： 12cat /etc/vsftpd.userlistOutputsammy 重新启动守护程序以加载配置更改： 1sudo systemctl restart vsftpd 配置到位后，我们继续测试FTP访问。 第5步 - 测试FTP访问我们已将服务器配置为仅允许用户sammy通过FTP连接。 让我们确保它按预期工作。 匿名用户应该无法连接 ：我们已禁用匿名访问。 让我们通过尝试匿名连接来测试它。 如果我们的配置设置正确，则应拒绝匿名用户的权限。 请务必将203.0.113.0替换为服务器的公共IP地址： 1234567ftp -p 203.0.113.0OutputConnected to 203.0.113.0.220 (vsFTPd 3.0.3)Name (203.0.113.0:default): anonymous530 Permission denied.ftp: Login failed.ftp&gt; 关闭连接： 1bye 除了sammy之外的用户应该无法连接 ：接下来，让我们尝试连接我们的sudo用户。 他们也应该被拒绝访问，并且应该在他们被允许输入密码之前发生： 1234567ftp -p 203.0.113.0OutputConnected to 203.0.113.0.220 (vsFTPd 3.0.3)Name (203.0.113.0:default): sudo_user530 Permission denied.ftp: Login failed.ftp&gt; 关闭连接： 1bye 用户sammy应该能够连接，读取和写入文件 ：让我们确保我们的指定用户可以连接： 12345678910ftp -p 203.0.113.0OutputConnected to 203.0.113.0.220 (vsFTPd 3.0.3)Name (203.0.113.0:default): sammy331 Please specify the password.Password: your_user&apos;s_password230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; 让我们切换到files目录并使用get命令将我们之前创建的测试文件传输到本地机器： 1234567cd filesget test.txtOutput227 Entering Passive Mode (203,0,113,0,169,12).150 Opening BINARY mode data connection for test.txt (16 bytes).226 Transfer complete.16 bytes received in 0.0101 seconds (1588 bytes/s)ftp&gt; 接下来，让我们使用新名称上传文件以测试写入权限： 12345put test.txt upload.txtOutput227 Entering Passive Mode (203,0,113,0,164,71).150 Ok to send data.226 Transfer complete.16 bytes sent in 0.000894 seconds (17897 bytes/s) 关闭连接： 1bye 现在我们已经测试了我们的配置，让我们采取措施进一步保护我们的服务器。 第6步 - 保护交易由于FTP不会加密传输中的任何数据，包括用户凭据，因此我们将启用TLS / SSL来提供加密。 第一步是创建用于vsftpd的SSL证书。 让我们使用openssl创建一个新证书，并使用-days标志使其有效一年。 在同一个命令中，我们将添加一个私有的2048位RSA密钥。 通过将-keyout和-out标志都设置为相同的值，私钥和证书将位于同一文件中： 1sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/vsftpd.pem -out /etc/ssl/private/vsftpd.pem 系统将提示您提供证书的地址信息。 将您自己的信息替换为以下突出显示的值： 12345678910111213141516171819OutputGenerating a 2048 bit RSA private key............................................................................+++...........+++writing new private key to &apos;/etc/ssl/private/vsftpd.pem&apos;-----You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]:USState or Province Name (full name) [Some-State]:NYLocality Name (eg, city) []:New York CityOrganization Name (eg, company) [Internet Widgits Pty Ltd]:DigitalOceanOrganizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []: your_server_ipEmail Address []: 有关证书标志的更多详细信息，请参阅OpenSSL Essentials：使用SSL证书，私钥和CSR 创建证书后，再次打开vsftpd配置文件： 1sudo nano /etc/vsftpd.conf 在文件的底部，您将看到以rsa_开头的两行。 评论它们，看起来像这样： /etc/vsftpd.conf文件 1234. . .# rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem# rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key. . . 在它们下面，添加以下指向我们刚刚创建的证书和私钥的行： /etc/vsftpd.conf文件 1234. . .rsa_cert_file=/etc/ssl/private/vsftpd.pemrsa_private_key_file=/etc/ssl/private/vsftpd.pem. . . 之后，我们将强制使用SSL，这将阻止无法处理TLS的客户端连接。 这对于确保所有流量都已加密是必要的，但它可能会强制您的FTP用户更改客户端。 将ssl_enable更改为YES ： /etc/vsftpd.conf文件 123. . .ssl_enable=YES. . . 之后，添加以下行以显式拒绝SSL上的匿名连接，并要求SSL进行数据传输和登录： /etc/vsftpd.conf文件 12345. . .allow_anon_ssl=NOforce_local_data_ssl=YESforce_local_logins_ssl=YES. . . 在此之后，通过添加以下行将服务器配置为使用TLS（SSL的首选后继者）： /etc/vsftpd.conf文件 12345. . .ssl_tlsv1=YESssl_sslv2=NOssl_sslv3=NO. . . 最后，我们将添加两个选项。 首先，我们不会要求重用SSL，因为它可能会破坏许多FTP客户端。 我们将需要“高”加密密码套件，目前这意味着密钥长度等于或大于128位： /etc/vsftpd.conf文件 1234. . .require_ssl_reuse=NOssl_ciphers=HIGH. . . 完成的文件部分应如下所示： /etc/vsftpd.conf文件 12345678910111213# This option specifies the location of the RSA certificate to use for SSL# encrypted connections.#rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem#rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.keyrsa_cert_file=/etc/ssl/private/vsftpd.pemrsa_private_key_file=/etc/ssl/private/vsftpd.pemssl_enable=YESallow_anon_ssl=NOforce_local_data_ssl=YESforce_local_logins_ssl=YESssl_tlsv1=YESssl_sslv2=NOssl_sslv3=NO 完成后，保存并关闭文件。 重新启动服务器以使更改生效： 1sudo systemctl restart vsftpd 此时，我们将无法再使用不安全的命令行客户端进行连接。 如果我们尝试过，我们会看到类似的东西： 12345678ftp -p 203.0.113.0Connected to 203.0.113.0.220 (vsFTPd 3.0.3)Name (203.0.113.0:default): sammy530 Non-anonymous sessions must use encryption.ftp: Login failed.421 Service not available, remote server has closed connectionftp&gt; 接下来，让我们验证我们是否可以使用支持TLS的客户端进行连接。 第7步 - 使用FileZilla测试TLS大多数现代FTP客户端都可以配置为使用TLS加密。 我们将演示如何与FileZilla连接，因为它支持跨平台。 请参阅其他客户的文档。 首次打开FileZilla时，在主页上方找到站点管理器图标，这是最上一行最左侧的图标。 点击它： 将打开一个新窗口。 单击右下角的“ 新建站点”按钮： 在“ 我的网站”下，将出现一个带有“ 新网站 ”字样的新图标。 您可以立即命名或稍后返回并使用“ 重命名”按钮。 使用名称或IP地址填写主机字段。 在“ 加密”下拉菜单下，选择“ 要求显式FTP over TLS” 。 对于登录类型 ，选择询问密码 。 在“ 用户”字段中填写您的FTP用户： 单击界面底部的“连接”。 系统将要求您输入用户密码： 单击确定以进行连接。 您现在应该使用TLS / SSL加密与您的服务器连接。 成功后，您将看到一个如下所示的服务器证书： 当您接受证书后，双击files夹并将upload.txt拖到左侧以确认您能够下载文件： 完成后，右键单击本地副本，将其重命名为upload-tls.txt并将其拖回服务器以确认您可以上传文件： 您现在已确认可以安全地成功传输启用了SSL / TLS的文件。 第8步 - 禁用Shell访问（可选）如果由于客户端要求而无法使用TLS，则可以通过禁用FTP用户以任何其他方式登录的方式来获得一些安全性。 防止它的一种相对简单的方法是创建一个自定义shell。 这不会提供任何加密，但会限制受感染帐户对FTP可访问的文件的访问。 首先，在bin目录中打开一个名为ftponly的文件： 1sudo nano /bin/ftponly 添加一条消息，告诉用户他们无法登录的原因： /斌/ ftponly 12#!/bin/shecho &quot;This account is limited to FTP access only.&quot; 保存文件并退出编辑器。 更改权限以使文件可执行： 1sudo chmod a+x /bin/ftponly 打开有效shell列表： 1sudo nano /etc/shells 在底部添加： / etc / shells中 12. . ./bin/ftponly 使用以下命令更新用户的shell： 1sudo usermod sammy -s /bin/ftponly 现在尝试以sammy身份登录您的服务器： 1ssh sammy@your_server_ip 你应该看到类似的东西： 12OutputThis account is limited to FTP access only.Connection to 203.0.113.0 closed. 这确认用户不能再ssh到服务器并且仅限于FTP访问。 结论在本教程中，我们介绍了为具有本地帐户的用户设置FTP。 如果您需要使用外部身份验证源，您可能需要了解vsftpd对虚拟用户的支持。 这通过使用PAM（可插入身份验证模块）提供了丰富的选项，如果您管理其他系统（如LDAP或Kerberos）中的用户，这是一个不错的选择。 执行完上面操作后的问题解决使用FileZilla FTP下载时提示“不安全的服务器，不支持FTPover TLS”,和“服务器不支持非ASCII字符”1、提示“不安全的服务器，不支持FTPover TLS 解决方法：在站点管理器中，加密方式选择： 2、提示“服务器不支持非ASCII字符” 解决方法：在站点管理器中字符集选择：自定义字符集：GBK OK,正常了 ftp连接错误——服务器发回了不可路由的地址。使用服务器地址代替。设置filezilla客户端的连接参数 选中某一连接项 高级——加密——只使用普通ftp 传输设置——传输模式——主动 重新连接 ubuntu下Apache虚拟站点配置https://www.linuxidc.com/Linux/2017-05/143590.htm apache配置二级域名apache2服务器mod_rewrite模块 开启方法[linux, ubuntu] 开启重写，p.s. 上面教程中说要把 /etc/apache2/sites-enabled/000-default 中的 AllowOverride None 修改为： AllowOverride All ，然而我的 Apache2 是新版（2.4），所以得转到 /etc/apache2/ 。将名为 apache2.conf 的文件中的 下面代码从 NONE 改为 ALL ： 12345&lt;Directory /var/www/&gt; Options Indexes FollowSymLinks AllowOverride All Require all granted&lt;/Directory&gt; 目标二级域名：mall.evelance.cn 阿里云控制台配置：在阿里云的控制台中找到域名管理，然后选择顶级域名 evelance.cn 后面的“解析”字样。在新打开的页面中我们可以看到一个提供域名解析的界面，选择解析类型为A类解析，然后输入 mall（我们想要的二级域名的头），然后在地址里面输入我们刚才查看到的ECS的公网ip，然后点击确认，之后我们的解析就会生效了。 ubuntu服务器配置： 进入 /etc/apache2/site-available/ ，复制默认的虚拟主机配置文件： 1sudo cp 000-default.conf mall.evelance.cn.conf 修改配置： 12345678910111213141516&lt;VirtualHost *:80&gt; ServerAdmin xxx@qq.com ServerName mall.evelance.com DocumentRoot /home/www/mall &lt;Directory "/home/www/mall"&gt; Options FollowSymLinks AllowOverride All #Require all denied Require all granted &lt;/Directory&gt; ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined&lt;/VirtualHost&gt; 在sites-enabled目录下建立符号链接： 123cd /etc/apache2/sites-enabled#建立对应的软链接sudo ln -s /etc/apache2/sites-available/mall.evelance.cn.conf /etc/apache2/sites-enabled/mall.evelance.cn.conf 在对应目录放入项目代码： 把项目文件放进 /home/www/mall 中，并赋予文件夹权限： 1sudo chmod -R 777 /home/www/mall 激活配置，重启 apache： 返回上级目录 cd ../site-enable/，输入 cd sites-available/ 输入 a2ensite mall.evelance.cn.conf ，如果提示已经激活过了，输入下面代码： 1234a2dissite mall.evelance.cn.confservice apache2 reloada2ensite mall.evelance.cn.confservice apache2 reload 参考： ECS简单配置多个二级域名 域名解析登录阿里云，进入控制台，选择云解析DNS。选择右侧的解析管理，进行二级域名的添加： 记录类型：A 主机记录：[mall].evelance.cn 解析线路：默认 记录值：你的公共IP TTL：10分钟 参考：阿里云添加二级域名的操作 支持https 在阿里云里申请免费Https证书SSL ubuntu apache2 配置安装ssl证书 阿里云 Ubuntu16.04 apache2 ssl证书下载与安装（必须有域名） 完成上述配置后，别忘了让防火墙允许 443 端口。sudo ufw allow 443/tcp]]></content>
      <categories>
        <category>后端</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ECS</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试系列大纲]]></title>
    <url>%2Fposts%2F46036%2F</url>
    <content type="text"><![CDATA[❗️持续更新中…❗️ 介绍根据网上各大前端面试题文章以及自我总结，沉淀下来的一套面试题合集，包含前端知识点 + 面试题。 大纲1 HTML根据以往面试经验，HTML部分很少有问到。所以这里仅列举一旦考则必问的面试题 1.1 面试题 HTML面试题 2 CSS个人经验：这部分面试题一般笔试考知识点多一些（多背），面试考布局更多一些（多实践）。所以CSS我拆成了两部分，把布局单独拧出来了。 2.1 知识点 + 部分面试题 CSS知识点 2.2 布局 CSS布局面试题 3 JavaScript这部分是面试重中之重，基本上啥都可能考。譬如比较经典的一个有关axios的面试题： 问：a、b、c三个请求，希望c在a、b获取数据后再发请求，要是你你会怎么做？ 答：axios.all 先请求 a、b，再在 then 的第一个回调中请求 c ，巴拉巴拉… 问：那 axios.all 内部是通过什么实现的呢？ 答：Promise.all，巴拉巴拉… 问：如果不用 Promise 该如何实现？ 答：可以用 高阶函数 ，巴拉巴拉… 12345678910111213141516// 示例（使用node读取文件做场景来说明）let fs = require('fs')let arr = []function fn(data) &#123; arr.push(data) if (arr.length === 2) &#123; // get ab // todo c &#125;&#125;fs.readFile('./a.txt', 'utf8', (err, data) =&gt; &#123; fn(data)&#125;)fs.readFile('./b.txt', 'utf8', (err, data) =&gt; &#123; fn(data)&#125;) 可以看出，往往 JS 面试题是层层深入的，需要你有坚实的基础，并且在平常开发时不仅满足会使用各种库和框架，还要深入了解原理。所以这一小节内容较多，各位做好抗压准备。 3.1 知识点 JS知识点 3.2 面试题 JS笔试题 JS面试题 4 浏览器/网络浏览器这边主要考察兼容性，当然有时候也考察下HTTP缓存等内容，所以我把它们归到了一起方便复习。 浏览器 5 框架 + 工具5.1 VueVue没什么好说的，数据响应式（双向数据绑定）是一定会问到的，其它例如生命周期之类的也常常出现，具体查看下面链接： Vue面试题 5.2 Webpack个人在面试中很少被问到 webpack 的问题？唯一一次与 webpack 相关的还是在一次面试的笔试题中，有这样一道： 写出你知道的性能优化方案（不要写 webpack 工具能做到的） 虽然我自己没碰到过，但保不齐其他公司不爱问，所以还是放在这儿： 如何使用webpack4 Webpack面试题 6 性能优化性能优化现在应该是必考题了，我去几家公司面就有几家会问到，常考的知识点有「首屏优化」「重排重绘优化」以及「css3动画优化」等。不太了解这部分的童鞋可以看下面链接： 网站性能优化 web性能优化-实践 7 算法这部分目前是我薄弱项，暂时不能给到大家更多帮助。不过对于面一般普通前端来说，也就顶多问一下常见的排序算法了。 这是我之前整理的常见排序算法：可以 点击此处 查看。 其他算法面试题会在后续更新… 简历模板网上的简历模板一搜一大堆，不过大都既不实用也不好看。所以最后我再分享几个觉得不错的模板给大家参考： 纸质模板 https://www.resumeviking.com/wp-content/uploads/2018/01/Dwight-Kavanagh-Resume-IT-QA-Analyst-11.pdf https://www.resumeviking.com/wp-content/uploads/2019/04/Emily_Carter_-_Resume_-_English_Teacher-9.pdf https://www.resumeviking.com/wp-content/uploads/2018/09/Karen_Philips_-_Resume_-_Web_Designer-4.pdf 上面两份模板都来自 此网站 ，想寻找更满意的版本可以进去逛逛。 在线模板 http://zhangwenli.com/cv/ 下载地址：https://github.com/Ovilia/cv https://html5up.net/read-only 下载地址：上方链接右上角 Download 更多本项目整合了大量下方资源的面试题内容，但毕竟是按照我自己技术栈整合的，所以如果你还想查缺补漏（例如 react 相关面试题等），可以点击下方链接了解更多： 前端开发面试题 前端面试考点多？看这些文章就够了 KieSun/Front-end-knowledge]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局面试题（面试系列）]]></title>
    <url>%2Fposts%2F10415%2F</url>
    <content type="text"><![CDATA[如何居中div？行内元素水平居中123#container &#123; text-align: center;&#125; 单个 div（块级元素）水平居中1234#center &#123; width: 200px; margin: 0 auto;&#125; 多个 div 水平居中12345678910111213/* 传统方案 */#container &#123; text-align: center;&#125;#center &#123; display: inline-block;&#125;/* flex 布局方案 */#container &#123; justify-content: center; display: flex;&#125; 绝对定位的 div 居中（已知宽高）子绝父相 + margin1234567891011#center &#123; position: absolute; width: 300px; height: 300px; margin: auto; /* 0 auto 水平居中；auto 水平垂直居中 */ top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /* 方便看效果 */&#125; 子绝父相 + 负边距123456789#center &#123; position: absolute; width:500px; height:300px; top: 50%; left: 50%; margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */ background-color: pink; /* 方便看效果 */&#125; 当被居中的元素是 inline or inline-block 元素12345#container &#123; display: table-cell; text-align: center; vertical-align: middle;&#125; 任意元素（未知宽高）子绝父相 + translate1234567891011#container &#123; position: relative;&#125;/* 利用transform */#center &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; flex（需考虑兼容性）1234567891011#container &#123; display: flex; display: -webkit-flex; /* Safari仍旧需要使用特定的浏览器前缀 */ align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */&#125;#center &#123; width: 100px; height: 100px; background-color: pink; /* 方便看效果 */&#125; 请解释一下CSS3的 Flexbox（弹性盒布局模型）,以及适用场景？该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。 在传统的布局方式中: block 布局是把块在垂直方向从上到下依次排列的； inline 布局则是在水平方向来排列。 flex 弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。 适用场景：弹性布局适合于移动前端开发，在 Android 和 iOS 上也完美支持。 参考：http://www.w3cplus.com/css3/flexbox-basics.html 如何使用 flex 实现三列等宽布局父元素 display: flex，子元素 flex: 1 解释子元素的设置等同于：flex: 1 1 auto flex的默认值是：0 1 auto 意思是项目默认有剩余空间也不放大（0），但空间不足会缩小（1） 现在改为了值 1 ，就可以放大了，所以三栏可以平分宽度 阅读：flex设置成1和auto有什么区别 如何使用 flex 实现下列布局 HTML 12345678&lt;div id="container"&gt; &lt;div class="box box1"&gt;1&lt;/div&gt; &lt;div class="box box2"&gt;2&lt;/div&gt; &lt;div class="box box3"&gt;3&lt;/div&gt; &lt;div class="box box4"&gt;4&lt;/div&gt; &lt;div class="box box5"&gt;5&lt;/div&gt;&lt;/div&gt;&lt;p&gt;margin-right: auto&lt;/p&gt; CSS 123456789101112131415161718192021#container &#123; display: flex; justify-content: flex-end; background-color: lightyellow;&#125;.box &#123; display: flex; align-items: center; justify-content: center; height: 50px; width: 75px; background-color: springgreen; border: 1px solid #333;&#125;.box1 &#123; margin-right: auto;&#125;p &#123; width: 100%; text-align: center;&#125; 摘自：css flex布局中妙用 margin: auto 用纯CSS创建一个三角形的原理是什么？12345678把上、左、右三条边隐藏掉（颜色设为 transparent）#demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent;&#125; css多列等高如何实现？原理利用 padding-bottom|margin-bottom 正负值相抵； 设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定 padding-bottom 时的高度， 当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度， 其他比这列矮的列则会用它们的 padding-bottom 来补偿这部分高度差。 因为背景是可以用在 padding 占用的空间里的，而且边框也是跟随 padding 变化的，所以就成功的完成了一个障眼法。 实现 HTML 1234567891011121314&lt;ul class="Article"&gt; &lt;li class="js-equalheight"&gt; &lt;p&gt; 一家将客户利益置于首位的经纪商， 为客户提供专业的交易工具一家将客户利益置于首位的经纪商 &lt;/p&gt; &lt;/li&gt; &lt;li class="js-equalheight"&gt; &lt;p&gt;一家将客户利益置于首位的经纪商，为客户提供专业的交易工具&lt;/p&gt; &lt;/li&gt; &lt;li class="js-equalheight"&gt; &lt;p&gt;一家将客户利益置于首位的经纪商&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; CSS 12345678910111213141516.Article &#123; overflow: hidden;&#125;.Article &gt; li &#123; float: left; margin: 0 10px -9999px 0; padding-bottom: 9999px; background: #4577dc; width: 200px; color: #fff;&#125;.Article &gt; li &gt; p &#123; padding: 10px;&#125; 有一个高度自适应的 div ，里面有两个 div ，一个高度 100px ，希望另一个填满剩下的高度。 HTML 123456&lt;body&gt; &lt;div class="outer"&gt; &lt;div class="A"&gt;&lt;/div&gt; &lt;div class="B"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; CSS 方案1123456789.A &#123; height: 100px; background-color: pink;&#125;.B &#123; background-color: blue; height: calc(100vh - 100px);&#125; 方案2123456789101112131415161718192021222324/* 利用border-box将padding包含在高度内； */.outer &#123; height: 100%; padding: 100px 0 0; box-sizing: border-box; background-color: pink;&#125;/* 用负margin值将A子容器顶到页面顶部*/.A &#123; height: 100px; margin: -100px 0 0; background: #BBE8F2;&#125;/* 剩下的高度100%-100px就是B容器所谓的100%高了*/.B &#123; height: 100%; background: #D9C666;&#125; 方案312345678910111213141516171819202122.outer &#123; height: 100%; padding: 100px 0 0; box-sizing: border-box; position: relative;&#125;/* 绝对定*/.A &#123; height: 100px; background: #BBE8F2; position: absolute; top: 0; left: 0; width: 100%;&#125;.B &#123; height: 100%; background: #D9C666;&#125; 方案4123456789101112131415161718.outer &#123; height: 100%; position: relative;&#125;.A &#123; height: 100px; background: #BBE8F2;&#125;.B &#123; background: #D9C666; width: 100%; position: absolute; top: 100px; left: 0; bottom: 0;&#125; 方案512345678910111213141516171819.outer &#123; height: 100%; background: red; display: flex; display: -webkit-flex; flex-direction: column; -webkit-flex-direction: row;&#125;.A &#123; width: 100%; height: 100px; background: green;&#125;.B &#123; background: blue; flex: 1;&#125; rem布局知道吗？原理是什么？rem是个相对单位，相对的是html根元素的font-size大小。这样一来我们就可以通过html上的字体大小来控制页面上所有以rem为单位的元素尺寸。 示例代码 例如在vue项目的index.html页中动态计算根元素字体大小 index.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no"&gt; ... &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; ... &lt;/noscript&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script&gt; ;(function(doc, win) &#123; const docEl = doc.documentElement const resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize' const recalc = () =&gt; &#123; const clientWidth = docEl.clientWidth // 把屏幕宽度划分成10份，那么每一份的宽度就等于1rem docEl.style.fontSize = clientWidth / 10 + 'px' &#125; if (!doc.addEventListener) return win.addEventListener(resizeEvt, recalc, false) doc.addEventListener('DOMContentLoaded', recalc, false) recalc() &#125;)(document, window) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 然后利用css预处理器定义一个mixin函数（下方用的stylus），用来将设计稿上的px转为对应的rem值 计算公式为： 页面元素的rem值 = 设计稿元素值（px）/（屏幕宽度 / 划分的份数） mixin.stylus 1234/* 把px转为rem */px2rem(designpx) $rem = 750 / 10; return (designpx / $rem)rem 最后在css中使用 某vue组件的style标签中 1234/* 375设计稿上100%宽以及50高的导航条（iPhone6的dpr为2，所以px值得都乘以2） */header width px2rem(750) height px2rem(100) rem布局的优缺点优点： 能维持能整体的布局效果，移动端兼容性好，不用写多个css代码，而且还可以利用@media进行优化。 缺点： 开头要引入一段 js 代码，单位都要改成 rem（ font-size 可以用 px ），计算 rem 比较麻烦(可以引用预处理器，但是增加了编译过程，相对麻烦了点)。PC 和 Mobile 要分开。 参考： 用 rem 实现 WebApp 自适应的优劣分析 CSS3 的字体大小单位[rem]到底好在哪？ 总结个人使用过的移动端布局方法 慎用 em 的原因em会叠加计算。在这个机制下太容易犯错了，因为你不知道这段css指定的字号具体是多少。 HTML 12345&lt;span&gt; abc &lt;span&gt;def&lt;/span&gt; abc&lt;/span&gt; CSS 1span &#123; font-size: 1.5em; &#125; 实际效果： 先要搞清楚 em 的计算原理，它是根据当前元素的字号按比例计算的。 外层 span 的字号是 16px（浏览器默认值），所以 1.5em 之后是 24px 。由于字号是继承的，导致内层 span 的字号继承过来是 24px ，再经过 1.5em 之后就成了 36px 。 所以，就算要用 em 的话，尽量不要用在继承属性（font-size）上，除非你真的清楚你在做什么！ 两列布局（左列定宽，右列自适应） HTML 1234&lt;body&gt; &lt;div id="left"&gt;左列定宽&lt;/div&gt; &lt;div id="right"&gt;右列自适应&lt;/div&gt;&lt;/body&gt; 1. 利用 float + margin123456789101112131415#left &#123; background-color: #f00; float: left; width: 100px; height: 500px;&#125;#right &#123; background-color: #0f0; height: 500px; margin-left: 100px; /*设置间隔，大于等于#left的宽度*/&#125;原理：#left左浮动，脱离文档流，#right为了不被#left挡住，设置margin-left大于等于#left的宽度达到视觉上的两栏布局 2. 使用 float + overflow（触发bfc）1234567891011121314#left &#123; background-color: #f00; float: left; width: 100px; height: 500px;&#125;#right &#123; background-color: #0f0; height: 500px; overflow: hidden; /*触发bfc达到自适应*/&#125;原理：#left左浮动，#right触发bfc达到自适应 3. 使用 table 实现123456789101112131415161718#parent &#123; width: 100%; display: table; height: 500px;&#125;#left &#123; width: 100px; background-color: #f00;&#125;#right &#123; background-color: #0f0;&#125;/*利用单元格自动分配宽度*/#left, #right &#123; display: table-cell;&#125; 4. 使用 position 实现123456789101112131415161718192021#parent&#123; position: relative;&#125; /*父相*/#left &#123; position: absolute; /*子绝*/ top: 0; left: 0; background-color: #f00; width: 100px; height: 500px;&#125;#right &#123; position: absolute; /*子绝*/ top: 0; left: 100px; /*值大于等于#left的宽度*/ right: 0; background-color: #0f0; height: 500px;&#125; 5. 使用 flex 实现123456789101112131415#parent &#123; width: 100%; height: 500px; display: flex;&#125;#left &#123; width: 100px; background-color: #f00;&#125;#right &#123; flex: 1; /*均分了父元素剩余空间*/ background-color: #0f0;&#125; 两列布局（一列不定宽，一列自适应）1. float + overflow1234567891011121314#left &#123; margin-right: 10px; float: left; /*只设置浮动,不设宽度*/ height: 500px; background-color: #f00;&#125;#right &#123; overflow: hidden; /*触发bfc*/ height: 500px; background-color: #0f0;&#125;原理：#left不设宽度左浮动，#right触发 bfc 达到自适应 2. flex 布局123456789101112131415#parent&#123; display: flex;&#125;#left &#123; /*不设宽度*/ margin-right: 10px; height: 500px; background-color: #f00;&#125;#right &#123; height: 500px; background-color: #0f0; flex: 1; /*均分#parent剩余的部分*/&#125; 三列布局（左中定宽，右侧自适应） HTML 1234567&lt;body&gt;&lt;div id="parent"&gt; &lt;div id="left"&gt;左列定宽&lt;/div&gt; &lt;div id="center"&gt;中间定宽&lt;/div&gt; &lt;div id="right"&gt;右列自适应&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 1. float + margin123456789101112131415161718192021222324#parent&#123; min-width: 310px;&#125; /*100+10+200,防止宽度不够,子元素换行*/#left &#123; margin-right: 10px; /*#left和#center间隔*/ float: left; width: 100px; height: 500px; background-color: #f00;&#125;#center&#123; float: left; width: 200px; height: 500px; background-color: #eeff2b;&#125;#right &#123; margin-left: 320px; /*等于#left和#center的宽度之和加上间隔,多出来的就是#right和#center的间隔*/ height: 500px; background-color: #0f0;&#125; 2. float + overflow12345678910111213141516171819202122232425#parent&#123; min-width: 320px;&#125; /*100+10+200+20,防止宽度不够,子元素换行*/#left &#123; margin-right: 10px; /*间隔*/ float: left; width: 100px; height: 500px; background-color: #f00;&#125;#center&#123; margin-right: 10px; /*在此定义和#right的间隔*/ float: left; width: 200px; height: 500px; background-color: #eeff2b;&#125;#right &#123; overflow: hidden; /*触发bfc*/ height: 500px; background-color: #0f0;&#125; 3. 利用 position123456789101112131415161718192021222324252627282930#parent &#123; position: relative;&#125; /*父相*/#left &#123; position: absolute; /*子绝*/ top: 0; left: 0; width: 100px; height: 500px; background-color: #f00;&#125;#center &#123; position: absolute; /*子绝*/ left: 100px; /*对应#left的width值*/ top: 0; width: 200px; height: 500px; background-color: #eeff2b;&#125;#right &#123; position: absolute; /*子绝*/ left: 300px; /*对应#left和#center的width值之和*/ top: 0; right: 0; height: 500px; background-color: #0f0;&#125; 4. 利用 table12345678910111213141516171819202122232425#parent &#123; width: 100%; height: 520px; /*抵消上下间距10*2的高度影响*/ margin: -10px 0; /*抵消上下边间距10的位置影响*/ display: table; /*左右两边间距无法消除,子元素改用padding设置盒子间距就没有这个问题*/ border-spacing: 10px; /*关键!!!设置间距*/&#125;#left &#123; display: table-cell; width: 100px; background-color: #f00;&#125;#center &#123; display: table-cell; width: 200px; background-color: #eeff2b;&#125;#right &#123; display: table-cell; background-color: #0f0;&#125; 5. 利用 flex123456789101112131415161718192021#parent &#123; height: 500px; display: flex;&#125;#left &#123; margin-right: 10px; /*间距*/ width: 100px; background-color: #f00;&#125;#center &#123; margin-right: 10px; /*间距*/ width: 200px; background-color: #eeff2b;&#125;#right &#123; flex: 1; /*均分#parent剩余的部分达到自适应*/ background-color: #0f0;&#125; 三列布局（两侧定宽，中间自适应）圣杯布局 详解 HTML 12345&lt;div class="container"&gt; &lt;div class="center"&gt;中间&lt;/div&gt; &lt;!-- 让中间第一，这样浮动的时候它会先占据100%宽 --&gt; &lt;div class="left"&gt;左边&lt;/div&gt; &lt;div class="right"&gt;右边&lt;/div&gt;&lt;/div&gt; CSS 12345678910111213141516171819202122232425262728293031.container &#123; height: 500px; min-width: 400px; /* 左边w*2+右边w */ padding: 0 100px 0 150px; /* 1. 父容器左右留出固定padding */ background-color: gray;&#125;.left &#123; margin-left: -100%; /* 4.1 让被挤到center下方的left左移整个容器的宽度，此时左上角与center重叠 */ position: relative; /* 4.2 为了让left移到最左边,设置相对定位 */ left: -150px; /* 4.3 然后相对自己左移自已宽度的单位，使自己移动到最左边 */ height: 100%; float: left; /* 2.1 左浮动 */ width: 150px; background-color: rgba(233, 233, 0, .2);&#125;.center &#123; height: 100%; width: 100%; /* 3. 让center占据剩下父容器的100%宽 */ float: left; /* 2.1 左浮动 */ background-color: rgba(165, 12, 23, .4);&#125;.right &#123; margin-right: -100px; /* 5. 给在第二行的right设置一个负自己宽度的margin-right。让其最右边 */ height: 100%; width: 100px; float: left; /* 2.1 左浮动 */ background-color: green;&#125; 双飞翼布局方法 详情 HTML 1234567&lt;div class="container"&gt; &lt;div class="center"&gt; &lt;div&gt;中间&lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;左边&lt;/div&gt; &lt;div class="right"&gt;右边&lt;/div&gt;&lt;/div&gt; CSS 1234567891011121314151617181920212223242526272829303132.container &#123; width: 100%; /* 1. 整个容器宽100%自适应 */ height: 500px; background-color: gray;&#125;.left &#123; width: 100px; /* 3.1 设置定宽 */ margin-left: -100%; /* 5. 左移容器宽度100%个单位，就把自己排在了center前面 */ background-color: rgba(233, 233, 0, .2);&#125;.center &#123; width: 100%; /* 4. 中间容器100%，此时会把左右挤到第二行 */ background-color: rgba(165, 12, 23, .4);&#125;.center div &#123; margin: 0 150px 0 100px; /* 7. 此时center的左右分别有100和150宽与left，right重叠。所以让center子容器左右margin抵消 */&#125;.right &#123; width: 150px; /* 3.2 设置定宽 */ margin-left: -150px; /* 6. 同样左移自身宽度的单位，让right也回到第一行 */ background-color: green;&#125;.left, .center, .right &#123; height: 100%; float: left; /*2. 子容器全部左浮动 */&#125; 布局的几种方式 伸缩布局 flex 流式布局 百分比 响应式布局 媒体查询（超小屏设备时：流式布局） &lt;!- 以上布局共同点：元素只能做到宽度的适配（排除图片）-&gt; rem布局 宽度和高度都能做到适配（等比适配） Flexflex布局和传统布局的优势？该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。 在传统的布局方式中: block 布局是把块在垂直方向从上到下依次排列的 inline 布局则是在水平方向来排列 flex 弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作 如何解决移动端 Retina 屏 1px 像素问题原理：媒体查询 + 变换缩放12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"/&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; #test &#123; width: 100%; height: 1px; margin-top: 50px; background: black; &#125; @media only screen and (-webkit-device-pixel-ratio:2 ) &#123; #test &#123; transform: scaleY(.5); &#125; &#125; @media only screen and (-webkit-device-pixel-ratio:3 ) &#123; #test &#123; transform: scaleY(.333333333333333333); &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="test"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; stylus 实现方案 stylus12345678910111213141516171819202122232425/* 给 dpr 1.5 的设备设置 0.7 的缩放 */@media (-webkit-min-device-pixel-ratio: 1.5), (min-device-pixel-ratio: 1.5) .border1px &amp;::after -webkit-transform: scaleY(.7) transform: scaleY(.7)/* 给 dpr 2.0 的设备设置 0.5 的缩放 */@media (-webkit-min-device-pixel-ratio: 2), (min-device-pixel-ratio: 2) .border1px &amp;::after -webkit-transform: scaleY(.5) transform: scaleY(.5)/* 给需要1px下边框的元素添加一个伪元素，使其宽100%；高为用户自定义 */border1px($color) position: relative &amp;:after display: block position: absolute left: 0 bottom: 0 width: 100% border-top: 1px solid $color content: ' ' html 12345678&lt;!-- 1. 给需要添加1像素边框的元素设置一个类作为标识，让媒体查询能够识别 --&gt;&lt;header class="border1px"&gt;&lt;/header&gt;&lt;style lang="stylus" scoped&gt;header ... border1px(black) /* 2. 通过border1px设置边框 */&lt;/style&gt; 其它实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。1&lt;div style="height:1px;overflow:hidden;background:red"&gt;&lt;/div&gt; 已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改1&lt;img src="1.jpg" style="width:480px!important;"&gt; 答案： 1234567891011121314151617181920&lt;!-- 方法一：max-width覆盖 --&gt;&lt;img src="1.jpg" style="width:480px!important; max-width: 300px"&gt;&lt;!-- 方法二：scale按比例缩放 --&gt;&lt;img src="1.jpg" style="width:480px!important; transform: scale(0.625, 1);" &gt;&lt;!-- 方法三：相同属性直接覆盖 --&gt;&lt;img src="1.jpg" style="width:480px!important; width:300px!important;"&gt;&lt;!-- 方法四：css动画样式优先级高于important特性 --&gt;&lt;style&gt;img &#123; animation: test 0s forwards;&#125;@keyframes test &#123; from &#123; width: 300px &#125; to &#123; width: 300px; &#125;&#125;&lt;/style&gt; 题目来源：Daily-Interview-Question 第60题]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack面试题（面试系列）]]></title>
    <url>%2Fposts%2F6706%2F</url>
    <content type="text"><![CDATA[下面的题目都摘自各种 webpack 面试相关的文章，我只选择了感觉很重要的一些题，想要了解更多，可以查看本文最后的参考链接。 webpack 有什么用 静态资源的合并/打包/压缩 解决加载慢，错综复杂的依赖关系 有哪些常见 loader 和 plugin，你用过哪些loader： css：postcss-l+autoprefixer，style-l(js到)，css-l(js中 import 的 css)，less-l，sass-l 图片/字体加载：url-loader，file-loader 图片压缩：image-webpack-loader js：babel-loader es6转es5，eslint-loader 检查js代码 plugin： webpack-dev-server 实时打包构建 html-webpack-plugin 配置启动页 clean-webpack-plugin 清理 dist 文件夹 mini-css-extract-plugin 提取css为单独文件 optimize-css-assets-webpack-plugin 压缩css loader 和 plugin 的区别是什么loaders 是加载器。用来处理源文件的（JSX，Scss，Less..），一次处理一个，让 webpack 有能力加载处理非js文件，plugin 是插件。并不直接操作单个文件，它直接对整个构建过程起作用。 如何按需加载代码import(‘文件路径’).then【代码执行到时再加载】 如何提高 webpack 构建速度 用 webpack4 用 externals 提取常用库 提前打包第三方库：dllplugin happypack：多线程进行打包，提升 loader 解析速度 webpack-parallel-uglify-plugin 并发压缩js，提升速度 如何利用 webpack 提升前端性能 动态加载：路由懒加载【import()动态加载模块，返回结果是Promise】 1234function loadView(view) &#123; return () =&gt; import( /* webpackChunkName: "view-[request]" */ `../components/$&#123;view&#125;.vue`)&#125;&#123; path: '/home', component: loadView('Home') &#125; 第三方依赖用 cdn（vue，vue-router，element-ui）【webpack.config.js externals】 压缩文件【uglifyjs-plugin/optimize-css-assets-plugin/image-webpack-loader】 提取公共代码【CommonChunkPlugin / splitChunksPlugin】 参考 关于webpack的面试题总结 使用webpack4提升180%编译速度 webpack4.0 各个击破]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue面试题（面试系列）]]></title>
    <url>%2Fposts%2F53756%2F</url>
    <content type="text"><![CDATA[watch 和 computed 区别 watch 是监听动作，computed 是计算属性 computed 有缓存，只在属性变化的时候才去计算。watch 没缓存，只要数据变化就执行 讲一下 Vue 的生命周期？创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中。 换句话说，此时页面中的类似 这样的语法还没有被替换成真正的数据。 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示【可以获取 DOM 节点 | 发起异步请求】 用户已经可以看到渲染好的页面了 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 Vue 的父组件和子组件生命周期钩子执行顺序是什么 加载渲染过程父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted 子组件更新过程父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated 父组件更新过程父beforeUpdate-&gt;父updated 销毁过程父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed 总结：从外到内，再从内到外 更多阅读 包你理解—vue 的生命周期 组件现在有个父子组件，我希望在父级中给子组件绑定一个原生click事件，这个事件会被触发吗？123456789101112&lt;div id='app'&gt; &lt;my-button @click='change'&gt;&lt;/my-button&gt;&lt;/div&gt;&lt;script&gt; export default &#123; methods: &#123; change() &#123; alert(1) &#125; &#125; &#125;&lt;/script&gt; 答：不能，绑定的该click事件会被当做组件上的一个普通属性看待，如果想要使click事件生效，可以使用 `@click.native=’change’` 的方式来实现。 组件间如何通讯？ props/$emit+v-on: 通过props将数据自上而下传递，而通过$emit和v-on来向上传递信息。 EventBus: 通过EventBus进行信息的发布与订阅 vuex: 是全局数据管理库，可以通过vuex管理全局的数据流 $attrs/$listeners: Vue2.4中加入的$attrs/$listeners可以进行跨级的组件通信 provide/inject：以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效，这成为了跨组件通信的基础 this.$emit 的返回值是什么？如果需要返回值该怎么办？this.$emit 的返回值就是 this ，即当前子组件 VueComponent 。 如果想要有返回值可以如下操作： 子组件 12345678910111213141516&lt;template&gt; &lt;input :value="name" @change="handleChange" /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['name'], methods: &#123; handleChange(e) &#123; const res = this.$emit("Echange", e.target.value, val =&gt; &#123; console.log(val); &#125;); console.log(res, res === this); &#125;, &#125;&#125;&lt;/script&gt; 父组件 12345678910111213141516171819&lt;template&gt; &lt;Child :name='name' @Echange="handleEventChange" /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; name: '', &#125; &#125; methods: &#123; handleEventChange(val, callback) &#123; this.name = val callback("hello") return 'hello' &#125; &#125;&#125;&lt;/script&gt; vue 指令能讲下 v-if 和 v-show 的区别吗？ v-if: 是否加载这个元素（一次性的） v-show：控制显示方式block or none（需要切换的，侧边栏） 因此：如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好 v-for 你使用过程中，有遇到什么问题或者关注点吗？ 避免将 v-if 和 v-for 放在同一个元素上，因为 v-for 优先级比 v-if 更高。例如要渲染 todo 列表中未完成的任务，给 li 标签同时写上 v-for 和 v-if 后会导致每次重新渲染都得遍历整个列表。优化方案是把需要遍历的 todoList 更换为在计算属性上遍历过滤。（Vue文档有详细说明，具体见下方「阅读更多」） 给 v-for 设置键绑定键值 key。理由见下。 在列表组件中添加 key 属性的作用？key的主要作用就是在更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的。这样可以更高效的更新虚拟 DOM。 另外如果给列表组件设置了过渡效果，不添加key属性会导致过渡效果无法触发。因为不添加key会导致vue无法区分它们，导致只会替换节点内部属性而不会触发过渡效果。 为什么不建议用 index 作为 key 呢？更新DOM时会出现性能问题 例如我们在使用index作为key值时想要下面列表进行倒序排列： 1234567&lt;li key='0'&gt;React&lt;/li&gt;&lt;li key='1'&gt;Vue&lt;/li&gt;&lt;li key='2'&gt;Angular&lt;/li&gt;&lt;!-- 倒序后↓↓↓↓↓↓↓↓↓↓ --&gt;&lt;li key='0'&gt;Angular&lt;/li&gt;&lt;li key='1'&gt;Vue&lt;/li&gt;&lt;li key='2'&gt;React&lt;/li&gt; vue这个时候仅会调换第一和第三项的文本，li元素则不会调换顺序，因为vue发现key值也就是index没变化。而这会导致li里面的文本重新渲染，影响性能。 而如果采用 id 作为 key，则仅仅需要移动下DOM就OK了，并不需要重新渲染DOM： 1234567&lt;li key='react'&gt;React&lt;/li&gt;&lt;li key='vue'&gt;Vue&lt;/li&gt;&lt;li key='angular'&gt;Angular&lt;/li&gt;&lt;!-- 倒序后↓↓↓↓↓↓↓↓↓↓ --&gt;&lt;li key='angular'&gt;Angular&lt;/li&gt;&lt;li key='vue'&gt;Vue&lt;/li&gt;&lt;li key='react'&gt;React&lt;/li&gt; 会发生一些状态bug 还是以上面例子为例，给每个li元素中加一个checkbox： 123&lt;li key='react'&gt;&lt;input type='checkbox'&gt;React&lt;/li&gt;&lt;li key='vue'&gt;&lt;input type='checkbox'&gt;Vue&lt;/li&gt;&lt;li key='angular'&gt;&lt;input type='checkbox'&gt;Angular&lt;/li&gt; 如果采用 index 作为 key，选中状态会出现bug（左边列表采用index，右边采用id形式）： 原因也是 index 没有变化被复用了，导致选中状态永远都是 index=0 的第一项。 阅读更多： 避免 v-if 和 v-for 用在一起 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？ Vue2.0 v-for 中 :key 到底有什么用？ Vue：为什么使用v-for时必须添加唯一的key？为什么不宜用index作为key？ 数据响应式（双向绑定）怎么做到的？原理：Vue 采用 数据劫持 结合 发布者-订阅者 模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter 以及 getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 第一步：需要 Observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。 第二步：Compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新数据。 第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情有： 在自身实例化时往属性订阅器（dep）里面添加自己。 自身必须有一个 update() 方法 待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。 第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的桥梁，达到数据变化 -&gt; 视图更新；视图交互变化（input） -&gt; 数据 model 变更的双向绑定效果。 参考： Vue.js双向绑定的实现原理 vue双向数据绑定简单实现(一) 追问1：那如果我要监听一个对象属性的删除或添加呢？受 defineProperty 限制，Vue 无法检测对象属性的删除和添加。所以我们可以利用 Vue 提供的 Vue.set 来解决此问题。 例子： 123有一个obj:&#123;a:1&#125;，想要this.obj.b=233，不会触发视图更新Vue.set(this.obj, 'b', 233) or this.$set(this.obj, 'b', 233) 追问2：为什么对象属性的删除或添加无法触发页面更新因为 vue 在实例化过程中，深度遍历了 data 下所有属性, 把属性全转为 getter/setter 。这样才能监听属性变化。所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。 当你在对象上新加了一个属性 newProperty ，当前新加的这个属性并没有加入 vue 检测数据更新的机制（因为是在初始化之后添加的）, vue.$set 是能让 vue 知道你添加了属性, 它会给你做处理。 js 实现简单的双向绑定12345678910111213141516171819202122232425&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" id="txt"&gt; &lt;p id="show"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; window.onload = function () &#123; let obj = &#123;&#125;; window.obj = obj Object.defineProperty(obj, "txt", &#123; get: function () &#123; return obj; &#125;, set: function (newValue) &#123; document.getElementById("txt").value = newValue; document.getElementById("show").innerHTML = newValue; &#125; &#125;) document.addEventListener("keyup", function (e) &#123; obj.txt = e.target.value; &#125;) &#125; &lt;/script&gt;&lt;/body&gt; Vue 的响应式原理中 Object.defineProperty 有什么缺陷？为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？ Vue 中使用 Object.defineProperty 进行双向数据绑定时，告知使用者是可以监听数组的，但是只是监听了数组的 push()、pop()、shift()、unshift()、splice()、sort()、reverse() 这八种方法，其他数组的属性检测不到。 Object.defineProperty 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应； Object.defineProperty 只能劫持对象的属性，因此对每个对象的属性进行遍历时，如果属性值也是对象需要深度遍历，那么就比较麻烦了，所以在比较 Proxy 能完整劫持对象的对比下，选择 Proxy。 Proxy 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。 答案参考：Daily-Interview-Question - 第51题更多阅读：实现双向绑定Proxy比defineproperty优劣如何 Vuex 用过吗？Vuex 是专为 Vue 应用程序开发的状态管理工具，相当于共享仓库，方便任何组件直接获取和修改。 state - 数据【存项目共享状态，是响应式的，store的数据改变，所有依赖此状态的组件会更新】 $store.state.count mutations - 方法【同步函数】 inc(state, 参数唯一) {} $store.commit(‘inc’, 2) getters - 包装数据 【store的计算属性，可缓存】 show: function(state) {} this.$store.getters.show 传参，返回函数：show(state) {return function(参数) {return …}}【不会缓存数据】 actions -【异步操作】【提交的是mutations，不直接修改状态】 increment(context, num) {context.commit()} this.$store.dispatch(‘’,arg) 使用 Vuex 管理数据，与直接在全局window下定义变量相比，有什么区别或者说优势？全局作用域下定义的数据是静态的，只能通过手动修改，修改后数据变了，但使用这些数据的组件并不会重新渲染，也必须得手动渲染。而且全局作用域下定义太多变量还容易造成变量污染。 Vuex 只要 store 中的数据更新，就会立即渲染所有使用 store 数据的组件。Vuex 使用单向数据流，要想修改 store 数据需要经过 action 层，mutation 层，层次划分明确，便于管理。 Vuex 是通过什么方式提供响应式数据的？在 Store 构造函数中通过 new Vue({}}) 实现的。利用 Vue 来监听 state 下的数据变化，给状态添加 getter、setter。 Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？Vuex 中修改 state 的唯一渠道就是执行 commit(‘xx’, payload) 方法，其底层通过执行 this._withCommit(fn) 设置_committing 标志变量为 true，然后才能修改 state，修改完毕还需要还原_committing 变量。外部修改虽然能够直接修改 state，但是并没有修改_committing 标志位，所以只要 watch 一下 state，state change 时判断是否_committing 值为 true，即可判断修改的合法性。 Vuex 原理vuex 仅仅是作为 vue 的一个插件而存在，不像 Redux,MobX 等库可以应用于所有框架，vuex 只能使用在 vue 上，很大的程度是因为其高度依赖于 vue 的 computed 依赖检测系统以及其插件系统， vuex 整体思想诞生于 flux,可其的实现方式完完全全的使用了 vue 自身的响应式设计，依赖监听、依赖收集都属于 vue 对对象 Property set get 方法的代理劫持。最后一句话结束 vuex 工作原理，vuex 中的 store 本质就是没有 template 的隐藏着的 vue 组件。 VueRouter 是什么？你平常是怎么用的？ 是什么：Vue-Router 是 Vue 官方的路由管理器 作用：为了页面跳转 原理：监听锚点值改变，渲染指定页面 123456789101112131415161718&lt;div class="h"&gt;我是头部&lt;/div&gt;&lt;div id="content" class="b"&gt;&lt;/div&gt;&lt;div class="f"&gt;我是底部&lt;/div&gt;&lt;script type="text/javascript"&gt;//监视锚点值的改变window.addEventListener('hashchange', function() &#123; var text = ''; switch (location.hash) &#123; case '#/music': text = '各种音乐的数据'; break; case '#/movie': text = '各种电影的数据'; break; &#125; document.getElementById('content').innerHTML = text;&#125;)&lt;/script&gt; 动态路由查询字符串： 去哪（列表页传参） xxx 导航（router中） { name:’detail’ , path:’/detail’, component: Detail } 去了干嘛（详情页接收参数）this.$route.query.id path方式： 去哪里 xxx 导航 { name:’detail’ , path:’/detail/:name’, component: Detail} 去了干嘛（获取路由参数）this.$route.params.name 编程式导航123456789// name配params：this.$router.push(&#123;name: 'Goods', params: &#123;goodsId:id&#125;&#125;)// path配query：this.$router.push(&#123;path: '/goods', query: &#123;goodsId:id&#125;&#125;)// 参数接收匹配：this.goodsId = this.$route.query.goodsIdthis.goodsId = this.$route.params.goodsId 路由守卫 全局守卫：beforeEach, beforeResolve, afterEach【没有next】 路由独享守卫：beforeEnter 组件内守卫：beforeRouteEnter【唯一next有回调】, Update, Leave 应用 全局守卫：beforeEach（用户登录以及权限判定） 123456789router.beforeEach((to, from, next) =&gt; &#123; const isLogin = localStroage.token // 个人中心需要登录 if (to.name === 'Member') &#123; isLogin ? next() : next('/login') &#125; else &#123; next() &#125;&#125;) 组件内守卫：beforeRouteEnter（根据用户从何而来，修改当前组件标题） 1234567// 详情页组件beforeRouteEnter(to, from, next) &#123; let title = '' title = from.name === 'news.list' ? '新闻详情' : '商品详情' // 一定要调用 next ，否则无法从列表页跳转到详情页 next(vm =&gt; vm.title = title) // 通过 vm 访问组件实例&#125; 讲一下完整的Vue路由生命周期 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 实现一个简单路由1234567891011121314151617181920212223// hash路由class Route&#123; constructor()&#123; // 路由存储对象 this.routes = &#123;&#125; // 当前hash this.currentHash = '' // 绑定this，避免监听时this指向改变 this.freshRoute = this.freshRoute.bind(this) // 监听 window.addEventListener('load', this.freshRoute, false) window.addEventListener('hashchange', this.freshRoute, false) &#125; // 存储 storeRoute (path, cb) &#123; this.routes[path] = cb || function () &#123;&#125; &#125; // 更新 freshRoute () &#123; this.currentHash = location.hash.slice(1) || '/' this.routes[this.currentHash]() &#125;&#125; vue脚手架生成的 router.js 中，有一段 base: process.env.BASE_URL 配置，你知道它引用了谁的路径么？1234const router = new Router(&#123; mode: 'history', base: process.env.BASE_URL, // &lt;- ... 它会和 vue.config.js 中的 publicPath 选项相符，即你的应用会部署到的线上/开发环境的基础路径： 12345const path = require('path')module.exports = &#123; // 旧版叫做baseURL // 线上/开发环境的路径配置 publicPath: process.env.NODE_ENV === 'production' ? 'http://你的线上环境' : '/', 你是如何使用插槽的？ 默认插槽：父html模板 | 子 具名插槽：父 | 子 作用域插槽：父 | 子提供数据 阅读更多：深入理解vue中的slot与slot-scope nextTick的更新原理Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。 nextTick的回调函数会等到同步任务执行完毕，DOM更新后才触发。 阅读更多：Vue.nextTick 的原理和用途 在 Vue 中，子组件为何不可以修改父组件传递的 Prop因为 prop 的传递是单向数据流，这样易于监测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。另外 props 传入的值如果对象的话，是可以直接在子组件里更改的，因为是同一个引用。 如果修改了，Vue 是如何监控到属性的修改并给出警告的123456789101112131415161718192021if (process.env.NODE_ENV !== 'production') &#123; var hyphenatedKey = hyphenate(key); if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) &#123; warn( ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."), vm ); &#125; defineReactive$$1(props, key, value, function () &#123; if (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123; warn( "Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm ); &#125; &#125;);&#125; 在initProps的时候，在defineReactive时通过判断是否在开发环境，如果是开发环境，会在触发set的时候判断是否此key是否处于updatingChildren中被修改，如果不是，说明此修改来自子组件，触发warning提示。 需要特别注意的是，当你从子组件修改的prop属于基础类型时会触发提示。 这种情况下，你是无法修改父组件的数据源的， 因为基础类型赋值时是值拷贝。你直接将另一个非基础类型（Object, array）赋值到此key时也会触发提示(但实际上不会影响父组件的数据源)， 当你修改object的属性时不会触发提示，并且会修改父组件数据源的数据。 虚拟DOM虚拟DOM实现原理? 虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象 状态变更时，记录新树和旧树的差异 最后把差异更新到真正的dom中 详细实现见虚拟DOM原理? 虚拟DOM的优劣如何?优点: 保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限 无需手动操作DOM: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率 跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等 缺点: 无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化 其它vue 的优点是什么？ 低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的”View”上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。 可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码。 可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。 当执行 import vue from ‘vue’ 时发生了什么？平时开发中，经常会用到这样一个语句： 1import Vue from 'vue'; 由于浏览器兼容性问题，通常这个语法是在 webpack 的构建流搭建的项目中执行的，那么这个语句到底做了什么呢？ 其实在 nodejs 中，执行 import 就相当于执行了 require，而 require 被调用，其实会用到 require.resolve 这个函数来查找包的路径，而这个函数在 nodejs 中会有一个关于优先级的算法。先看一下 import Vue from &#39;vue&#39; 这一句做了什么： import Vue from &#39;vue&#39; 解析为 const Vue = require(&#39;vue&#39;)。 require 判断 vue 是否未 nodejs 核心包，如我们常用的：path，fs 等，是则直接导入，否则继续往下走。 vue 非 nodejs 核心包，判断 vue 是否未 ‘/‘ 根目录开头，显然不是，继续往下走。 vue 是否为 ‘./‘、’/‘ 或者 ‘../‘ 开头，显然不是，继续往下走。 以上条件都不符合，读取项目目录下 node_modules 包里的包。 到了第五步，import Vue from &#39;vue&#39; 就找到了 vue 所在的实际位置了，那么问题来了，node_modules 下的 vue 是一个文件夹，而引入的 Vue 是一个 javascript 对象，那它是怎么取到这个对象呢？ 其实对于一个 npm 包，内部还有一个文件输出的规则，先看下 node_modules/vue 下的文件结构是怎么样的： 123456├── LICENSE├── README.md├── dist├── package.json├── src└── types 是不是看起来很笼统，其实对于 npm 包，require 的规则是这样的： 查找 package.json 下是否定义了 main 字段，是则读取 main 字段下定义的入口。 如果没有 package.json 文件，则读取文件夹下的 index.js 或者 index.node。 如果都 package.json、index.js、index.node 都找不到，抛出错误 Error: Cannot find module &#39;some-library&#39;。 那么看一下 vue 的 package.json 文件有这么一句： 12345&#123; ... "main": "dist/vue.runtime.common.js", ...&#125; 到这里就很清晰了： 1234import vue from 'vue';// 最后转换为const vue = require('./node_modules/vue/dist/vue.runtime.common.js'); 而 vue.runtime.common.js 文件的最后一行是：module.exports = Vue;，就正好跟我们平时使用时的 new Vue({}) 是一致的，这就是 import vue from &#39;vue&#39; 的过程了。 当然，这个是我们平时使用得最多的导入方式，还有其他一些导入规则，都可以在 nodejs 的文档 中找到。 文章来源：https://www.jianshu.com/p/fad3688cbd81 Vue 和 jQuery 有什么区别？jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：$(“label”).val();,它还是依赖DOM元素的值。 Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定，也就是MVVM。 谈谈你对 MVVM 开发模式的理解 Model 数据模型层，保存页面中的数据 View 视图层，页面数据的展示； ViewModel M，V调度者。双向数据绑定。通过监听 Model 数据的改变来控制V的更新，处理用户交互操作； M 数据改变 =&gt;VM =&gt; 触发 View 更新 V 用户操作 =&gt; VM =&gt; M 数据同步更新 开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom 。 请你讲一下Vue项目中使用token登录的具体流程对 token 完全不了解的同学可以查看我博客中转载的 这篇文章 。 不想看长篇大论的我这里简单描述下基于 token 身份验证的整个流程： 用户通过账户名和密码发送登录请求 服务端对账户的有效性进行验证 验证成功后再利用「密钥」和「加密算法」（如：HMAC-SHA256）对「用户数据」（如账号信息）做一个签名的 token 返回给客户端 客户端本地存储 token ，并在每次请求的 header 中带上 token 服务端验证 token 并返回数据 对于 Vue 项目来说，具体流程如下： 客户端：登录页带上用户名和密码请求登录接口 服务端：接收请求并在数据库中查询账户的有效性 服务端：查询通过后利用「密钥」和「加密算法」对「用户数据」做签名 token 并返回给客户端此 token （此 token 有时效性） 客户端：本地存储 token（如 localStorage + Vuex） 客户端：每次路由跳转前都要判断 localStorage 是否存在 token ，有则正常跳转，无则跳转回登录页 客户端：每次发送请求时，在 Axios 请求头里携带上 token 服务端：接收请求并判断请求头有无 token ，有且 token 没有过期，正常返回数据；无或 token 失效返回 401 状态码 客户端：一旦发现 401 则重定向到登录页 一般回答完毕后面试官还会追问一些细节，这里列举两个常问的： 你是如何利用 Axios 实现携带 token 以及 401 状态码判定的？ 利用 Axios 的请求/响应拦截。使用 axios.interceptors.request.use 进行请求拦截，判断 localStorage 是否有 token ，有则在请求头里携带 token 。使用 axios.interceptors.response.use 进行响应拦截，判断 response.status 是否为 401 ，是则代表 token 失效，清空本地 token ，跳转登录页 你是如何监控路由跳转，并在没有 token 时跳转回登录页的？ 使用 Vue Router 的全局路由守卫 router.beforeEach ，该方法接收三个参数：to、from 和 next ，如果用户访问的是不需要登录就能访问的页面（如 to.path === ‘/login’），则直接跳转。否则判断本地是否有 token ，有则调用 next() ，无则 next(‘/login’) 跳转回登录页 SPA 的缺点有哪些，如何解决？ 不利于SEO 首屏渲染时间过长 vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？首页白屏的原因：单页面应用的 html 是靠 js 生成，因为首屏需要加载很大的js文件(app.js vendor.js)，所以当网速差的时候会产生一定程度的白屏 解决办法： 1.将公用的JS库通过script标签外部引入，减小app.bundle的大小，让浏览器并行下载资源文件，提高下载速度； 2.在配置路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundle 的体积，在调用某个组件时再加载对应的js文件； 3.上骨架屏或loading动画，提升用户体验； 4.合理使用web worker优化一些计算 5.缓存一定要使用，但是请注意合理使用 6.最后可以借助一些工具进行性能评测，重点调优，例如chrome开发者工具的 performance 或 Google PageSpeed Insights 插件协助测试。]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS面试题（面试系列）]]></title>
    <url>%2Fposts%2F24235%2F</url>
    <content type="text"><![CDATA[ES6let / const全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？ES6规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let、const、class命令声明的全局变量，不属于顶层对象的属性。只在一个块级作用域（Script）中，获取时不加 window/global 就好： 12345let aa = 1;const bb = 2;console.log(aa); // 1console.log(bb); // 2 答案链接：关于 const 和 let 声明的变量不在 window 上 箭头函数箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异： 1、函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 2、不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 3、不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。 4、不可以使用 new 命令，因为： 没有自己的 this，无法调用 call，apply。 没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 proto new 过程大致是这样的： 123456789101112function newFunc(father, ...rest) &#123; var result = &#123;&#125;; result.__proto__ = father.prototype; var result2 = father.apply(result, rest); if ( (typeof result2 === 'object' || typeof result2 === 'function') &amp;&amp; result2 !== null ) &#123; return result2; &#125; return result;&#125; 题目来源：Daily-Interview-Question 第58题 Promise10 个 Ajax 同时发起请求，全部返回展示结果，并且至多允许三次失败，说出设计思路这个问题相信很多人会第一时间想到 Promise.all ，但是这个函数有一个局限在于如果失败一次就返回了，直接这样实现会有点问题，需要变通下。以下是两种实现思路 1234567891011121314151617181920212223242526272829303132333435363738// 以下是不完整代码，着重于思路 非 Promise 写法let successCount = 0let errorCount = 0let datas = []ajax(url, (res) =&gt; &#123; if (success) &#123; success++ if (success + errorCount === 10) &#123; console.log(datas) &#125; else &#123; datas.push(res.data) &#125; &#125; else &#123; errorCount++ if (errorCount &gt; 3) &#123; // 失败次数大于3次就应该报错了 throw Error('失败三次') &#125; &#125;&#125;)// Promise 写法let errorCount = 0let p = new Promise((resolve, reject) =&gt; &#123; if (success) &#123; resolve(res.data) &#125; else &#123; errorCount++ if (errorCount &gt; 3) &#123; // 失败次数大于3次就应该报错了 reject(error) &#125; else &#123; resolve(error) &#125; &#125;&#125;)Promise.all([p]).then(v =&gt; &#123; console.log(v);&#125;); JS 垃圾回收机制谈谈垃圾回收机制的方式及内存管理？题目及答案来源： 2019 前端面试 | “HTML + CSS + JS”专题 JavaScript 基础部分，编号为 [js_11] 一、垃圾回收机制——GC Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。 原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。 通常情况下有两种实现方式： 标记清除 引用计数 标记清除： js 中最常用的垃圾回收方式就是标记清除。 当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 引用计数的含义是跟踪记录每个值被引用的次数。 当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。 二、内存管理 Javascript 引擎基础 GC 方案是 （simple GC）：mark and sweep（标记清除），即： 1）遍历所有可访问的对象； 2）回收已不可访问的对象。 GC 的缺陷 和其他语言一样，JavaScript 的 GC 策略也无法避免一个问题：GC 时，停止响应其他操作，这是为了安全考虑。而 Javascript 的 GC 在 100ms 甚至以上，对一般的应用还好，但对于 JS 游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免 GC 造成的长时间停止响应。 GC 优化策略 1）分代回收（Generation GC） 这个和 Java 回收策略思想是一致的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次 GC 的耗时。 2）增量 GC 这个方案的思想很简单，就是“每次处理一点，下次再处理一点”，如此类推。 更多阅读： JS垃圾回收机制 哪些操作会造成内存泄漏？意外的全局变量引起的内存泄漏123function foo(arg) &#123; bar = '全局变量'; // 没有声明变量 实际上是全局变量=&gt;window.bar&#125; 原因：全局变量，不会被回收。 为什么不能泄漏到全局？平时不都会定义一些全局变量么：全局变量根据定义无法被垃圾回收机制收集。需要特别注意用于临时存储和处理大量信息的全局变量。如果必须使用全局变量来存储数据，请确保将其指定为null或在完成后重新分配它。 解决：使用严格模式避免，函数内使用var定义，块内使用let、const。 闭包引起的内存泄漏1234567function bindEvent() &#123; var obj = document.createElement("XXX"); var unused = function () &#123; console.log(obj,'闭包内引用obj obj不会被释放'); &#125;; // obj = null;&#125; 原因：闭包可以维持函数内局部变量，使其得不到释放，造成内存泄漏。 解决：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对dom的引用。例如上述案例，手动解除引用 obj = null 。 被遗忘的定时器和回调函数123456789var someResource = getData();setInterval(function() &#123; var node = document.getElementById('Node'); if(node) &#123; node.innerHTML = JSON.stringify(someResource)); // 定时器也没有清除 &#125; // node、someResource 存储了大量数据 无法回收&#125;, 1000); 原因：当不需要 setInterval 或者 setTimeout 时，定时器没有被clear，定时器的回调函数以及内部依赖的变量都不能被回收，造成内存泄漏。 解决：在定时器完成工作的时候，手动清除定时器 没有清理 DOM 元素引用12345var refA = document.getElementById('refA');document.body.removeChild(refA); // dom删除了console.log(refA, "refA"); // 但是还存在引用能console出整个div 没有被回收refA = null;console.log(refA, "refA"); // 解除引用 原因: 保留了DOM节点的引用,导致GC没有回收 解决：refA = null IE9以下浏览器环境导致的循环引用1234var element = document.getElementById('something');var myObject = new Object();myObject.element = element; // element属性指向domelement.someThing = myObject; // someThing回指myObject 出现循环引用(两个对象一直互相包含 一直存在计数)。 原因：IE9以下 BOM 和 DOM 对象使用 C++ 以 COM 对象的形式实现的。COM 的垃圾收集机制采用的是引用计数策略，这种机制在出现循环引用的时候永远都释放不掉内存。 解决：不使用它们的时候，手动切断链接：myObject.element = null; element.someThing = null; 闭包能讲下 JavaScript 的闭包么？一个函数包含了另一个函数或另一个对象，里面这个对象或函数都可以使用外部函数的变量或参数，此时就形成了闭包。 你平常怎么用闭包的？匿名自执行函数避免全局污染（模块化开发）创建了一个匿名立即执行函数，由于外部无法引用它内部的变量，因此在函数执行完后会立刻释放资源，不污染全局对象。 123456789101112const msg = (function () &#123; const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'] const today = new Date() const msg = 'Today is ' + days[today.getDay()] + ', ' + today.getDate() return &#123; getMsg() &#123; return msg &#125; &#125;&#125;())console.log(msg.getMsg()) 缓存数据有时候我们需要获取一个处理过程很耗时的对象，并且往往会把这个复杂的处理过程封装成一个方法。但每次需要用到它时都需要调用它从而花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包就可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。 12345678910111213141516171819202122var CachedSearchBox = (function () &#123; var cache = &#123;&#125;, count = []; return &#123; attachSearchBox: function (dsid) &#123; if (dsid in cache) &#123; //如果结果在缓存中 return cache[dsid]; //直接返回缓存中的对象 &#125; var fsb = new uikit.webctrl.SearchBox(dsid); //新建 cache[dsid] = fsb; //更新缓存 if (count.length &gt; 100) &#123; //保正缓存的大小&lt;=100 delete cache[count.shift()]; &#125; return fsb; &#125;, clearSearchBox: function (dsid) &#123; if (dsid in cache) &#123; cache[dsid].clearSelection(); &#125; &#125; &#125;;&#125;)(); 拿到正确的值12345for(var i = 0; i &lt; 10; i++) &#123; setTimeout(function()&#123; console.log(i) //10个10 &#125;, 1000)&#125; 解决方案：for循环中声明10个自执行函数，保存当时的值到内部 1234567for (var i = 0; i &lt; 10; i++) &#123; (function(j) &#123; setTimeout(() =&gt; &#123; console.log(j) &#125;, 1000); &#125;)(i)&#125; 高级排他场景：一个ul li列表，鼠标移入时高亮当前li标签，移除之前li标签的高亮状态。 常规写法：两层for循环，外层遍历li标签，给每个li添加 onmouseover 事件；里层for循环用来在高亮当前li标签之前，移除所有li标签高亮状态。 闭包写法：定义一个preIndex变量存储上次高亮li标签的索引，for循环内部使用立即执行函数+闭包保存index索引，这样就使li标签与index索引一一对应，然后在onmouseover事件触发后，根据preIndex找到之前高亮标签并移除高亮状态，并设置当前标签高亮，最后将preIndex设置为当前高亮标签的index索引。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; list-style: none; &#125; ul li &#123; width: 100%; height: 20px; margin-bottom: 5px; background-color: grey; &#125; li.active &#123; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li class="active"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; window.onload = function() &#123; let list = document.querySelectorAll('li') // 记录移动前选中li的对应索引 let preActiveIndex = 0 for (let i = 0; i &lt; list.length; i++) &#123; (function(j) &#123; const li = list[i] li.onmouseover = function() &#123; // 清除 list[preActiveIndex].className = '' // 设置 this.className = 'active' // 赋值 preActiveIndex = j &#125; &#125;)(i) &#125; &#125; // 常规写法 // window.onload = function() &#123; // let list = document.querySelectorAll('li') // for (let i = 0; i &lt; list.length; i++) &#123; // const li = list[i] // li.onmouseover = function() &#123; // for (let j = 0; j &lt; list.length; j++) &#123; // list[j].className = '' // &#125; // this.className = 'active' // &#125; // &#125; // &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 闭包会产生哪些问题？闭包会使函数中的变量不能及时释放，造成内存消耗过大，从而导致网页的性能问题。不过目前浏览器引擎都基于 V8，而 V8 引擎有个 gc 回收机制，不用太过担心变量不会被回收。 Event LoopsetTimeout、Promise、Async/Await 的区别这题主要是考察这三者在事件循环中的区别，事件循环中分为宏任务队列和微任务队列。其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。 题目来源：https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/33 概念性问题观察者模式与发布订阅模式有什么区别可以把观察者模式想象成顾客与微商的关系。顾客关注了微商的商品，微商就会记住顾客，每当微商有新产品时，就会直接私聊来通知所有关注了自己的顾客。这里的顾客就相当于观察者，微商就是被观察者。 而发布订阅模式可以看做是顾客通过「商城平台」关注了商家的商品，商家一旦上新就通过「商城平台」向关注了自己的顾客群发消息，这里的顾客就是订阅者，「商城平台」就是事件总线，商家就是发布者。 通过上面两个例子就能看出，观察者模式的模型跟发布/订阅者模型里，差距就差在有没有一个中央的事件总线。如果有这个事件总线，我们就可以认为是个发布订阅模型。如果没有，那么就可以认为是个观察者模型。因为其实它们都实现了一个关键的功能：发布事件-订阅事件并触发事件。 讲一下面向对象的三大特征？封装继承和多态 不过这个回答到以后，肯定会问你具体啥意思的，不了解的同学可点击 这个 链接查看。 什么是重写，什么是重载？重写就是子类覆盖掉父类的方法重载就是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 开放性提问这部分就只放题目不给参考答案了，毕竟每个人经历不同，放这儿让你们有个准备吧。 你在平时写项目中遇到的最大的困难在哪，又是如何解决掉的？ 你简历上的项目作品中，挑一个讲一下存在哪些技术难点？ 在使用Vue过程中遇到过哪些印象深刻的问题，如何解决的？ 未来3-5年对自己的计划？ 为什么喜欢前端？ 对自己做一个自我评价吧 谈谈你自己的不足，或者想提升的？ 做的最成功的一件事？ 有没有什么主动争取的东西？ 你是怎么学前端的？ 平时有关注一些博客什么的吗，讲一个最近看的？ 你还有什么想问我的嘛？]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode自定义snippet片段]]></title>
    <url>%2Fposts%2F17235%2F</url>
    <content type="text"><![CDATA[最近我有个需求，想要在 github 上使用 markdown 语法时居中图片，然而搜了几种办法都无效，最后在 DavidWells 的 gist 中找到了答案（p.s. 如果无法翻墙，你还可以参考 这篇博客） 解决了一个问题又出现了另一个，其实我已经把博客写完了，但其中需要居中的图片比较多，而居中代码还比较繁琐，要是一个个手动替换也太麻烦了。然后就想到了使用 snippet ，官网教程在这里：Creating your own snippets 具体该如何实现呢： Code → 首选项 → 用户代码片段 在弹出的下拉列表中输入你想要在哪种文件中使用这种片段（例如我只希望在 markdown 文件中使用，就键入 markdown） 此时 vs code 就会帮我们自动新建一个名为 markdown.json 的文件，我们在这个 json 文件中定义我们的代码片段就好了 接着我们进入该文件，编写 snippet 配置： 1234567891011&#123; "Img centered": &#123; "prefix": "mimg", "body": [ "&lt;div align=center&gt;", "\t&lt;img src='$1' alt='$2' width='$3'&gt;", "&lt;/div&gt;" ], "description": "Centered image in markdown" &#125;&#125; 然而当我保存后在 md 文件中使用时，按下 tab 并没有效果，经过阅读官方文档，发现有这样一句话：Enable it with &quot;editor.tabCompletion&quot;: &quot;on&quot;, type a snippet prefix, and press Tab to insert a snippet. 所以你还需要进入 首选项 → 设置 ，在顶部输入框键入 editor.tabCompletion 来搜索此配置，将 off 改为 on 就 OK 了 现在大功告成，在 md 文件中，键入 mimg 后按下 tab 键，先前写好的 snippet 就能够使用了 结语：关于 vs code 的 snippet 片段，网上非常多教程，大家自行搜索就好，这篇笔记的重点是上方第 6 步把 editor.tabCompletion 改为 on 。这一步至关重要，不修改会导致你以为自己的 snippet 设置没生效。]]></content>
      <categories>
        <category>前端</category>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器面试题（面试系列）]]></title>
    <url>%2Fposts%2F38402%2F</url>
    <content type="text"><![CDATA[cookie 与 本地存储 相关cookie、session、localStorage 分别是什么？cookie 是存储在浏览器上的一小段数据，用来记录某些当页面关闭或者刷新后仍然需要记录的信息。 用户在输入用户名密码提交给服务端，服务端验证通过后会创建一个 session 用于记录用户的相关信息，这个 session 可保存在服务器内存中，也可保存在数据库中。 localStorage HTML5 本地存储 web storage 特性的 API 之一，用于将大量数据（最大 5M）保存在浏览器中，保存后数据永远存在不会失效过期，除非用 JS 手动清除。 cookie 的使用123456789101112131415161718192021// 设置document.cookie = 'age=16' // 每次只能设置一对cookie// 获取document.cookie // 获取全部cookie值，获取特定用循环// 删除document.cookie = 'name=xiaoming; max-age=-1000' // 设置一个当前之前的时间即可// 设置过期时间var name = 'one_name'var value = '123'var exp = new Date()exp.setTime(exp.getTime() + 60 * 2000) // 过期时间 2分钟document.cookie = name + "=" + escape(value) + ";expires=" + exp.toGMTString()console.log(name + "=" + escape(value) + ";expires=" + exp.toGMTString())// 如果不在浏览器中设置过期时间，cookie 被保存在内存中，生命周期随浏览器的关闭而结束，// 这种 cookie 简称会话 cookie。// 如果在浏览器中设置了 cookie 的过期时间，cookie 被保存在硬盘中，// 关闭浏览器后，cookie 数据仍然存在，直到过期时间结束才消失。 cookie, localStorage 和 sessionStorage 的区别用途 cookie：是服务器发给浏览器保存的（字符串）数据，一般用来记录用户信息方便服务端确认用户身份 localStorage、sessionStorage：本地存储，可以保存一些不太重要的数据，例如当前用户坐标，购物车信息等 存储大小 cookie：4k localStorage, sessionStorage：5M 有效期 cookie：关闭浏览器失效（默认） localStorage：永久，除非js手动删和清除浏览器缓存 sessionStorage：页面不关闭就不失效，包括重新加载或恢复页面也不失效。但在新标签或窗口打开一个页面，则会重新生成 cookie 与 session 区别都是用来确认用户身份的，区别在于 cookie 保存在客户端，session 保存在服务端。 另外，session 是基于 cookie 的。服务器端在生成 session 后，会让客户端的 cookie 代为保存 sessionID 。 阅读： 一文带你看懂cookie，面试前端不用愁 聊一聊cookie Cookie禁用了，Session还能用吗？ session,cookie,sessionStorage,localStorage的区别及应用场景 如何实现同一个浏览器多个标签页之间的通信？1. websocket 通讯 全双工（full-duplex）通信自然可以实现多个标签页之间的通信。 2. 定时器 setInterval+cookie 在页面 A 设置一个使用 setInterval 定时器不断刷新，检查 Cookies 的值是否发生变化，如果变化就进行刷新的操作。 3. 使用 localStorage localStorage 是浏览器多个标签共用的存储空间，所以可以用来实现多标签之间的通信（ps：session 是会话级的存储空间，每个标签页都是单独的）。 直接在 window 对象上添加监听即可： 1234window.onstorage = (e) =&gt; &#123;console.log(e)&#125;// 或者这样window.addEventListener("storage", (e) =&gt; console.log(e)) HTML5的离线储存使用，解释工作原理？ 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。 原理：HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 如何使用： 页面头部像下面一样加入一个manifest的属性 在 cache.manifest 文件的编写离线存储的资源 在离线状态时，操作 window.applicationCache 进行需求实现。 详细的使用请参考： HTML5 离线缓存-manifest简介 有趣的HTML5：离线存储 浏览器对 HTML5 离线储存资源的管理和加载？在线的情况下: 浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下: 浏览器就直接使用离线存储的资源。 用户点外卖的份数怎么和后台通信？万一用户中断了再进了怎么获取？为什么不用 cookie？ 将购物车信息存在 localStorage 从 localStorage 中获取 用户禁用 cookie 时无法使用 兼容性经常遇到的浏览器的兼容性有哪些？ IE 浏览器不支持 Promise babel-polyfill → webpack.config.js 的 entry 中设置 [‘babel-polyfill’, ‘./src/main.js’] 各浏览器之间默认样式的差异 normalize.css 与 reset 区别 → normalize.css 消除各浏览器之间默认样式的差异、保留有用的默认样式；而 reset 会清除所有的默认样式，过于暴力，例如会让 h 标题标签不再默认加粗，ul li 前面默认的小圆点也没了） html5 某些新增标签不被识别 html5shiv.js - 解决 ie9 以下对 html5 某些新增标签不识别的问题（e.g. video标签不识别不显示） 用法：[if lt IE 9]&gt;&lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;&lt;![endif] 通过 document.createElement 方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。 CSS3 媒体查询失效 respond.js - 能解决 ie9 以下不支持媒体查询问题 自动添加浏览器前缀 posscss-loader+autoprefixer ie6 不支持 min-height/width 添加额外的 _min-height ie6 识别 常见hack（针对特定ie版本的样式控制） _color - ie6 识别 *color - ie6/7 识别 color: red\9; ie8及以下识别 ie条件注释写法：(lt 小于 | gt 大于 | lte 小于等于 | gte 大于等于 | ! 不等于) 移动端兼容性呢？ 移动端点透问题 解决方案 ios滚动卡顿 使用 better-scroll 插件 ios 顶部输入框 fixed 布局失效（当键盘弹起时）❌ 安卓 键盘遮挡输入框 ❌ position:fixed; 在 android 下无效怎么处理？【❌待验证】原因： fixed 的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的 viewport ，原来的网页还好好的在那，fixed 的内容也没有变过位置。 解决： 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"/&gt; 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？❌click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。 在做移动端项目时遇到过什么问题？参考阅读：H5与APP混合开发遇到的问题总结 Polyfill什么是 Polyfillpolyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。 例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象，所有这些都是 W3C 地理位置 API 定义的对象和函数。 因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发，一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。 做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？❌比如： html5shiv、Geolocation、Placeholder 列举IE与其他浏览器不一样的特性？事件目标对象触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性 获取字符代码如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性 阻止某个事件的默认行为IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法 停止事件冒泡IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation() 通信如何实现浏览器内多个标签页之间的通信? (阿里)WebSocket、SharedWorker； 也可以调用 localStorage 、cookies 等本地存储方式； localStorage 另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件， 我们通过监听事件，控制它的值来进行页面信息通信； 注意：Safari 在无痕模式下设置localStorage 值时会抛出 QuotaExceededError 的异常； webSocket 如何兼容低浏览器？(阿里)Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 页面渲染与缓存从输入 URL 到页面展现中间发生了什么？ DNS 查询 建立 TCP 连接（三次握手） 发送 HTTP 请求 服务端web服务器对请求做处理（监听80端口 路由 渲染HTML模板 生成响应） 发送 HTTP 响应 关闭 TCP 连接（四次挥手） 浏览器解析HTML，CSS，图片，JS 处理 HTML 标记并构建 DOM 树 处理 CSS 标记并构建 CSS 规则树 将 DOM树 与 CSS规则树 合并成一个渲染树。 根据渲染树来布局，以计算每个节点的几何信息。 将各个节点绘制到屏幕上 这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM 阅读更多： 浏览器的渲染：过程与原理 细说浏览器输入URL后发生了什么 style 标签写在 body 后与 body 前（head）有什么区别？style 标签放在 body 后，会导致当加载到此样式时，页面将停止之前的渲染。此样式表被解析后，将重新渲染页面，也就出现了短暂的花屏现象。 所以不要写在 body 后，要把样式放在 head 中。 缓存策略执行过程 一个 Response Header 示例 强缓存与协商缓存的异同 相同点：最终都是走的本地缓存 不同点：强缓存不发请求，直接读本地缓存。协商缓存发请求到服务器 基本原理 1）浏览器在加载资源时，根据请求头的 expires 和 cache-control 判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。 2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过 last-modified 和 Etag 验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源 3）如果前面两者都没有命中，直接从服务器加载资源 如何实现页面每次打开时清除本页缓存？ 用 HTML 标签设置 HTTP 头信息： 1234&lt;meta http-equiv="Pragma" content="no-cache"&gt;header("Cache-Control: no-cache, must-revalidate")&lt;meta http-equiv="Cache-Control" content="no-cache"&gt;&lt;meta http-equiv="Expires" content="0"&gt; 说明：HTTP 头信息 Expires 和 Cache-Control 为应用程序服务器提供了一个控制浏览器和代理服务器上缓存的机制。 HTTP 头信息 Expires 告诉代理服务器它的缓存页面何时将过期。 HTTP1.1 规范中新定义的头信息 Cache-Control 可以通知浏览器不缓存任何页面。当点击后退按钮时，浏览器重新访问服务器已获取页面。 ​ 如下是使用 Cache-Control 的基本方法： ​ 1）no-cache：强制缓存从服务器上获取新的页面； ​ 2）no-store：在任何环境下缓存不保存任何页面。 ​ HTTP1.0 规范中的 Pragma: no-cache等同于 HTTP1.1 规范中的 Cache-Control: no-cache，同样可以包含在头信息中。 在需要打开的 url 后面增加一个随机的参数：增加参数前：url=test/test.jsp增加参数后：url=test/test.jsp?ranparam=random() expires 和 cache-control 的区别都是用的本地系统时间，但 expires 存的是个服务端绝对时间，修改客户端系统时间会有影响 cache-control 是相对时间，即使客户端时间发生改变，相对时间也不会随之改变。例如设置 max-age = 10s，那么在 10s 以内，使用浏览器缓存的资源 cache-control 的优先级高于 expires http get 和 post 区别 语义：GET 用来读数据，POST 用来写数据 参数：GET 放在 url 里，POST 放消息体里 大小：GET 长度有限制，一般 1024 个字符。POST 4~10Mb 限制 缓存：GET 请求可以被浏览器缓存，POST 不能 cache-control 和 Etag 的区别一个不发请求，一个发请求。超过缓存时间，只要 if-None-Match 和服务器端 etag 相同，仍然缓存。并且 Etag 比 cache-control 的优先级更高。 http 和 https 的区别HTTPS 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS作用 一种是建立一个信息安全通道，来保证数据传输的安全 另一种就是确认网站的真实性。 区别 https 协议需要到 ca 申请证书，有免费付费可选 http是明文传输，https 则是具有安全性的 ssl 加密传输协议。 非对称加密 性能问题：https 做了加密就意味着客户端服务端也需要附带解密步骤，相比来说，在通讯快捷上，性能有所不如 http 。 对非对称性加密的理解 不要去硬记。 你只要想：既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证。 参考： 非对称加密与HTTPS 完全理解 HTTPS 如何做到传输安全 介绍 HTTPS 握手过程 客户端使用https的url访问web服务器,要求与服务器建立ssl连接 web服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端 客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥 客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥 之后服务器与客户端使用秘钥加密传输 参考来源： 第 44 题：介绍 HTTPS 握手过程 阅读更多： 一次安全可靠的通信——HTTPS原理 HTTP1.1 与 HTTP2 的区别 基于HTTPS的 多路复用 服务端推送 简单讲解一下 http2 的多路复用阅读更多：多路复用 HTTP2采用二进制格式传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。 多路复用代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。 HTTP2中： 同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。 单个连接上可以并行交错的请求和响应，之间互不干扰。 阅读更多： HTTP1.0、HTTP1.1 和 HTTP2.0 的区别 性能优化你有用过哪些前端性能优化的方法？资源合并压缩 压缩 html，css，js【html-webpack/optimize-css-assets/webpack-parallel-uglify】-plugin 图片：image-webpack-loader，雪碧图，iconfont图标字体 合并 减少http请求，每个http请求都带来慢启动，三次握手，连接建立，所以资源合并由为重要 服务端启用 gzip（压缩率80%） 浏览器请求 header 设置 accept-encoding: gzip 服务器响应 header 返回 content-encoding: gzip【apache的 httpd.conf】 浏览器加载原理优化原理：html 在转 DOM 时，节点引用 css/img 不影响继续转化，但 js 会阻塞，因为 js 有可能修改 dom 树 css 放 head js 尽量不放 head，如果放则 js 内嵌，且在所有css前面 | 对于会阻塞后续内容的外部 js ，用 defer 首屏优化 懒加载：列表滚动图片懒加载 按需加载 webpack codespliting 使用cdn加速：把静态资源（能被浏览器缓存的js/css）分发到离用户最近节点就近获取，提高响应速度和成功率 缓存优化 http协议缓存：强缓存/协商缓存 使用浏览器缓存来减少请求数量 css，js 加 MD5 后缀 本地存储 localStorage （地理位置，购物车） app cache ❌ service worker ❌ 渲染优化 减少重绘和重排 集中改变样式（cssText，类名切换） 批量修改DOM（display:none，createDocumentFragment） 读写分离（尽量不要一行代码又读又写 div.style.left = div.offsetLeft + 1 + ‘px’; &lt;=重复两次就是两次重排，先存起来就只会导致一次重排） 动画 css3动画 webkit-transform: translateZ(0); / will-change: transform; GPU渲染，浏览器生成DOM元素快照，在GPU的层上缓存起来做单独做动画 js动画 使用 requestAnimationFrame 提升流畅度（确保js尽早在每一帧开始时执行） 列表滚动重用（类似ios cell复用）❌ 使用SSR（server side rendering）后端渲染，数据直接输出到HTML ❌ 其它检测浏览器版本版本有哪些方式？功能检测、userAgent特征检测 123比如：navigator.userAgent//"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36(KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36" 判断用户的浏览器类型123456789101112function isAndroid() &#123; return /Android/.test(navigator.userAgent);&#125;function isiPhone() &#123; return /iPhone/.test(navigator.userAgent);&#125;function isiPad() &#123; return /iPad/.test(navigator.userAgent);&#125;function isiOS() &#123; return /(iPhone)|(iPad)/i.test(navigator.userAgent);&#125; 介绍一下你对浏览器内核的理解主要分成两部分： 渲染引擎(Layout engineer 或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 详细文章：浏览器内核的解析和对比 常见状态码形象记忆：https://http.cat/ 200 服务器成功返回请求 301 永久重定向，浏览器会记住 | 302 临时重定向 | 304 请求页面未修改 400 请求错误，服务器不理解 | 401 请求未授权 | 403 服务器拒绝请求 | 404 资源不存在 | 405 方法禁用 500 服务器内部错误 | 503 服务暂时不可用（超载or停机维护） 谈谈你对 TCP 三次握手和四次挥手的理解 答案地址 页面可见性(Page Visibility API)有哪些用途 通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等; 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放； 网页验证码干嘛的,是为了解决什么安全问题区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。 如果需要手动写动画，你认为最小时间间隔是多久，为什么？多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms 第一次访问页面中时弹出引导，用户关闭引导，之后再次进入页面时不希望出现引导，如何实现？❌localStorage 实现一个页面操作不会整页刷新的网站，并且能在浏览器的前进，后退时正确响应。给出你的技术实现方案？ onhashchange window.history.pushState（添加新的历史记录）/replaceState(state,title, url)【改掉当前历史记录】 配合 onpopstate 事件来监听历史记录的改变 websocket实现了客户端与服务端之间的全双工通信，当服务端数据变化时，可以第一时间通知到客户端。 与 HTTP 的区别 http 只能由客户端发起，而 webSocket 是双向的 webSocket 传输的数据包相对于 http 而言很小，很适合移动端使用 没有同源限制，可以跨域共享资源 TCP 和 UDPTCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来 TCP三次握手过程 第一次握手：主机 A 通过向主机 B 发送一个含有同步序列号的标志位的数据段给主机 B ，向主机 B 请求建立连接，通过这个数据段， 主机 A 告诉主机 B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。 第二次握手：主机 B 收到主机 A 的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机 A，也告诉主机 A 两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我 第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段：”我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机 A 和主机B 就可以传输数据了。 TCP断开连接要进行4次 第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ； 第二次： 主机 B 收到 FIN 后对其作出响应，确认这一方向上的 TCP 连接将关闭,将ACK置1； 第三次： 由 B 端再提出反方向的关闭请求，将 FIN 置 1 ； 第四次： 主机 A 对主机 B 的请求进行确认，将 ACK 置 1 ，双方向的关闭结束。 UDP（User Data Protocol，用户数据报协议）UDP 是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 TCP 与 UDP 的区别1、TCP 面向连接；UDP 不面向连接； 2、TCP 传输可靠（三次握手），UDP 则不可靠，不保证正确性（UDP 传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发）； 3、UDP 开销小，传输快； 使用场景 TCP：效率要求相对低，但对准确性要求相对高的场景（文件传输，邮件接收，远程登录） UDP：效率要求相对高，但对准确性要求相对低的场景（在线视频，语音电话） 参考：TCP 和 UDP 的区别 网络七层协议 参考：OSI七层协议大白话解读 CDN是什么Content Delivery Network，简称CDN，翻译成中文是内容分发网络。 CDN是通过在网络上的各个地方放置一定数量的节点服务器，构成在现有的互联网基础之上的一层智能虚拟网络，这层网络的主要功能是将信息（源站内容）分发至靠近用户的各个节点服务器上，让用户可以就近获取所需信息。 通过CDN，可以有效降低源站的访问压力，减轻骨干网络的拥塞，提升用户的访问速度，从而提升用户体验。还可在一定程度上保障源站的安全。 CDN 的用途可以说很窄，也可以说很广。说窄是因为CDN只是基于互联网之上的一种服务，只是给网络/网站加速的；说广是因为几乎所有的互联网业务（如网页、电商、APP、游戏、下载、影视点播、直播等等）都需要用到 CDN ，而如今互联网又无处不在。 来源：https://www.zhihu.com/question/282510029/answer/427307826]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS笔试题（面试系列）]]></title>
    <url>%2Fposts%2F41818%2F</url>
    <content type="text"><![CDATA[JS类型相关typeof 没定义的变量会报错吗？typeof let定义了的呢？ 未声明的变量使用 typeof 返回字符串 “undefined” typeof 一个 let 定义的变量会因为暂时性死区报错 ReferenceError（前提：let/const 未声明之前赋值或使用） 1234567891011var tmp = 123if (true) &#123; tmp = 'abc' // ReferenceError: tmp is not defined let tmp&#125;console.log(typeof tmp) // ReferenceError: tmp is not definedlet tmplet tmpconsole.log(typeof tmp) // undefined 不会报错 typeof 的值有哪些7种数据类型（返回的都是字符串形式）： string, number, function, object, undefined, boolean, symbol（表独一无二的值） 注意： null 和 数组 返回的都是 object NaN 返回的是 number valueOf 和 toString toString(): 返回一个反映这个对象的字符串。 valueOf(): 返回它相应的原始值。 字符串判断一个单词是否是回文1234var str = "mamam"function checkPalindrom(str) &#123; return str === str.split('').reverse().join('')&#125; 验证回文字符串给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 输入: “A man, a plan, a canal: Panama” 输出: true 输入: “race a car” 输出: false 123456789var str = "A man, a plan, a canal: Panama"var isPalindrome = function (s) &#123; var reg = /[^A-Za-z0-9]/g var tempStr = s.replace(reg, "") var reverseStr = tempStr.split("").reverse().join("") return reverseStr.toLowerCase() === tempStr.toLowerCase()&#125;;console.log(isPalindrome(str)) 统计字符串出现最多的字母12345678910111213141516171819202122var str = "afjghdfraaaasdenas"function findMaxDuplicateChar(str) &#123; if (str.length == 1) return str let charObj = &#123;&#125; for (let i = 0; i &lt; str.length; i++) &#123; if (!charObj[str.charAt(i)]) &#123; charObj[str.charAt(i)] = 1 &#125; else &#123; charObj[str.charAt(i)] += 1 &#125; &#125; let maxChar = '', maxValue = 1 for (var key in charObj) &#123; if (charObj[key] &gt;= maxValue) &#123; maxChar = key maxValue = charObj[key] &#125; &#125; return maxChar&#125; 字符串中的第一个唯一字符给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 s = “leetcode” 返回 0. s = “loveleetcode” 返回 2. 1234567891011var str = "leetcode"function firstUniqChar(str) &#123; for (var i = 0; i &lt; str.length; i++) &#123; var curChar = str[i] if (str.lastIndexOf(curChar) === str.indexOf(curChar)) &#123; return i &#125; &#125; return -1&#125;console.log(firstUniqChar(str)) 有效的字母异位词即判断字符串中是否只有字符的位置不同，也就是判断两个字符串中包含的字符以及这些字符出现的次数是否相同 输入: s = “anagram”, t = “nagaram” 输出: true 输入: s = “rat”, t = “car” 输出: false 12345678var s = "anagram", t = "nagaram"function isAnagram(s, t) &#123; if (s.length !== t.length) return false; var ss = s.split("").sort().join("") var tt = t.split("").sort().join("") return ss === tt ? true : false&#125;console.log(isAnagram(s, t)) 判断一个给定的字符串是否是同构的 输入: s = “egg”, t = “add”输出: true输入: s = “foo”, t = “bar”输出: false 12345678910var isIsomorphic = function(s, t) &#123; var i = 0 while (i &lt; s.length) &#123; if (s.indexOf(s[i]) != t.indexOf(t[i]))&#123; return false &#125; i++ &#125; return true&#125; 报数报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 123451. 12. 113. 214. 12115. 111221 1 被读作 &quot;one 1&quot; (&quot;一个一&quot;) , 即 11。 11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。 21 被读作 &quot;one 2&quot;, “one 1&quot; （&quot;一个二&quot; , &quot;一个一&quot;) , 即 1211。 12345678910111213141516171819202122232425var countAndSay = function (n) &#123; // 从1开始报数 var result = '1' // 循环第 N 次 for (let i = 1; i &lt; n; i++) &#123; // 默认当前连续的数字的次数为1 var repeatCount = 1 var str = '' // 循环当前数字 for (let j = 0; j &lt; result.length; j++) &#123; console.log(result[j], result[j + 1]) // 当前数字和后面一个是否相同，相同则重复数计数+1 if (result[j] === result[j+1]) &#123; repeatCount++ &#125; else &#123; // 否则就把到目前为止的报数“读出来” str += repeatCount + result[j] repeatCount = 1 &#125; &#125; // 当前第N次报数的结果，下次报数以此为准 result = str &#125; return result&#125; 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。 输入: [“flower”,”flow”,”flight”] 输出: “fl” 输入: [“dog”,”racecar”,”car”] 输出: “” 1234567891011121314151617var arr = ["flower", "flow", "flight"]function longestCommonPrefix(arr) &#123; if (!arr.length) return "" var firstStr = arr[0] var result = "" for (var i = 0; i &lt; firstStr.length; i++) &#123; for (var j = 1; j &lt; arr.length; j++) &#123; if (firstStr[i] !== arr[j][i]) &#123; return result &#125; &#125; result += firstStr[i] &#125; return result&#125;console.log(longestCommonPrefix(arr)) 生成指定长度的随机字母数字字符串1234567function getRandomStr(len) &#123; var str = "" for (var i = 0; i &lt; len; i++ ) &#123; str += Math.random().toString(36).substring(2) &#125; return str.substring(0, len)&#125; 如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC’ 变成 ‘aBc’123456789101112// 方法一：常规function transformStr(str) &#123; let tempArr = str.split('') let result = tempArr.map(char =&gt; &#123; return char === char.toUpperCase() ? char.toLowerCase() : char.toUpperCase() &#125;) return result.join('')&#125;console.log(transformStr('aBc'))// 方法二：正则'aBc'.replace(/[A-Za-z]/g, char =&gt; char === char.toUpperCase() ? char.toLowerCase() : char.toUpperCase()) 题目来源：Daily-Interview-Question 第69题 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。1234567const find = (S, T) =&gt; &#123; if (S.length &lt; T.length) return -1 for (let i = 0; i &lt; S.length; i++) &#123; if (S.slice(i, i + T.length) === T) return i &#125; return -1&#125; 用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。123456789101112function test(num) &#123; var str = num + ""; if (str.length &gt; 1) &#123; var newStr = str.substring(str.length - 1); var oldStr = str.substring(0, str.length - 1); return newStr + test(oldStr); &#125; else &#123; return str; &#125;&#125;console.log(test(123)); 找出字符串中连续出现最多的字符和个数12'abcaakjbb' =&gt; &#123;'a':2,'b':2&#125;'abbkejsbcccwqaa' =&gt; &#123;'c':3&#125; 解答： 1234567891011121314151617181920212223242526const str = "abcaakjbb";function findLongest (str) &#123; if (!str || typeof str !== 'string') return &#123;&#125; var obj = &#123;&#125;, maxCount = 0, // 最大连续次数 curCount = 1 // 当前连续次数（默认最小连续次数为1） for (let i = 0; i &lt; str.length; i++) &#123; var curChar = str[i] // 当前字符 if (curChar === str[i + 1]) &#123; // 如果连续 ++curCount // 当前连续次数+1 if (maxCount &lt; curCount) &#123; maxCount = curCount obj = &#123; [curChar]: maxCount &#125; // 只要当前连续次数比之前的大，就直接覆盖obj &#125; if (maxCount === curCount) &#123; // 有可能若干字符连续次数相同，那么追加到obj obj[curChar] = maxCount &#125; &#125; else &#123; // 如果不连续 curCount = 1 // 重置连续次数 &#125; &#125; return obj&#125;console.log(findLongest(str)); 数组判断数组的方法12345678910var arr = [1, 2, 3]arr instanceof ArrayObject.prototype.toString.call(arr) === '[object Array]'Array.isArray(arr)arr.constructor === Array // 前提是保证 constructor 不会被更改// 不能使用 typeof 因为 它返回的是个 'object' JS数组去重123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var arr = [1, 1, "1", "1", NaN, NaN, &#123;&#125;, NaN]// 方法1：indexOf去重（无法对 对象，NaN 识别去重）// → indexOf 不认 NaN，遇到NaN就返回 -1function myDistinct(arr) &#123; var result = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (result.indexOf(arr[i]) === -1) &#123; result.push(arr[i]) &#125; &#125; return result&#125;// 返回数组：[ 1, '1', NaN, NaN, &#123;&#125;, &#123;&#125;, NaN ]// 原数组：[ 1, 1, '1', '1', NaN, NaN, &#123;&#125;, &#123;&#125;, NaN ]// 方法2：filter + indexOf（对 对象 和 NaN 无效）function myDistinct(arr) &#123; var result = arr.filter((item, index, arr) =&gt; &#123; // 重复的值的索引肯定大于第一次出现这个值的索引，不会被返回 return arr.indexOf(item) === index &#125;); return result&#125;// 返回数组：[ 1, '1', &#123;&#125;, &#123;&#125; ]// 原数组：[ 1, 1, '1', '1', NaN, NaN, &#123;&#125;, &#123;&#125;, NaN ]// 方法3：filter 升级版（解决了 对象 和 NaN 的问题）function myDistinct(arr) &#123; var obj = &#123;&#125; return arr.filter((item, index) =&gt; &#123; // 由于对象的键值只能是字符串，导致 1 和 '1' 被认为是相同的值，所以下方使用 typeof item + item 拼成字符串作为 key 值来避免这个问题 return obj.hasOwnProperty(typeof item + JSON.stringify(item)) ? false : obj[typeof item + JSON.stringify(item)] = true &#125;)&#125;// 返回数组：[ 1, '1', NaN, &#123;&#125; ]// 原数组：[ 1, 1, '1', '1', NaN, NaN, &#123;&#125;, &#123;&#125;, NaN ]// 方法4：for循环（解决了 对象 和 NaN 的问题）~function() &#123; var arr = [1, 1, "1", "1", NaN, NaN, &#123;&#125;, NaN] var prop = Array.prototype prop.myDistinct = function myDistinct() &#123; var hash = &#123;&#125; for (var i = 0; i &lt; this.length; i++) &#123; var temp = typeof this[i] + JSON.stringify(this[i]) if (hash[temp]) &#123; this[i] = this[this.length - 1] this.length-- i-- continue &#125; hash[temp] = true &#125; return this &#125; console.log(arr.myDistinct())&#125;()// 方法5：ES6 Set去重（能应对NaN重复，对对象无效）function myDistinct(arr) &#123; return [...new Set(arr)]&#125; 两个数组比较，判断是否有相同元素（交集）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var nums1 = [1, 2, 3, NaN, &#123;&#125;]var nums2 = [2, 2, 8, 10, NaN, &#123;&#125;]// 方法1：filter + indexOf（不支持 NaN 和 &#123;&#125;）function intersect(nums1, nums2) &#123; return nums1.filter(v =&gt; &#123; const index = nums2.indexOf(v) if (index &gt; -1) &#123; nums2.splice(index, 1) return v &#125; &#125;)&#125;console.log(intersect(nums1, nums2))// 方法2：filter + indexOf（支持 NaN，不支持 &#123;&#125;）function intersect(nums1, nums2) &#123; const aHasNaN = nums1.some(v =&gt; isNaN(v)) const bHasNaN = nums2.some(v =&gt; isNaN(v)) return nums1.filter(v =&gt; &#123; const index = nums2.indexOf(v) if (index &gt; -1) &#123; nums2.splice(index, 1) return v &#125; &#125;).concat(aHasNaN &amp;&amp; bHasNaN ? [NaN] : [])&#125;console.log(intersect(nums1, nums2))// 方法3：哈希表（支持 NaN，&#123;&#125;）function intersect(nums1, nums2) &#123; const map = &#123;&#125; const res = [] for (let n of nums1) &#123; if (map[n]) &#123; map[n]++ &#125; else &#123; map[n] = 1 &#125; &#125; for (let n of nums2) &#123; if (map[n] &gt; 0) &#123; res.push(n) map[n]-- &#125; &#125; return res&#125;console.log(intersect(nums1, nums2)) 如何实现数组的随机排序？12345678910111213141516171819202122var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]// 方法1：随机交换数组内的元素function result(arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; // 随机索引【Math.random()返回一个浮点, 伪随机数在范围[0，1)】 let randomIndex = parseInt(Math.random() * arr.length) // 存下当前正常索引值对应的数字 let curNum = arr[i] // 将其重新赋值为随机索引对应的数字 arr[i] = arr[randomIndex] // 将随机索引对应的数字替换为当前正常索引值对应的数字 arr[randomIndex] = curNum &#125; return arr&#125;// 方法2：sort() 可以调用一个函数做为参数，如果这个函数返回的值为负数表示数组中的 a 项排在 b 项前arr.sort(function() &#123; return Math.random() - .5&#125;)console.log(arr) 找出正数组中的最大差值12345678910var arr = [10,5,11,7,8,9]; // 11-5=6function getMaxProfit(arr) &#123; var min = max = arr[0]; for(var i=0; i&lt;arr.length; i++) &#123; min = min &lt;= arr[i] ? min : arr[i]; max = max &gt;= arr[i] ? max : arr[i]; &#125; return Math.abs(max - min);&#125; 从排序数组中删除重复项123456789101112// 若 nums = [1,1,2], 则函数应返回长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。// 若 nums = [0,0,1,1,1,2,2,3,3,4], 则返回 5, 并且原数组被修改为 0, 1, 2, 3, 4。var nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]function removeDuplicates(nums) &#123; for (var i = 1; i &lt; nums.length; i++) &#123; if (nums[i - 1] === nums[i]) &#123; nums.splice(i - 1, 1) i-- &#125; &#125; return nums.length&#125; 找出数组中出现次数最多的元素，并给出其出现过的位置1234567891011121314151617181920212223var arr = [1, 1, 2, 1, 10, 10, 11, 1, 7]function fn(arr) &#123; var bestItem, indexs = [], obj = &#123;&#125; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; var item = arr[i].toString() obj[item] ? obj[item].push(i) : obj[item] = [].concat([i]) &#125; var tempArr = Object.entries(obj) bestItem = parseInt(tempArr[0][0]) indexs = tempArr[0][1] for (const [key, value] of tempArr) &#123; if (indexs.length &lt; value.length) &#123; bestItem = parseInt(key) indexs = value &#125; &#125; return &#123; bestItem, indexs &#125;&#125;console.log(fn(arr)) 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组 已知如下数组： var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组 123456789101112131415161718192021222324252627282930// ES6// 扁平化数组Array.prototype.flat = function() &#123; return [].concat(...this.map(item =&gt; Array.isArray(item) ? item.flat() : [item]))&#125;// 数组去重Array.prototype.unique = function() &#123; return [...new Set(this)]&#125;// 数组排序const sort = (a, b) =&gt; a - bconsole.log(arr.flat().unique().sort(sort))// ===========================================// ES5Array.prototype.flat = function() &#123; return this.toString().split(',').map(v =&gt; +v)&#125;Array.prototype.unique = function() &#123; var obj = &#123;&#125; return this.filter((item, index) =&gt; &#123; var tempItem = typeof item + JSON.stringify(item) return obj.hasOwnProperty(tempItem) ? false : obj[tempItem] = true &#125;)&#125;const sort = (a, b) =&gt; a - bconsole.log(arr.flat().unique().sort(sort)) 使用迭代的方式实现 flatten 函数 迭代实现 12345678let arr = [1, 2, [3, 4, 5, [6, 7], 8], 9, 10, [11, [12, 13]]]const flatten = function(arr) &#123; while (arr.some(v =&gt; Array.isArray(v))) &#123; arr = [].concat(...arr) &#125; return arr&#125; 递归实现 123const flatten = function(arr) &#123; return [].concat(...arr.map(v =&gt; Array.isArray(v) ? flatten(v) : [v]))&#125; 字符串转换 123function flatten(arr) &#123; return arr.join(',').split(',').map(v =&gt; Number(v))&#125; 买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 123456789101112var arr = [7, 1, 5, 3, 6, 4]function maxProfit(arr) &#123; var income = 0; for (var i = 1, len = arr.length; i &lt; len; i++) &#123; var gap = arr[i] - arr[i - 1] // 后一个与前一个比较，大于零则赚 if (gap &gt; 0) &#123; income += gap &#125; &#125; return income&#125;console.log(maxProfit(arr)) 旋转数组给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 输入: [1,2,3,4,5,6,7] 和 k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 1234567891011var arr = [1, 2, 3, 4, 5, 6, 7]function rotate(arr, k) &#123; for (var i = 0; i &lt; k; i++) &#123; var temp = arr.pop() arr.unshift(temp) &#125; return arr&#125;console.log(rotate(arr, 3)) 判断数组是否存在重复给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 输入: [1,2,3,1] 输出: true 输入: [1,2,3,4] 输出: false 1234567891011121314151617181920var arr = [1, 2, 3, 1]function containsDuplicate(arr) &#123; var obj = &#123;&#125; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; if (obj[arr[i]]) &#123; return true &#125; else &#123; obj[arr[i]] = true &#125; &#125; return false&#125;// orfunction containsDuplicate(arr) &#123; return [...new Set(arr)].length !== arr.length&#125;console.log(containsDuplicate(arr)) 找出只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 1234567891011121314151617181920212223242526var arr = [4, 1, 2, 1, 2]function singleNumber(arr) &#123; var tempArr = arr tempArr.sort() var onceNumber = null for (var i = 0, len = tempArr.length - 1; i &lt; len; i++) &#123; if (tempArr[i] !== tempArr[i + 1]) &#123; onceNumber = tempArr[i] &#125; else &#123; ++i &#125; &#125; // 有可能排序后最后一个才是单着的数字，所以直接赋值为数组最后一个值 return onceNumber !== null ? onceNumber : tempArr[tempArr.length - 1]&#125;// orfunction singleNumber(arr) &#123; const a = [...new Set(arr)].reduce((total, cur) =&gt; total + cur, 0) const b = arr.reduce((total, cur) =&gt; total + cur, 0) return 2 * a - b&#125;console.log(singleNumber(arr)) 加一给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 12345678910111213141516171819202122var arr = [9, 9, 9] // 预期：[1, 0, 0, 0]function plusOne(arr) &#123; var count = arr.length - 1 // 从末尾往前倒 while (count &gt; -1) &#123; // 只要当前位+1大于9，就把当前位置为0，count-- if (arr[count] + 1 &gt; 9) &#123; arr[count] = 0 count-- &#125; else &#123; // 一旦当前位+1不大于9，就放心+1，且直接退出，不用再算更高位的了 arr[count]++ break; &#125; &#125; // 如果while后，第一位还是0，证明这个数组所有数字都为9.这个时候往数组最前面加个1就好 if (arr[0] === 0) &#123; arr.unshift(1) &#125; return arr;&#125;;console.log(plusOne(arr)) 移动零给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 1234567891011121314151617var arr = [0, 1, 0, 3, 12] // 预期：[ 1, 3, 12, 0, 0 ]var moveZeroes = function (nums) &#123; // 长度提取出来 var len = nums.length for (var i = 0; i &lt; len; i++) &#123; // 从头往后遍历，遇到0则删掉追放到尾部， // 同时让i--，因为头部删了个0；同时len--，因为不再判断追加后的 if (nums[i] === 0) &#123; nums.splice(i, 1) nums.push(0) i-- len-- &#125; &#125; return nums&#125;console.log(moveZeroes(arr)) 某公司 1 到 12 月份的销售额存在一个对象里面如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]。 12345678910111213141516// for循环let obj = &#123;1:222, 2:123, 5:888&#125;;function fn(obj) &#123; let arr = [] for (let i = 1; i &lt;= 12; i++) &#123; obj[i] ? arr.push(obj[i]) : arr.push(null) &#125; return arr&#125;console.log(fn(obj))// Array.fromlet obj = &#123;1:222, 2:123, 5:888&#125;;const result = Array.from(&#123; length: 12 &#125;).map((_, index) =&gt; obj[index + 1] || null);console.log(result); 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 12345678910111213var nums = [2, 7, 11, 15], target = 9function twoSum(nums, target) &#123; for (let i = 0; i &lt; nums.length; i++) &#123; const num = nums[i] // 第二个数索引 const targetIndex = nums.indexOf(target - num) // 确保存在第二个数，且不为当前遍历的数 if (targetIndex &gt; -1 &amp;&amp; targetIndex !== i) &#123; return [i, targetIndex] &#125; &#125;&#125;console.log(twoSum(nums, target)) 旋转图像给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例 2: 123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]],原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 1234567891011121314151617181920var matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]function rotate(arr) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; for (var j = i + 1; j &lt; arr.length; j++) &#123; var tempArr = arr[j][i] arr[j][i] = arr[i][j] arr[i][j] = tempArr &#125; arr[i].reverse() &#125; return arr&#125;console.log(rotate(matrix)) 如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』？123456789101112131415161718192021222324252627282930313233343536373839404142434445var num = 12000000.11// 方法1：利用 toLocaleString() 返回某语言系统下数字的表示字符串 IE6+num.toLocaleString()// 方法2function toThousands(num) &#123; if (typeof num !== 'number') return 0 // 判断 num 是否小于 0 ，小于则设 flag 为 "-" 并且把 num 转为绝对值 if (num &lt; 0) &#123; flag = "-" num = Math.abs(num) &#125; // 转为数组 e.g. [ '12000000', '11' ] var arr = num.toString().split(".") // 分别把「.」左边和右边存起来 var left = [...arr[0]] var right = "" // 如果 num 不是个整数的情况 if (arr.length &gt; 1) &#123; right = "." + arr[1] &#125; var count = left.length - 1 // 操作左边整数部分，逆向遍历并且逢3前面加个「,」 ，最后 i-1 while (count &gt; 0) &#123; // [1,2,0,0,0,0] // 例如如果数组长度为6，则一开始 count=5 ，不加 // count=3 时，就需要在前面加个「,」 if (count % 3 === 0) &#123; left.splice(-count, 0, ',') &#125; count-- &#125; // 正负符号 + 左边 + 小数点和右边 return flag + left.join("") + right&#125;// 方法3：正则function toThousands(num) &#123; return num &amp;&amp; num .toString() .replace(/(\d)(?=(\d&#123;3&#125;)+\.)/g, function($1, $2)&#123; return $2 + ',' &#125;)&#125; 两个数组合并成一个数组请把两个数组 [&#39;A1&#39;, &#39;A2&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;D1&#39;, &#39;D2&#39;] 和 [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]，合并为 [&#39;A1&#39;, &#39;A2&#39;, &#39;A&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;C&#39;, &#39;D1&#39;, &#39;D2&#39;, &#39;D&#39;]。 考察点：假设有一种情况，让你在一个列表中插入一个广告，不光是数组，对象依然有这种需求，这道题其实就是平常经常需要用到的一个小功能。 12345678910let arr1 = ["A1", "A2", "B1", "B2", "C1", "C2", "D1", "D2"]let arr2 = ["A", "B", "C", "D"]console.log( [...arr1, ...arr2].sort((v2, v1) =&gt; ( v2.codePointAt(0) - v1.codePointAt(0) || v1.length - v2.length || v2.codePointAt(1) - v1.codePointAt(1) ))) 第一个条件v2.codePointAt(0) - v1.codePointAt(0) 保证了所有已A开头的字符串会放在最前边，然后依次是B和C。 第二个条件v1.length - v2.length保证A会被放在A1和A2之后。 第三个条件v2.codePointAt(1) - v1.codePointAt(1)保证了A1会被放在A2前边。 这是我挑的一个比较好的答案，更多解法可在此查看 随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]。解析：由于题意没有说清楚，到底是按「数字区间」排还是按照「连续数字」排，所以两种都写出来供参考 答案： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 随机整数function randomArr(min, max) &#123; return Math.round(Math.random() * (max - min) + min)&#125;// 初始化数组let initArr = Array.from(&#123;length: 10&#125;, () =&gt; randomArr(20, 100))// 数组去重initArr = [...new Set(initArr)]// 数组排序initArr.sort((a, b) =&gt; a - b)// 1. 区间分类解法：function createTargetArr(initArr) &#123; let obj = &#123;&#125; initArr.map((num) =&gt; &#123; const initNum = Math.floor(num / 10) if (!obj[initNum]) obj[initNum] = [] obj[initNum].push(num) &#125;) let result = [] for (const key in obj) &#123; result.push(obj[key]) &#125; return result&#125;console.log(createTargetArr(initArr))// 2. 连续数字分类解法：function createTargetArr(initArr) &#123; let continueArr = [], tempArr = [] console.log(initArr) initArr.map((e, index) =&gt; &#123; tempArr.push(e) if (initArr[index + 1] !== ++e) &#123; continueArr.push(tempArr) tempArr = [] &#125; &#125;); return continueArr&#125;console.log(createTargetArr(initArr)) 题目来源：Daily-Interview-Question 第67题 打印出 1 - 10000 之间的所有对称数 例如：121、1331 等123456789101112131415161718192021222324252627// 遍历 10000 次function symmetry(begin, end) &#123; let result = [] for (let i = begin &gt; 10 ? begin : 11; i &lt; end; i++) &#123; let str = i + "" if (str === str.split("").reverse().join("")) &#123; result.push(str) &#125; &#125; return result&#125;console.log(symmetry(11, 100))// 利用对称数function symmetry() &#123; var arr = [] for (let i = 1; i &lt; 10; i++) &#123; arr.push(i * 11); // 两位数的对称数 for (let j = 0; j &lt; 10; j++) &#123; arr.push(i * 101 + j * 10) // 三位数的对称数 arr.push(i * 1001 + j * 110) // 四位数的对称数，当i和j均为9是值为9999 &#125; &#125; return arr&#125;console.log(symmetry()); 题目来源：Daily-Interview-Question 第81题 实现 convert 方法，把原始 list 转换成树形结构，要求尽可能降低时间复杂度以下数据结构中，id 代表部门编号，name 是部门名称，parentId 是父部门编号，为 0 代表一级部门，现在要求实现一个 convert 方法，把原始 list 转换成树形结构，parentId 为多少就挂载在该 id 的属性 children 数组下，结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 原始 list 如下let list = [ &#123;id:1,name:'部门A',parentId:0&#125;, &#123;id:2,name:'部门B',parentId:0&#125;, &#123;id:3,name:'部门C',parentId:1&#125;, &#123;id:4,name:'部门D',parentId:1&#125;, &#123;id:5,name:'部门E',parentId:2&#125;, &#123;id:6,name:'部门F',parentId:3&#125;, &#123;id:7,name:'部门G',parentId:2&#125;, &#123;id:8,name:'部门H',parentId:4&#125;];const result = convert(list, ...);// 转换后的结果如下let result = [ &#123; id: 1, name: '部门A', parentId: 0, children: [ &#123; id: 3, name: '部门C', parentId: 1, children: [ &#123; id: 6, name: '部门F', parentId: 3 &#125;, &#123; id: 16, name: '部门L', parentId: 3 &#125; ] &#125;, &#123; id: 4, name: '部门D', parentId: 1, children: [ &#123; id: 8, name: '部门H', parentId: 4 &#125; ] &#125; ] &#125;, ···]; 解答： 1234567891011121314151617181920212223242526272829303132333435363738// 常规function convert(list) &#123; function fn(pid) &#123; return list.filter(dep =&gt; &#123; if (dep.parentId === pid) &#123; // 以自己为根节点，找儿子 let children = fn(dep.id) dep.children = children.length ? children : null return true &#125; &#125;) &#125; // 找最外层根节点0 return fn(0)&#125;// mapfunction convert (arr) &#123; // 数组转对象 var obj = &#123;&#125; for (const item of arr) &#123; obj[item.id] = item &#125; var result = [] // 循环数组，如果是父部门则装进结果数组然后跳过本次循环，再根据剩下的子部门找相应父部门，把自己挂载到父部们下 for (const item of arr) &#123; if (item.parentId === 0) &#123; result.push(item) continue &#125; if (item.parentId in obj) &#123; let parent = obj[item.parentId] parent.children = parent.children || [] parent.children.push(item) &#125; &#125; return result&#125; 题目来源：Daily-Interview-Question 第88题 编程题，请写一个函数，完成以下功能12输入：'1,2,3,5,7,8,10'输出：'1~3,5,7~8,10' 解答： 1234567891011121314151617181920212223242526272829let str = "1,2,3,5,7,8,10,11"function fn(str) &#123; let arr = str.split(",").map(v =&gt; +v) let continueNum = arr[0] // tempNum负责存储连续数字的起始 let result = [] for (let i = 0; i &lt; arr.length; i++) &#123; let curNum = arr[i], nextNum = arr[i + 1] // 当前+1等于下一个数则跳过 // 不相等则处理 if (curNum + 1 !== nextNum) &#123; // 分两种情况， // 一开始就连续数字：[1,2,5,7] 当i为2时满足上方if条件，tempNum = 1，curNum = 2 // 一开始非连续数字：[3,5,7] 当i为1时就满足上方if条件，tempNum = 3，curNum = 3 if (curNum !== continueNum) &#123; // 连续数字打头的tempNum + ~ + 目前数字为止 result.push(continueNum + "~" + curNum) &#125; else &#123; // 否则直接把当前数字推入数组 result.push(curNum) &#125; // 无论连续还是不连续，都把下一项当做连续的起始 continueNum = nextNum &#125; &#125; return result.join(',')&#125;console.log(fn(str)) 补全代码，实现数组按姓名、年纪、任意字段排序。1234567var users = [ &#123; name: "John", age: 20, company: "Baidu" &#125;, &#123; name: "Pete", age: 18, company: "Alibaba" &#125;, &#123; name: "Ann", age: 19, company: "Tecent" &#125;]users.sort(byField('age'))users.sort(byField('company')) 解答： 123456789101112var users = [ &#123; name: "John", age: 20, company: "Baidu" &#125;, &#123; name: "Pete", age: 18, company: "Alibaba" &#125;, &#123; name: "Ann", age: 19, company: "Tecent" &#125;]var byField = function (key) &#123; return (a, b) =&gt; a[key] &gt; b[key]&#125;users.sort(byField('age'))console.log(users)users.sort(byField('company'))console.log(users) 题目来源：2019 前端面试 | “HTML + CSS + JS”专题 「JavaScript 基础」部分编号 js_12 实现一个 reduce 函数解析：reduce是归并方法，它并不对每一项执行目标函数，简单来说概括为如下步骤： 不断地对数组的前两项“取出”，对其执行目标函数，计算得到的返回值 把上述返回值“填回”数组首部，作为新的 array[0] 持续循环执行这个过程，直到数组中每一项都访问了一次 返回最终结果 举个例子🌰 对数组 [1，2，3] 归并执行 (prev, cur) =&gt; prev + cur，流程如图： 123[1, 2, 3] // 取出 1 + 2 ，填回 3[3, 3] // 取出 3 + 3 ，填回 6[6] // 最终结果为 6 答案： 123456789101112function reduce(arr, fn, initValue) &#123; const tempArr = (initValue === undefined ? [] : [initValue]).concat(arr) while (tempArr.length &gt; 1) &#123; tempArr.splice(0, 2, fn(tempArr[0], tempArr[1])) &#125; return tempArr[0]&#125;var sum = reduce([1, 2, 3], function (previous, current) &#123; return previous + current&#125;, 0)console.log(sum) 随机数 / 数字如何获取0-9的随机数 Math.round(num)：将 num 四舍五入取整 Math.floor(num)：将 num 向下取整，即返回 num 的整数部分。当然我们也可以使用 parseInt() 方法代替。 Math.ceil(num)：向上取整 12345678// (min, max)：return Math.round(Math.random() * (max - min - 2) + min + 1)// [min, max]：return Math.round(Math.random() * (max - min) + min)// (n, m]：return Math.ceil(Math.random() * (max - min) + min)// [n, m)：return Math.floor(Math.random() * (max - min) + min) 随机获取数组中的元素123456789var arr = ["前端", "后端", "全栈"]function fn(arr) &#123; return arr[parseInt(Math.random() * arr.length)]&#125;var i = 0while (i&lt;10) &#123; console.log(fn(arr)) i++&#125; 打乱数组顺序12345678910var arr = [1,2,3,4,5,6,7,'a','dsfs',8,9,'v']function fn(arr) &#123; for(var i = 0; i &lt; arr.length; i++) &#123; var randomIndex = parseInt(Math.random() * arr.length) var temp = arr[i] arr[i] = arr[randomIndex] arr[randomIndex] = temp &#125; return arr&#125; 保留指定小数位12var num =4.345678num = num.toFixed(4) // 4.3457 第四位小数位以四舍五入计算 前端价格展示，保留2位小数。位数不够补零123function priceFormat(price) &#123; return parseFloat(Math.round(price * 100) / 100).toFixed(2)&#125; 如何将字符串转化为数字，例如’12.3b’？12parseFloat('12.3b')// 12.3 如何检查一个数字是否为整数？ 将它对 1 进行取模，看看是否有余数。 1234567function isInt(num) &#123; return num % 1 === 0&#125;console.log(isInt(4)) // trueconsole.log(isInt(12.2)) // falseconsole.log(isInt(0.3)) // false 为什么0.1+0.2不等于0.3？在什么场景下遇到这个问题，如何解决？ 二进制模拟十进制进行计算时 的精度问题 12345678910111213141516171819// 方法1：ES6的 Number.EPSILON ，这个值无限接近于0。0.1 + 0.2的精度误差在这个值的范围内function numbersEqual(a,b) &#123; return Math.abs(a - b) &lt; Number.EPSILON&#125;var a = 0.1 + 0.2, b=0.3console.log(numbersEqual(a,b)) //true// 方法2：parseFloat + 内置函数 toFixedfunction formatNum(num, fixed = 10) &#123; // a.toFixed(fixed) 先转为小数点10位的字符串 "0.3000000000" return parseFloat(a.toFixed(fixed)) // 然后通过parseFloat转为浮点数&#125;var a = 0.1 + 0.2;console.log(formatNum(a)) //0.3// 方法3：内置函数toPrecision(中文：精确，精度)// 参数是精度.比如 5.1234 ，传 2 返回 5.1 ，传 1 返回 5 ；0.2 + 0.1 传 2 返回 0.30(0.1 + 0.2).toPrecision(10) == 0.3 // true 参考： 0.1 + 0.2不等于0.3？为什么JavaScript有这种“骚”操作？ JavaScript的设计缺陷?浮点运算：0.1 + 0.2 != 0.3 写一个函数，生成一个随机颜色字符串，合法的颜色为 #000000 ~ #ffffff1234567891011function getRandColor() &#123; //补全 const dict = '0123456789abcdef' let result = '#' for (let i = 0; i &lt; 6; i++) &#123; result += dict[Math.floor(Math.random() * dict.length)] &#125; return result&#125;var color = getRandColor()console.log(color) 对象 &amp; 原型 &amp; 原型链写一下浅/深拷贝 深拷贝和浅拷贝针对的是引用类型，JS中的变量类型分为值类型（基本类型）和引用类型；对值类型进行复制操作会对值进行一份拷贝，而对引用类型复制，则会进行地址的拷贝，最终两个变量指向同一份数据。对于引用类型，会导致a b指向同一份数据，此时如果对其中一个进行修改，就会影响到另外一个，有时候这可能不是我们想要的结果。 浅拷贝1234567891011121314151617181920212223// 实现一个浅拷贝，就是遍历源对象，然后在将对象的属性的属性值都放到一个新对象里就ok了// 方法1：遍历function copy(obj) &#123; if (!obj || typeof obj !== 'object') return var newObj = obj.constructor === Array ? [] : &#123;&#125; for (var key in obj) &#123; newObj[key] = obj[key] &#125; return newObj&#125;var a = &#123;b: 'bb', c: 'cc', d: &#123;e: 'ee'&#125;&#125;var b = copy(a)console.log(b) // &#123; b: 'bb', c: 'cc', d: &#123; e: 'ee' &#125; &#125;// 方法2：原生方法 Object.assignvar a = &#123;a : 'old', b : &#123; c : 'old'&#125;&#125;var b = Object.assign(&#123;&#125;, a)b.a = 'new'b.b.c = 'new'console.log(a) // &#123; a: 'old', b: &#123; c: 'new' &#125; &#125;console.log(b) // &#123; a: 'new', b: &#123; c: 'new' &#125; &#125; 深拷贝123456789101112131415161718192021222324252627282930313233343536373839404142// 方法1：转 JSON 再转回来var obj1 = &#123;a: &#123;name: '小红'&#125;, b: 2&#125;var obj2 = JSON.parse(JSON.stringify(obj1))obj1.a.name = '被修改了'obj2 //&#123;"a":&#123;"name":"小红"&#125;,"b":2&#125; 《---没有被修改// JSON方法的缺点：// 不能复制 function、正则、Symbol// 循环引用报错// 相同的引用会被重复复制// 方法2：递归的方法function copy(obj) &#123; // 递归退出条件 // 拷贝对象不存在或不是数组或不是对象 if (!obj || typeof obj !== 'object') return obj var newObj = obj.constructor === Array ? [] : &#123;&#125; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; // 避免相互引用对象导致死循环，如 obj.a = obj（其实下面三行不写也没事儿，系统会自动把 obj.a 设为 undefined） if (obj[key] === obj) &#123; continue &#125; // 如果是数组或者对象 if (typeof obj[key] === 'object') &#123; // 递归 newObj[key] = copy(obj[key]) &#125; else &#123; // 否则直接返回 newObj[key] = obj[key] &#125; &#125; &#125; return newObj&#125;var old = &#123; a: 'old', b: &#123; c: 'old' &#125; &#125;var newObj = copy(old)newObj.b.c = 'new'console.log(old) // &#123; a: 'old', b: &#123; c: 'old' &#125; &#125;console.log(newObj) // &#123; a: 'old', b: &#123; c: 'new' &#125; &#125; 参考： 浅探js深拷贝和浅拷贝 深拷贝的终极探索 拓展：编程题，写个程序把 entry 转换成如下对象1234567891011121314151617181920var entry = &#123; a: &#123; b: &#123; c: &#123; dd: 'abcdd' &#125; &#125;, d: &#123; xx: 'adxx' &#125;, e: 'ae' &#125;&#125;// 要求转换成如下对象var output = &#123;'a.b.c.dd': 'abcdd','a.d.xx': 'adxx','a.e': 'ae'&#125; 解答： 12345678910111213141516function fn(obj, parentKey = "", result = &#123;&#125;) &#123; for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; const ele = obj[key]; const keyName = `$&#123;parentKey&#125;$&#123;key&#125;` if (typeof ele === 'object' &amp;&amp; !Array.isArray(ele)) &#123; fn(ele, keyName+'.', result) &#125; else &#123; result[keyName] = ele &#125; &#125; &#125; return result&#125;console.log(fn(entry)) JavaScript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？hasOwnProperty hasOwnProperty 返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法不会检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。 使用方法： object.hasOwnProperty(proName) 其中参数 object 是必选项，一个对象的实例；proName 是必选项。一个属性名称的字符串值。 如果 object 具有指定名称的属性，那么 JavaScript 中 hasOwnProperty 函数方法返回 true，反之则返回 false。 instanceof 的实现原理 思路：只要右边变量的 prototype 在左边变量的原型链上即可。 12345678910111213function myInstanceOf(leftValue, rightValue) &#123; let rightProto = rightValue.prototype // 取右表达式的 prototype 值 leftValue = leftValue.__proto__ // 取左表达式的 __proto__ 值 while (true) &#123; if (leftValue === null) &#123; return false &#125; if (leftValue === rightProto) &#123; return true &#125; leftValue = leftValue.__proto__ &#125;&#125; 参考：浅谈 instanceof 和 typeof 的实现原理 要求设计 LazyMan 类，实现以下功能123456789101112131415161718192021LazyMan('Tony');// Hi I am TonyLazyMan('Tony').sleep(10).eat('lunch');// Hi I am Tony// 等待了10秒...// I am eating lunchLazyMan('Tony').eat('lunch').sleep(10).eat('dinner');// Hi I am Tony// I am eating lunch// 等待了10秒...// I am eating dinerLazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');// Hi I am Tony// 等待了5秒...// I am eating lunch// I am eating dinner// 等待了10秒...// I am eating junk food 答案： 12345678910111213141516171819202122232425262728293031323334353637383940414243class LazyManClass &#123; constructor (name) &#123; this.name = name this.task = [] console.log('Hi I am', name) setTimeout(() =&gt; &#123; this.next() &#125;, 0) &#125; eat (str) &#123; this.task.push(() =&gt; &#123; console.log('I am eating', str) this.next() &#125;) return this &#125; sleep (n) &#123; this.task.push(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log('等待了' + n + 's') this.next() &#125;, n * 1000) &#125;) return this &#125; sleepFirst (n) &#123; this.task.unshift(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log('等待了' + n + 's') this.next() &#125;, n * 1000) &#125;) return this &#125; next () &#123; let fn = this.task.shift() fn &amp;&amp; fn() &#125;&#125;;let LazyMan = function (name) &#123; return new LazyManClass(name)&#125;; 解析： 这道题的关键点有如下几个： 链式调用，通过返回 this 实现 内部需要维护一个 taskList ，根据不同逻辑，向 taskList 中push 、shift、unshift 执行函数 每执行一个task，需要继续执行后续 task，这通过 next 函数实现。 题目来源：Daily-Interview-Question 第56题 实现一个 new12345678910111213141516function _new(fn, ...args) &#123; const obj = Object.create(fn.prototype) const ret = fn.apply(obj, args) return ret instanceof Object ? ret : obj&#125;// 测试function Person(name, age) &#123; this.name = name this.age = age this.sayHi = function() &#123;&#125;&#125;Person.prototype.run = function() &#123;&#125;console.log(_new(Person, 'Lance', 19))console.log(new Person('Jerry', 20)) 实现一个单例1234567891011121314151617181920212223242526272829303132333435363738// ES5function Person(name, age) &#123; this.name = name; this.age = age;&#125;let Singleton = function(Fn) &#123; let _instance = null; Singleton = function(...args) &#123; if (_instance) return _instance; return (_instance = new Fn(...args)); &#125;; return Singleton;&#125;;var peopleSingleton = Singleton(Person);var ming = new peopleSingleton("ming", 18);var fang = new peopleSingleton("fang", 28);console.log(ming, fang);// ES6class People &#123; constructor(name, age) &#123; if (typeof People.instance === 'object') &#123; return People.instance &#125; People.instance = this this.name = name this.age = age return this &#125;&#125;var ming = new People('ming', 20)var fang = new People('fang', 19)console.log(ming, fang) ES6实现一个 sleep 函数比如 sleep(1000) 意味着等待1000毫秒，可从 Promise、Generator、Async/Await 等角度实现。 123456789101112131415161718192021222324252627// Promiseconst sleep = delay =&gt; new Promise(resolve =&gt; setTimeout(resolve, delay))sleep(1000).then(() =&gt; console.log('Done'))// Generatorfunction* sleepGenerator(delay) &#123; yield new Promise(resolve =&gt; setTimeout(resolve, delay))&#125;sleepGenerator(1000).next().value.then(() =&gt; console.log('Done'))// async / awaitconst sleep = delay =&gt; new Promise(resolve =&gt; setTimeout(resolve, delay))async function output() &#123; await sleep(1000) console.log('Done')&#125;output()// ES5function sleep(cb, delay) &#123; if (typeof cb === 'function') setTimeout(cb, delay)&#125;function output() &#123; console.log('Done')&#125;sleep(output, 1000) Promise 和 setTimeout 的区别？Promise 是微任务，setTimeout 是宏任务，同一个事件循环中，promise.then 总是先于 setTimeout 执行。 Promise 构造函数是同步还是异步执行？then 呢？Promise 如何实现 then 处理？Promise 的构造函数是同步执行的；then 中的方法是异步执行的。 Promise 实现 then 处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102const PENDING = "pending";const FULFILLED = "fulfilled";const REJECTED = "rejected";function Promise(executor) &#123; let self = this; self.status = PENDING; //成功的回调 self.onFulfilled = []; //失败的回调 self.onRejected = []; //PromiseA+ 2.1 function resolve(value) &#123; if(self.status === PENDING) &#123; self.status = FULFILLED; self.value = value; //PromiseA+ 2.2.6.1 self.onFulfilled.forEach(fn =&gt; fn()); &#125; &#125; function reject(reason) &#123; if(self.status === PENDING) &#123; self.status = REJECTED; self.reason = reason; //PromiseA+ 2.2.6.2 self.onRejected.forEach(fn =&gt; fn()); &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123; //PromiseA+ 2.2.1 / PromiseA+ 2.2.5 / PromiseA+ 2.2.7.3 / PromiseA+ 2.2.7.4 onFulfilled = typeof onFulfilled === "function" ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === "function" ? onRejected : reason =&gt; &#123;throw reason&#125;; let self = this; //PromiseA+ 2.2.7 let promise2 = new Promise((resolve, reject) =&gt; &#123; if(self.status === FULFILLED) &#123; //PromiseA+ 2.2.2 //PromiseA+ 2.2.4 --- setTimeout setTimeout(() =&gt; &#123; try &#123; //PromiseA+ 2.2.7.1 let x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; //PromiseA+ 2.2.7.2 reject(e); &#125; &#125;); &#125;else if (self.status === REJECTED) &#123; //PromiseA+ 2.2.3 setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;else if (self.status === PENDING) &#123; self.onFulfilled.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); self.onRejected.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; &#125;); return promise2;&#125; 首先，需要知道 Promise.all() 的功能： 如果传入的参数是一个空的可迭代对象，那么此promise 对象回调完成（resolve），只有此情况，是同步执行的，其它都是异步返回的。 如果传入的参数不包含任何 promise，则返回一个异步完成。promises 中所有的 promise 都“完成”时或参数中不包含 promise 时回调完成。 如果参数中有一个 promise 失败，那么 Promise.all 返回的 promise 对象失败。 在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组。 12345678910111213141516171819202122232425Promise.all = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let index = 0; let result = []; if(promises.length === 0) &#123; resolve(result); &#125;else &#123; function processValue(i, data) &#123; result[i] = data; if(++index === promises.length) &#123; esolve(result); &#125; &#125; for(let i = 0; i &lt; promises.length; i++) &#123; //promises[i] 可能是普通值 Promise.resolve(promises[i]).then((data) =&gt; &#123; processValue(i, data); &#125;, (err) =&gt; &#123; reject(err); return; &#125;); &#125; &#125; &#125;);&#125; 实现一个基本的 Promise12345678910111213141516171819202122232425262728293031323334353637383940// 未添加异步处理等其他边界情况// ①自动执行函数，②三个状态，③thenclass Promise &#123; constructor (fn) &#123; // 三个状态 this.state = 'pending' this.value = undefined this.reason = undefined let resolve = value =&gt; &#123; if (this.state === 'pending') &#123; this.state = 'fulfilled' this.value = value &#125; &#125; let reject = value =&gt; &#123; if (this.state === 'pending') &#123; this.state = 'rejected' this.reason = value &#125; &#125; // 自动执行函数 try &#123; fn(resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125; // then then(onFulfilled, onRejected) &#123; switch (this.state) &#123; case 'fulfilled': onFulfilled() break case 'rejected': onRejected() break default: &#125; &#125;&#125; 如何实现 Promise.prototype.finally() ？不管成功还是失败，都会走到 finally 中,并且 finally 之后，还可以继续 then。并且会将值原封不动的传递给后面的 then。 1234567891011Promise.prototype.finally = function (callback) &#123; return this.then((value) =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; return value; &#125;); &#125;, (err) =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; throw err; &#125;); &#125;);&#125; 题目来源：2019 前端面试 | “HTML + CSS + JS”专题「《ES6 速学：⑤ Promise 对象》[编号：es6_05]」 Event Loop &amp; setTimeoutsetTimeout 的机制等到当前脚本的同步任务和 “任务队列” 中已有的事件，全部处理完以后，才会执行 setTimeout 指定的任务。 参考：JavaScript 运行机制详解：再谈Event Loop 使用setTimeout模拟setInterval12345// 可避免setInterval因执行时间导致的间隔执行时间不一致setTimeout (function () &#123; // do something setTimeout (arguments.callee, 500)&#125;, 500) Event Loop有关 Event Loop 相关的概念和面试题可参考我的博客：Event Loop 学习笔记 自我测验上面两篇文章阅读完毕后可以自我测验下： 12345678910111213141516171819202122232425//请写出输出内容async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); 题目出处和答案参考：从一道题浅说 JavaScript 的事件循环 DOMgetElementsByClassName 和 querySelectorAll 的区别 参数上：querySelectorAll 方法接收的参数是一个 CSS 选择符。而 getElementsBy 系列接收的参数只能是单一的 className、tagName 和 name 123var c1 = document.querySelectorAll('.b1 .c')var c2 = document.getElementsByClassName('c')var c3 = document.getElementsByClassName('b2')[0].getElementsByClassName('c') 返回值上：querySelectorAll 返回的是一个 Static Node List，而 getElementsBy 系列的返回的是一个 Live Node List 参考： querySelectorAll 方法相比 getElementsBy 系列方法有什么区别？ 静态NodeList 和 动态NodeList的区别 原生 JS 添加类 element.setAttribute(“class”, ‘Lance’) element.className = “lance awesome” 追加类：element.setAttribute(“class”, element.getAttribute(“class”) + “ “ + “lance”) 编写一个可拖拽的 div HTML 1&lt;div id="sw"&gt;&lt;/div&gt; CSS 1#sw &#123; position: absolute; width: 100px; height: 100px; background-color: yellow; &#125; JS 12345678910111213141516171819202122232425var flag = falsevar position = nullvar sw = document.querySelector("#sw")sw.addEventListener("mousedown", function (e) &#123; flag = true position = [e.clientX, e.clientY] console.log(e.clientX, e.clientY)&#125;)// 这里监听 document ，如果监听 sw 则会有快速拖动导致鼠标「脱离」 div 的 bugdocument.addEventListener("mousemove", function (e) &#123; if (!flag) return var x = e.clientX var y = e.clientY var moveX = x - position[0] var moveY = y - position[1] var left = parseInt(sw.style.left || 0) var top = parseInt(sw.style.top || 0) // 注意 style.left 带 px 单位 sw.style.left = left + moveX + 'px' sw.style.top = top + moveY + 'px' position = [x, y]&#125;)document.addEventListener("mouseup", function() &#123; flag = false&#125;) 预测执行结果下面代码打印结果是什么？为什么?12345var b = 10;(function b() &#123; b = 20; console.log(b)&#125;)() 答案： 非严格模式：[Function b] 严格模式：Uncaught TypeError: Assignment to constant variable 解析： 12345678910var b = 10;(function b() &#123; // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b()&#123;&#125;，拿此b做赋值； // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。 // （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等） b = 20; console.log(b); // [Function b] console.log(window.b); // 10，不是20&#125;)();// 严格模式下能看到错误：Uncaught TypeError: Assignment to constant variable 其他情况例子： 有window： 123456var b = 10;(function b() &#123; window.b = 20; console.log(b); // [Function b] console.log(window.b); // 20是必然的&#125;)(); 有var: 123456var b = 10;(function b() &#123; var b = 20; // IIFE内部变量 console.log(b); // 20 console.log(window.b); // 10 &#125;)(); 解析来源 ← 输出以下代码执行的结果并解释为什么12345678910var obj = &#123; '2': 3, '3': 4, 'length': 2, 'splice': Array.prototype.splice, 'push': Array.prototype.push&#125;obj.push(1)obj.push(2)console.log(obj) 结果： 解析参考： 结果最后变为一个稀疏数组[,,1,2]。因为在对象中加入splice属性方法，和length属性后。这个对象变成一个类数组。属性名称可转换为数字时，会映射成为索引下标。所以对象实际可这样描述：[,,3,4],然后继续执行length 属性复制，length 原来值为4，length：2 语句将数组截断成为长度为2的数组。此时数组为[,,]。接着push（1）、push (2)。数组追加两个值，[,,1,2]。小菜看法，有错望指正！！！ 参考来源： Daily-Interview-Question 第 46 题 小菜解析 输出以下代码的执行结果并解释为什么123456var a = &#123;n: 1&#125;;var b = a;a.x = a = &#123;n: 2&#125;;console.log(a.x)console.log(b.x) 答案： 12a.x // --&gt; undefinedb.x // --&gt; &#123;n: 2&#125; 解析： 1、优先级.的优先级高于=，所以先执行a.x，堆内存中的{n: 1}就会变成{n: 1, x: undefined}，改变之后相应的b.x也变化了，因为指向的是同一个对象。 2、赋值操作是从右到左，所以先执行a = {n: 2}，a的引用就被改变了，然后这个返回值又赋值给了a.x，需要注意的是这时候a.x是第一步中的{n: 1, x: undefined}那个对象，其实就是b.x，相当于b.x = {n: 2} 题目来源：Daily-Interview-Question 第53题 输出以下代码运行结果12345678910111213141516171819// example 1var a=&#123;&#125;, b='123', c=123; a[b]='b';a[c]='c'; console.log(a[b]);---------------------// example 2var a=&#123;&#125;, b=Symbol('123'), c=Symbol('123'); a[b]='b';a[c]='c'; console.log(a[b]);---------------------// example 3var a=&#123;&#125;, b=&#123;key:'123'&#125;, c=&#123;key:'456'&#125;; a[b]='b';a[c]='c'; console.log(a[b]); 分析：这题考察的是对象的键名的转换。 对象的键名只能是字符串和 Symbol 类型。 其他类型的键名会被转换成字符串类型。 对象转字符串默认会调用 toString 方法。 解答： 123456789// example 1var a=&#123;&#125;, b='123', c=123;a[b]='b';// c 的键名会被转换成字符串'123'，这里会把 b 覆盖掉。a[c]='c'; // 输出 cconsole.log(a[b]); 1234567891011// example 2var a=&#123;&#125;, b=Symbol('123'), c=Symbol('123'); // b 是 Symbol 类型，不需要转换。a[b]='b';// c 是 Symbol 类型，不需要转换。任何一个 Symbol 类型的值都是不相等的，所以不会覆盖掉 b。a[c]='c';// 输出 bconsole.log(a[b]); 12345678910111213// example 3var a=&#123;&#125;, b=&#123;key:'123'&#125;, c=&#123;key:'456'&#125;; // b 不是字符串也不是 Symbol 类型，需要转换成字符串。// 对象类型会调用 toString 方法转换成字符串 [object Object]。a[b]='b';// c 不是字符串也不是 Symbol 类型，需要转换成字符串。// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。a[c]='c'; // 输出 cconsole.log(a[b]); 题目来源：Daily-Interview-Question 第76题 请写出如下代码的打印结果123456789101112131415161718function Foo() &#123; Foo.a = function() &#123; console.log(1) &#125; this.a = function() &#123; console.log(2) &#125;&#125;Foo.prototype.a = function() &#123; console.log(3)&#125;Foo.a = function() &#123; console.log(4)&#125;Foo.a();let obj = new Foo();obj.a();Foo.a(); 解答： 12345678910111213141516171819202122232425262728293031323334353637function Foo() &#123; Foo.a = function() &#123; console.log(1) &#125; this.a = function() &#123; console.log(2) &#125;&#125;// 以上只是 Foo 的构建方法，没有产生实例，此刻也没有执行Foo.prototype.a = function() &#123; console.log(3)&#125;// 现在在 Foo 上挂载了原型方法 a ，方法输出值为 3Foo.a = function() &#123; console.log(4)&#125;// 现在在 Foo 上挂载了直接方法 a ，输出值为 4Foo.a();// 立刻执行了 Foo 上的 a 方法，也就是刚刚定义的，所以// # 输出 4let obj = new Foo();/* 这里调用了 Foo 的构建方法。Foo 的构建方法主要做了两件事：1. 将全局的 Foo 上的直接方法 a 替换为一个输出 1 的方法。2. 在新对象上挂载直接方法 a ，输出值为 2。*/obj.a();// 因为有直接方法 a ，不需要去访问原型链，所以使用的是构建方法里所定义的 this.a，// # 输出 2Foo.a();// 构建方法里已经替换了全局 Foo 上的 a 方法，所以// # 输出 1 题目来源：Daily-Interview-Question 第100题 分别写出如下代码的返回值12String('11') == new String('11');String('11') === new String('11'); 解析： 返回 true 和 falsenew String() 返回的是对象== 的时候，实际运行的是：String(&#39;11&#39;) == new String(&#39;11&#39;).toString(); 输出以下代码运行结果12345671 + "1"2 * "2"[1, 2] + [2, 1]"a" + + "b" 解析： 1 + “1” 加性操作符：如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来 所以值为：“11” 2 * “2” 乘性操作符：如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值 [1, 2] + [2, 1] Javascript中所有对象基本都是先调用valueOf方法，如果不是数值，再调用toString方法。 所以两个数组对象的toString方法相加，值为：”1,22,1” “a” + + “b” 后边的“+”将作为一元操作符，如果操作数是字符串，将调用Number方法将该操作数转为数值，如果操作数无法转为数值，则为NaN。 所以值为：”aNaN” 以上均参考：《Javascript高级程序设计》 题目来源：Daily-Interview-Question 第116题 下方js执行后的打印值为？12345678910function demo() &#123; this.length = 10; var fn = function() &#123; console.log(this.length); // 输出多少？ &#125; arr = [fn, 'hello layui']; fn.length = 100; arr[0]();&#125;demo() 答案：2 解析：this指向问题一般看谁在调用就OK了，在上述函数中，fn的拥有者是arr并且也是它调用的，所以this指向arr，arr中有两个成员，length为2。 延伸123function fn() &#123;&#125;fn.length = 2console.log(fn.length) // length 为多少？ 答案：0 解析：length 是js函数对象的一个属性值，该值是指 “该函数有多少个必须要传入的参数”，即形参的个数。形参的数量不包括剩余参数个数，仅包括 “第一个具有默认值之前的参数个数”，然而fn不需要传递参数，length为0。 拓展阅读：JS 中函数的 length 属性 算法题我面的都不是什么大公司，所以很少被问到算法，不过对于前端来说，了解一些基本的算法还是很有必要的，起码最常见的排序算法得掌握，例如冒泡和快排。这部分内容可参考我的博客： 常见排序算法 使用递归完成 1 到 100 的累加？123456function fn(num) &#123; if(num === 1) return 1 return num + fn(num - 1)&#125;console.log(fn(100)) 正则对正则不太熟练的同学，在这儿我分享掘金的一篇教程。这篇教程对我来说真的是受益匪浅，希望也能帮助到你： JS正则表达式完整教程（略长） 写一个函数 isValidUsername(str)，判断用户输入的是不是合法的用户名（长度 6-20 个字符，只能包括字母、数字、下划线）？123456function isValidUsername(str) &#123; let reg = /^\w&#123;6,20&#125;$/ return reg.test(str)&#125;console.log(isValidUsername('swlance')) 写一个函数 isPhoneNum(str)，判断用户输入的是不是手机号？12345function isPhoneNum(str) &#123; return /^1[3578]\d&#123;9&#125;$/g.test(str)&#125;console.log(isPhoneNum('13871455497')) 写一个函数 isEmail(str)， 判断用户输入的是不是邮箱？（e.g. xxx@gmail.com 或者 xxx@swlance.com.cn）12345function isEmail(str) &#123; return /^\w+@\w+(\.\w+)&#123;1,2&#125;$/.test(str)&#125;console.log(isEmail('xxx@swlance.com.cn')) 写一个函数 trim(str)，去除字符串两边的空白字符？12345function trim(str) &#123; return str.replace(/^\s+|\s+$/g, '')&#125;console.log(trim(' xxxswlance.cn ')) 上述正则题目来源：2019 前端面试 | “HTML + CSS + JS”专题 「《JS 提供的对象：② 正则表达式》[编号：js_17]」 转化为驼峰命名12var s1 = "get-element-by-id"// 转化为 getElementById 1234function fn(str) &#123; return str.replace(/-\w/g, x =&gt; x.slice(1).toUpperCase())&#125;console.log(fn(s1)) 场景题数学逻辑某果蔬平台商品设置与订单应付款的计算规则说明如下： A.商品可被设置为不参与其他优惠活动，即不参与会员折扣、满减活动B.会员价商品不参与其他优惠活动，即不参与会员折扣、满减活动C.用户积分可抵扣，积分抵扣规则为100积分可抵扣0.5元D.订单计算规则为： Step 1：购物车中的商品分别计算参与优惠部分的商品总价与不参与优惠的商品总价； Step 2：参与优惠的商品总价可参与满减活动 Step 3：上一步处理之后，参与优惠的商品总价可参与会员折扣 Step 4：所有商品总价，扣减掉积分可抵扣的部分得到订单应支付金额 该果蔬平台有一个商户A，在后台创建了一个商品fruit_a，定价为10元/KG。用户购买3KG商品，问下列各独立场景下，应付款几何？[需要写出结果与计算式，如下所示] Eg. 商品设置了阶梯价，&gt;=3KG，价格为8元/KG；应付款24=8*3元 2.1 用户有500积分，店铺积分可抵扣，抵扣规则为100积分可抵扣0.5元；店铺设置有满减活动，满20元减3元；商品设置阶梯价，》=3KG，价格为8元/KG，则用户应付款为____元。（5.0分） 2.2 用户有500积分，店铺积分可抵扣，抵扣规则为100积分可抵0.5元；商品设置会员价8元/KG，使用会员价必须使用余额支付；店铺设置有满减活动，满20元减3元；用户若实用余额支付应付款为元。若使用在线支付，则应付款为元；（8.0元） 2.3 用户有500积分，店铺积分不可抵扣，抵扣规则为100积分可抵0.5元；店铺有开启会员折扣，会员折扣为8.5折，使用会员折扣必须使用余额支付；店铺设置有满减活动，满20元减3元；用户若使用余额支付应付款为元，若使用在线支付，则应付款为元;(8.0分) 参考答案： 2.18×3-3-500/100×0.5=18.5元 2.28×3-500/100×0.5=21.5元10×3-3-500/100×0.5=24.5元 2.3（10×3-3）×0.85=22.95元10×3-3=27元 非常规题[‘1’, ‘2’, ‘3’].map(parseInt)的结果正确答案：[1, NaN, NaN] 答案解析：[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ? 其它修改以下 print 函数，使之输出 0 到 99，或者 99 到 012345678function print(n)&#123; setTimeout(() =&gt; &#123; console.log(n); &#125;, Math.floor(Math.random() * 1000));&#125;for(var i = 0; i &lt; 100; i++)&#123; print(i);&#125; 解答： 1234567891011121314151617181920212223242526function print0(n)&#123; setTimeout(() =&gt; &#123; console.log(n); &#125;, 0, Math.floor(Math.random() * 1000));//关闭延迟&#125;function print1(n) &#123; setTimeout( (() =&gt; &#123; console.log(n); &#125;)(), Math.floor(Math.random() * 1000) //自执行 );&#125;function print2(n) &#123; setTimeout(() =&gt; &#123; console.log(--i); &#125;, Math.floor(Math.random() * 1000)); //全局i&#125;function print3(n) &#123; // setTimeout(() =&gt; &#123; console.log(n); //&#125;, Math.floor(Math.random() * 1000)); //注释&#125; 题目来源：Daily-Interview-Question 第101题]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS知识点（面试系列）]]></title>
    <url>%2Fposts%2F49170%2F</url>
    <content type="text"><![CDATA[盒模型标准盒模型（W3C标准）： 一个块的总宽度 = 内容宽度 + margin(左右) + padding(左右) + border(左右) 怪异盒模型（IE标准）： 一个块的总宽度 = width（包含 padding 和 border） + margin(左右) 怪异盒模型触发条件如果 html 文件最顶部 doctype 缺失，则在 ie6、7、8 将会触发怪异模式(quirks); 通过css来设置盒模型123box-sizing: content-box; /* 标准模型 */ border-box; /* IE模型 */ inherit; /* 从父元素继承 */ 应用场景 怪异盒模型（border-box） 比如我们想做一个内边距 10px ，边框为 2px ，最终包括边框宽度为 100px 的 div ，之前的做法是先算出内容宽 width 。但有点繁琐，需要人算。此时我们可以把 div 的 box-sizing 设置为 border-box ，我们就可以直接把 width 设置为 100px ，其余的 padding 和 border 按照给定好的值一一填入，就可以完成这一切工作，省去了人为的计算内容宽 content 的过程，减少计算量的同时减少了错误率。 CSS选择符有哪些？哪些属性可以继承？ id选择器（ #my-id ） 类选择器（ .my-class-name ） 标签选择器（ div, h1, p ） 相邻选择器（ h1 + p 紧贴在 h1 后面的第一个 p 标签。同级标签，之间不能有其他标签 ） 子代选择器（ ul &gt; li ul 标签下的下一个层级的 li ，并不是所有 ） 后代选择器（ li a ） 通配符选择器（ * ） 属性选择器（ a[rel = “external”] ） 伪类选择器（ a:hover, li:nth-child ） 可继承属性font-size font-family color, UL LI DL DD DT; 不可继承属性border padding margin width height CSS优先级算法如何计算？ 写在后面的覆盖写在前面的 描述越具体优先级越高 (div , div[class=’restart’]) 同权重 行内样式 &gt; 内嵌样式 &gt; 外部样式 !important 优先级最高 CSS3新增伪类有那些？ p:first-of-type 属于其父元素的特定类型首个子元素 等同于 :nth-of-type(1) p:last-of-type 属于其父元素的特定类型的最后一个子元素 等同于 :nth-last-of-type(1) ::after 在元素之前添加内容,也可以用来做清除浮动。 ::before 在元素之后添加内容 :enabled/:disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中。 display:none、visibility：hidden和opacity: 0的区别？ display：none （不占空间，不能点击）（回流+重绘） visibility：hidden （占据空间，不可点击）（重绘） opacity: 0（占据空间，可以点击）（重建图层，性能较高） 更多：分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景 position 跟 display 、float 这些特性相互叠加后会怎么样？ position 属性规定元素的定位类型 display 属性规定元素应该生成的框的类型 float 属性是一种布局方式，定义元素在哪个方向浮动。 优先级机制：position：absolute/fixed 优先级最高，有他们在时，float 不起作用，display 值需要调整。float 或者 absolute 定位的元素，只能是块元素或表格。 讲一讲 position 属性中的各种值 值 是否脱标占有位置 可使用边偏移 描述 static 不脱标，正常模式 不可以 自动（没有）定位（默认定位方式） relative(自恋) 不脱标，占有位置 可以 相对定位，相对于其原文档流的位置进行定位 absolute(拼爹) 完全脱标，不占位置 可以 绝对定位，相对于其上一个已经定位（不为static）的父元素进行定位 fixed(浏览器) 完全脱标，不占位置 可以 固定定位，相对于浏览器窗口进行定位（老IE不支持） inherit 规定从父元素继承 position 属性的值 CSS3 有哪些新特性？过渡12345678910111213/* 语法 */transition: CSS属性，过渡时间，效果曲线（默认ease），延迟时间（默认0）/* demo1 *//*宽度从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒，0.2秒后执行过渡*/transition: width .5s ease .2s/* demo2 *//* 分开写 */transition-property: width;transition-duration: 1s;transition-timing-function: linear;transition-delay: 2s; 动画1234567891011121314151617181920212223242526/* 语法 */animation：动画名称，动画时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）/* demo1 *//* 执行一次logo2-line动画，运动时间2秒，运动曲线为 linear */animation: logo2-line 2s linear;/* demo2 *//* 2秒后开始执行一次 logo2-line 动画，运动时间2秒，运动曲线为 linear */animation: logo2-line 2s linear 2s;/* demo3 *//*无限执行 logo2-line 动画，每次运动时间2秒，运动曲线为 linear，并且执行反向动画*/animation: logo2-line 2s linear alternate infinite;还有一个重要属性：用来指定在动画执行之前和之后如何给动画的目标应用样式。animation-fill-mode: none | forwards | backwards | both;/*动画分为 初始状态 等待期 动画执行期 完成期 四个阶段。- none 表示 等待期和完成期，元素样式都为初始状态样式，不受动画定义（@keyframes）的影响- forwards 表示等待期保持初始样式，完成期间保持最后一帧样式- backwards 表示等待期为第一帧样式，完成期跳转为初始样式- both 表示 等待期样式为第一帧样式，完成期保持最后一帧样式*/ 参考：如何理解animation-fill-mode及其使用？ 形状转换transform: 适用于2D或3D转换的元素 (3d看这里)transform-origin: 转换元素的位置（围绕那个点进行转换,默认中心）。默认 x, y, z ： 50%, 50%, 0 对应 left, top 缩放 scale 位移 translate 旋转 rotate 倾斜 skew 12345transform: rotate(30deg);transform: translate(30px, 30px);transform: scale(.8);transform: skew(10deg, 10deg);transform-origin: left top; /* 左上（默认中心）【改变元素变形的原点】 */ 资源对 transition 、animation 和 transform 这块儿内容不熟的同学可以参考我的博客简单上手教程，基本上每个属性都有相应的 demo 展示：Lance的个人博客-css分类 另外，上面的知识点参考于下方资源，可自取： 个人总结（css3新特性） cubic-bezier贝塞尔在线预览 transition-timing-function | cssreference Understanding The CSS3 transition-timing-function Property 翻译 | 深入理解CSS时序函数 css3动画详解【推荐】 选择器属性选择器 div[index] { background: red } 表示 div 下面带 index 属性的背景为红色 div[index=a] { background: red } 表示 div 下面的自定义属性 index=a 的 div 的颜色变成红色。 div[index~=a] { background: red } 只要 div 中 index 属性带 a 这个单词的就生效。[a这个单词必须独立存在] p[class~=’lance’] 只会匹配到 class=”xxx lance”，而不会匹配 class=”xxlancexx” div[index*=a] { background: red } 只要 div 里面的 index 属性带 a 字母的就生效。 div[index^=a] { background: red } 以 a 开头的 div[index$=a] { background: red } 以 a 结尾 div[index|=a] { background:red } 只要以 a- 开头的 当需要多个的时候： div[key1=value1][key2=value2][key3=value3]…. { background:red } 结构性伪类选择器前提：假如 div 是下面 p 标签的父元素 p:nth-child(n) div 下类型为 p 的第 n 个子元素，下标从 1 开始！！ :nth-child(odd) 奇数 :nth-child(even) 偶数 p:nth-last-child(n) 从倒数，div 下类型为 p 的第 n 个子元素 p:last-child div 下最后一个子元素如果是 p ，则生效，否则不生效 p:first-child div 下第一个子元素如果是 p ，则生效，否则不生效【css2的】 p:first-of-type div 下第一个类型为 p 的子元素【不需要 p 是这个 div 下的第一个子元素】 p:last-of-type div 下最后一个类型为 p 的子元素 参考：css选择器中:first-child与:first-of-type的区别 伪元素选择器 ::first-letter 文本的第一个单词或字（如中文、日文、韩文等） ::first-line 文本第一行； ::selection 可改变选中文本的样式； ::before 和 ::after 在元素内部的开始火结束为止创建一个元素，该元素为行内元素，必须结合 content 属性使用 div::before { content: ‘开始’ } 目标伪类选择器:target 目标伪类选择器， : 选择器可用于选取当前活动的目标元素 1234:target &#123; color: red; font-size: 30px;&#125; 阴影12/* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */box-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2); 边框 边框图片 border-image 1border-image: image-source image-height image-width image-repeat 圆角边框 border-radius 1border-radius: 左上角，右上角，右下角，左下角 CSS弹性布局（flex）Flex容器属性1234567891011121314151617主轴方向：水平排列（默认） | 水平反向排列 | 垂直排列 | 垂直反向排列flex-direction: row | row-reverse | column | column-reverse;换行：不换行（默认） | 换行 | 反向换行(第一行在最后面)flex-wrap: nowrap | wrap | wrap-reverse;flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrapflex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;主轴对齐方式：起点对齐（默认） | 终点对齐 | 居中对齐 | 两端对齐 | 分散对齐justify-content: flex-start | flex-end | center | space-between | space-around;交叉轴对齐方式：拉伸对齐（默认） | 起点对齐 | 终点对齐 | 居中对齐 | 第一行文字的基线对齐align-items: stretch | flex-start | flex-end | center | baseline;多根轴线对齐方式：拉伸对齐（默认） | 起点对齐 | 终点对齐 | 居中对齐 | 两端对齐 | 分散对齐align-content: stretch | flex-start | flex-end | center | space-between | space-around; Flex项目属性123456789101112131415161718顺序：数值越小越靠前，默认为0order: &lt;number&gt;;放大比例：默认为0，如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推flex-grow: &lt;number&gt;;缩小比例：默认为1，如果空间不足则会缩小，值为0不缩小flex-shrink: &lt;number&gt;;项目自身大小：默认auto，为原来的大小，可设置固定值 50px/50%flex-basis: &lt;length&gt; | auto;flex-grow, flex-shrink 和 flex-basis 的简写，默认值为0 1 auto两个快捷值：auto (1 1 auto) 和 none (0 0 auto)flex:none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]项目自身对齐：继承父元素（默认） | 起点对齐 | 终点对齐 | 居中对齐 | 基线对齐 | 拉伸对齐align-self: auto | flex-start | flex-end | center | baseline | stretch; 应用左右分栏、上下分栏。（检验下自己如何完成下列布局） 对 flex 不熟悉的同学可以参考下面网站进行学习： 30 分钟学会 Flex 布局 flex网页布局首选方案 灵活应用 flex 弹性布局快速构建 web 结构 不愿意看长篇大论的可以通过这个塔防游戏来学习：Flexbox Defense li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？场景 有时，在写页面的时候，会需要将 这个块状元素横排显示，此时就需要将 display 属性设置为 inline-block ，此时问题出现了，在两个 元素之间会出现大约 8px 左右的空白间隙 原因浏览器的默认行为是把 inline 元素间的空白字符（空格换行 tab ）渲染成一个空格，也就是我们上面的代码 换行后会产生换行字符，而它会变成一个空格，当然空格就占用一个字符的宽度。 解决给 ul 标签设置 font-size: 0; 并为 li 元素重新设置 font-size: xxpx; BFC(块级格式化上下文：block formatting context)理解BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。我们可以利用这些特性解决特定环境下的布局问题。 常见 BFC 应用清除元素内部浮动 计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。 只要把父元素设为 BFC 就可以清理子元素的浮动了，最常见的用法就是在父元素上设置 overflow: hidden 样式，对于 IE6 加上 zoom: 1 就可以了。 解决外边距合并问题 盒子垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠 属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠，那么我们创建不属于同一个 BFC ，就不会发生 margin 重叠了。 1234567&lt;div class="container4 green" style="height: 500px;"&gt; &lt;!-- 给其中一个 div 外面包一个 div ，然后通过触发外面这个 div 的 BFC ，就可以阻止这两个 div 的 margin 重叠 --&gt; &lt;div style="overflow: hidden;"&gt; &lt;div class="blue w100 h100" style="margin-bottom: 20px;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="red w200 h200" style="margin-top: 20px;"&gt;&lt;/div&gt;&lt;/div&gt; 两栏布局，实现左定宽+右宽自适应 普通流体元素BFC后，为了和浮动元素不产生任何交集，顺着浮动边缘形成自己的封闭上下文 12345&lt;div class="container" style="height: 300px; background-color: red;"&gt; &lt;div style="width: 100px; height: 100px; float: left; background-color: blue;"&gt;&lt;/div&gt; &lt;div style="overflow: hidden; background-color: green;"&gt;我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容&lt;/div&gt; &lt;!-- 给右侧div添加 overflow: hidden即可 --&gt;&lt;/div&gt; 注意：设置浮动后，div 会被 float 覆盖，而文本却不会被 float 覆盖，是因为 float 当初设计的时候就是为了使文本围绕在浮动对象的周围。 参考: [布局概念] 关于CSS-BFC深入理解 请解释一下为什么需要清除浮动？清除浮动的方式浮动本质是用来做一些文字混排效果的，但是被我们拿来做布局用，则会有很多的问题出现。 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，为了解决这些问题，此时就需要在该元素中清除浮动。准确地说，并不是清除浮动，而是清除浮动后造成的影响 本质清除浮动主要为了解决父级元素因为子级浮动引起内部高度为 0 的问题。 如何清除设置一个 clearfix 类，在出现浮动问题的父元素上添加此类即可： 12345678910.clearfix::after &#123; content: ""; display: block; clear: both; height: 0; visibility: hidden;&#125;.clearfix &#123; *zoom: 1;&#125; 什么是外边距合并？外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并： 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并： 尽管看上去有些奇怪，但是外边距甚至可以与自身发生合并。 假设有一个空元素，它有外边距，但是 没有边框或填充 。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并： 如果这个外边距遇到另一个元素的外边距，它还会发生合并： 注释：只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。 浏览器是怎样解析CSS选择器的？从右向左的，这样会提高查找选择器所对应的元素的效率 样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。 只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。 抽离样式模块怎么写，说出思路，有无实践经验？我们按照 CSS 的性质和用途，将 CSS 文件分成 「公共型样式」、「特殊型样式」、「皮肤型样式」，并以此顺序引用（按需求决定是否添加版本号）。 公共型样式：包括了以下几个部分：“标签的重置和设置默认值”、“统一调用背景图和清除浮动或其他需统一处理的长样式”、“网站通用布局”、“通用模块和其扩展”、“元件和其扩展”、“功能类样式”、“皮肤类样式”。 特殊型样式：当某个栏目或页面的样式与网站整体差异较大或者维护率较高时，可以独立引用一个样式：“特殊的布局、模块和元件及扩展”、“特殊的功能、颜色和背景”，也可以是某个大型控件或模块的独立样式。 皮肤型样式：如果产品需要换肤功能，那么我们需要将颜色、背景等抽离出来放在这里。 参考：CSS规范 - 分类方法 元素竖向的百分比设定是相对于父容器的高度吗？ 对于 height 属性来说是的。 对于 margin-top/bottom(padding-top/bottom) 来讲不是，而是相对于容器的宽度计算的 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？响应式网站设计（Responsive Web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。 1234567@media screen and (max-width: 990px) &#123; .container&#123; background: orange; &#125;&#125;/* &lt;head&gt;里边 &lt;link rel=”stylesheet” href=”xxx.css” media=”only screen and (max-width:480px)”&gt; */ 页面头部必须有 meta 声明的 viewport ： 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"&gt; 兼容 ie6-8 方案：使用 respond.js 插件： 123&lt;!--[if lte IE 8]&gt;&lt;script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 响应式和自适应设计的区别其实 RWD 和 AWD 都是响应式设计，从外观上很难分辨，但他们自己运行机理不同， RWD 是主动式的响应设计，AWD 是被动式的响应式设计。 RWD 不管用户使用的是什么设备都是在服务器把数据推送到浏览器后，脚本或 CSS 自行侦测屏幕大小后执行对应的样式表内容，并且一直通过本地脚本在监听屏幕大小的变化，随时做出样式响应的变化，所以是主动的。 AWD 是用户通过浏览器发送请求后，服务器根据请求中用户设备信息（request headers 的 user-agent）做出判断，调用已经在服务器里准备好的，适应对应设备样式文件+HTML内容+JS，返回给浏览器以这种方式响应不同设备。 1234567var deviceAgent = request.headers["user-agent"].toLowerCase();var agentID = deviceAgent.match(/(iphone|ipod|ipad|android)/);if (agentID) &#123; console.log("手机访问");&#125; else &#123; console.log("电脑访问");&#125; 你对 line-height 是如何理解的？如何单行文本垂直居中？多行文本呢？行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS 中起高度作用的是 height 和 line-height ，没有定义 height 属性，最终其表现作用一定是 line-height 。 单行文本垂直居中：（行高 == 元素高度）12height:40px;line-height:40px; /* 行高==高 */ 多行文本垂直居中：（父容器table，子容器table-cell+vertical-align:middle）12345678910111213141516&lt;div&gt; &lt;span&gt; 啊实打实大苏打啊实打实大师大师的啊实打实大苏打 &lt;/span&gt;&lt;/div&gt;div &#123; width: 300px; height: 200px; display: table; background-color: pink;&#125;span &#123; display: table-cell; vertical-align: middle;&#125; 设置元素浮动后，该元素的display值是多少？自动变成了 display: block 让页面里的字体变清晰，变细用 CSS 怎么做？1-webkit-font-smoothing: antialiased; overflow: scroll 时不能平滑滚动的问题怎么处理？一个 div 使用了 overflow:scroll; ，在移动端可以滚动，但是无法平滑滚动（就像浏览网页那样） 开启滚动硬件加速： 1-webkit-overflow-scrolling: touch; 什么是 CSS 预处理器 / 后处理器？CSS 预处理器CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件 Sass（SCSS）、LESS CSS 后处理器CSS 后处理器 是对 CSS 进行处理，并最终生成 CSS 的 预处理器，它属于广义上的 CSS 预处理器。 我们很久以前就在用 CSS 后处理器 了，最典型的例子是 CSS 压缩工具（如 clean-css），只不过以前没单独拿出来说过。还有最近比较火的 Autoprefixer，以 Can I Use 上的 浏览器支持数据 为基础，自动处理兼容性问题。 Rework、PostCSS 参考：CSS预处理器和后处理器 图片为什么有左右上下间隙,怎么去除：原因： 左右：因为 img 是 inline-block 行内元素，行内元素之间有『换行（回车），空格，tab』时会产生左右间隙 上下：行内元素默认与父容器基线对齐，而基线与父容器底部有一定间隙，所以上下图片间有间隙 解决办法： 移除上下间隙： img 本身设置 display: block; 父元素设置 font-size: 0; （基线与字体大小有关，字体为零，基线间就没距离了） img本身设置 vertical-align: bottom;（让 inline-block 的 img 与每行的底部对齐） 移除左右间距： 行内元素间不要有换行，连成一行写消除间隙 第一行结尾写上 &lt;!-- ，第二行开头跟上 --&gt; 。即利用注释消除间距 父元素 font-size 设置 0]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML知识点（面试系列）]]></title>
    <url>%2Fposts%2F13781%2F</url>
    <content type="text"><![CDATA[你对语义化的理解用正确的标签做正确的事情 利于开发：使代码结构清晰，可读性高，方便维护 利于SEO：方便爬虫根据语义标签确定页面结构和关键字的权重 你在平常工作中使用过哪些语义标签？header, nav, aside, main, section, article, footer, canvas, video, audio 你说你用过canvas/video/audio，你是怎么用它们的？ 画布：canvas 123456789101112131415&lt;body&gt; &lt;canvas width="500" height="500"&gt;&lt;/canvas&gt; &lt;script&gt; var canvas = document.querySelector("canvas") &lt;!-- 获取上下文 --&gt; var ctx = canvas.getContext("2d") ctx.beginPath() &lt;!-- 设置图形轮廓的颜色 --&gt; ctx.strokeStyle = "red" &lt;!-- 绘制直线 --&gt; ctx.moveTo(10, 20) ctx.lineTo(100, 200) ctx.stroke() &lt;/script&gt; &lt;/body&gt; 媒体元素：video 和 audio 12&lt;video src="视频资源路径" poster="海报资源路径" controls autoplay&gt;&lt;audio src="音频资源路径" controls autoplay loop&gt; 解释下移动端为什么要添加 meta viewport ，怎么写？作用： 防止页面在移动端可以缩放。 写法： 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; 解释： 使用 viewport 来控制浏览器视口的宽度和缩放比例 添加 width=device-width 以便让视口的宽度与设备一致 添加 initial-scale=1.0 设置初始缩放比例为1.0 添加 user-scalable=no 使得用户不能放大或缩小网页 添加 minimum-scale=1.0, maximum-scale=1.0 是为了兼容 iOS10 不支持 user-scalable 导致用户仍可缩放 参考阅读： 在移动浏览器中使用viewport元标签控制布局 HTML 具有视口元标记 移动端web开发——视口 关于图片，你了解哪些形式，你觉得哪种场合用哪种？它们优劣如何？然后这些图片的应用场景能说说不？ 格式 特点 使用场景 JPG/JPEG 有损压缩 体积小 不支持透明 1. 大的背景图； 2. 轮播图； 3. Banner 图 PNG 无损压缩 质量高 体积大 支持透明 1. 小 Logo； 2. 透明背景 GIF 支持动画 动态图片 SVG 文本文件 体积小 不失真 兼容性好 能适应不同设备且画质不能损坏的图片 Base64 文本文件 依赖编码 小图标解决方案 大小不超过 2KB，且更新率低的图片 webp 细节丰富 支持透明 支持动画 兼容性差 Chrome UC 等浏览器支持，局限性大，一般不考虑 雪碧图 一次加载多处使用 小图太多的时候，集中成一张图片减少 HTTP 请求 更多阅读：面试知识点 - 图片]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS知识点（面试系列）]]></title>
    <url>%2Fposts%2F31920%2F</url>
    <content type="text"><![CDATA[JS类型string，number，boolean，undefined，null，symbol，object 值类型和引用类型的区别两种类型的区别是：存储位置不同； 值类型存储在栈（stack）中，占空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用类型存储在堆（heap）中,占据空间大、大小不固定。如果存在栈中，影响程序运行性能；引用类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 JS的类型检测 typeof （判断一个变量是什么类型）undefined object function boolean string number symbol instanceof （判断当前对象是不是某个类型） 1234567891011121314&lt;!-- 要检测的对象 instanceof 某个构造函数 --&gt;function Car(make, model, year) &#123; this.make = make; this.model = model;&#125;var auto = new Car('Honda', 'Accord');console.log(auto instanceof Car);// expected output: trueconsole.log(auto instanceof Object);// expected output: true Object.prototype.toString.call()（检测一个对象的类型） 1console.log(Object.prototype.toString.call("Lance"));//[object String] === 和 == 的区别== 在允许强制转换的条件下检查值的等价性，而 === 是在不允许强制转换的条件下检查值的等价性； 因此 === 常被称为「严格等价」。（”55” == 55 true, “55” === 55 false。p.s. 把字符串转为数值） 哪些非 boolean 值被强制转换为一个 boolean 时，它是 false ？ &quot;&quot;（空字符串） 0, -0, NaN （非法的 number ） null, undefined null，undefined 的区别？ null 表示一个对象是「没有值」的值，也就是值为 “空”； undefined 表示一个变量声明了没有初始化(赋值)； undefined 的类型（typeof）是 undefined ； null 的类型（typeof）是 object ； JavaScript 将未赋值的变量默认值设为undefined； JavaScript 从来不会将变量设为 null 。它是用来让程序员表明某个用 var 声明的变量时没有值的。 在验证 null 时，一定要使用 === ，因为 == 无法分别 null 和 undefined 12null == undefined // truenull === undefined // false DOMDOM 操作——怎样添加、移除、移动、复制、创建和查找节点？1234567891011121314（1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点（2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点（3）查找 querySelector("ul") / querySelectorAll("ul li") // 查找单个元素 / 多个元素 getElementsByTagName("div") getElementsByClassName() getElementById() DOM数操作123456789101112131415161718192021// 添加新节点var p1 = document.createElement('p')p1.innerHTML = 'this is p1'div1.appendChild(p1) // 添加新创建的元素// 移动已有节点。注意，这里是“移动”，并不是拷贝var p2 = document.getElementById('p2')div1.appendChild(p2)// 获取父元素var div1 = document.getElementById('div1')var parent = div1.parentElement// 获取子元素var div1 = document.getElementById('div1')var child = div1.childNodes// 删除节点var div1 = document.getElementById('div1')var child = div1.childNodesdiv1.removeChild(child[0]) offsetWidth/offsetHeight，clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别 offsetWidth/offsetHeight 返回值包含 content + padding + border，效果与 e.getBoundingClientRect() 相同； clientWidth/clientHeight 返回值只包含 content + padding，如果有滚动条，也不包含滚动条； scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。 什么是 Virtual DOM，为何要用 Virtual DOM？Virtual DOM 的概念有很多解释，分别是：一个对象，两个前提，三个步骤。 一个对象指的是 Virtual DOM 是一个基本的 JavaScript 对象，也是整个 Virtual DOM 树的基本。 两个前提分别是 JavaScript 很快和直接操作 DOM 很慢，这是 Virtual DOM 得以实现的两个基本前提。 得益于 V8 引擎的出现，让 JavaScript 可以高效地运行，在性能上有了极大的提高。 直接操作 DOM 的低效和 JavaScript 的高效相对比，为 Virtual DOM 的产生提供了大前提。 三个步骤指的是 Virtual DOM 的三个重要步骤，分别是：生成 Virtual DOM 树、对比两棵树的差异、更新视图。 1.生成 Virtual DOM 树： DOM 是前端工程师最常接触的内容之一，一个 DOM 节点包含了很多的内容，但是抽象出一个 DOM 节点却只需要三部分：节点类型，节点属性、子节点。所以围绕这三个部分，我们可以使用 JavaScript 简单地实现一棵 DOM 树，然后给节点实现渲染方法，就可以实现虚拟节点到真实 DOM 的转化。 2.对比两棵树的差异： 比较两棵 DOM 树的差异是 Virtual DOM 算法最核心的部分，这也是我们常说的的 Virtual DOM 的 diff 算法。在比较的过程中，我们只比较同级的节点，非同级的节点不在我们的比较范围内，这样既可以满足我们的需求，又可以简化算法实现。 比较“树”的差异，首先是要对树进行遍历，常用的有两种遍历算法，分别是深度优先遍历和广度优先遍历，一般的 diff 算法中都采用的是深度优先遍历。对新旧两棵树进行一次深度优先的遍历，这样每个节点都会有一个唯一的标记。在遍历的时候，每遍历到一个节点就把该节点和新的树的同一个位置的节点进行对比，如果有差异的话就记录到一个对象里面。 例如，上面的 div 和新的 div 有差异，当前的标记是 0，那么：patches[0] = [{difference}, {difference}, …]。同理 p 是 patches[1]，ul 是 patches[3]，以此类推。这样当遍历完整棵树的时候，就可以获得一个完整的差异对象。 在这个差异对象中记录了有改变的节点，每一个发生改变的内容也不尽相同，但也是有迹可循，常见的差异包括四种，分别是： 替换节点 增加/删除子节点 修改节点属性 改变文本内容 对象的原生方法Object.assign()copy 对象的可枚举属性 语法：Object.assign(target, …sources) 参数：目标对象, …源对象 返回值：目标对象 123const obj = &#123; a: 1 &#125;;const copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; a: 1 &#125; Object.create()创建新对象 语法：Object.create(proto, [ propertiesObject ]) 参数：新创建对象的原型对象, 用于指定创建对象的一些属性，（eg：是否可读、是否可写，是否可以枚举etc） Object.is()用来判断两个值是否是同一个值 123456789101112131415Object.is('haorooms', 'haorooms'); // trueObject.is(window, window); // trueObject.is('foo', 'bar'); // falseObject.is([], []); // falsevar test = &#123; a: 1 &#125;;Object.is(test, test); // trueObject.is(null, null); // true// 特例Object.is(0, -0); // falseObject.is(-0, -0); // trueObject.is(NaN, 0/0); // true Object.keys / Object.values返回给定对象的自身可枚举属性 / 值 的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 1234567891011121314// simple arrayvar arr = ['a', 'b', 'c'];console.log(Object.keys(arr)); // console: ['0', '1', '2']// array like objectvar obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.keys(obj)); // console: ['0', '1', '2']var obj = &#123; foo: 'bar', baz: 42 &#125;;console.log(Object.values(obj)); // ['bar', 42]// array like objectvar obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.values(obj)); // ['a', 'b', 'c'] Object.entries()**Object.entries()** 方法返回对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。 12345678const obj = &#123; foo: 'bar', baz: 42 &#125;;console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]// iterate through key-value gracefullyconst obj = &#123; a: 5, b: 7, c: 9 &#125;;for (const [key, value] of Object.entries(obj)) &#123; console.log(`$&#123;key&#125; $&#123;value&#125;`); // "a 5", "b 7", "c 9"&#125; 数组数组的遍历方法 标准for循环 forEach((当前值, 当前索引,当前数组)=&gt;{}) 无法中途退出循环，只能用 return 退出本次回调，进行下一次回调。 它总是返回 undefined 值,即使你 return 了一个值。 for-in（不推荐）会把继承链的对象属性都会遍历一遍，而且数组遍历不一定按次序 for-in 循环返回的是所有能通过对象访问的、可枚举的属性。 for (variable of iterable)（ES6）可迭代 Array ，Map，Set，String 等（迭代的是值 value ） 在 for-of 中如果遍历中途要退出，可以使用 break 退出循环。 ES5 map (不改变原数组) 会给原数组中的每个元素都按顺序调用一次 callback 函数 reduce (不改变原数组) 数组中的前项和后项做某种计算,并累计最终值。 12345678// arr.reduce(function(total, currentValue, currentIndex, arr), initialValue)// callback 参数// (累积器, 当前元素, 当前元素索引, 当前数组)// initialValue:指定第一次回调 的第一个参数var wallets = [4, 7.8, 3]var totalMoney = wallets.reduce(function (countedMoney, curMoney) &#123; return countedMoney + curMoney;&#125;, 0) filter（不改变原数组） 1234var arr = [2, 3, 4, 5, 6]var morearr = arr.filter(function (number) &#123; return number &gt; 3&#125;) // [4,5,6] every（不改变原数组）测试数组的所有元素是否都通过了指定函数的测试 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。 如果所有元素都满足条件，则返回 true 。1234var arr = [1,2,3,4,5]var result = arr.every(function (item, index) &#123; return item &gt; 2&#125;) // false some（不改变原数组）测试是否至少有一个元素通过 callback 中的条件.对于放在空数组上的任何条件，此方法返回 false 。 如果有一个元素满足条件，则表达式返回 true , 剩余的元素不会再执行检测。 如果没有满足条件的元素，则返回 false 。12345678// some(callback, thisArg)// callback:// (当前元素, 当前索引, 调用some的数组)var arr = [1,2,3,4,5]var result = arr.some(function (item,index) &#123; return item &gt; 3&#125;) // true ES6 find() &amp; findIndex() 根据条件找到数组成员 find() 定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回 undefined 。 findIndex() 定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 -1 。 1234567891011121314&lt;!-- 语法 --&gt;let new_array = arr.find(function(currentValue, index, arr), thisArg)let new_array = arr.findIndex(function(currentValue, index, arr), thisArg)&lt;!-- 这两个方法都可以识别NaN,弥补了indexOf的不足 --&gt;&lt;!-- find --&gt;let a = [1, 4, -5, 10].find((n) =&gt; n &lt; 0);&lt;!-- 返回元素-5 --&gt;let b = [1, 4, -5, 10,NaN].find((n) =&gt; Object.is(NaN, n));&lt;!-- 返回元素NaN --&gt;&lt;!-- findIndex --&gt;let a = [1, 4, -5, 10].findIndex((n) =&gt; n &lt; 0);&lt;!-- 返回索引2 --&gt;let b = [1, 4, -5, 10,NaN].findIndex((n) =&gt; Object.is(NaN, n));&lt;!-- 返回索引4 --&gt; keys() &amp; values() &amp; entries() 遍历键名、遍历键值、遍历键名+键值 三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。 1234567891011121314151617181920// 语法array.keys() array.values() array.entries()for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" for in 和 for of 区别12345678910111213141516171819Object.prototype.objCustom = function() &#123;&#125;;Array.prototype.arrCustom = function() &#123;&#125;;let iterable = [3, 5, 7];iterable.foo = 'hello';for (let i in iterable) &#123; &lt;-- 循环的是索引 console.log(i); // 打印 0, 1, 2, "foo", "arrCustom", "objCustom"&#125;for (let i in iterable) &#123; if (iterable.hasOwnProperty(i)) &#123; console.log(i); // 打印 0, 1, 2, "foo" &#125;&#125;for (let i of iterable) &#123; &lt;-- 迭代的是值 console.log(i); // 打印 3, 5, 7&#125; 参考：JavaScript 数组遍历方法的对比 JS数组有哪些方法改变原数组的方法（9个）splice() 添加 / 删除数组元素 splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目 array.splice(index,howmany,item1,…..,itemX) index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX： 可选。向数组添加的新项目。 返回值: 如果有元素被删除,返回包含被删除项目的新数组。 删除元素 1234567// 从数组下标0开始，删除3个元素let a = [1, 2, 3, 4, 5, 6, 7]let item = a.splice(0, 3) // [1,2,3]console.log(a) // [4,5,6,7]// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7let item = a.splice(-1, 3) // [7] 删除并添加 123456789// 从数组下标0开始，删除3个元素，并添加元素'添加'let a = [1, 2, 3, 4, 5, 6, 7]let item = a.splice(0,3,'添加') // [1,2,3]console.log(a) // ['添加',4,5,6,7]// 从数组最后第二个元素开始，删除3个元素，并添加两个元素'添加1'、'添加2'let b = [1, 2, 3, 4, 5, 6, 7]let item = b.splice(-2,3,'添加1','添加2') // [6,7]console.log(b) // [1,2,3,4,5,'添加1','添加2'] 不删除只添加 1234567let a = [1, 2, 3, 4, 5, 6, 7]let item = a.splice(0,0,'添加1','添加2') // [] 没有删除元素，返回空数组console.log(a) // ['添加1','添加2',1,2,3,4,5,6,7]let b = [1, 2, 3, 4, 5, 6, 7]let item = b.splice(-1,0,'添加1','添加2') // [] 没有删除元素，返回空数组console.log(b) // [1,2,3,4,5,6,'添加1','添加2',7] 在最后一个元素的前面添加两个元素 sort() 数组排序 定义: sort() 方法对数组元素进行排序，并返回这个数组。 参数可选: 规定排序顺序的比较函数。 默认情况下 sort() 方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用 toString() 方法将元素转化为字符串的 Unicode (万国码)位点，然后再比较字符。 不传参 1234567// 字符串排列 看起来很正常var a = ["Banana", "Orange", "Apple", "Mango"]a.sort() // ["Apple","Banana","Mango","Orange"]// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的var a = [10, 1, 3, 20,25,8]console.log(a.sort()) // [1,10,20,25,3,8]; 比较函数的两个参数： sort 的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素： 若比较函数返回值 &lt;0 ，那么 a 将排到 b 的前面; 若比较函数返回值 =0 ，那么 a 和 b 相对位置不变； 若比较函数返回值 &gt;0 ，那么 b 排在 a 将的前面； 数字升降序 12345678910var array = [10, 1, 3, 4, 20, 4, 25, 8]; array.sort(function(a,b)&#123; return a-b;&#125;);console.log(array); // [1,3,4,4,8,10,20,25];array.sort(function(a,b)&#123; return b-a;&#125;);console.log(array); // [25,20,10,8,4,4,3,1]; pop() 删除一个数组中的最后的一个元素 定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。 123let a = [1,2,3]let item = a.pop() // 3console.log(a) // [1,2] shift() 删除数组的第一个元素 定义: shift()方法删除数组的第一个元素，并返回这个元素。 123let a = [1,2,3]let item = a.shift() // 1console.log(a) // [2,3] push() 向数组的末尾添加元素 定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 参数: item1, item2, …, itemX ,要添加到数组末尾的元素 123let a = [1,2,3]let item = a.push('末尾', '233') // 5console.log(a) // [1,2,3,'末尾', '233'] unshift() 定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。 参数: item1, item2, …, itemX ,要添加到数组开头的元素 123let a = [1, 2, 3]let item = a.unshift('开头', '开头2') // 5console.log(a) // [ '开头', '开头2', 1, 2, 3 ] reverse() 颠倒数组中元素的顺序 定义: reverse() 方法用于颠倒数组中元素的顺序。 123let a = [1,2,3]a.reverse()console.log(a) // [3,2,1] 不改变原数组的方法（8个）slice() 浅拷贝数组的元素 定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。 语法：array.slice(begin, end); 12345678910111213let a= ['hello','world']let b=a.slice(0,1) // ['hello']// 新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。// 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。a[0] = '改变原数组'console.log(a,b) // ['改变原数组','world'] ['hello']let a = [&#123;name:'OBKoro1'&#125;]let b = a.slice()console.log(b,a) // [&#123;"name":"OBKoro1"&#125;] [&#123;"name":"OBKoro1"&#125;]// a[0].name='改变原数组'// console.log(b,a) // [&#123;"name":"改变原数组"&#125;] [&#123;"name":"改变原数组"&#125;] join() 数组转字符串 定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。 语法: array.join(str) 12345678910111213let a = ['hello','world']let str = a.join() // 'hello,world'let str2 = a.join('+') // 'hello+world'let a = [['OBKoro1','23'],'test']let str1 = a.join() // OBKoro1,23,testlet b = [&#123;name:'OBKoro1',age:'23'&#125;,'test']let str2 = b.join() // [object Object],test// 对象转字符串推荐JSON.stringify(obj)// 结论：// join()/toString() 方法在数组元素是数组的时候，会将里面的数组也调用 join()/toString() ,// 如果是对象的话，对象会被转为 [object Object] 字符串。 toLocaleString() 数组转字符串 定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。 12345678910111213let a = [&#123; name: 'OBKoro1'&#125;, 23, 'abcd', new Date()]console.log(a.join(","))console.log(a.toString())console.log(a.toLocaleString('en-us'))console.log(a.toLocaleString('zh-cn'))[object Object],23,abcd,Tue Feb 26 2019 11:47:03 GMT+0800 (中国标准时间)[object Object],23,abcd,Tue Feb 26 2019 11:47:03 GMT+0800 (中国标准时间)[object Object],23,abcd,2/26/2019, 11:47:03 AM[object Object],23,abcd,2019/2/26 上午11:47:03 concat 合并数组 定义： 方法用于合并两个或多个数组，返回一个新数组。 语法：var newArr =oldArray.concat(arrayX,arrayX,……,arrayX) 参数：arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。 1234567891011121314let a = [1, 2, 3]let b = [4, 5, 6]//连接两个数组let newVal = a.concat(b) // [1,2,3,4,5,6]// 连接三个数组let c = [7, 8, 9]let newVal2 = a.concat(b, c) // [1,2,3,4,5,6,7,8,9]// 添加元素let newVal3 = a.concat('添加元素',b, c,'再加一个')// [1,2,3,"添加元素",4,5,6,7,8,9,"再加一个"]// 合并嵌套数组 会浅拷贝嵌套数组let d = [1,2 ]let f = [3,[4]]let newVal4 = d.concat(f) // [1,2,3,[4]] ES6扩展运算符 ... 合并数组123let a = [2, 3, 4, 5]let b = [ 4,...a, 4, 4]console.log(a,b) // [2, 3, 4, 5] [4,2,3,4,5,4,4] indexOf() 查找数组是否存在某个元素，返回下标 定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 p.s. 字符串也有此方法，要注意当 ‘lance’.indexOf(‘’) 一个空字符串时，返回0而不是-1 语法：array.indexOf(searchElement,fromIndex) 参数： searchElement (必须):被查找的元素 fromIndex (可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。 严格相等的搜索: 数组的 indexOf 搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等===搜索元素，即数组元素要完全匹配才能搜索成功。 注意：indexOf() 不能识别NaN 1234let a=['啦啦',2,4,24,NaN]console.log(a.indexOf('啦')) // -1console.log(a.indexOf('NaN')) // -1console.log(a.indexOf('啦啦')) // 0 lastIndexOf() 查找指定元素在数组中的最后一个位置 定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找） 语法：arr.lastIndexOf(searchElement,fromIndex) 参数: searchElement(必须): 被查找的元素 fromIndex(可选): 逆向查找开始位置，默认值数组的 长度-1，即查找整个数组。 关于fromIndex有三个规则: 正值。如果该值大于或等于数组的长度，则整个数组会被查找。 负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找) 负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 12345let a = ['OB',4,'Koro1',1,2,'Koro1',3,4,5,'Koro1'] // 数组长度为10// let b=a.lastIndexOf('Koro1',4) // 从下标4开始往前找 返回下标2// let b=a.lastIndexOf('Koro1',100) // 大于或数组的长度 查找整个数组 返回9// let b=a.lastIndexOf('Koro1',-11) // -1 数组不会被查找let b = a.lastIndexOf('Koro1',-9) // 从第二个元素4往前查找，没有找到 返回-1 ES7 includes() 查找数组是否包含某个元素 返回布尔 定义： 返回一个布尔值，表示某个数组是否包含给定的值 语法：array.includes(searchElement,fromIndex=0) 参数： searchElement (必须):被查找的元素 fromIndex (可选):默认值为 0 ，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回 false 。负值绝对值超过长数组度，重置从 0 开始搜索。 includes 方法是为了弥补 indexOf 方法的缺陷而出现的: indexOf 方法不能识别 NaN indexOf 方法检查是否包含某个值不够语义化，需要判断是否不等于 -1 ，表达不够直观 12345let a = ['OB','Koro1',1,NaN]// let b=a.includes(NaN) // true 识别NaN// let b=a.includes('Koro1',100) // false 超过数组长度 不搜索// let b=a.includes('Koro1',-3) // true 从倒数第三个元素开始搜索// let b=a.includes('Koro1',-100) // true 负值绝对值超过数组长度，搜索整个数组 参考：js 数组详细操作方法及解析合集 字符串字符串的方法charAt 返回字符串字符 从一个字符串中返回指定字符如果指定的 index 值超出了该范围，则返回一个空字符串 12var anyString = "Brave new world"console.log(anyString.charAt(0)) // B substring 返回字符串子集 返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。 如果 indexStart 等于 indexEnd，substring 返回一个空字符串。 如果省略 indexEnd，substring 提取字符一直到字符串末尾。 如果任一参数小于 0 或为 NaN，则被当作 0。 如果任一参数大于 stringName.length，则被当作 stringName.length。 如果 indexStart 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。见下面的例子。 12345678var anyString = "Mozilla"// 输出 "Moz"console.log(anyString.substring(0,3))console.log(anyString.substring(3,0))console.log(anyString.substring(3,-3))console.log(anyString.substring(3,NaN))console.log(anyString.substring(-2,3))console.log(anyString.substring(NaN,3)) replace 替换字符串 返回一个由替换值（replacement）替换一些或所有匹配的模式（pattern）后的新字符串。模式可以是一个字符串或者一个 正则表达式 ，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。 toLowerCase / toUpperCase 转换字母大小写字母转为全小写或全大写 includes includes() 返回布尔值：表示是否找到了参数字符。 12let str = "qdywxs"console.log(str.includes("y")) //--&gt;true repeat 获取字符串重复 n 次。 12let s = "qdywxs"console.log(s.repeat(3)) //--&gt;qdywxsqdywxsqdywxs startsWith 返回布尔值：表示参数字符串是否在源字符串的头部。 12console.log("swlance".startsWith("s")); //--&gt;trueconsole.log("swlance".startsWith("l")); //--&gt;false endsWith 返回布尔值，表示参数字符串是否在源字符串的尾部。 12console.log("swlance".endsWith("e")); //--&gt;trueconsole.log("swlance".endsWith("o")); //--&gt;false 什么是 JavaScript 作用链域？全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找， 直至全局函数，这种组织形式就是作用域链。 闭包什么是闭包/对闭包的理解函数中有另一个函数或有另一个对象，里面的函数或者是对象都可以使用外面函数中定义的变量或者参数，此时形成闭包。 YouDontKnowJS对闭包的解释 —— 闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。由于这个性质，闭包让我们能够从一个函数内部访问其外部函数的作用域 闭包就是能够读取其他函数内部变量的函数。可以简单理解成“定义在一个函数内部的函数” 闭包的用途 保存：缓存数据，延长作用域链 保护：形成私有作用域，保护里面私有变量不受外界干扰，避免全局污染 缺点：耗内存，耗性能，函数中的变量不能及时释放 如何使用闭包要使用闭包，只需要简单地将一个函数定义在另一个函数内部，并将它暴露出来。要暴露一个函数，可以将它返回或者传给其他函数。 内部函数将能够访问到外部函数作用域中的变量，即使外部函数已经执行完毕。 想要缓存数据的时候就用闭包，把想要缓存的数据放在外层函数和内层函数的中间位置。 闭包应用场景li 节点的 onclick 事件都能正确的弹出当前被点击的 li 索引1234567891011121314151617&lt;ul id="testUL"&gt; &lt;li&gt; index = 0&lt;/li&gt; &lt;li&gt; index = 1&lt;/li&gt; &lt;li&gt; index = 2&lt;/li&gt; &lt;li&gt; index = 3&lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var nodes = document.getElementsByTagName("li") for (var i = 0; i &lt; nodes.length; i += 1) &#123; nodes[i].onclick = (function (i) &#123; return function () &#123; // &lt;----重点是此处返回了个一个匿名函数，这个函数能访问 // 立即执行函数作用域内的i这个变量，形成闭包 console.log(i) &#125; //不用闭包的话，值每次都是4 &#125;)(i) &#125;&lt;/script&gt; 用闭包模拟私有方法使用闭包定义能访问私有函数和私有变量的公有函数（也叫做模块模式） 123456789101112131415161718192021222324var counter = (function() &#123; var privateCounter = 0 function changeBy(val) &#123; privateCounter += val &#125; return &#123; increment: function() &#123; changeBy(1) &#125;, decrement: function() &#123; changeBy(-1) &#125;, value: function() &#123; return privateCounter; &#125; &#125;&#125;)() // 立即执行函数console.log(counter.value()) // logs 0counter.increment()counter.increment()console.log(counter.value()) // logs 2counter.decrement()console.log(counter.value()) // logs 1 环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。 它俩都无法在匿名函数外部直接访问。必须通过匿名包装器返回的对象的三个公共函数访问。 解决 循环+闭包 问题直接 点击此处 查看 this对 this 的理解 this 总是指向函数的直接调用者（而非间接调用者） 如果有 new 关键字，this 指向 new 出来的那个对象 在事件中，this 指向触发这个事件的对象，特殊的是，IE 中的 attachEvent 中的 this 总是指向全局对象 window 重要： 普通函数的 this 指向是在函数的执行期间绑定的 箭头函数的 this 指向是在函数创建期间就绑定好了的，指向的是创建该箭头函数所在的作用域对象 一般不在事件（比如 onclick ）上传递箭头函数，使用 function 就好 判定 this 摘自 YouDontKnowJS 现在，我们可以按照优先顺序来总结一下从函数调用的调用点来判定 this 的规则了。按照这个顺序来问问题，然后在第一个规则适用的地方停下。 函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。var bar = new foo() 函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。var bar = foo.call( obj2 ) 函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。var bar = obj1.foo() 否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。var bar = foo() 以上，就是理解对于普通的函数调用来说的 this 绑定规则 所需的全部。是的……几乎是全部。 apply, call, bind 的区别 apply, call, bind 本身存在于大 Function 构造函数的 prototype 中 所有的函数都是大 Function 的实例对象 apply, call, bind 方法都可以改变 this 的指向 apply(对象, [参数1, 参数2, 餐数3, …]) call(对象, 参数1, 参数2, 餐数3,…) bind(对象,参数1, 参数2, 餐数3,…) 函数名称.bind()—-&gt;返回值是复制之后的这个函数 区别 apply，call 是调用的时候改变 this 指向，然后返回函数执行的结果。 参数较多时用 apply ，参数较少时用 call bind 是复制一份函数并返回，并且这个函数的 this 指向变成了传入的第一个参数。 JavaScript 原型什么是原型 实例对象中有个属性 __proto__ ，是个对象，叫原型，不是标准的属性，浏览器使用的—–&gt;可以叫原型对象 构造函数中有一个属性 prototype ，也是个对象，叫原型，是标准属性，程序员使用—&gt;可以叫原型对象 实例对象的 __proto__ 和构造函数中的 prototype 相等—&gt; true 又因为实例对象是通过构造函数来创建的，构造函数中有原型对象prototype 实例对象的 __proto__ 指向了构造函数的原型对象 prototype 每个对象都会在其内部初始化一个属性，就是 prototype（原型）。原型就是 __proto__（IE8不支持，非标准属性） 或者是 prototype ，都是原型对象。 作用 共享数据，目的是：节省内存空间 实现继承，目的是：节省内存空间 原型链什么是原型链精简版 原型链是一种关系，实例对象和原型对象之间的关系，关系是通过原型（proto）来联系的。 详细版 每个对象都会在其内部初始化一个属性 prototype（原型），当我们访问一个对象的属性时， 如果这个对象内部不存在这个属性，那么他就会去 prototype 里找这个属性，这个 prototype 又会有自己的 prototype ，于是就这样一直找下去，也就是我们平时所说的原型链的概念。 原型和原型链 原型链最终指向 分别使用原型链和 class 的方式实现继承1. 组合继承（原型链 + 借用构造函数）【不推荐】123456789101112131415161718192021function Person(name, age) &#123; this.name = name this.age = age&#125;Person.prototype.sayHi=function () &#123;&#125;function Student(name, age, weight) &#123; // 借用构造函数 Person.call(this, name, age) this.weight = weight&#125;// 改变原型指向----继承// 我们让 Student.prototype 指向一个 Person 的实例对象// 这个对象的 __proto__ 指向的是 Person.prototype// 所以我们就可以借助这个实例对象拿到 sayHi 方法，实现继承Student.prototype = new Person()Student.prototype.eat = function () &#123;&#125;var stu = new Student("Lance", 20, 120)var stu2 = new Student("Will", 200 , 110)// 属性和方法都被继承了 由上面方案引出的问题： 为什么不能 Student.prototype = Person.prototype对象的赋值只是引用的赋值, 上面两者都指向同一个内存地址，只要随便通过 1 个途径就能修改该内存地址的对象，这样子类就无法单独扩展方法，因为会影响父类。 单纯的原型链继承有什么缺陷虽然改变了原型的指向，但属性在初始化的时候就已经固定了【Student.prototype = new Person(“小明”, 29, 90)】，如果是多个对象实例化，那么每个实例对象的属性的初始值就都是一样的。换句话说，无法向父类传递参数。 单纯的借用构造函数继承有什么缺陷只能继承父类构造函数里面的属性和方法【Person.call(this, name, age)】，但父类的 prototype（原型）上的属性和方法不能继承。 组合继承的缺点调用了两次父类的构造函数。第一次给子类的原型添加了父类构造函数中的属性方法，第二次又给子类的构造函数添加了父类的构造函数的属性方法，从而覆盖了子类原型中的同名参数。这种被覆盖的情况造成了性能上的浪费： 123456789101112function SuperType() &#123; this.name = 'parent' this.arr = [1, 2, 3]&#125;SuperType.prototype.say = function() &#123;&#125;function SubType() &#123; SuperType.call(this) // 第二次调用SuperType&#125;SubType.prototype = new SuperType() // 第一次调用SuperType 2. 寄生组合继承【推荐】1234567891011121314151617181920212223function Person(name, age) &#123; this.name = name this.age = age this.sayHi = function() &#123;&#125;&#125;Person.prototype.eat = function() &#123;&#125;function Student(name, age, weight) &#123; Person.call(this, name, age) this.weight = weight this.study = function() &#123;&#125;&#125;var F = function ()&#123;&#125;// 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费F.prototype = Person.prototype // 创建了父类原型的浅复制Student.prototype = new F();// 上面三段js代码也可以用 Student.prototype = Object.create(Person.prototype) 代替Student.prototype.constructor = Student // 修正原型的构造函数var stu1 = new Student("Lance", 19, 120)console.dir(stu1) 3. class 实现继承1234567891011121314151617181920212223class Person &#123; constructor(name, age) &#123; this.name = name this.age = age // 类本身的方法 this.sayHi = function() &#123;&#125; &#125; // 这里的 eat 相当于 prototype 中的 eat eat() &#123;&#125;&#125;// 关键点：extends superclass Student extends Person &#123; constructor(name, age, weight) &#123; super(name, age) this.weight = weight this.study = function() &#123;&#125; &#125; run() &#123;&#125;&#125;var stu = new Student("Jerry", 20, 100)console.dir(stu) 原型链，proto 和 prototype 的区别对象拥有 __proto__ 属性，函数拥有 prototype 属性。某个实例对象的 __proto__ 指向构造它的构造函数的 prototype 属性。所以：实例对象的 __proto__ 指向了构造函数的原型对象 prototype： 1234567// 构造函数function B(b) &#123; this.b = b&#125;// 实例对象var b = new B('lc')b.__proto__ === B.prototype // true 参考：彻底理解什么是原型链，prototype和proto的区别。 对象 函数（包括构造函数）是对象 对象不一定是函数 对象有 __proto__ 函数有 prototype 创建对象的三种方式字面量的方式12345var obj = &#123; name: "Lance", age: 20, sayHi: function()&#123;&#125;&#125; 调用系统的构造函数1234var obj = new Object()obj.name = 'Lance'obj.age = 20obj.sayHi = function()&#123;&#125; 自定义构造函数12345function Person(name, age) &#123; this.name = name this.age = age this.sayHi = function()&#123;&#125;&#125; new 操作符具体干了什么呢？ 创建一个新对象，如：var obj = {}; 新对象的 __proto__ 属性指向构造函数的原型对象。 将构造函数的作用域赋值给新对象。（也所以this对象指向新对象） 执行构造函数内部的代码，将属性添加给obj中的this对象。 返回新对象obj。 12345function _new(fn, ...args) &#123; const obj = Object.create(fn.prototype) const ret = fn.apply(obj, args) return ret instanceof Object ? ret : obj&#125; 通过 new 的方式创建对象和通过字面量创建有什么区别？ 字面量创建对象，不会调用 Object 构造函数, 简洁且性能更好; new Object() 方式创建对象本质上是方法调用，涉及到在 proto 链中遍历该方法，当找到该方法后，又会生产方法调用必须的 堆栈信息，方法调用结束后，还要释放该堆栈，性能不如字面量的方式 事件什么是事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 事件处理机制：IE9以下只支持事件冒泡、Firefox、Chrome等则同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。 ev.stopPropagation();（旧 ie 的方法 ev.cancelBubble = true） 事件流 什么是DOM事件模型主要有三种 DOM 事件模型： 事件冒泡：元素先监听到这个事件，往外传播； 事件捕获：Document 最先监听到这个事件； DOM 事件流：先捕获，再冒泡。允许在某些地方监听事件，假设在某个元素两阶段都绑定一个事件监听器，看你是决定在左边捕获阶段监听，还是右边冒泡阶段监听，哪一边有响应，哪一边事件就被触发。即可以在任一阶段、任意时机监听事件。 事件绑定的三种方式1234567891011121314151617// 【 DOM0 级事件 】// 第一种：作为属性，写在标签上// &lt;div onclick="fun();"&gt;click&lt;/div&gt; ← 绑定在事件冒泡阶段// 第二种，使用 onclickdocument.getElementById("xxx").onclick = function()&#123;&#125; // ← 绑定在事件冒泡阶段// 【 DOM2 级事件 】// 第三种：使用推荐的标准模式document.getElementById("xxx").addEventListener("click", function(e)&#123;&#125;, false)// 第三种可以改变事件绑定的阶段// ---&gt; 为 false 时，绑定在事件冒泡阶段（默认下是绑定在冒泡阶段）// ---&gt; 为 true 时，绑定在捕获阶段// 如果绑定在捕获阶段，监听函数就只在捕获阶段触发// 如果绑定在冒泡阶段，监听函数只在冒泡阶段触发。 DOM2 事件传播机制DOM 作为事件处理的一个基本标准，DOM2 级事件为 DOM 事件的升级； DOM2 级事件定义用于处理指定和删除事件处理程序的操作： addEventListener removeEventListener 所有的 DOM 节点都包含这两个方法，并且它们都接受三个参数： 事件类型； 事件处理方法； 布尔参数。如果是 true 表示在捕获阶段调用事件处理程序；如果是 false，则是在事件冒泡阶段处理。 事件的执行顺序 无论是哪种绑定方式，对于同一个绑定元素，都是遵循先绑定的先执行原则。 如果是以 onclick 的方式绑定的，如果对同一个元素重复绑定的话，后面的会覆盖前面的。但是如果是以 addEventListener 方式绑定的话，同一个元素绑定多少次，就会执行多少次。 如果在 DOM 中直接使用 onclick ，则 onclick 的绑定是早于 addEventListener 的。 我们给一个 dom 同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？会执行两次事件，按代码执行顺序来 规律：绑定在被点击元素的事件是按照代码顺序发生，其他元素通过冒泡或者捕获“感知”的事件，按照W3C的标准，先发生捕获事件，后发生冒泡事件。所有事件的顺序是：其他元素捕获阶段事件 -&gt; 本元素代码顺序事件 -&gt; 其他元素冒泡阶段事件 事件委托绑定在父级元素，利用事件冒泡去触发父级事件处理函数的一种技巧。 实现一个事件委托123456789101112131415161718192021222324252627282930313233var ul = document.querySelector('ul')function listen(element, eventType, targetElement, fn) &#123; element.addEventListener(eventType, function(e) &#123; // 先拿到当前事件的直接触发对象 var curTarget = e.target // 看它是不是使用者监听的目标对象类型 // 一旦发现不是，就执行循环 while(!curTarget.matches(targetElement)) &#123; // 先看看当前对象是不是和父元素相同 // 相同则把当前对象置为空，且不执行回调 if (curTarget === element) &#123; curTarget = null break &#125; // 不相同则把当前对象设置成自己的父对象 curTarget = curTarget.parentNode &#125; // 是，则先看当前对象有没有值，有值则执行回调函数 curTarget &amp;&amp; fn(e, curTarget, e) &#125;)&#125;listen(ul, 'click', 'li', function(event, el) &#123; console.log(event, el)&#125;);// jquery 使用方式$("ul").on("click", "li", function(e) &#123; console.log($(e.target).html());&#125;);// 这个 on 事件是绑定在 ul 上面的，li 是目标元素，// on 事件内部是通过 e.target 来判断点击元素是不是 li 的 解释以下概念：事件传播机制、阻止传播、取消默认事件、事件代理？1. 事件传播机制主要有三种： 事件冒泡：事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的元素（从小到大）； 事件捕获：不太具体的节点更早接收事件，而最具体的元素最后接收事件，和事件冒泡相反（从大到小）； DOM事件流：DOM2 级事件规定事件流包括三个阶段，事件捕获阶段，处于目标阶段，事件冒泡阶段，首先发生的是事件捕获，为截取事件提供机会，然后是实际目标接收事件，最后是冒泡阶段（标准浏览器现在都使用 DOM 事件流，IE 不支持事件流，只支持事件冒泡）。 2. 阻止传播 stopPropagation() 取消事件进一步捕获或冒泡。 3. 取消默认事件 preventDefault() 取消事件默认行为。 4. 事件代理 通过事件冒泡（或者事件捕获）给父元素添加事件监听，e.target 指向引发触发事件的元素。 什么是节流和防抖介绍 debounce（防抖）的作用是在让在用户动作停止后延迟x ms再执行回调 throttle（节流）的作用是在用户动作时每隔一定时间（如200ms）执行一次回调 节流防抖作用 debounce 应用在搜索框的即时搜索（input 事件），避免用户狂按键盘导致的频繁请求 throttle 应用在监听 resize 改变布局或 onscroll 滚动 防抖： 123456789101112131415161718192021// &lt;input type="text" oninput="change()"&gt;// 防抖（一段时间会等，然后带着一起做了）function debounce(fn, delay) &#123; let timer = null return function() &#123; const context = this, args = arguments if (timer) &#123; window.clearTimeout(timer) &#125; timer = setTimeout(() =&gt; &#123; fn.apply(context, args) timer = null &#125;, delay) &#125;&#125;var change = debounce(function() &#123; var input = document.querySelector("input") console.log(input.value)&#125;, 1000) 节流： 1234567891011121314151617181920// &lt;div class="sw"&gt;23333&lt;/div&gt;// 节流（一段时间执行一次之后，就不执行第二次）function throttle(fn, delay) &#123; let canUse = true return function() &#123; var context = this, args = arguments if (canUse) &#123; fn.apply(context, args) canUse = false setTimeout(()=&gt;canUse = true, delay) &#125; &#125;&#125;var sw = document.querySelector(".sw")sw.addEventListener("click", throttle(function(e) &#123; console.log(e)&#125;, 1000)) 参考： 在React、Vue和小程序中使用函数节流和函数防抖 函数防抖与函数节流 JS事件中防抖debounce和节流throttle概念原理的学习 mouseover 和 mouseenter 的区别 mouseover：不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。支持事件冒泡。相对应 mouseout 事件。 mouseenter：只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。不支持事件冒泡。相对应 mouseleave 事件。 参考：JavaScript中的 mouseover 与 mouseenter ，mouseout 和 mouseleave 的区别 window.onload 和 document.onDOMContentLoaded 有什么区别？123456789//当页面所有资源加载完成，则触发（涉及到所有资源，所以触发时机较晚）。window.onload = function() &#123; console.log("window loaded");&#125;;//DOM 结构解析完成（并不是页面上资源加载完成，而是 dom 结构渲染完成）。document.addEventListener("DOMContentLoaded", function() &#123; console.log("DOMContentLoaded");&#125;); ES6相关ES6 用到过吗，新增了哪些东西，你用到过什么？ let 和 const 模板字符串 箭头函数（自己没有 this ，从自己的作用域链的上一层继承 this ） for-of（用来遍历数据—例如数组中的值）e.g. Array，String，Set，Map arguments 对象可被不定参数和默认参数完美代替 Promise 数组的拓展 数组.find((item,index,arr) =&gt; {条件}) 返回满足条件的第一个元素的值。否则返回 undefined 数组.findIndex((item,index,arr)=&gt;{…}) 返回满足条件的第一个元素的索引值。否则返回 -1 数组.includes(数据,[searchIndex]) 判断数据是否在数组中,第二个参数(可选参数)为从指定索引处(包含索引处的值)开始搜索 返回布尔值(es7时加入) 扩展运算符 … 引入 module 模块的概念 const 和 let 区别 let 定义变量可以只声明不赋值 const 定义常量声明时必须赋值，一旦定义不可轻易改变值 共同点解决 var 没有块作用域、变量提升、可以重复声明的问题。let 和 const 有自己的块作用域，不存在变量提升问题，同一块作用域中不可重复声明（会报错） let var 区别 var 有变量提升，let 没有 let 的作用域是块，而 var 的作用域是函数 12345678910111213var a = 5var b = 10if (a === 5) &#123;let a = 4 // The scope is inside the if-blockvar b = 1 // The scope is inside the functionconsole.log(a) // 4console.log(b) // 1&#125;console.log(a) // 5console.log(b) // 1 let 有暂时性死区，只要 let/const 声明的变量，在未声明之前使用或者赋值都会报错（ReferenceError） let 不能重复定义 可以改变 const 定义的某个对象的属性吗可以，因为对象是复杂类型，const 存储的是引用，所以改变对象的成员不会报错，但不建议这样做。 箭头函数（ this 指向） 箭头函数，本质上，就是一个匿名函数 箭头函数无法通过 call、apply、bind 来手动改变内部 this 指向 箭头函数：自动 .bind(this) 也就是说箭头函数中的 this 指向与其所在作用域的 this 指向相同 总结： 箭头函数不会创建自己的 this ，它只会从自己的作用域链的 上一层继承 this 1234567891011121314151617181920212223function Person() &#123; // Person() 构造函数定义 `this` 作为它自己的实例. this.age = 0 setInterval(function growUp() &#123; // 在非严格模式, growUp() 函数定义 `this`作为全局对象, // 与在 Person() 构造函数中定义的 `this`并不相同. this.age++ &#125;, 1000)&#125;var p = new Person()// 使用箭头函数function Person() &#123; this.age = 0 setInterval(() =&gt; &#123; this.age++ // |this| 正确地指向 p 实例 &#125;, 1000)&#125;var p = new Person() 箭头函数与普通函数的区别 箭头函数是匿名函数，不能作为构造函数，不能使用 new。 1234var B = () =&gt; &#123; value:1;&#125;var b = new B(); //--&gt;TypeError: B is not a constructor 箭头函数不绑定 arguments，取而代之用 rest 参数 … 解决。 123456789101112131415function A(a) &#123; console.log(arguments);&#125;var B = (b) =&gt; &#123; console.log(arguments);&#125;//...c 即为 rest 参数var C = (...c) =&gt; &#123; console.log(c);&#125;A(1); //--&gt;[object Arguments] &#123;0: 1&#125;B(2); //--&gt;ReferenceError: arguments is not definedC(3); //--&gt;[3] 箭头函数不绑定 this，会捕获其所在的上下文的 this 值，作为自己的 this 值。 12345678910111213var obj = &#123; a: 10, b: function() &#123; console.log(this.a); &#125;, c: function() &#123; return () =&gt; &#123; console.log(this.a); &#125; &#125;&#125;obj.b(); //--&gt;10obj.c()(); //--&gt;10 箭头函数通过 call() 或 apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。 123456789101112131415var obj = &#123; a: 10, b: function(n) &#123; var f = (v) =&gt; v + this.a; return f(n); &#125;, c: function(n) &#123; var f = (v) =&gt; v + this.a; var m = &#123;a:20&#125;; return f.call(m,n); &#125;&#125;console.log(obj.b(1)); //--&gt;11console.log(obj.c(1)); //--&gt;11 箭头函数没有原型属性。 12345678var a = () =&gt; &#123; return 1;&#125;function b() &#123; return 2;&#125;console.log(a.prototype); //--&gt;undefinedconsole.log(b.prototype); //--&gt;object&#123;...&#125; 箭头函数不能当做 Generator 函数,不能使用 yield 关键字。箭头函数不能换行。 12var a = () =&gt; 1; //--&gt;SyntaxError: Unexpected token =&gt; Set 和 Map概念 Set 是有序列表，类似于数组，但是没有重复值 Map 是存储许多键值对的有序列表，key 和 value 支持所有数据类型 相同点 都是有序列表 Set 值不重复；Map 键不重复 用法 SET 属性： Set.prototype.constructor：构造函数，默认就是 Set 函数 Set.prototype.size：返回实例的成员总数 操作方法： add(value)：添加一个值，返回Set结构本身 delete(value)：删除某个值，返回布尔值 has(value)：返回布尔值，表示是否是成员 clear()：清除所有成员，无返回值 遍历方法（ key() 和 values() 行为是一致的。） keys()：返回键名的遍历器（什么是遍历器？Iterator） values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 MAP 属性 size ：返回 Map 结构的成员总数。 操作方法 set(key, value): set 方法设置键名 key 对应的键值为 value ，然后返回整个 Map 结构。 get(key) ：get 方法读取 key 对应的键值，如果找不到 key ，返回 undefined 。 has(key)：has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。 delete(key)：delete 方法删除某个键，返回 true 。如果删除失败，返回 false 。 clear()：clear方法清除所有成员，没有返回值。 遍历方法 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历 Map 的所有成员。 用途Set 集合可以用来过滤数组中重复的元素，只能通过 has 方法检测指定的值是否存在，或者是通过 forEach 处理每个值。 Map 集合通过 set() 添加键值对，通过 get() 获取键值，各种方法的使用查看文章教程，你可以把它看成是比 Object 更加强大的对象。 Set 与 数组 的区别set不可重复，array可重复 Map 与 对象 的区别 Object 的键只能是字符串或者 symbol ，Map 的键可以是任意类型的值（包括对象） Map 可以通过 size 获取元素个数，对象得遍历。 Map 是有序的（根据用户插入的顺序进行排序），对象排序有自己规则（比如先排数字开头的 key ，再到字符串） Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。 12345678910111213141516var map = new Map()map.set("name", "Lance")map.set("age", 18)var per = &#123; name: 'Jerry', age: 19&#125;for (const attr of map.values()) &#123; console.log(attr)&#125; // Lance 18for (const attr of Object.keys(per)) &#123; console.log(per[attr])&#125; // Jerry 19 Promisepromise 是什么Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。 诞生的原因异步网络请求的回调地狱，而且我们还得对每次请求的结果进行一些处理，代码会更加臃肿。 promise 使用场景有哪些 ajax请求得到返回值的时间不同,有了 callback 的回调结果之后才能知道接下来应该做什么 node 中读取文件 三种状态 pending: 初始状态，既不是成功，也不是失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 优缺点Promise 的优点: 一旦状态改变，就不会再变，任何时候都可以得到这个结果； 可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。 Promise 的缺点: 无法取消 Promise，错误需要通过回调函数来捕获； 当处于 pending 状态时，无法得知目前进展到哪一个阶段。 基本用法12345678910111213//defined Promise async functionfunction asyncFun() &#123; return new Promise((resolve, reject) =&gt; &#123; if(resolve) &#123; resolve(/*resolve parameter*/) &#125;else&#123; reject(new Error(/*Error*/)) &#125; &#125;)&#125;//use Promise&amp;thenasyncFun().then(/*function*/).then(/*function*/)... promise 特性参考：八段代码彻底掌握 Promise promise 里面 return 一个 string，和在 resolve 一个 string 的区别return 一个 string 后续的 then 不会执行; resolve 一个 string 会返回一个 promise 对象，对象的值是这个 string 在 then 里面 throw 一个 error，怎么捕捉1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// throw 这个 error 后，在紧挨的下一个 then 中添加两个回调方法（ resolve 的，和 reject ）。// 然后在第二个 reject 方法中可以捕获new Promise(function (resolve, reject) &#123; return resolve("返回Promise") &#125;) .then(data =&gt; &#123; console.log("第一个then") throw new Error("我是错误") &#125;) .then(resolve =&gt; &#123; console.log("成功") console.log(resolve) &#125;, err =&gt; &#123; console.log("紧挨的失败") console.log(err) &#125;) .catch(err =&gt; &#123; console.log("catch错误") console.log(err) &#125;);// 123// 第一个then// 紧挨的失败// Error: 我是错误// at Promise.then.data (&lt;anonymous&gt;:6:15)// 在 then 的链式调用后添加一个 catch 来捕获new Promise(function (resolve, reject) &#123; return resolve("返回Promise")&#125;).then(data =&gt; &#123; console.log("第一个then") throw new Error("我是错误")&#125;).then(err =&gt; &#123; console.log("then错误") console.log(err)&#125;).catch(err =&gt; &#123; console.log("catch错误") console.log(err)&#125;)console.log("123")// 123// 第一个 then// catch 错误// Error: 我是错误// at Promise.then.data 使用 Promise 封装一个 url1234567891011121314151617var url = ''var getJSON = url =&gt; new Promise((resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest() xhr.open('GET', url) xhr.send(null) xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; // &lt;= 请求已完成，且响应已就绪 if (xhr.status === 200) &#123; // &lt;= 状态OK resolve(JSON.parse(xhr.responseText)) &#125; else &#123; reject(new Error("请求失败")) &#125; &#125; &#125;&#125;)getJSON(url).then(res =&gt; console.log(res)) 在 Promise 链式调用中，怎样才能保证上一个 promise 出现报错不会影响到后续 .then 的正常执行为了不影响后续 .then 的执行，需要在每一个 then 中指定失败的回调 1234567891011121314let asyncFunc = () =&gt; new Promise(resolve =&gt; &#123; resolve("123") // 123, 二楼 // throw new Error("出错了") // Error: 出错了, 二楼&#125;);asyncFunc().then(res =&gt; &#123; console.log(res) return Promise.resolve("二楼")&#125;, err =&gt; &#123; // &lt;====== 指定失败的回调 console.log(err) return Promise.resolve("二楼")&#125;).then(res =&gt; &#123; console.log(res)&#125;) Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？1Promise new的时候会立即执行里面的代码 then是微任务 会在本次任务执行完的时候执行 setTimeout是宏任务 会在下次任务执行的时候执行 Async / Await是什么 async 用于声明一个异步的 function await 用于等待一个异步方法执行完成 Asyncasync 函数会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。 Awaitawait 是在等待一个 async 函数完成。不过按 语法说明 ，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值 123456789101112131415function getSomething() &#123; return "something"&#125;function testAsync() &#123; return Promise.resolve("hello async")&#125;async function test() &#123; const v1 = await getSomething() const v2 = await testAsync() console.log(v1, v2)&#125;test() 优势让代码更易读 假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。 传统 promise ，链式调用 then 一个接一个 改用 async/await 后就像同步代码一样 123456789101112131415161718192021222324252627function doIt() &#123; console.time("doIt") const time1 = 300 step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`) console.timeEnd("doIt") &#125;);&#125;doIt()// =======async function doIt() &#123; console.time("doIt"); const time1 = 300 const time2 = await step1(time1) const time3 = await step2(time2) const result = await step3(time3) console.log(`result is $&#123;result&#125;`) console.timeEnd("doIt")&#125;doIt() 参考：理解 JavaScript 的 async/await 解构赋值数组用法12345678910111213141516171819202122// 前后的形式必须完全一致 才可以完成结构赋值let [foo, [[bar], baz]] = [1, [[2], 3]]foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"]third // "baz"let [x, , y] = [1, 2, 3]x // 1y // 3let [head, ...tail] = [1, 2, 3, 4]head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a']x // "a"y // undefinedz // []// 如果解构不成功，变量的值就等于undefined。 对象用法12345678910// 对象的属性没有次序，变量必须与属性同名，才能取到正确的值。&#123;name, age&#125; = &#123;name:'wang',age: 18&#125;name // wangage // 18// 支持别名&#123;name:nname, age&#125; = &#123;name:'wang',age: 18&#125;name // '' 取别名时原名就会为空字符串nname // wangage // 18 …运算符12345678[a, ...b] = [1, 2, 3, 4, 5]a // 1b // [2,3,4,5]var app = (...sum) =&gt; &#123;sum.forEach(item =&gt; console.log(item))&#125;app(1,2,3,4) // 1,2,3,4// 此运算符或得值为数组形式 主要用于替代函数中的 arguments(伪数组) 属性// 这样可以非常方便的遍历获取到的未知个数的实参 函数中的 rest（剩余）参数 剩余参数语法允许我们将一个不定数量的参数表示为一个数组。 ——&gt; MDN - 剩余参数 123456789101112131415161718192021function sum(...theArgs) &#123; return theArgs.reduce((previous, current) =&gt; &#123; return previous + current &#125;);&#125;console.log(sum(1, 2, 3))// expected output: 6console.log(sum(1, 2, 3, 4))// expected output: 10// 下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们function multiply(multiplier, ...theArgs) &#123; return theArgs.map(function (element) &#123; return multiplier * element &#125;);&#125;var arr = multiply(2, 1, 2, 3)console.log(arr) // [2, 4, 6] 剩余参数和 arguments 对象的区别剩余参数和 arguments 对象之间的区别主要有三个： 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。 arguments 对象不是一个真正的数组，而剩余参数是真正的 Array 实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach 或 pop 。 arguments 对象还有一些附加的属性 （如 callee 属性）。 arguments.callee 属性包含当前正在执行的函数。 模块化模块化发展无模块化 –&gt; CommonJS规范 –&gt; AMD规范 –&gt; CMD规范 –&gt; ES6模块化 无模块劣势12345678910&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="jquery_scroller.js"&gt;&lt;/script&gt;&lt;script src="main.js"&gt;&lt;/script&gt;...缺点：被依赖的放在前面，否则使用就会报错污染全局作用域维护成本高依赖关系不明显 CommonJS规范（NodeJS）1234567891011121314151617// 定义模块math.jsvar basicNum = 0function add(a, b) &#123; return a + b&#125;module.exports = &#123; //在这里写上需要向外暴露的函数、变量 add, basicNum&#125;// 引用自定义的模块时，参数包含路径，可省略.jsvar math = require('./math')math.add(2, 5)// 引用核心模块时，不需要带路径var http = require('http')http.createService(...).listen(3000) exports 是对 module.exports 的引用。比如我们可以认为在一个模块的顶部有这句代码： exports = module.exports 所以，我们不能直接给 exports 赋值: ✅ exports.foo = ‘bar’ ❌ exports = {foo: ‘bar’} //error 这种方式是错误的，相当于重新定义了 exports 优点 解决了依赖、全局变量污染的问题 缺点 CommonJS 用同步的方式加载模块，这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。所以不适合浏览器端模块加载，更合理的方案是使用异步加载。 AMD规范（RequireJS）AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 12345678910111213141516/** 网页中引入 require.js 及 main.js **/&lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt;/** main.js 入口文件/主模块 **/// 首先用 config() 指定各模块路径和引用名require.config(&#123; baseUrl: "js/lib", paths: &#123; "jquery": "jquery.min", //实际路径为js/lib/jquery.min.js "underscore": "underscore.min", &#125;&#125;);// 执行基本操作require(["jquery","underscore"], function($,_)&#123; // some code here&#125;); 优点 适合在浏览器环境中异步加载模块、并行加载多个模块 缺点 必须要提前加载所有的依赖，然后才可以使用，而不是需要使用时再加载。（不能按需加载） CMD（SeaJS）与AMD类似，不同点在于： AMD 推崇依赖前置、提前执行 CMD 推崇依赖就近、延迟执行。 CMD 与 AMD 区别 12345678910111213141516171819/** AMD写法 **/define(["a", "b", "c", "d", "e", "f"], function(a, b, c, d, e, f) &#123; // 等于在最前面声明并初始化了要用到的所有模块 a.doSomething() if (false) &#123; // 即便没用到某个模块 b，但 b 还是提前执行了 b.doSomething() &#125;&#125;)/** CMD写法 **/define(function(require, exports, module) &#123; var a = require('./a') //在需要时申明 a.doSomething() if (false) &#123; var b = require('./b'); b.doSomething() &#125;&#125;) ES6模块化ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成： export 和 import 。 export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。 123456789101112/** 定义模块 math.js **/var basicNum = 0var add = function (a, b) &#123; return a + b&#125;;export &#123; basicNum, add &#125;/** 引用模块 **/import &#123; basicNum, add &#125; from './math'function test(ele) &#123; ele.textContent = add(99 + basicNum)&#125; es6 在导出的时候有一个默认导出， export default ，使用它导出后，在 import 的时候，不需要加上 {} ，模块名字可以随意起。该名字实际上就是个对象，包含导出模块里面的函数或者变量。 12345678/** export default **///定义输出export default &#123; basicNum, add &#125;//引入import math from './math'function test(ele) &#123; ele.textContent = math.add(99 + math.basicNum)&#125; 参考： 前端模块化：CommonJS,AMD,CMD,ES6 这一次，我要弄懂javascript的模块化 模块化开发怎么做？立即执行函数,不暴露私有成员 12345678910111213var module1 = (function()&#123; var _count = 0 var m1 = function()&#123; //... &#125; var m2 = function()&#123; //... &#125; return &#123; m1, m2 &#125;&#125;)(); 异步AjaxAjax 是什么? 如何创建一个Ajax？使用 JavaScript 异步获取数据，而且页面不会发生整页刷新的，提高了用户体验。 创建 XMLHttpRequest 对象,也就是创建一个异步调用对象 创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息 设置响应 HTTP 请求状态变化的函数 发送 HTTP 请求 获取异步调用返回的数据 使用 JavaScript 和 DOM 实现局部刷新 12345678910111213141516171819202122// 1. 创建一个 XMLHttpRequest 类型的对象 —— 相当于打开了一个浏览器var xhr = new XMLHttpRequest()// 2. 打开与一个网址之间的连接 —— 相当于在地址栏输入访问地址xhr.open('GET', 'news/list?type=gn')// 3. 通过连接发送一次请求 —— 相当于回车或者点击访问发送请求xhr.send(null)// POST请求：// xhr.open('POST', 'login', true)// xhr.send('username=admin&amp;password=admin')// 4. 指定 xhr 状态变化事件处理函数 —— 相当于处理网页呈现后的操作xhr.onreadystatechange = function () &#123; // 通过 xhr 的 readyState 判断此次请求的响应是否接收完成 // 4代表done if (this.readyState === 4) &#123; // 通过 xhr 的 responseText 获取到响应的响应体 console.log(this) &#125;&#125; Ajax 原理Ajax 的原理简单来说是在用户和服务器之间加了—个中间层（Ajax 引擎），通过 XMLHttpRequest 对象来向服务器发异步请求，从服务器获得数据，然后用 JavaScript 来操作 DOM 而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据 Ajax 的过程只涉及 JavaScript、XMLHttpRequest 和 DOM。XMLHttpRequest 是 Ajax 的核心机制。 Ajax 解决浏览器缓存问题？ 在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”) 在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”) 在URL后面加上一个随机数： “fresh=” + Math.random() 在URL后面加上时间戳：”nowtime=” + new Date().getTime() 什么是同源策略？同源策略是浏览器的一种安全策略，所谓同源是指 域名，协议，端口 完全相同，只有同源的地址才可以相互通过 AJAX 的方式请求。 如何解决跨域问题jsonp借助于 script 标签发送跨域请求的技巧 原理 css，script 标签允许跨域。客户端借助 script 标签请求服务端的一个动态网页（php 文件），服务端的这个动态网页返回一段带有函数调用的 JavaScript 全局函数调用的脚本，将原本需要返回给客户端的数据传递进去。 客户端： foo(…arr) {console.log(arr.join(“,”))} 定义方法，名称随便 服务端会获取参数名 callback 的值 foo ，然后把数据扔进 foo 中调用 一旦数据返回，就相当于在调用上面的 foo 服务端： foo([‘我’, ‘是’, ‘你’, ‘原’, ‘本’, ‘需’, ‘要’, ‘的’, ‘数’, ‘据’]) 特色 JSONP 需要服务端配合，服务端按照客户端的要求返回一段 JavaScript 调用客户端的函数 只能发送 GET 请求 CORS 跨域资源共享服务端设置： 12345// 服务端请求头设置：允许远端访问header('Access‐Control‐Allow‐Origin: *');// 这种方案无需客户端作出任何变化（客户端不用改代码），只是在被请求的服务端响应的时候添加一个 // Access-Control-Allow-Origin 的响应头，表示这个资源是否允许指定域请求。 如果跨域 + 发送 cookie： 前端：withCredentials = true 后端：Access-Control-Allow-Origin 不为 * ，(Access-Control-Allow-Credentials, true) 如果还需要发送 post 请求： 前端： post:[‘Content-Type’] = ‘application/x-www-form-urlencoded’; qs.stringify(): 对象序列化成URL的形式，以 &amp; 进行拼接 代理除此之外，还可以通过前端设置代理实现跨域，原理是利用后端不存在跨域问题。比如可以在 @vue/cli 项目中新建 vue.config.js 文件来配置代理。如果你想了解更多这方面的设置，可以阅读我的这篇博客 Axios异步请求跨域解决方案 JSON 和 JSONP 的区别JSON 返回的是一串 JSON 格式数据；而 JSONP 返回的是脚本代码（包含一个函数调用）。 JSONP 的全名叫做 JSON with padding，就是把 JSON 对象用符合 JS 语法的形式包裹起来以使其他的网站可以请求到，也就是将 JSON 封装成 JS 文件传过去。 defer 和 async 的区别 两者都是异步加载，但 defer 是按照加载顺序执行脚本的；async 则是无序加载脚本，例如a.js写在b.js前面，但如果b.js先加载完，则立即执行，不会等a.js的加载。 参考：https://segmentfault.com/q/1010000000640869 preload 和 prefetch 的区别是什么？对当前页面需要的资源，使用 preload 进行预加载，对其它页面需要的资源进行 prefetch 空闲加载。 123456&lt;!-- 对sty1e.cs5和 index.js进行pre1oad预加载 --&gt;&lt;link rel="preload" href="style.css" as="style"&gt;&lt;link rel="preload" href="index.js" as="script"&gt;&lt;!--对资源进行 prefetch预加载--&gt;&lt;link rel="prefetch" href="next.css"&gt;&lt;link rel="prefetch" href="next.js"&gt; setTimeout、setInterval、requestAnimationFrame 各有什么特点？setTimeout 和 setInterval 都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器 UI 线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。 requestAnimationFrame 采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。 setTimeout 倒计时为什么会出现误差？setTimeout() 只是将事件插入了“任务队列”，必须等当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码消耗时间很长，也有可能要等很久，所以并没办法保证回调函数一定会在 setTimeout() 指定的时间执行。所以， setTimeout() 的第二个参数表示的是最少时间，并非是确切时间。 HTML5 标准规定了 setTimeout() 的第二个参数的最小值不得小于 4 毫秒，如果低于这个值，则默认是 4 毫秒。在此之前。老版本的浏览器都将最短时间设为 10 毫秒。另外，对于那些 DOM 的变动（尤其是涉及页面重新渲染的部分），通常是间隔 16 毫秒执行。这时使用 requestAnimationFrame() 的效果要好于 setTimeout()。 简单解释单线程、任务队列的概念？单线程： JavaScript 是浏览器用来与用户进行交互、进行 DOM 操作的，这也使得了它必须是单线程这一特性。 所谓单线程也就是只有一条线，一步一步走。 任务队列： 任务（消息）队列是一个先进先出的队列，它里面存放着各种任务（消息）。 在 JavaScript 中任务有两种，一种是同步任务，一种是异步任务。 同步任务：各个任务按照文档定义的顺序一一推入“执行栈”中，当前一个任务执行完毕，才会开始执行下一个任务。 异步任务：各个任务推入“任务队列”中，只有在当前的所有同步任务执行完毕，才会将队列中的任务“出队”执行。 当线程中没有执行任何同步代码的前提下才会执行异步代码。 其它JSON 的了解一种轻量级的数据交换格式。 它是基于 JavaScript 的一个子集。 数据格式简单、易于读写、占用带宽小。 e.g. {“age”:”12”, “name”:”back”} JSON读写的基本封装： 12345678910111213var storage = &#123; set: (key, val) =&gt; &#123; localStorage.setItem(key, JSON.stringify(val)) &#125;, get: key =&gt; &#123; return JSON.parse(localStorage.getItem(key) === null ? '[]' : localStorage.getItem(key)) &#125;, remove: key =&gt; &#123; localStorage.removeItem(key) &#125;&#125;export default storage JSON 方法的缺点 不能复制function、正则、Symbol 循环引用报错 相同的引用会被重复复制 概念性问题你理解的面向对象一种编程开发思想。是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。 什么叫优雅降级和渐进增强？ 优雅降级：Web 站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。 如：border-shadow 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 如：默认使用 flash 上传，但如果浏览器支持 HTML5 的文件上传功能，则使用 HTML5 实现更好的体验 compose 函数 ❌函数柯里化 ❌]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于移动端适配,你必须要知道的(转载)]]></title>
    <url>%2Fposts%2F32377%2F</url>
    <content type="text"><![CDATA[关于移动端适配，你必须要知道的转载自 ConardLi 的 关于移动端适配，你必须要知道的备用地址：知乎 - 关于移动端适配，你必须要知道的 导读移动端适配，是我们在开发中经常会遇到的，这里面可能会遇到非常多的问题： 1px问题 UI图完美适配方案 iPhoneX适配方案 横屏适配 高清屏图片模糊问题 … 上面这些问题可能我们在开发中已经知道如何解决，但是问题产生的原理，以及解决方案的原理可能会模糊不清。在解决这些问题的过程中，我们往往会遇到非常多的概念：像素、分辨率、PPI、DPI、DP、DIP、DPR、视口等等，你真的能分清这些概念的意义吗？本文将从移动端适配的基础概念出发，探究移动端适配各种问题的解决方案和实现原理。 一、英寸一般用英寸描述屏幕的物理大小，如电脑显示器的17、22，手机显示器的4.8、5.7等使用的单位都是英寸。需要注意，上面的尺寸都是屏幕对角线的长度：英寸(inch,缩写为in)在荷兰语中的本意是大拇指，一英寸就是指甲底部普通人拇指的宽度。英寸和厘米的换算：1英寸 = 2.54 厘米 二、分辨率 2.1 像素像素即一个小方块，它具有特定的位置和颜色。图片、电子屏幕（手机、电脑）就是由无数个具有特定颜色和特定位置的小方块拼接而成。像素可以作为图片或电子屏幕的最小组成单位。下面我们使用sketch打开一张图片：将这些图片放大即可看到这些像素点：通常我们所说的分辨率有两种，屏幕分辨率和图像分辨率。 2.2 屏幕分辨率屏幕分辨率指一个屏幕具体由多少个像素点组成。下面是apple的官网上对手机分辨率的描述：iPhone XS Max 和 iPhone SE的分辨率分别为2688 x 1242和1136 x 640。这表示手机分别在垂直和水平上所具有的像素点数。当然分辨率高不代表屏幕就清晰，屏幕的清晰程度还与尺寸有关。 2.3 图像分辨率我们通常说的图片分辨率其实是指图片含有的像素数，比如一张图片的分辨率为800 x 400。这表示图片分别在垂直和水平上所具有的像素点数为800和400。同一尺寸的图片，分辨率越高，图片越清晰。 2.4 PPIPPI(Pixel Per Inch)：每英寸包括的像素数。PPI可以用于描述屏幕的清晰度以及一张图片的质量。使用PPI描述图片时，PPI越高，图片质量越高，使用PPI描述屏幕时，PPI越高，屏幕越清晰。在上面描述手机分辨率的图片中，我们可以看到：iPhone XS Max 和 iPhone SE的PPI分别为458和326，这足以证明前者的屏幕更清晰。由于手机尺寸为手机对角线的长度，我们通常使用如下的方法计算PPI:iPhone 6的PPI为 ，那它每英寸约含有326个物理像素点。 2.5 DPIDPI(Dot Per Inch)：即每英寸包括的点数。这里的点是一个抽象的单位，它可以是屏幕像素点、图片像素点也可以是打印机的墨点。平时你可能会看到使用DPI来描述图片和屏幕，这时的DPI应该和PPI是等价的，DPI最常用的是用于描述打印机，表示打印机每英寸可以打印的点数。一张图片在屏幕上显示时，它的像素点数是规则排列的，每个像素点都有特定的位置和颜色。当使用打印机进行打印时，打印机可能不会规则的将这些点打印出来，而是使用一个个打印点来呈现这张图像，这些打印点之间会有一定的空隙，这就是DPI所描述的：打印点的密度。在上面的图像中我们可以清晰的看到，打印机是如何使用墨点来打印一张图像。所以，打印机的DPI越高，打印图像的精细程度就越高，同时这也会消耗更多的墨点和时间。 三、设备独立像素实际上，上面我们描述的像素都是物理像素，即设备上真实的物理单元。下面我们来看看设备独立像素究竟是如何产生的：智能手机发展非常之快，在几年之前，我们还用着分辨率非常低的手机，比如下面左侧的白色手机，它的分辨率是320x480，我们可以在上面浏览正常的文字、图片等等。但是，随着科技的发展，低分辨率的手机已经不能满足我们的需求了。很快，更高分辨率的屏幕诞生了，比如下面的黑色手机，它的分辨率是640x940，正好是白色手机的两倍。理论上来讲，在白色手机上相同大小的图片和文字，在黑色手机上会被缩放一倍，因为它的分辨率提高了一倍。这样，岂不是后面出现更高分辨率的手机，页面元素会变得越来越小吗？然而，事实并不是这样的，我们现在使用的智能手机，不管分辨率多高，他们所展示的界面比例都是基本类似的。乔布斯在iPhone4的发布会上首次提出了Retina Display(视网膜屏幕)的概念，它正是解决了上面的问题，这也使它成为一款跨时代的手机。在iPhone4使用的视网膜屏幕中，把2x2个像素当1个像素使用，这样让屏幕看起来更精致，但是元素的大小却不会改变。如果黑色手机使用了视网膜屏幕的技术，那么显示结果应该是下面的情况，比如列表的宽度为300个像素，那么在一条水平线上，白色手机会用300个物理像素去渲染它，而黑色手机实际上会用600个物理像素去渲染它。我们必须用一种单位来同时告诉不同分辨率的手机，它们在界面上显示元素的大小是多少，这个单位就是设备独立像素(Device Independent Pixels)简称DIP或DP。上面我们说，列表的宽度为300个像素，实际上我们可以说：列表的宽度为300个设备独立像素。打开chrome的开发者工具，我们可以模拟各个手机型号的显示情况，每种型号上面会显示一个尺寸，比如iPhone X显示的尺寸是375x812，实际iPhone X的分辨率会比这高很多，这里显示的就是设备独立像素。 3.1 设备像素比设备像素比device pixel ratio简称dpr，即物理像素和设备独立像素的比值。在web中，浏览器为我们提供了window.devicePixelRatio来帮助我们获取dpr。在css中，可以使用媒体查询min-device-pixel-ratio，区分dpr：12@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2)&#123; &#125;复制代码 在React Native中，我们也可以使用PixelRatio.get()来获取DPR。当然，上面的规则也有例外，iPhone 6、7、8 Plus的实际物理像素是1080 x 1920，在开发者工具中我们可以看到：它的设备独立像素是414 x 736，设备像素比为3，设备独立像素和设备像素比的乘积并不等于1080 x 1920，而是等于1242 x 2208。实际上，手机会自动把1242 x 2208个像素点塞进1080 * 1920个物理像素点来渲染，我们不用关心这个过程，而1242 x 2208被称为屏幕的设计像素。我们开发过程中也是以这个设计像素为准。实际上，从苹果提出视网膜屏幕开始，才出现设备像素比这个概念，因为在这之前，移动设备都是直接使用物理像素来进行展示。紧接着，Android同样使用了其他的技术方案来实现DPR大于1的屏幕，不过原理是类似的。由于Android屏幕尺寸非常多、分辨率高低跨度非常大，不像苹果只有它自己的几款固定设备、尺寸。所以，为了保证各种设备的显示效果，Android按照设备的像素密度将设备分成了几个区间：当然，所有的Android设备不一定严格按照上面的分辨率，每个类型可能对应几种不同分辨率，所以，每个Android手机都能根据给定的区间范围，确定自己的DPR，从而拥有类似的显示。当然，仅仅是类似，由于各个设备的尺寸、分辨率上的差异，设备独立像素也不会完全相等，所以各种Android设备仍然不能做到在展示上完全相等。 3.2 移动端开发在iOS、Android和React Native开发中样式单位其实都使用的是设备独立像素。iOS的尺寸单位为pt，Android的尺寸单位为dp，React Native中没有指定明确的单位，它们其实都是设备独立像素dp。在使用React Native开发App时，UI给我们的原型图一般是基于iphone6的像素给定的。为了适配所有机型，我们在写样式时需要把物理像素转换为设备独立像素：例如：如果给定一个元素的高度为200px(这里的px指物理像素，非CSS像素)，iphone6的设备像素比为2，我们给定的height应为200px/2=100dp。当然，最好的是，你可以和设计沟通好，所有的UI图都按照设备独立像素来出。我们还可以在代码(React Native)中进行px和dp的转换：123456789101112131415import &#123;PixelRatio &#125; from &apos;react-native&apos;;const dpr = PixelRatio.get();/** * px转换为dp */export function pxConvertTodp(px) &#123; return px / dpr;&#125;/** * dp转换为px */export function dpConvertTopx(dp) &#123; return PixelRatio.getPixelSizeForLayoutSize(dp);&#125;复制代码 3.3 WEB端开发在写CSS时，我们用到最多的单位是px，即CSS像素，当页面缩放比例为100%时，一个CSS像素等于一个设备独立像素。但是CSS像素是很容易被改变的，当用户对浏览器进行了放大，CSS像素会被放大，这时一个CSS像素会跨越更多的物理像素。页面的缩放系数 = CSS像素 / 设备独立像素。 3.4 关于屏幕这里多说两句Retina屏幕，因为我在很多文章中看到对Retina屏幕的误解。Retina屏幕只是苹果提出的一个营销术语： 在普通的使用距离下，人的肉眼无法分辨单个的像素点。 为什么强调普通的使用距离下呢？我们来看一下它的计算公式：a代表人眼视角，h代表像素间距，d代表肉眼与屏幕的距离，符合以上条件的屏幕可以使肉眼看不见单个物理像素点。它不能单纯的表达分辨率和PPI，只能一种表达视觉效果。让多个物理像素渲染一个独立像素只是Retina屏幕为了达到效果而使用的一种技术。而不是所有DPR &gt; 1的屏幕就是Retina屏幕。比如：给你一块超大尺寸的屏幕，即使它的PPI很高，DPR也很高，在近距离你也能看清它的像素点，这就不算Retina屏幕。我们经常见到用K和P这个单位来形容屏幕：P代表的就是屏幕纵向的像素个数，1080P即纵向有1080个像素，分辨率为1920X1080的屏幕就属于1080P屏幕。我们平时所说的高清屏其实就是屏幕的物理分辨率达到或超过1920X1080的屏幕。K代表屏幕横向有几个1024个像素，一般来讲横向像素超过2048就属于2K屏，横向像素超过4096就属于4K屏。 四、视口视口(viewport)代表当前可见的计算机图形区域。在Web浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的UI， 菜单栏等——即指你正在浏览的文档的那一部分。一般我们所说的视口共包括三种：布局视口、视觉视口和理想视口，它们在屏幕适配中起着非常重要的作用。 4.1 布局视口布局视口(layout viewport)：当我们以百分比来指定一个元素的大小时，它的计算值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。所以，布局视口是网页布局的基准窗口，在PC浏览器上，布局视口就等于当前浏览器的窗口大小（不包括borders 、margins、滚动条）。在移动端，布局视口被赋予一个默认值，大部分为980px，这保证PC的网页可以在手机浏览器上呈现，但是非常小，用户可以手动对网页进行放大。我们可以通过调用document.documentElement.clientWidth / clientHeight来获取布局视口大小。 4.2 视觉视口视觉视口(visual viewport)：用户通过屏幕真实看到的区域。视觉视口默认等于当前浏览器的窗口大小（包括滚动条宽度）。当用户对浏览器进行缩放时，不会改变布局视口的大小，所以页面布局是不变的，但是缩放会改变视觉视口的大小。例如：用户将浏览器窗口放大了200%，这时浏览器窗口中的CSS像素会随着视觉视口的放大而放大，这时一个CSS像素会跨越更多的物理像素。所以，布局视口会限制你的CSS布局而视觉视口决定用户具体能看到什么。我们可以通过调用window.innerWidth / innerHeight来获取视觉视口大小。 4.3 理想视口布局视口在移动端展示的效果并不是一个理想的效果，所以理想视口(ideal viewport)就诞生了：网站页面在移动端展示的理想大小。如上图，我们在描述设备独立像素时曾使用过这张图，在浏览器调试移动端时页面上给定的像素大小就是理想视口大小，它的单位正是设备独立像素。上面在介绍CSS像素时曾经提到页面的缩放系数 = CSS像素 / 设备独立像素，实际上说页面的缩放系数 = 理想视口宽度 / 视觉视口宽度更为准确。所以，当页面缩放比例为100%时，CSS像素 = 设备独立像素，理想视口 = 视觉视口。我们可以通过调用screen.width / height来获取理想视口大小。 4.4 Meta viewport&lt;meta&gt; 元素表示那些不能由其它HTML元相关元素之一表示的任何元数据信息，它可以告诉浏览器如何解析页面。我们可以借助&lt;meta&gt;元素的viewport来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果。12&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;&quot;&gt;复制代码 上面是viewport的一个配置，我们来看看它们的具体含义： Value 可能值 描述 width 正整数或device-width 以pixels（像素）为单位， 定义布局视口的宽度。 height 正整数或device-height 以pixels（像素）为单位， 定义布局视口的高度。 initial-scale 0.0 - 10.0 定义页面初始缩放比率。 minimum-scale 0.0 - 10.0 定义缩放的最小值；必须小于或等于maximum-scale的值。 maximum-scale 0.0 - 10.0 定义缩放的最大值；必须大于或等于minimum-scale的值。 user-scalable 一个布尔值（yes或者no） 如果设置为 no，用户将不能放大或缩小网页。默认值为 yes。 4.5 移动端适配为了在移动端让页面获得更好的显示效果，我们必须让布局视口、视觉视口都尽可能等于理想视口。device-width就等于理想视口的宽度，所以设置width=device-width就相当于让布局视口等于理想视口。由于initial-scale = 理想视口宽度 / 视觉视口宽度，所以我们设置initial-scale=1;就相当于让视觉视口等于理想视口。这时，1个CSS像素就等于1个设备独立像素，而且我们也是基于理想视口来进行布局的，所以呈现出来的页面布局在各种设备上都能大致相似。 4.6 缩放上面提到width可以决定布局视口的宽度，实际上它并不是布局视口的唯一决定性因素，设置initial-scale也有肯能影响到布局视口，因为布局视口宽度取的是width和视觉视口宽度的最大值。例如：若手机的理想视口宽度为400px，设置width=device-width，initial-scale=2，此时视觉视口宽度 = 理想视口宽度 / initial-scale即200px，布局视口取两者最大值即device-width 400px。若设置width=device-width，initial-scale=0.5，此时视觉视口宽度 = 理想视口宽度 / initial-scale即800px，布局视口取两者最大值即800px。 4.7 获取浏览器大小浏览器为我们提供的获取窗口大小的API有很多，下面我们再来对比一下： window.innerHeight：获取浏览器视觉视口高度（包括垂直滚动条）。 window.outerHeight：获取浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。 window.screen.Height：获取获屏幕取理想视口高度，这个数值是固定的，设备的分辨率/设备像素比 window.screen.availHeight：浏览器窗口可用的高度。 document.documentElement.clientHeight：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距。 document.documentElement.offsetHeight：包括内边距、滚动条、边框和外边距。 document.documentElement.scrollHeight：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与clientHeight相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。五、1px问题为了适配各种屏幕，我们写代码时一般使用设备独立像素来对页面进行布局。而在设备像素比大于1的屏幕上，我们写的1px实际上是被多个物理像素渲染，这就会出现1px在有些屏幕上看起来很粗的现象。5.1 border-image基于media查询判断不同的设备像素比给定不同的border-image：1234567891011.border_1px&#123; border-bottom: 1px solid #000; &#125; @media only screen and (-webkit-min-device-pixel-ratio:2)&#123; .border_1px&#123; border-bottom: none; border-width: 0 0 1px 0; border-image: url(../img/1pxline.png) 0 0 2 0 stretch; &#125; &#125;复制代码 5.2 background-image和border-image类似，准备一张符合条件的边框背景图，模拟在背景上。12345678910.border_1px&#123; border-bottom: 1px solid #000; &#125; @media only screen and (-webkit-min-device-pixel-ratio:2)&#123; .border_1px&#123; background: url(../img/1pxline.png) repeat-x left bottom; background-size: 100% 1px; &#125; &#125;复制代码 上面两种都需要单独准备图片，而且圆角不是很好处理，但是可以应对大部分场景。 5.3 伪类 + transform基于media查询判断不同的设备像素比对线条进行缩放：1234567891011121314151617181920.border_1px:before&#123; content: &apos;&apos;; position: absolute; top: 0; height: 1px; width: 100%; background-color: #000; transform-origin: 50% 0%; &#125; @media only screen and (-webkit-min-device-pixel-ratio:2)&#123; .border_1px:before&#123; transform: scaleY(0.5); &#125; &#125; @media only screen and (-webkit-min-device-pixel-ratio:3)&#123; .border_1px:before&#123; transform: scaleY(0.33); &#125; &#125;复制代码 这种方式可以满足各种场景，如果需要满足圆角，只需要给伪类也加上border-radius即可。 5.4 svg上面我们border-image和background-image都可以模拟1px边框，但是使用的都是位图，还需要外部引入。借助PostCSS的postcss-write-svg我们能直接使用border-image和background-image创建svg的1px边框：12345678910@svg border_1px &#123; height: 2px; @rect &#123; fill: var(--color, black); width: 100%; height: 50%; &#125; &#125;.example &#123; border: 1px solid transparent; border-image: svg(border_1px param(--color #00b1ff)) 2 2 stretch; &#125;复制代码 编译后：12.example &#123; border: 1px solid transparent; border-image: url(&quot;data:image/svg+xml;charset=utf-8,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; height=&apos;2px&apos;%3E%3Crect fill=&apos;%2300b1ff&apos; width=&apos;100%25&apos; height=&apos;50%25&apos;/%3E%3C/svg%3E&quot;) 2 2 stretch; &#125;复制代码 上面的方案是大漠在他的文章中推荐使用的，基本可以满足所有场景，而且不需要外部引入，这是我个人比较喜欢的一种方案。 5.5 设置viewport通过设置缩放，让CSS像素等于真正的物理像素。例如：当设备像素比为3时，我们将页面缩放1/3倍，这时1px等于一个真正的屏幕像素。123456789const scale = 1 / window.devicePixelRatio; const viewport = document.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;); if (!viewport) &#123; viewport = document.createElement(&apos;meta&apos;); viewport.setAttribute(&apos;name&apos;, &apos;viewport&apos;); window.document.head.appendChild(viewport); &#125; viewport.setAttribute(&apos;content&apos;, &apos;width=device-width,user-scalable=no,initial-scale=&apos; + scale + &apos;,maximum-scale=&apos; + scale + &apos;,minimum-scale=&apos; + scale);复制代码 实际上，上面这种方案是早先flexible采用的方案。当然，这样做是要付出代价的，这意味着你页面上所有的布局都要按照物理像素来写。这显然是不现实的，这时，我们可以借助flexible或vw、vh来帮助我们进行适配。 六、移动端适配方案尽管我们可以使用设备独立像素来保证各个设备在不同手机上显示的效果类似，但这并不能保证它们显示完全一致，我们需要一种方案来让设计稿得到更完美的适配。 6.1 flexible方案flexible方案是阿里早期开源的一个移动端适配解决方案，引用flexible后，我们在页面上统一使用rem来布局。它的核心代码非常简单：1234567// set 1rem = viewWidth / 10function setRemUnit () &#123; var rem = docEl.clientWidth / 10 docEl.style.fontSize = rem + &apos;px&apos;&#125;setRemUnit();复制代码 rem 是相对于html节点的font-size来做计算的。我们通过设置document.documentElement.style.fontSize就可以统一整个页面的布局标准。上面的代码中，将html节点的font-size设置为页面clientWidth(布局视口)的1/10，即1rem就等于页面布局视口的1/10，这就意味着我们后面使用的rem都是按照页面比例来计算的。这时，我们只需要将UI出的图转换为rem即可。以iPhone6为例：布局视口为375px，则1rem = 37.5px，这时UI给定一个元素的宽为75px（设备独立像素），我们只需要将它设置为75 / 37.5 = 2rem。当然，每个布局都要计算非常繁琐，我们可以借助PostCSS的px2rem插件来帮助我们完成这个过程。下面的代码可以保证在页面大小变化时，布局可以自适应，当触发了window的resize和pageShow事件之后自动调整html的fontSize大小。1234567// reset rem unit on page resizewindow.addEventListener(&apos;resize&apos;, setRemUnit)window.addEventListener(&apos;pageshow&apos;, function (e) &#123; if (e.persisted) &#123; setRemUnit() &#125;&#125;)复制代码 由于viewport单位得到众多浏览器的兼容，上面这种方案现在已经被官方弃用： lib-flexible这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用viewport来替代此方案。 下面我们来看看现在最流行的vh、vw方案。 6.2 vh、vw方案vh、vw方案即将视觉视口宽度 window.innerWidth和视觉视口高度 window.innerHeight 等分为 100 份。上面的flexible方案就是模仿这种方案，因为早些时候vw还没有得到很好的兼容。 vw(Viewport&#39;s width)：1vw等于视觉视口的1% vh(Viewport&#39;s height) :1vh 为视觉视口高度的1% vmin : vw 和 vh 中的较小值 vmax : 选取 vw 和 vh 中的较大值 如果视觉视口为375px，那么1vw = 3.75px，这时UI给定一个元素的宽为75px（设备独立像素），我们只需要将它设置为75 / 3.75 = 20vw。这里的比例关系我们也不用自己换算，我们可以使用PostCSS的 postcss-px-to-viewport 插件帮我们完成这个过程。写代码时，我们只需要根据UI给的设计图写px单位即可。当然，没有一种方案是十全十美的，vw同样有一定的缺陷： px转换成vw不一定能完全整除，因此有一定的像素差。 比如当容器使用vw，margin采用px时，很容易造成整体宽度超过100vw，从而影响布局效果。当然我们也是可以避免的，例如使用padding代替margin，结合calc()函数使用等等… 七、适配iPhoneXiPhoneX的出现将手机的颜值带上了一个新的高度，它取消了物理按键，改成了底部的小黑条，但是这样的改动给开发者适配移动端又增加了难度。 7.1 安全区域在iPhoneX发布后，许多厂商相继推出了具有边缘屏幕的手机。这些手机和普通手机在外观上无外乎做了三个改动：圆角（corners）、刘海（sensor housing）和小黑条（Home Indicator）。为了适配这些手机，安全区域这个概念变诞生了：安全区域就是一个不受上面三个效果的可视窗口范围。为了保证页面的显示效果，我们必须把页面限制在安全范围内，但是不影响整体效果。 7.2 viewport-fitviewport-fit是专门为了适配iPhoneX而诞生的一个属性，它用于限制网页如何在安全区域内进行展示。contain: 可视窗口完全包含网页内容cover：网页内容完全覆盖可视窗口默认情况下或者设置为auto和contain效果相同。 7.3 env、constant我们需要将顶部和底部合理的摆放在安全区域内，iOS11新增了两个CSS函数env、constant，用于设定安全区域与边界的距离。函数内部可以是四个常量： safe-area-inset-left：安全区域距离左边边界距离 safe-area-inset-right：安全区域距离右边边界距离 safe-area-inset-top：安全区域距离顶部边界距离 safe-area-inset-bottom：安全区域距离底部边界距离 注意：我们必须指定viweport-fit后才能使用这两个函数：12&lt;meta name=&quot;viewport&quot; content=&quot;viewport-fit=cover&quot;&gt;复制代码 constant在iOS &lt; 11.2的版本中生效，env在iOS &gt;= 11.2的版本中生效，这意味着我们往往要同时设置他们，将页面限制在安全区域内：12345body &#123; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom);&#125;复制代码 当使用底部固定导航栏时，我们要为他们设置padding值：12345&#123; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom);&#125;复制代码 八、横屏适配很多视口我们要对横屏和竖屏显示不同的布局，所以我们需要检测在不同的场景下给定不同的样式： 8.1 JavaScript检测横屏window.orientation:获取屏幕旋转方向1234567891011window.addEventListener(&quot;resize&quot;, ()=&gt;&#123; if (window.orientation === 180 || window.orientation === 0) &#123; // 正常方向或屏幕旋转180度 console.log(&apos;竖屏&apos;); &#125;; if (window.orientation === 90 || window.orientation === -90 )&#123; // 屏幕顺时钟旋转90度或屏幕逆时针旋转90度 console.log(&apos;横屏&apos;); &#125;&#125;);复制代码 8.2 CSS检测横屏1234567@media screen and (orientation: portrait) &#123; /*竖屏...*/&#125;@media screen and (orientation: landscape) &#123; /*横屏...*/&#125;复制代码 九、图片模糊问题 9.1 产生原因我们平时使用的图片大多数都属于位图（png、jpg...），位图由一个个像素点构成的，每个像素都具有特定的位置和颜色值：理论上，位图的每个像素对应在屏幕上使用一个物理像素来渲染，才能达到最佳的显示效果。而在dpr &gt; 1的屏幕上，位图的一个像素可能由多个物理像素来渲染，然而这些物理像素点并不能被准确的分配上对应位图像素的颜色，只能取近似值，所以相同的图片在dpr &gt; 1的屏幕上就会模糊: 9.2 解决方案为了保证图片质量，我们应该尽可能让一个屏幕像素来渲染一个图片像素，所以，针对不同DPR的屏幕，我们需要展示不同分辨率的图片。如：在dpr=2的屏幕上展示两倍图(@2x)，在dpr=3的屏幕上展示三倍图(@3x)。 9.3 media查询使用media查询判断不同的设备像素比来显示不同精度的图片：1234567891011121314.avatar&#123; background-image: url(conardLi_1x.png); &#125; @media only screen and (-webkit-min-device-pixel-ratio:2)&#123; .avatar&#123; background-image: url(conardLi_2x.png); &#125; &#125; @media only screen and (-webkit-min-device-pixel-ratio:3)&#123; .avatar&#123; background-image: url(conardLi_3x.png); &#125; &#125;复制代码 只适用于背景图 9.4 image-set使用image-set：1234.avatar &#123; background-image: -webkit-image-set( &quot;conardLi_1x.png&quot; 1x, &quot;conardLi_2x.png&quot; 2x );&#125;复制代码 只适用于背景图 9.5 srcset使用img标签的srcset属性，浏览器会自动根据像素密度匹配最佳显示图片：123&lt;img src=&quot;conardLi_1x.png&quot; srcset=&quot; conardLi_2x.png 2x, conardLi_3x.png 3x&quot;&gt;复制代码 9.6 JavaScript拼接图片url使用window.devicePixelRatio获取设备像素比，遍历所有图片，替换图片地址：123456const dpr = window.devicePixelRatio;const images = document.querySelectorAll(&apos;img&apos;);images.forEach((img)=&gt;&#123; img.src.replace(&quot;.&quot;, `@$&#123;dpr&#125;x.`);&#125;)复制代码 9.7 使用svgSVG的全称是可缩放矢量图（Scalable Vector Graphics）。不同于位图的基于像素，SVG 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。除了我们手动在代码中绘制svg，我们还可以像使用位图一样使用svg图片：123456&lt;img src=&quot;conardLi.svg&quot;&gt;&lt;img src=&quot;data:image/svg+xml;base64,[data]&quot;&gt;.avatar &#123; background: url(conardLi.svg);&#125;复制代码 参考 99designs.com/blog/tips/p… www.w3cplus.com/css/vw-for-… aotu.io/notes/2017/… 分辨率小科普 小结希望你阅读本篇文章后可以达到以下几点： 理清移动端适配常用概念 理解移动端适配问题产生的原理，至少掌握一种解决方案]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站性能优化]]></title>
    <url>%2Fposts%2F41624%2F</url>
    <content type="text"><![CDATA[关键渲染路径What关键渲染路径（Critical Rendering Path）指的是：「浏览器所经历的一系列步骤，从而将 HTML、CSS 和 JavaScript 转换为在屏幕上呈现的像素内容」我们要做的，就是优化关键渲染路径，这样就能提高网页呈现的速度，从而使用户和老板更满意。 网页生成过程说白了，「关键渲染路径」即「网页生成的过程」，简要概述就是： 处理 HTML 标记并构建 DOM 树 处理 CSS 标记并构建 CSSOM 树 将 DOM 与 CSSOM 合并成一个渲染树 根据渲染树来布局，以计算每个节点的几何信息 将各个节点绘制到屏幕上 将 HTML 转为 DOM文档对象模型（DOM）存储的是「页面内容」及每个节点「属性方面的数据」。DOM 中对象之间的关系展示了父子节点以及兄弟节点。 注意：DOM 的构建过程是逐步实现的，意味着一旦获得了 HTML 就可以开始构建 DOM 了，不需要等待整个 HTML 页面加载完毕后再去构建 DOM 。 将 CSS 转为 CSSOM 合并渲染树完成了 DOM 树和 CSSOM 树的构建以后，就要将它们合并成一个渲染树。 注意：某些节点如果通过 CSS 隐藏，那么在渲染树中也会被忽略，例如我们在 HTML 中编写的 span 节点，它就不会出现在渲染树中。因为有一个 CSS 规则在 span 上设置了 display: none 属性。 布局与绘制在渲染树构建阶段，我们已经计算了哪些节点应该是可见的以及它们的计算样式，所以在布局阶段，我们就需要计算它们在设备视口内的确切位置和大小。这个过程称为布局，或者叫做重排。 最后，既然我们知道了哪些节点可见、它们的计算样式以及几何信息，我们终于可以将这些信息传递给最后一个阶段：将渲染树中的每个节点转换成屏幕上的实际像素。这一步通常称为“绘制”或“栅格化”。到此，浏览器对网页的第一次生成过程已经结束。 而我们的前端网站性能优化，也就是针对整个「关键渲染路径」而言的。只有最大限度的缩短上面第 1 至 5 步耗费的总时间，才能尽快的将内容渲染到屏幕上，此外还能缩短首屏的加载时间。 网页加载的优化优化DOM压缩+删除注释为了将 HTML 文件尽可能快的传输给浏览器（客户端），我们需要压缩文件的大小，例如下面html文件： 123456789101112131415161718&lt;html&gt;&lt;head&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* reset */ * &#123; padding: 0; margin: 0; list-style: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 头部 --&gt; &lt;header&gt;...&lt;/header&gt; &lt;!-- 正文 --&gt; &lt;main&gt;...&lt;/main&gt; &lt;!-- 底部 --&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 这段代码包含了非常多的注释，这些注释对开发者来说可能有用，然而浏览器在遇到注释时却会忽略它们的，所以根本没必要展示给浏览器，我们完全可以移除它们。另外空格和换行也是个大问题，它会增加我们文件的体积，所以我们需要利用一些工具去压缩它。 上图是在删除掉所有注释，并使用 在线JS压缩工具 压缩后的文件大小对比。当然，这种策略同样适用于 CSS 文件，你可以使用类似的步骤对 CSS 进行注释的删除与压缩。 如果你使用 webpack 构建你的应用，你可以使用下面插件来优化html、css和js： optimize-css-assets-webpack-plugin（优化css） html-webpack-plugin（配置与优化html） webpack-parallel-uglify-plugin（优化js） 优化 CSSOMCSS 在默认情况下是阻塞渲染的一类资源，也就是说浏览器在 CSSOM 构建完成以前是不会渲染任何已处理的内容的，所以我们必须对 CSS 进行精简。由于浏览器必须同时具有 DOM 以及 CSSOM 才能构建渲染树，所以 HTML 和 CSS 都是阻塞渲染的资源。刚才已经针对 HTML 进行了优化，现在该轮到 CSS 了。 压缩+删除注释这一点不多赘述，参考上面html的优化步骤。 内联 CSS如果你的 css 文件很小，小到仅有几十甚至几KB，那么你完全可以将 css 内联进 html ，因为相比使用 link 外链还得发一个请求，内联的代价要小的多得多。 利用 Media 媒体查询有时候一些 CSS 样式只在特定条件下使用，比如打印网页或者网页在大型显示器上显示时。这个时候我们的 media 媒体查询就能大显身手了，它能让这些特定的 CSS 资源不去阻塞页面的渲染。 123&lt;link rel="stylesheet" href="style.css"&gt;&lt;link rel="stylesheet" href="print.css" media="print"&gt;&lt;link rel="stylesheet" href="other.css" media="(min-width: 980px)"&gt; 上面的例子在我们的项目中很常见，第一个样式表适用于所有情况，它始终会阻塞渲染。但第二个样式表则不然，它只在打印内容时适用，因此在网页首次加载时，该样式表不需要阻塞渲染。最后一个样式表声明则只在特定环境下被执行，一旦不符合最小宽度大于980px，则始终不会被加载，这样我们就又少了一个不阻塞页面渲染的 CSS 资源。 注意： 「阻塞渲染」仅是指浏览器是否需要暂停网页的首次渲染，直至该资源准备就绪。无论哪一种情况，浏览器仍会下载 CSS 资源，只不过不阻塞渲染的资源优先级较低罢了。 CSS会造成阻塞吗？ css 加载不会阻塞 DOM 树的解析 css 加载会阻塞 DOM 树也就是页面的渲染 css 加载会阻塞后面 js 语句的执行 css 加载不阻塞外部脚本的加载了解更多：https://www.cnblogs.com/chenjg/p/7126822.html 优化 JavaScript默认情况下，无论内联还是外联，浏览器遇到文档中的 JavaScript 时都会暂停 DOM 构建，并立即开始执行 JavaScript ，等到脚本执行完毕后，再继续构建 DOM。所以为了提高页面渲染速度，我们可以让 JavaScript 异步执行。 window.onload这种解决方案是让脚本在网页加载完毕后再执行。当网页加载完毕后，浏览器会发出 onload 事件，我们可以将 JavaScript 放进 onload 事件的回调函数中，这样当 onload 事件被触发后，就能执行我们的脚本了，示例如下： 1234567891011121314&lt;html&gt; &lt;head&gt; &lt;script&gt; function load() &#123; init() doSomethingElse() &#125; window.onload = load &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;...&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; defer / async我们还可以向 script 标签添加异步关键字，那样可以让浏览器在等待脚本期间不阻止 DOM 以及 CSSOM 的构建。 而关于 defer 和 async 的区别，一图胜千言： （出处：https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html） 简单来说，当浏览器遇到 script 脚本的时候： &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，即不等待后续载入的文档元素，读到就加载并执行。 &lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 &lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt;有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 注意：HTML5 规定，defer 脚本最后的延迟执行应该按照书写顺序来执行，即下面示例脚本，a.js 一定在 b.js 前面执行： 1234567&lt;html&gt;&lt;head&gt; &lt;script defer src="./js/a.js"&gt;&lt;/script&gt; &lt;script defer src="./js/b.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 但在 「JavaScript 高级程序设计（第三版）」中作者表示： 在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。 我个人是试验过各种浏览器的，Chrome、Firefox、Safari，没有出现作者所说的情况。所以我猜测作者写上这一句话的原因是：即使在 HTML5 规范中有这么一条，不一定所有的浏览器厂商都会遵照这个规定，可能某些浏览器厂商并没有实现这个规范，所以为了安全起见，在开发中使用一个 defer 是非常有必要的。 HTTP 缓存这部分内容可以点击此处查看 渲染性能的优化页面不仅要快速加载，而且要顺畅地运行；例如列表页的滚动应与手指的滑动一样快，侧边栏的弹出隐藏动画应如丝绸般顺滑。所以除了对关键渲染路径的优化以外，我们还得确保自己编写的代码能（包括其他第三方代码）更高效地运行。 像素管道首先我们要了解下「像素管道」的概念。像素管道是「网页从像素到屏幕」的一系列关键节点： JavaScript：指的是使用 JavaScript 来实现一些视觉变化的效果。（e.g. 给页面添加 DOM 元素） 样式计算：指的是根据「匹配选择器」计算出元素所应用的 CSS 规则的过程。 布局：指的是浏览器根据元素所应用的规则计算它们要占据的空间大小及其在屏幕的位置。 绘制：指的是填充像素的过程。（e.g. 绘制文本、颜色、边框和阴影，基本上包括元素的每个可视部分）绘制一般是在多个层上完成的。 合成：由于页面的各部分可能被绘制到多层，所以它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。 我们在编写代码的时候要时刻注意这五个关键节点，因为其中的每一个部分都可能为我们的应用带来“卡顿”。 使用 requestAnimationFrame试想一下，假设现在浏览器正在执行有关样式方面的工作，然后出现了需要处理的 JavaScript 。这个时候浏览器会马上停下手中的活儿，转而执行插进来的 JavaScript ，然而新来的 JavaScript 是有可能导致刚才处理的样式工作重新返工的（配合上面的「管道图」来看，相当于 style 阶段完成后却执行了 JavaScript ，导致丢帧），这样一来浏览器就很有可能丢失了刚才处理完的这一帧，从而导致卡顿现象。所以没错，当你在使用 JavaScript 编写一段动画时，可以使用 RequestAnimationFrame API，该 API 能够提升我们的动画流畅度，因为它会安排 JavaScript 尽早在每一帧的开始执行，这样尽量给浏览器留出足够的时间来运行代码，然后是样式过程——&gt;布局过程——&gt;绘制过程——&gt;渲染层合并过程。示例： 123456789function animationWidth() &#123; var div = document.getElementById('box'); div.style.width = parseInt(div.style.width) + 1 + 'px'; if (parseInt(div.style.width) &lt; 200) &#123; requestAnimationFrame(animationWidth) &#125;&#125;requestAnimationFrame(animationWidth); 避免重排与重绘What 重排：当 DOM 的变化影响了元素的几何信息（DOM 对象的位置和尺寸大小），浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。 重绘：当一个元素更改了非几何属性（e.g. 背景、文本或阴影），但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。 浏览器的渲染队列思考以下代码将会触发几次渲染？ 1234div.style.left = '10px';div.style.top = '10px';div.style.width = '20px';div.style.height = '20px'; 根据我们上文的定义，这段代码理论上会触发4次重排+重绘，因为每一次都改变了元素的几何属性。但实际上最后只触发了一次重排，这都得益于浏览器的渲染队列机制：当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。 强制刷新队列12345678div.style.left = '10px';console.log(div.offsetLeft);div.style.top = '10px';console.log(div.offsetTop);div.style.width = '20px';console.log(div.offsetWidth);div.style.height = '20px';console.log(div.offsetHeight); 这段代码会触发4次重排+重绘，因为在console中你请求的这几个样式信息，无论何时浏览器都会立即执行渲染队列的任务，即使该值与你操作中修改的值没关联。因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘。强制刷新队列的style样式请求： offsetTop, offsetLeft, offsetWidth, offsetHeight scrollTop, scrollLeft, scrollWidth, scrollHeight clientTop, clientLeft, clientWidth, clientHeight getComputedStyle(), 或者 IE的 currentStyle 所以我们在开发中，应该谨慎的使用这些style请求，注意上下文关系，避免一行代码一个重排，这对性能是个巨大的消耗。 重排优化建议分离读写操作12345678div.style.left = '10px';div.style.top = '10px';div.style.width = '20px';div.style.height = '20px';console.log(div.offsetLeft);console.log(div.offsetTop);console.log(div.offsetWidth);console.log(div.offsetHeight); 还是上面触发4次重排+重绘的代码，这次只触发了一次重排：在第一个console的时候，浏览器把之前上面四个写操作的渲染队列都给清空了。剩下的console，因为渲染队列本来就是空的，所以并没有触发重排，仅仅拿值而已。 样式集中改变1234div.style.left = '10px';div.style.top = '10px';div.style.width = '20px';div.style.height = '20px'; 虽然现在大部分浏览器有渲染队列优化，不排除有些浏览器以及老版本的浏览器效率仍然低下。 建议通过改变 class 或者 csstext 属性集中改变样式 123456789// badvar left = 10;var top = 10;el.style.left = left + "px";el.style.top = top + "px";// good el.className += " theclassname";// goodel.style.cssText += "; left: " + left + "px; top: " + top + "px;"; 缓存布局信息12345678// bad 强制刷新 触发两次重排div.style.left = div.offsetLeft + 1 + 'px';div.style.top = div.offsetTop + 1 + 'px';// good 缓存布局信息 相当于读写分离var curLeft = div.offsetLeft;var curTop = div.offsetTop;div.style.left = curLeft + 1 + 'px';div.style.top = curTop + 1 + 'px'; 离线改变dom 隐藏要操作的dom在要操作dom之前，通过 display 隐藏 dom ，当操作完成之后，才将元素的 display 属性为可见，因为不可见的元素不会触发重排和重绘。 123dom.display = 'none'// 修改dom样式dom.display = 'block' 通过使用 DocumentFragment 创建一个 dom 碎片,在它上面批量操作 dom ，操作完成之后，再添加到文档中，这样只会触发一次重排。 复制节点，在副本上工作，然后替换它！ position属性为absolute或fixedposition属性为absolute或fixed的元素，重排开销比较小，不用考虑它对其他元素的影响 优化动画 可以把动画效果应用到position属性为absolute或fixed的元素上，这样对其他元素影响较小动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量：比如实现一个动画，以1个像素为单位移动这样最平滑，但是 reflow 就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多。 启用 GPU 加速此部分来自优化CSS重排重绘与浏览器性能GPU（图像加速器）：GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成，因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。GPU 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。 1234567891011121314/* * 根据上面的结论 * 将 2d transform 换成 3d * 就可以强制开启 GPU 加速 * 提高动画性能 */div &#123; transform: translate3d(10px, 10px, 0);&#125;/* 又或者使用 will-change 属性来创建新层 */div &#123; will-change: transform;&#125; 参考资源 Google Web Fundamentals - Performance css加载会造成阻塞吗？ async vs defer attributes]]></content>
      <categories>
        <category>前端</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event Loop 学习笔记]]></title>
    <url>%2Fposts%2F10505%2F</url>
    <content type="text"><![CDATA[我们只关心打钩的的阶段： timers poll（此阶段会停留一段时间） check（执行一些立即执行的函数【主要就是：setImmediate(fn) 函数】） 123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ✅ ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll ✅ │&lt;─────┤ connections, ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ✅ ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ timers 和 poll 根据 官方文档 的描述，事件循环应该是从 timers 开始的，但不一定。 NodeJS的内部代码大概是这样写的： 开启 eventLoop() 执行 JS() 但由于启动 event loop 是开个进程，需要时间的，而执行 JS 也得启动V8引擎，也是需要时间的，所以不确定这两个谁快谁慢。所以： 有可能 setTimeout 先执行，后才进入 timers 阶段 也有可能先进入 timers 阶段，后执行 setTimeout 假设一段代码： 1setTimeout(fn, 1000); 当我们在执行这段代码时，会把 fn 放进 timers 中的一个队列中去（也可以认为是一个数组）。然后JS就做自己的事情去了。此时 timers 可能开启了，也可能没有开启。但最大的可能是，在执行 setTimeout(fn, 1000); 的时候，我们进入了 poll 阶段，poll 阶段就是等待（e.g. 等待ajax请求成功，或者读文件成功），大概几十毫秒。在等待期间，它会看时间，比如刚才JS让我1000毫秒后执行一个fn，现在刚过去500毫秒，那我继续等，直到等到1000毫秒时，赶紧经过 check 阶段，进入 timers 阶段去执行 fn： 执行完毕后，又进入 poll 阶段，什么都不做，继续等。这个等有个时间限制的，假设是3s，那么3s后如果什么都没等到，就进入 check 阶段，然后再回到 timers 阶段，如此循环。 checkcheck 阶段会执行一些立即执行的函数，主要就是 setImmediate(fn) 函数。该函数类似 setTimeout，但没有第二个参数。 12setTimeout(() =&gt; console.log("fn"), 1000);setImmediate(() =&gt; console.log("fn2")); 所以在执行例如 setImmediate(fn2) 时，fn2 不会进入 timers，而会进入 check 阶段的一个队列中： 由于我们不确定 timers 这个一阶段结束了还是未结束，所以我们以二阶段 poll 来研究。 当执行 setTimeout 后，我们把 fn 扔进了 timers ，然后进入 poll 阶段开始等，现在又执行到了 setImmediate ，这是个立即执行函数，有事情开始做了，所以 poll 不等了，直接进入 check 阶段去执行 fn2。 然后又回到 timers 阶段，不执行 fn（因为没到1000毫秒），又进入 poll 阶段，等到 1000 毫秒后，进入 check 阶段，然后返回 timers 阶段，开始执行 fn （fn只能在进入 timers 阶段才能执行）。 经典考题12setTimeout(() =&gt; console.log("fn"), 0);setImmediate(() =&gt; console.log("fn2")); 按照理论（NodeJS内部代码先调用的 event loop，再调用的执行JS），应该 fn2 先执行，但实际结果是不一定的，有可能先打印 fn，再打印 fn2；也有可能先打印 fn2，再打印 fn。原因就在于 开启event loop 和 执行 JS 的顺序是随机的。 如果先开启了 event loop ，那么就先从 poll 阶段开始，因为 timers 阶段没发现有任何函数，所以进入 poll 开始等。接着等到了 执行JS ，执行第一段代码，就把0s延迟的 fn 放进了 timers 的队列，接着执行第二段代码，把 fn2 放进了 check 队列，此刻 执行JS 完毕，event loop 说：你执行完了是吧？我可以开始做事了，然后 poll 发现有任务要执行了，就进入 check 阶段执行 fn2，再返回到 timers 阶段，发现有个 fn 已经过时间了（因为延迟0s），马上执行 fn。所以这种情况下，先打印 fn2，再打印 fn。 但如果 event loop 开启的比较慢，执行JS这一步先开始了。那么就会先把 fn 扔进队列，再才开始进入 timers 的第一阶段，此刻 timers 发现已经有了个 fn，还是 0s 延迟执行，所以就执行了 fn，再进入 poll ，poll 发现还有个 fn2 在等我立即执行，就接着进入 check 然后执行 fn2。所以这种情况下，先打印 fn，再打印 fn2。 说到底，就是看 fn 是在第一次进入 timers 阶段前就存在，还是第一次进入 timers 阶段后才存在。 那怎样才能保证 fn2 先执行呢？解决方案把这两段代码放进一个 setTimeout 中去，然后延迟1s执行，为的就是等 event loop 开启后，进入 poll 阶段，再开始执行这两段代码： 1234setTimeout(() =&gt; &#123; setTimeout(() =&gt; console.log("fn"), 0); setImmediate(() =&gt; console.log("fn2"));&#125;, 1000); process.nextTick()这个重要的异步API不属于 event loop 的任何一个阶段。nextTick 队列会在当前阶段后就被执行。 以下面代码为例： 12345setTimeout(() =&gt; &#123; setTimeout(() =&gt; console.log("fn"), 0); setImmediate(() =&gt; console.log("fn2")); process.nextTick(() =&gt; console.log("fn3"));&#125;, 1000); 由于三段代码被放进了一个 setTimeout 中，且在1s后再被执行。所以1s后 event loop 肯定已经存在，此时就从 poll 阶段开始，然后执行三段代码，第一段把 fn 放进 timers 的队列，第二段把 fn2 放进 check 队列，然后 poll 阶段执行完了，根据 nextTick 队列会在当前阶段后就被执行，所以此刻在马上要进入 check 阶段之前，就把 nextTick 中的代码执行掉了，所以先打印 fn3，然后进入 check 阶段后打印 fn2，最后重新进入 timers 打印 fn。 再来看下面这段代码： 12345678setTimeout(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log("fn"); process.nextTick(() =&gt; console.log("fn4")); &#125;, 0); setImmediate(() =&gt; console.log("fn2")); process.nextTick(() =&gt; console.log("fn3"));&#125;, 1000); 由于fn4紧跟着fn，所以在 timers 阶段完成后，就执行了fn4（注意fn4不会放进 timers 的队列，而是在队列里函数执行完后，紧跟着执行 fn4），所以最终顺序为： fn3, fn2, fn, fn4 面试题123456789101112131415setTimeout(() =&gt; &#123; setImmediate(() =&gt; &#123; console.log("setImmediate1"); setTimeout(() =&gt; &#123; console.log("setTimeout1"); &#125;, 0); &#125;); setTimeout(() =&gt; &#123; console.log("setTimeout2"); setImmediate(() =&gt; &#123; console.log("setImmediate2"); &#125;); &#125;, 0);&#125;, 1000); 执行第2行 setImmediate 后，把 setImmediate 中的函数 f1 放进 check 中（此刻不执行f1），然后执行第9行的 setTimeout ，把 setTimeout 中的函数 f2 放进 timers 中（此刻也不执行f2），然后进入poll阶段等待，发现有f1待执行，所以执行f1，打印 setImmediate1 ，接着把 f3 放进 timers 的队列。此刻check阶段完成，重回 timers 阶段，发现队列中的 f2，执行 f2，打印 setTimeout2 ，接着把 f4 扔进 check 队列，然后执行 f3， 打印 setTimeout1 ，执行完后，进入 poll 阶段，发现有 f4 没执行，进入 check 阶段，执行f4，所以最后打印 setImmediate2 。 宏任务&amp;微任务Event LoopNodeJS： timers（setTimeout） poll check（setImmediate） 注意：nextTick不属于任何阶段，但会在当前阶段后执行 如果强行问NodeJS中的宏任务微任务，那就是： setTimeout和setImmediate是宏任务，nextTick是微任务。因为nextTick不用等到下个阶段，会在当前阶段完成后立即执行。 还有个 promise.then(fn)【注意是小写的p，大写的P不能直接then】，一般不考。Node中的 promise.then 一般是用 nextTick 实现的，所以也按照当前阶段的后面来推。这里then里面的fn不是马上放队列（setTImeout，setImmediate和nextTick都是里面的fn马上放队列），而是当你resolve以后，才放进当前阶段的后面执行。 chrome： 宏任务（一会儿）setTimeout 微任务（马上）.then(fn) fn放马上 一会儿就是等会做，马上就是立即做；如果一会儿里面有个马上做的，还是马上做。 注意： 遇到 await 把它转为 promise 再看，因为 await 本来就是 promise 的语法糖。 new Promise 是立即执行的，.then 才是微任务。 面试题123456789101112131415161718async function async1() &#123; console.log(1); await async2(); console.log(2);&#125;async function async2() &#123; console.log(3);&#125;async1();new Promise(function(resolve) &#123; console.log(4); resolve();&#125;).then(function() &#123; console.log(5);&#125;); 画图！！！不画图做不出来！！！ 代码从上到下，先执行 11 行 async1，进入 async1，先打印1。遇到 await 转为 promise =&gt; async2(() =&gt; console.log(3)).then(() =&gt; console.log(2)); （await后面所有代码都属于then当中的，比如第4行后面加个console.log(“233”)，那么此行代码也属于then）而 async2 本身的代码会被立即执行，所以打印第8行中的3。打印完后执行 then （执行then其实是需要resolve的，但async会去看你函数中有没有resolve，如果没有会自动加上resolve，相当于async帮你干了这样一件事：Promise.resolve(async2()).then(f1)），then就是放队列，我们把 console.log(2) 记做任务 f1 放进「马上」中去，但此刻不执行。此刻 async1 彻底执行完了。 接着执行 13 行的 new Promise，14 到 15 行代码会被立即执行（new Promise中的函数会被立即执行，没有什么宏任务微任务，就相当于裸写14到15行代码），所以打印4。在执行完14行resolve的时候，会指明执行then后面的第一个函数，而不是第二个函数（reject时所执行的），也就是17行代码的任务也放进「马上」中去，该任务记做 f2 ，至此当前代码全部执行完毕，然后看「马上」中的任务，执行 f1，打印2。接着执行 f2， 打印5。 注意点：上面的 resolve 只是决定执行then里面的成功回调函数，并不决定加入队列。决定加入队列的是 then。 总结宏任务（一会儿）：setTimeout，setInterval，setImmediate（优先级比前两个高，因为是在check阶段） 微任务（马上）：promise.then，process.nextTick 宏任务微任务执行顺序：有微任务先执行微任务，微任务都执行完了，再执行宏任务]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>EventLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event Loop、计时器、nextTick（转载）]]></title>
    <url>%2Fposts%2F61492%2F</url>
    <content type="text"><![CDATA[这是一篇转载文章，源地址是方应杭在掘金上发表的一篇译文：Event Loop、计时器、nextTick 原文：https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/ 以下是译文： 什么是事件循环（Event Loop，注意空格）JavaScript 是单线程的，有了 event loop 的加持，Node.js 才可以非阻塞地执行 I/O 操作，把这些操作尽量转移给操作系统来执行。 我们知道大部分现代操作系统都是多线程的，这些操作系统可以在后台执行多个操作。当某个操作结束了，操作系统就会通知 Node.js，然后 Node.js 就（可能）会把对应的回调函数添加到 poll（轮询）队列，最终这些回调函数会被执行。下文中我们会阐述其细节。 Event Loop 详解当 Node.js 启动时，会做这几件事 初始化 event loop 开始执行脚本（或者进入 REPL，本文不涉及 REPL）。这些脚本有可能会调用一些异步 API、设定计时器或者调用 process.nextTick() 开始处理 event loop 如何处理 event loop 呢？下图给出了一个简单的概览： 123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ 其中每个方框都是 event loop 中的一个阶段。 每个阶段都有一个「先入先出队列」，这个队列存有要执行的回调函数（译注：存的是函数地址）。不过每个阶段都有其特有的使命。一般来说，当 event loop 达到某个阶段时，会在这个阶段进行一些特殊的操作，然后执行这个阶段的队列里的所有回调。 什么时候停止执行这些回调呢？下列两种情况之一会停止： 队列的操作全被执行完了 执行的回调数目到达指定的最大值 然后，event loop 进入下一个阶段，然后再下一个阶段。 一方面，上面这些操作都有可能添加计时器；另一方面，操作系统会向 poll 队列中添加新的事件，当 poll 队列中的事件被处理时可能会有新的 poll 事件进入 poll 队列。结果，耗时较长的回调函数可以让 event loop 在 poll 阶段停留很久，久到错过了计时器的触发时机。你可以在下文的 timers 章节和 poll 章节详细了解这其中的细节。 注意，Windows 的实现和 Unix/Linux 的实现稍有不同，不过对本文内容影响不大。本文囊括了 event loop 最重要的部分，不同平台可能有七个或八个阶段，但是上面的几个阶段是我们真正关心的阶段，而且是 Node.js 真正用到的阶段。 各阶段概览 timers 阶段：这个阶段执行 setTimeout 和 setInterval 的回调函数。 I/O callbacks 阶段：不在 timers 阶段、close callbacks 阶段和 check 阶段这三个阶段执行的回调，都由此阶段负责，这几乎包含了所有回调函数。 idle, prepare 阶段（译注：看起来是两个阶段，不过这不重要）：event loop 内部使用的阶段（译注：我们不用关心这个阶段） poll 阶段：获取新的 I/O 事件。在某些场景下 Node.js 会阻塞在这个阶段。 check 阶段：执行 setImmediate() 的回调函数。 close callbacks 阶段：执行关闭事件的回调函数，如 socket.on(‘close’, fn) 里的 fn。 一个 Node.js 程序结束时，Node.js 会检查 event loop 是否在等待异步 I/O 操作结束，是否在等待计时器触发，如果没有，就会关掉 event loop。 各阶段详解timers 阶段计时器实际上是在指定多久以后可以执行某个回调函数，而不是指定某个函数的确切执行时间。当指定的时间达到后，计时器的回调函数会尽早被执行。如果操作系统很忙，或者 Node.js 正在执行一个耗时的函数，那么计时器的回调函数就会被推迟执行。 注意，从原理上来说，poll 阶段能控制计时器的回调函数什么时候被执行。 举例来说，你设置了一个计时器在 100 毫秒后执行，然后你的脚本用了 95 毫秒来异步读取了一个文件： 12345678910111213141516171819202122232425const fs = require('fs');function someAsyncOperation(callback) &#123; // 假设读取这个文件一共花费 95 毫秒 fs.readFile('/path/to/file', callback);&#125;const timeoutScheduled = Date.now();setTimeout(() =&gt; &#123; const delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;毫秒后执行了 setTimeout 的回调`);&#125;, 100);// 执行一个耗时 95 毫秒的异步操作someAsyncOperation(() =&gt; &#123; const startCallback = Date.now(); // 执行一个耗时 10 毫秒的同步操作 while (Date.now() - startCallback &lt; 10) &#123; // 什么也不做 &#125;&#125;); 当 event loop 进入 poll 阶段，发现 poll 队列为空（因为文件还没读完），event loop 检查了一下最近的计时器，大概还有 100 毫秒时间，于是 event loop 决定这段时间就停在 poll 阶段。在 poll 阶段停了 95 毫秒之后，fs.readFile 操作完成，一个耗时 10 毫秒的回调函数被系统放入 poll 队列，于是 event loop 执行了这个回调函数。执行完毕后，poll 队列为空，于是 event loop 去看了一眼最近的计时器（译注：event loop 发现卧槽，已经超时 95 + 10 - 100 = 5 毫秒了），于是经由 check 阶段、close callbacks 阶段绕回到 timers 阶段，执行 timers 队列里的那个回调函数。这个例子中，100 毫秒的计时器实际上是在 105 毫秒后才执行的。 注意：为了防止 poll 阶段占用了 event loop 的所有时间，libuv（Node.js 用来实现 event loop 和所有异步行为的 C 语言写成的库）对 poll 阶段的最长停留时间做出了限制，具体时间因操作系统而异。 I/O callbacks 阶段这个阶段会执行一些系统操作的回调函数，比如 TCP 报错，如果一个 TCP socket 开始连接时出现了 ECONNREFUSED 错误，一些 *nix 系统就会（向 Node.js）通知这个错误。这个通知就会被放入 I/O callbacks 队列。 poll 阶段（轮询阶段）poll 阶段有两个功能： 如果发现计时器的时间到了，就绕回到 timers 阶段执行计时器的回调。 然后再，执行 poll 队列里的回调。 当 event loop 进入 poll 阶段，如果发现没有计时器，就会： 如果 poll 队列不是空的，event loop 就会依次执行队列里的回调函数，直到队列被清空或者到达 poll 阶段的时间上限。 如果 poll 队列是空的，就会： 如果有 setImmediate() 任务，event loop 就结束 poll 阶段去往 check 阶段。 如果没有 setImmediate() 任务，event loop 就会等待新的回调函数进入 poll 队列，并立即执行它。 一旦 poll 队列为空，event loop 就会检查计时器有没有到期，如果有计时器到期了，event loop 就会回到 timers 阶段执行计时器的回调。 check 阶段这个阶段允许开发者在 poll 阶段结束后立即执行一些函数。如果 poll 阶段空闲了，同时存在 setImmediate() 任务，event loop 就会进入 check 阶段。 setImmediate() 实际上是一种特殊的计时器，有自己特有的阶段。它是通过 libuv 里一个能将回调安排在 poll 阶段之后执行的 API 实现的。 一般来说，当代码执行后，event loop 最终会达到 poll 阶段，等待新的连接、新的请求等。但是如果一个回调是由 setImmediate() 发出的，同时 poll 阶段空闲下来了，event loop就会结束 poll 阶段进入 check 阶段，不再等待新的 poll 事件。 （译注：感觉同样的话说了三遍） close callbacks 阶段如果一个 socket 或者 handle 被突然关闭（比如 socket.destroy()），那么就会有一个 close 事件进入这个阶段。否则（译注：我没看到这个否则在否定什么，是在否定「突然」吗？），这个 close 事件就会进入 process.nextTick()。 setImmediate() vs setTimeout()setImmediate 和 setTimeout 很相似，但是其回调函数的调用时机却不一样。 setImmediate() 的作用是在当前 poll 阶段结束后调用一个函数。 setTimeout() 的作用是在一段时间后调用一个函数。 这两者的回调的执行顺序取决于 setTimeout 和 setImmediate 被调用时的环境。 如果 setTimeout 和 setImmediate 都是在主模块（main module）中被调用的，那么回调的执行顺序取决于当前进程的性能，这个性能受其他应用程序进程的影响。 举例来说，如果在主模块中运行下面的脚本，那么两个回调的执行顺序是无法判断的： 12345678// timeout_vs_immediate.jssetTimeout(() =&gt; &#123; console.log('timeout');&#125;, 0);setImmediate(() =&gt; &#123; console.log('immediate');&#125;); 运行结果如下： 1234567$ node timeout_vs_immediate.jstimeoutimmediate$ node timeout_vs_immediate.jsimmediatetimeout 但是，如果把上面代码放到 I/O 操作的回调里，setImmediate 的回调就总是优先于 setTimeout 的回调： 1234567891011// timeout_vs_immediate.jsconst fs = require('fs');fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log('timeout'); &#125;, 0); setImmediate(() =&gt; &#123; console.log('immediate'); &#125;);&#125;); 运行结果如下： 1234567$ node timeout_vs_immediate.jsimmediatetimeout$ node timeout_vs_immediate.jsimmediatetimeout setImmediate 的主要优势就是，如果在 I/O 操作的回调里，setImmediate 的回调总是比 setTimeout 的回调先执行。（译者注：怎么总是把一个道理翻来覆去地说） process.nextTick()你可能发现 process.nextTick() 这个重要的异步 API 没有出现在任何一个阶段里，那是因为从技术上来讲 process.nextTick() 并不是 event loop 的一部分。实际上，不管 event loop 当前处于哪个阶段，nextTick 队列都是在当前阶段后就被执行了。 回过头来看我们的阶段图，你在任何一个阶段调用 process.nextTick(回调)，回调都会在当前阶段继续运行前被调用。这种行为有的时候会造成不好的结果，因为你可以递归地调用 process.nextTick()，这样 event loop 就会一直停在当前阶段不走……无法进入 poll 阶段。 为什么 Node.js 要这样设计 process.nextTick 呢？ 因为有些异步 API 需要保证一致性，即使可以同步完成，也要保证异步操作的顺序，看下面代码： 1234function apiCall(arg, callback) &#123; if (typeof arg !== 'string') return process.nextTick(callback, new TypeError('argument should be string'));&#125; 这段代码检查了参数的类型，如果类型不是 string，就会将 error 传递给 callback。 这段代码保证 apiCall 调用之后的同步代码能在 callback 之前运行。用于用到了 process.nextTick()，所以 callback 会在 event loop 进入下一个阶段前执行。为了做到这一点，JS 的调用栈可以先 unwind 再执行 nextTick 的回调，这样无论你递归调用多少次 process.nextTick() 都不会造成调用栈溢出（V8 里对应 RangeError: Maximum call stack size exceeded）。 如果不这样设计，会造成一些潜在的问题，比如下面的代码： 123456789101112let bar;// 这是一个异步 API，但是却同步地调用了 callbackfunction someAsyncApiCall(callback) &#123; callback(); &#125;//`someAsyncApiCall` 在执行过程中就调用了回调someAsyncApiCall(() =&gt; &#123; // 此时 bar 还没有被赋值为 1 console.log('bar', bar); // undefined&#125;);bar = 1; 开发者虽然把 someAsyncApiCall 命名得像一个异步函数，但是实际上这个函数是同步执行的。当 someAsyncApiCall 被调用时，回调也在同一个 event loop 阶段被调用了。结果回调中就无法得到 bar 的值。因为赋值语句还没被执行。 如果把回调放在 process.nextTick() 中执行，后面的赋值语句就可以先执行了。而且 process.nextTick() 的回调会在 eventLoop 进入下一个阶段前调用。（译注：又是把一个道理翻来覆去地讲） 1234567891011let bar;function someAsyncApiCall(callback) &#123; process.nextTick(callback);&#125;someAsyncApiCall(() =&gt; &#123; console.log('bar', bar); // 1&#125;);bar = 1; 一个更符合现实的例子是这样的： 123const server = net.createServer(() =&gt; &#123;&#125;).listen(8080);server.on('listening', () =&gt; &#123;&#125;); .listen(8080) 这句话是同步执行的。问题在于 listening 回调无法被触发，因为 listening 的监听代码在 .listen(8080) 的后面。 为了解决这个问题，.listen() 函数可以使用 process.nextTick() 来执行 listening 事件的回调。 process.nextTick() vs setImmediate()这两个函数功能很像，而且名字也很令人疑惑。 process.nextTick() 的回调会在当前 event loop 阶段「立即」执行。 setImmediate() 的回调会在后续的 event loop 周期（tick）执行。 （译注：看起来名字叫反了） 二者的名字应该互换才对。process.nextTick() 比 setImmediate() 更 immediate（立即）一些。 这是一个历史遗留问题，而且为了保证向后兼容性，也不太可能得到改善。所以就算这两个名字听起来让人很疑惑，也不会在未来有任何变化。 我们推荐开发者在任何情况下都使用 setImmediate()，因为它的兼容性更好，而且它更容易理解。 什么时候用 process.nextTick()？There are two main reasons: 使用的理由有两个： 让开发者处理错误、清除无用的资源，或者在 event loop 当前阶段结束前尝试重新请求资源 有时候有必要让一个回调在调用栈 unwind 之后，event loop 进入下阶段之前执行 为了让代码更合理，我们可能会写这样的代码： 12345const server = net.createServer();server.on('connection', (conn) =&gt; &#123; &#125;);server.listen(8080);server.on('listening', () =&gt; &#123; &#125;); 假设 listen() 在 event loop 一启动的时候就执行了，而 listening 事件的回调被放在了 setImmediate() 里，listen 动作是立即发生的，如果想要 event loop 执行 listening 回调，就必须先经过 poll 阶段，当时 poll 阶段有可能会停留，以等待连接，这样一来就有可能出现 connect 事件的回调比 listening 事件的回调先执行。（译注：这显然不合理，所以我们需要用 process.nextTick） 再举一个例子，一个类继承了 EventEmitter，而且想在实例化的时候触发一个事件： 12345678910111213const EventEmitter = require('events');const util = require('util');function MyEmitter() &#123; EventEmitter.call(this); this.emit('event');&#125;util.inherits(MyEmitter, EventEmitter);const myEmitter = new MyEmitter();myEmitter.on('event', () =&gt; &#123; console.log('an event occurred!');&#125;); 你不能直接在构造函数里执行 this.emit(‘event’)，因为这样的话后面的回调就永远无法执行。把 this.emit(‘event’) 放在 process.nextTick() 里，后面的回调就可以执行，这才是我们预期的行为： 1234567891011121314151617const EventEmitter = require('events');const util = require('util');function MyEmitter() &#123; EventEmitter.call(this); // use nextTick to emit the event once a handler is assigned process.nextTick(() =&gt; &#123; this.emit('event'); &#125;);&#125;util.inherits(MyEmitter, EventEmitter);const myEmitter = new MyEmitter();myEmitter.on('event', () =&gt; &#123; console.log('an event occurred!');&#125;);]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Node</tag>
        <tag>EventLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS垃圾回收机制]]></title>
    <url>%2Fposts%2F20229%2F</url>
    <content type="text"><![CDATA[一直以来我对JS垃圾回收机制的了解仅仅停留在两个词儿上：标记清除和引用计数。除此之外我就啥不知道了。最近空下来阅读了不少相关文章，算是对JS的垃圾回收机制有了点粗浅的认识。这篇博客算是一个笔记，也是一个总结。而我阅读的文章也会在最后的“资源”一节列出，想更加深入了解JS垃圾回收机制的小伙伴可以点击查看。 什么是垃圾要想理解JS的垃圾回收机制，首先得确定什么才是所谓的要被回收的垃圾。一般情况下，没有被引用的对象就是垃圾，是需要被清除的。下面是我总结的几大类型。 全局变量所有全局的变量都不是垃圾，因为浏览器会认为你在任何情况下都有可能使用到全局变量。例如下面这种情况： 12345var str = "hello world";// 此处省略若干代码console.log(str); 在顶部定义了一个全局变量str，你是完全有可能在 n 行代码以后打印这个变量的。 局部变量通常情况下，局部作用域变量在函数执行完毕后就是垃圾，再也用不到了： 1234567function fn() &#123; var str = "hello world"; console.log(str);&#125;fn();fn(); 当开始执行fn时，才产生 str ，它的作用域就在 fn 中，fn 执行结束后，str 就是垃圾，会被销毁。你可能会说，我完全有可能调用两次 fn 啊，但这里要注意的一点是，当你再次执行 fn 时，产生的是一个全新的 str ，和刚才的 str 完全没关系。 单引用一个单引用对象，没有引用就是垃圾： 12345var user = &#123; name: "John"&#125;;user = null; 我在全局作用域下定义了变量 user ，指向一个对象，然而却在最后把变量 user 设置为 null。此时就没有谁在引用 {name: “John”} 这个对象了，所以它是垃圾，会被销毁。 多引用如果一个对象有两个及以上的引用，它不一定会被回收： 1234567var user = &#123; name: "John"&#125;;var admin = user;user = null; 即使我们删掉了其中一个引用，但 admin 仍然还引用着 object ，所以此 object 还不会被回收。 环引用还记得文章开头说的下面这段话吗？ 一般情况下，没有被引用的对象就是垃圾，是需要被清除的。 环引用就是个例外，当几个对象相互引用，但没有被其它任何人引用时，它们仍然是垃圾，需要被回收，我们考虑下面代码： 123456789101112131415function marry(man, woman) &#123; woman.husband = man; man.wife = woman; return &#123; father: man, mother: woman &#125;&#125;var family = marry(&#123; name: "John"&#125;, &#123; name: "Ann"&#125;); 上述代码我们创建了一个家庭（family）对象，其中包含一个男人（man）对象和一个女人（woman）对象，并让女人的丈夫（husband）设为男人，男人的妻子（wife）设为女人。它们之间的关系可以用下图表示： 接着我们执行下面操作： 12delete family.father;delete family.mother.husband; 此刻删掉家庭对丈夫的引用，以及妻子对丈夫的引用，此时不再有任何人引用丈夫，所以此时丈夫是垃圾，需要被回收： 让我们回到丈夫还没有被家庭和妻子去除引用的时刻。然后执行下面代码： 1family = null; 这个时候，我们直接删掉了全局（外界）对家庭这个对象的引用，则家庭和丈夫以及妻子就都“死掉”了，需要被回收。你可能会说，它们之间不是存在相互引用关系吗？但此刻它们已经不被外界所引用，所以它们会被回收。 如何实现垃圾回收分析完什么是所谓的垃圾之后，我们就可以开始讨论如何实现垃圾回收了。也就是文章开头提到的「标记清除」和「引用计数」。 标记清除简单来理解，标记清除机制会从全局作用域开始，把所有它遇到的变量都标记一遍，如果这些被标记的变量还引用了其他变量，就再标记，一直标记到再也没有新的对象为止，这个标记过程就结束了。标记过程结束后就开始进行清除过程，把所有刚才没有被标记过的对象都删掉。这就是标记清除算法： 听起来这种实现很美好不是吗？但是此方法有个缺点很伤，那就是在变量对象多了以后，造成遍历很慢的后果。而且我们会不定时对这些变量都要再标记一遍，然而我们知道JS是单线程的，标记期间JS代码的执行会被中断，而标记的时间又很久，就造成不好的影响，这就是它的缺点。 所以针对这个缺点，我们会对标记清除做一些改进： 分代收集（Generational collection）类比我们手机网络的2G，3G和4G，这里的G就是 Generational 的意思，而我们的对象可以大致分为两种： 新一代（e.g. 一个函数中的临时变量） 老一代（e.g. window 对象） 不同代的回收策略是不一样的，一般老一代的对象停留时间会很久，而这种停留时间越久的对象，后面用到它的时间也可能越久（这只是一种推测，不一定对，仅仅是一种策略）。所以可能在第一轮标记后，会隔一段时间才会去再看它，比如3s后。 而新一代的对象，比如一个函数中的临时变量，函数执行完就可回收，不用从头开始遍历，这样的临时对象就会被马上标记然后立即马上删除，这样的对象就有可能隔1毫秒就看它一次，没被标记就删除了它。 增量收集（Incremental collection）举个例子，假如此刻有 10000 个需要遍历的对象，我不一次性遍历完，而是先遍历1000个，然后执行JS，再遍历1000个，再执行JS… 这样遍历10次就能遍历完，而且JS也不会有明显卡顿。 空闲收集（Idle-time collection）这个优化即字面意思，由于JS不是一直在执行的，所以我等到JS执行完后空闲下来再开始遍历。 引用计数每次对象被引用的时候就+1，再被引用时就再+1，有人不引用它时就-1，再不引用就又-1，当这个对象被减到0时就该被垃圾回收了。 此算法的缺点也有不少，但被大家所熟知的一个缺点就是循环引用无法被回收。在早期的IE版本里（ie4-ie6），对宿主对象（也就是 Document 对象）采用是引用计数的垃圾回收机制，一旦你在JS中没有正确使用闭包，就会导致内存泄漏，这也就是此算法的一个缺陷。循环引用会导致没法回收，这个循环引用只限定于有宿主对象参与的循环引用，而js对象之间即使形成循环引用，也不会产生内存泄漏，因为对js对象的回收算法不是计数的方式。示例如下： 1234567891011121314151617181920212223function closure()&#123; var oDiv = document.getElementById('oDiv');//oDiv用完之后一直驻留在内存中 oDiv.onclick = function () &#123; alert(oDiv.innerHTML);//这里用oDiv导致内存泄露 &#125;;&#125;// 以上代码创建了一个作为 div 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。// 由于匿名函数保存了一个对closure()的活动对象的引用，因此就会导致无法减少div 的引用数。// 只要匿名函数存在，element 的引用数至少也是1，因此它所占用的内存就永远不会被回收closure();//最后应将oDiv解除引用来避免内存泄露function closure()&#123; var oDiv = document.getElementById('oDiv'); var test = oDiv.innerHTML; oDiv.onclick = function () &#123; alert(test); &#125;; oDiv = null;&#125;// 解决办法: 把 oDiv.innerHTML 的一个副本保存在一个变量中，// 从而消除闭包中该变量的循环引用,同时将 oDiv 变量设为null。 好了，有关JS的垃圾回收机制就写到这里，想要了解更多可以点击下面的资源链接~ 完。 资源 Garbage collection 几种垃圾回收算法 V8 之旅： 垃圾回收器]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue数据响应式的简单实现]]></title>
    <url>%2Fposts%2F44406%2F</url>
    <content type="text"><![CDATA[今天来实现一个简单的 Vue 数据响应式，最终达到两个基本效果： 当用户在 input 中输入内容时，文本节点会跟着改变 当直接更新 message 属性后，页面中 input 标签和文本节点的值会跟着改变 最终效果： 原理Vue 实现数据响应式的核心原理是：借助发布/订阅模式 + 数据劫持 。 创建 vue 实例时深度遍历 data 下所有属性，利用 Object.defineProperty 把属性转为 getter/setter。 Vue 实现了 发布订阅者模式，在模板编译过程中解析 Vue 指令，给组件中的属性添加上相应订阅者（Watcher），这样在数据变更后会触发相应属性的 setter ，通过消息订阅器（Dep）发消息给所有订阅者（Watcher），从而触发相应组件的更新。 文件结构12345678.├── Compiler.js # 指令解析器├── Dep.js # 消息订阅器├── Observer.js # 观察者├── Vue.js # Vue的简单实现├── Watcher.js # 订阅者├── index.html└── main.js # 入口文件 具体代码index.html包含一个 input 标签和文本节点。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="message"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;script src="dist/main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Dep.js 消息订阅器发布订阅者模式的简单实现。包含核心方法 listen 以及 notify ，listen 负责给属性添加订阅者，notify 负责在属性发生变化时通知所有该属性的订阅者。 123456789101112131415161718192021class Dep &#123; constructor() &#123; console.log("【Dep】实例化了一个消息订阅器") // 订阅者数组 this.list = []; &#125; listen(sub) &#123; // 谁要订阅我，就调用listen，把自己添加进订阅者数组中去 this.list.push(sub); &#125; notify() &#123; // 当属性发生变化后，会在 setter 中调用此方法， // 消息订阅者通知订阅者数组中的所有人执行update操作 this.list.forEach(function (item, index) &#123; item.update(); &#125;); &#125;&#125;Dep.prototype.target = null;export default Dep; main.js 入口文件该文件中 new 一个 Vue 实例，并把该实例挂载到 window 对象上。 123456789import Vue from './Vue'var vm = new Vue(&#123; el: '#app', data: &#123; message: 'lance' &#125;&#125;)window.vm = vm; Observer.js 观察者深度遍历 data 下的所有属性，利用 Object.defineProperty 把属性转为 getter/setter ，并在此过程中给每个属性都绑定上发布/订阅模块。 1234567891011121314151617181920212223242526272829import Dep from './Dep';class Observer &#123; constructor(data) &#123; this.data = data; Object.keys(this.data).forEach(key =&gt; &#123; this._bind(data, key, data[key]); &#125;); &#125; _bind(data, key, val) &#123; var myDep = new Dep(); Object.defineProperty(data, key, &#123; // 新建vm实例时，给data添加属性就是第一次赋值，就调用了get get() &#123; // 第一次访问这个属性时 // 把订阅者(Watcher对象)注入发布/订阅模块 // 后续访问就不用再添加这个属性的订阅者了 if (Dep.target) myDep.listen(Dep.target); return val &#125;, set(newValue) &#123; if (newValue === val) return val = newValue; myDep.notify(); &#125; &#125;); &#125;&#125;export default Observer; Watcher.js 订阅者实现 update 方法，在属性发生变化时收到通知并执行它，从而更新组件数据。 1234567891011121314151617181920212223import Dep from './Dep';class Watcher &#123; // watcher需要当前组件中的： // 【节点】，【节点上相关的data属性】，【vm实例】 constructor(node, name, vm) &#123; this.node = node; this.name = name; this.vm = vm; // 将消息订阅器实例的当前订阅者设置为自己 Dep.target = this; this.update() Dep.target = null; &#125; update() &#123; // 得到数据变更通知后更新组件 if (this.node.nodeType === 1) &#123; this.node.value = this.vm[this.name]; &#125; this.node.nodeValue = this.vm[this.name]; &#125;&#125;export default Watcher; Compiler.js 指令解析器负责解析挂载到 Vue 上的 html 模板，找出 Vue 相关的指令。例如遇到 input 标签上有 v-model ，则给绑定的属性添加订阅者（Watcher），并为 input 标签添加 input 事件，在用户输入 value 后更改 data 中相应属性的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import Watcher from './Watcher';// 辨认 &#123;&#123;&#125;&#125; 的正则const REG = /\&#123;\&#123;(.*)\&#125;\&#125;/class Compiler &#123; constructor(el, vm) &#123; this.el = document.querySelector(el); this.vm = vm; this.frag = this._createFragment() this.el.appendChild(this.frag); &#125; _createFragment() &#123; var frag = document.createDocumentFragment(); var child; // 遍历挂载对象下的所有节点 while (child = this.el.firstChild) &#123; this._compile(child); frag.appendChild(child); &#125; return frag; &#125; _compile(node) &#123; var self = this; // 类型为元素 if (node.nodeType === 1) &#123; var attr = node.attributes; if (attr.hasOwnProperty('v-model')) &#123; var name = attr['v-model'].nodeValue; // 添加 input 监听事件 node.addEventListener('input', function(e) &#123; self.vm[name] = e.target.value; &#125;); node.value = this.vm[name]; // 给该属性添加订阅者 new Watcher(node, name, this.vm); &#125; &#125; // 元素为文本 if (node.nodeType === 3) &#123; // 目标：转化html中的 &#123;&#123;message&#125;&#125; 和 绑上watcher if (REG.test(node.nodeValue)) &#123; // 获取匹配到的字符串 var name = RegExp.$1; name = name.trim(); // 给元素添加订阅者，当vm实例的数据发生改变时, // 能收到通知并触发watcher中的update来更新元素上的值 // 传递： // node节点（因为要改变元素中的值） // name属性名 // 实例vm（为了调用vm下的属性） console.log("【Compiler】解析到文本元素，给它创建一个watcher实例") new Watcher(node, name, this.vm); &#125; &#125; &#125;&#125;export default Compiler; Vue.js调用 Compiler 和 Observer ，实现数据响应式。 12345678910111213141516171819202122232425262728293031import Observer from './Observer';import Compiler from './Compiler';class Vue &#123; constructor(options) &#123; this.$options = options; this.$el = this.$options.el; this._data = this.$options.data; Object.keys(this._data).forEach(key =&gt; &#123; this._proxy(key); &#125;); new Observer(this._data); new Compiler(this.$el, this); &#125; // 每次获取或赋值data中的属性时这样写代码： // Vue.$options.data.message 很长 // 我们的期望：Vue.message _proxy(key) &#123; var self = this; Object.defineProperty(this, key, &#123; get () &#123; return self._data[key]; &#125;, set (value) &#123; self._data[key] = value; &#125; &#125;); &#125;&#125;export default Vue 最后根目录下运行 webpack main.js 进行打包，浏览器运行 index.html 文件后便能看到文章开头的实现效果，完。]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS严格模式vs非严格模式]]></title>
    <url>%2Fposts%2F15966%2F</url>
    <content type="text"><![CDATA[前言以下为《JavaScript高级程序设计（第3版）》中有关 严格模式 的笔记。 介绍“严格模式” 是 ECMAScript5 最早引入的概念。可以在函数内部选择进行较为严格的全局或局部的错误条件检测。使用严格模式的好处是可以提早知道代码中存在的错误，及时捕获一些可能导致编程错误的 ECMAScript 行为。 如何使用在JS文件代码的顶部或者函数中输入下面字符串来开启严格模式： 12345678"use strict";orfunction fn() &#123; "use strict"; ...&#125; 严格模式 VS 非严格模式变量在严格模式下，不允许意外的创建全局变量： 12345// 未声明变量message = "Hello world";// 非严格模式: 创建全局变量// 严格模式: 抛出 ReferenceError 不能对变量调用 delete 操作符： 123456var color = "red";// 删除变量delete color;// 非严格模式: 静默失败// 严格模式: 抛出 ReferenceError 严格模式下对变量名也有限制。 不能使用 implements、interface、let、package、 private、protected、public、static 和 yield 作为变量名。这些都是保留字，将来的 ECMAScript 版本中可能会用到它们。在严格模式下，用以上标识符作为变量名会导致语法错误。 对象在严格模式下操作对象比在非严格模式下更容易导致错误。一般来说，非严格模式下会静默失败的 情形，在严格模式下就会抛出错误。因此，在开发中使用严格模式会加大早发现错误的可能性。 在下列情形下操作对象的属性会导致错误: 为只读属性赋值会抛出 TypeError; 对不可配置的(nonconfigurable)的属性使用 delete 操作符会抛出 TypeError; 为不可扩展的(nonextensible)的对象添加属性会抛出 TypeError。 使用对象的另一个限制与通过对象字面量声明对象有关。在使用对象字面量时，属性名必须唯一。 例如： 12345678// 重名属性var person = &#123; name: "Nicholas", name: "Greg"&#125;;// 非严格模式: 没有错误，以第二个属性为准// 严格模式: 抛出语法错误 函数函数的命名参数严格模式要求命名函数的参数必须唯一。例如： 1234567// 重名参数function sum(num, num) &#123; // do something&#125;// 非严格模式: 没有错误，只能访问第二个参数//严格模式: 抛出语法错误 在非严格模式下，这个函数声明不会抛出错误。通过参数名只能访问第二个参数，要访问第一个参数必须通过 arguments 对象。 argumentsarguments 对象的行为所不同。 在非严格模式下，修改命名参数的值也会反映到 arguments 对象中。 而严格模式下这两个值是完全独立的。 例如： 1234567// 修改命名参数的值function showValue(value) &#123; value = "Foo"; alert(value); //"Foo" alert(arguments[0]); // 非严格模式: "Foo" &lt;---&gt; 严格模式: "Hi"&#125;showValue("Hi"); 以上代码中，函数 showValue() 只有一个命名参数 value。调用这个函数时传入了一个参数”Hi”， 这个值赋给了 value。而在函数内部，value 被改为”Foo”。在非严格模式下，这个修改也会改变 arguments[0] 的值，但在严格模式下，arguments[0] 的值仍然是传入的值。 另一个变化是淘汰了 arguments.callee 和 arguments.caller。在非严格模式下，这两个属性一个引用函数本身，一个引用调用函数。而在严格模式下，访问哪个属性都会抛出 TypeError。 例如： 123456789101112// 访问 arguments.calleefunction factorial(num)&#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) &#125;&#125;var result = factorial(5);// 非严格模式: 没有问题// 严格模式: 抛出 TypeError 类似地，尝试读写函数的 caller 属性，也会导致抛出 TypeError。所以，对于上面的例子而言， 访问 factorial.caller 也会抛出错误。 函数名与变量类似，严格模式对函数名也做出了限制，不允许用 implements、interface、let、package、private、protected、public、static 和 yield 作为函数名。 函数声明的位置只能在脚本的顶级和在函数内部声明函数。也就是说，在 if 语句中声明函数会导致语法错误： 12345678//在 if 语句中声明函数if (true)&#123; function doSomething() &#123; //... &#125;&#125;// 非严格模式: 将函数提升到 if 语句外部// 严格模式: 抛出语法错误 eval()eval在包含上下文中不再创建变量或函数。例如： 1234567//使用 eval() 创建变量function doSomething() &#123; eval("var x=10"); alert(x);&#125;// 非严格模式: 弹出对话框显示 10// 严格模式: 调用 alert(x) 时会抛出 ReferenceError 如果是在非严格模式下，以上代码会在函数 doSomething() 中创建一个局部变量 x，然后 alert() 还会显示该变量的值。但在严格模式下，在 doSomething() 函数中调用 eval() 不会创建变量 x，因此 调用 alert() 会导致抛出 ReferenceError，因为 x 没有定义。 可以在 eval() 中声明变量和函数，但这些变量或函数只能在被求值的特殊作用域中有效，随后就 将被销毁。因此，以下代码可以运行，没有问题： 123"use strict";var result = eval("var x=10, y=11; x+y");alert(result); //21 这里在 eval() 中声明了变量 x 和 y，然后将它们加在一起，返回了它们的和。于是，result 变 量的值是 21，即 x 和 y 相加的结果。而在调用 alert() 时，尽管 x 和 y 已经不存在了，result 变量的值仍然是有效的。 eval 与 arguments严格模式已经明确禁止使用 eval 和 arguments 作为标识符，也不允许读写它们的值。例如： 12345// 把 eval 和 arguments 作为变量引用var eval = 10;var arguments = "Hello world!";// 非严格模式: 没问题，不出错// 严格模式: 抛出语法错误 在非严格模式下，可以重写 eval，也可以给 arguments 赋值。但在严格模式下，这样做会导致语 法错误。不能将它们用作标识符，意味着以下几种使用方式都会抛出语法错误： 使用var声明 赋予另一个值 尝试修改包含的值，如使用++ 用作函数名 用作命名的函数参数 在 try-catch 语句中用作例外名 抑制 this在非严格模式下使用函数的 apply() 或 call() 方法时，null 或 undefined 值会被转换为全局对象。而在严格模式下，函数的 this 值始终是指定的值，无论指定的是什么值。例如： 12345678//访问属性var color = "red";function displayColor() &#123; alert(this.color);&#125;displayColor.call(null);// 非严格模式: 访问全局属性// 严格模式: 抛出错误，因为 this 的值为 null 以上代码向 displayColor.call() 中传入了 null，如果在是非严格模式下，这意味着函数的 this 值是全局对象。结果就是弹出对话框显示”red”。而在严格模式下，这个函数的 this 的值是 null，因 此在访问 null 的属性时就会抛出错误。 其他变化with抛弃了 with 语句。非严格模式下的 with 语句能够改变解析标识符的路径，但在严格模式下，with 被简化掉了。因此，在严格模式下使用 with 会导致语法错误。例如： 123456//with 的语句用法with(location) &#123; alert(href);&#125;// 非严格模式: 允许// 严格模式: 抛出语法错误 八进制字面量严格模式也去掉了 JavaScript 中的八进制字面量。以 0 开头的八进制字面量过去经常会导致很多错 误。在严格模式下，八进制字面量已经成为无效的语法了。例如： 1234//使用八进制字面量var value = 010;// 非严格模式: 值为 8// 严格模式: 抛出语法错误 ECMAScript5 也修改了严格模式下 parseInt() 的行为。如今，八进制字面量在严格模式下会被当作以 0 开头的十进制字面量。例如： 1234//使用 parseInt() 解析八进制字面量var value = parseInt("010");// 非严格模式: 值为 8// 严格模式: 值为 10]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue+Koa实现cookie传输]]></title>
    <url>%2Fposts%2F26486%2F</url>
    <content type="text"><![CDATA[后端登录接口设置 cookie： 1234567891011121314router.post('/login', async ctx =&gt; &#123; ... let user = &#123; username: 'Lance', age: 20, ... &#125; ctx.cookies.set('username', user.username), &#123; // httpOnly：表示当前设置的cookie是否允许客户端进行操作（js） // 默认true，表示这个cookie能用于http协议的数据传输，但不允许js操作和篡改 httpOnly: false, &#125;); ...&#125;); 读取浏览器自动带上的cookie： 123456router.post(&apos;/like&apos;, async ctx =&gt; &#123; ... // 从cookie中读取 username let username = ctx.cookies.get(&apos;username&apos;); ...&#125;); 文档：Koa - response 前端123456789101112131415161718created() &#123; // 从cookie中获取用户信息cookie // 如果有cookie if (document.cookie) &#123; // cookie = "uid=1; username=admin;" =&gt; ['uid=1', 'username=admin'] let arr1 = document.cookie.split("; "); let cookiesArr = arr1.map(item =&gt; &#123; // item = "uid=1" =&gt; ['uid', 1] let arr2 = item.split("="); return &#123; [arr2[0]]: arr2[1] &#125; &#125;); // &#123;uid: "6", username: "YWRtaW4"&#125; let cookie = Object.assign(&#123;&#125;, ...cookiesArr); ... &#125;&#125;, 后端cookie的加密在 app.js 中添加密钥： 123const app = new Koa();// 密钥app.keys = ['sw_lance']; 然后在 routers/main.js 路由中的cookie设置中增加一个字段： 1234// 设置cookiectx.cookies.set('username', user.username, &#123; signed: true, // 使用加密方式处理&#125;); 这样就能加密了，但在前端chrome下查看cookie会发现，虽然有了加密cookie，但明文的cookie仍然在： 后端session加密首先仍然要在 app.js 中添加密钥： 1234const app = new Koa();// 密钥app.keys = ['sw_lance'];npm i koa-session 在 app.js 中引入： 123456789101112131415const session = require("koa-session")const app = new Koa();// 密钥app.keys = ['sw_lance'];const CONFIG = &#123; key: 'koa:sess', maxAge: 86400000, autoCommit: true, overwrite: true, httpOnly: true, signed: true, rolling: false, renew: false,&#125;;app.use(Session(CONFIG, app)); 在 routers/main.js 的 login API中种下cookie和session： 1234567891011router.post('/login', async ctx =&gt; &#123; ... // uid用下面的session存，username没那么重要，可以用cookie ctx.cookies.set('username', new Buffer(user.get('username')).toString('base64'), &#123; httpOnly: false, signed: true, // maxAge: 10000, &#125;); // uid用session存 ctx.session.uid = user.get('id');&#125;); 在 routers/main.js 的 like API中获取session： 123router.post('/like', async ctx =&gt; &#123; let uid = ctx.session.uid;&#125;);]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>koa</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios异步请求跨域解决方案]]></title>
    <url>%2Fposts%2F15391%2F</url>
    <content type="text"><![CDATA[场景 后端 127.0.0.1（默认80）；前端 127.0.0.1:8081 在 vue 开发过程中使用 axios 发起 POST 请求： 123456axios(&#123; method: 'GET', url: 'http://127.0.0.1'&#125;).then(data =&gt; &#123;&#125;); 会报跨域错误： 原因是浏览器同源策略，只有 同协议、同域名、同端口 三同的地址才能互相通过 AJAX 的方式请求。而上面情形虽然协议（http）和域名（127.0.0.1）都相同，但端口不同（80 和 8081），所以无法正常请求。 解决方案方案一服务端添加响应头，以 Koa 为例，在 app.js 中添加响应头： 1234app.use(async (ctx, next) =&gt; &#123; ctx.set("Access-Control-Allow-Origin", "*"); await next();&#125;); 这样设置会允许任何来源（*）的跨域。 但往往后端的某些接口是需要身份验证的，比如用户对文章、商品之类的进行评论或点赞，就需要用户登录才能操作。这种情况下就需要使用到 cookie 或者 session ，所以还得设置 Access-Control-Allow-Credentials 为 true ，表示在 CORS 请求中允许客户端发送 cookie 。然而一旦这样设置，Access-Control-Allow-Origin 就不能再是通配符 * ，必须指定具体的域，所以服务端最终的 header 设置为： 12345app.use(async (ctx, next) =&gt; &#123; ctx.set("Access-Control-Allow-Origin", "http://127.0.0.1:8081"); ctx.set("Access-Control-Allow-Credentials", true); await next();&#125;); 后端这样设置后，前端就能够实现跨域请求了。 方案二如果服务端不加 ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); 这一段。可以在 @vue-cli 中 配置代理 。也就是 前端设置代理 的解决方案。 原理利用后端不存在跨域问题，而让vue服务器代为获取数据。因为启动vue项目本质上也是用 node 启了个服务器（127.0.0.1:8080），配置了代理后，就不再是浏览器直接请求我们在 axios 中配置的 http://127.0.0.1/（默认80端口） ，而是用vue启动的这个服务器去请求 http://127.0.0.1/ 这个接口，由于后端相互之前请求不存在跨域问题，所以能获取数据，获取后给到前端。 在前端项目根目录下新建 vue.config.js 文件： 1234567891011121314module.exports = &#123; devServer: &#123; proxy: &#123; // 前端 axios 发这样的请求：http://127.0.0.1:8081/api/ (8081是启动vue项目时的端口)，会被此处捕获，然后代为请求真正的服务器API地址 `http://127.0.0.1` '/api': &#123; target: 'http://127.0.0.1', // 此处是服务端API接口，不写端口默认80 changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125; &#125;, &#125; &#125;&#125; 前端发送 POST 跨域请求上面也提到了，前端有时候往往不止需要发送 GET 请求，POST 请求也是常有的事儿。所以还需要对 Axios 进行如下配置： vue 项目下的 main.js 中全局配置 axios 123456import axios from 'axios';axios.defaults.baseURL = 'http://127.0.0.1';axios.defaults.withCredentials = true; // 让 ajax 携带 cookieaxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; // 设置post请求的头部格式Vue.prototype.$ajax = axios 由于需要把请求时的数据序列化为url的形式，所以要下载 qs 包 1npm i qs 在具体页面中发送 POST 请求 123456789101112import qs from 'qs'let loginInfo = &#123; username: '', password: '',&#125;,this.$ajax(&#123;(&#123; method: 'post', url: 'http://127.0.0.1/login', data: qs.stringify(login_info),&#125;)]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CORS详解（转载）]]></title>
    <url>%2Fposts%2F52542%2F</url>
    <content type="text"><![CDATA[转载文章博客源：CORS详解 关于CORS说到CORS，就不得不先了解跨站HTTP请求（Cross-site HTTP request）。 跨域HTTP请求是指发起请求的资源所在域不同于该请求所指向资源所在的域的HTTP请求。 正如大家所知，出于安全考虑，浏览器会限制脚本中发起的跨站请求。使用XMLHttpRequest发起HTTP请求必须遵守同源策略。 具体而言，Web 应用程序能且只能使用 XMLHttpRequest 对象向其加载的源域名发起 HTTP 请求，而不能向任何其它域名发起请求。 由于Web应用技术越来越丰富，我们非常渴望在不丢失安全的前提下，能够实现跨站请求。特别是现在的Web程序结构，一般是HTML+REST API。在之前的实现中，我们一般采用jsonp来发起跨站请求，这其实是利用了html标签的特点。 W3C的Web应用工作组推荐了一种新的机制，即跨域资源共享（Cross-Origin Resource Sharing），也就是当前我们提到的CORS。 CORS的核心，就是让服务器来确定是否允许跨域访问。 1、典型场景1.1、简单请求什么是简单请求？全部满足以下条件的请求可以称之为简单请求： 只使用GET、HEAD或者POST请求方法。如果是POST，则数据类型（Content-Type）只能是application/x-www-form-urlencodeed、multipart/form-data、text/plain中的一种。 没有使用自定义的请求头（如x-token） 按照这个规则，那我们的能实现跨域请求的情况如下： Server代码： 12345678910111213'use strict';var http = require('http');var server = http.createServer((req, res) =&gt; &#123; //之后设置了Access-Control-Allow-Origin，才会允许跨域 res.setHeader('Access-Control-Allow-Origin', '*'); res.write('abc'); res.end();&#125;);server.listen(10000, () =&gt; &#123; console.log('started.');&#125;); Client代码： 1234567891011121314151617181920212223242526var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readyState === XMLHttpRequest.DONE)&#123; console.log('Result：', xhr.responseText); &#125;&#125;//场景一：GET请求，不需要Header，允许跨域xhr.open('GET', 'http://localhost:10000/', true);xhr.send();//场景二： POST请求，需要设置为指定Header（不设置content-type也可），允许跨域xhr.open('POST', 'http://localhost:10000/', true);//此处value必须是text/plain或者application/x-www-form-urlencoded或者multipart/form-data。//此处也可以不设置xhr.setRequestHeader('Content-Type', 'text/plain');xhr.send();//场景三：DELETE请求（不允许跨域）xhr.open('DELETE', 'http://localhost:10000/', true);xhr.send();//场景四：POST请求，有自定义Header（不允许跨域）xhr.open('POST', 'http://localhost:10000/', true);xhr.setRequestHeader('x-token', 'a');xhr.send(); 1.2、预请求不同于简单请求，预请求要求必须先发送一个OPTIONS请求给站点，来查明该站点是否允许跨域请求，这样做的原因是为了避免跨站请求可能对目的站点的数据造成的损坏。 如果请求满足以下任一条件，则会产生预请求： 请求以GET、HEAD、POST之外的方法发起。或者，使用POST，但数据类型为application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。（注：之前的版本只有text/plain可以不用发起预请求）。 使用了自定义请求头。 按照如上规则，我们来列举几个应用场景： Server端代码： 123456789101112131415161718'use strict';var http = require('http');var server = http.createServer((req, res) =&gt; &#123; //之后设置了Access-Control-Allow-Origin，才会允许跨域 res.setHeader('Access-Control-Allow-Origin', '*'); res.setHeader('Access-Control-Allow-Methods', 'POST, DELETE, GET'); res.setHeader('Access-Control-Allow-Headers', 'x-token'); //设置预请求缓存1天，1天内再次请求，可以跳过预请求 //此功能需要客户端缓存支持，如果客户端禁用缓存，那么每次都会预请求 res.setHeader('Access-Control-Max-Age', 60 * 60 * 24); res.write('abc'); res.end();&#125;);server.listen(10000, () =&gt; &#123; console.log('started.');&#125;); Client端代码： 123456789101112131415161718192021222324var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readyState === XMLHttpRequest.DONE)&#123; console.log('Result：', xhr.responseText); &#125;&#125;//场景一：DELETE请求，发送OPTIONS，匹配，允许跨域xhr.open('DELETE', 'http://localhost:10000/', true);xhr.send();//场景二：PUT请求，发送OPTIONS，不匹配，不允许跨域xhr.open('PUT', 'http://localhost:10000/', true);xhr.send();//场景三：DELETE请求匹配，使用自定义Header不匹配，不允许跨域xhr.open('DELETE', 'http://localhost:10000/', true);xhr.setRequestHeader('x-token1', 'aa');xhr.send();//场景四：POST请求，匹配的自定义Header，允许跨域xhr.open('POST', 'http://localhost:10000/', true);xhr.setRequestHeader('x-token', 'a');xhr.send(); 1.3、带凭证的请求一般来说，对于跨站请求，浏览器是不会发送凭证（HTTP Cookies和验证信息）的。如果要发送带凭证的信息，只需要给XMLHttpRequest设置一个特殊的属性withCredentials = true，通过这种方式，浏览器就允许发送凭证信息。 带凭证的请求可能是简单请求，也可以是会有预请求。是否允许跨域，会先判断简单请求和预请求的规则，然后还会带上带凭证的请求自己的规则。 在带凭证的请求中，后端的响应必须包含HeaderAccess-Control-Allow-Credentials=true，同时Header Access-Control-Allow-Origin，不能再使用*号这种匹配符。 具体示例如下： 服务端代码： 123456789101112131415161718'use strict';var http = require('http');var server = http.createServer((req, res) =&gt; &#123; //要处理带凭证的请求，此Header不能使用*。 res.setHeader('Access-Control-Allow-Origin', 'http://10.16.85.170:8000'); res.setHeader('Access-Control-Allow-Methods', 'POST, DELETE, GET'); res.setHeader('Access-Control-Allow-Headers', 'x-token'); res.setHeader('Access-Control-Max-Age', 60 * 60 * 24); //只有设置了该Header，才允许带凭证的请求。 res.setHeader('Access-Control-Allow-Credentials', true); res.write('abc'); res.end();&#125;);server.listen(10000, () =&gt; &#123; console.log('started.');&#125;); 客户端代码： 1234567891011var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readyState === XMLHttpRequest.DONE)&#123; console.log('Result：', xhr.responseText); &#125;&#125;//优先满足预请求，然后满足凭证请求，允许跨域。xhr.open('POST', 'http://localhost:10000/', true);xhr.withCredentials = true;xhr.setRequestHeader('x-token', 'a');xhr.send(); 2、HTTP响应头2.1、 后端HTTP响应头此处列举后端有关CORS的响应头： Access-Control-Allow-Origin： | 允许的域名，只能有一个值。比如“”或“abc.com”，”a.com,b.com”这种不允许 Access-Control-Expose-Headers: 允许的白名单Header，多个用逗号隔开 Access-Control-Max-Age: 预请求缓存时间，单位秒，禁用缓存时无效哦！ Access-Control-Allow-Credentials: true | false 是否允许带凭证的请求，如果为true，则Origin只能是具体的值 Access-Control-Allow-Methods: 允许的请求类型，多个用逗号隔开 Access-Control-Allow-Headers: 在实际请求中，允许的自定义header，多个用逗号隔开 2.2、 浏览器发出跨域请求的响应头此处列举出浏览器在发送跨域请求时，会带上的响应头： Origin: 告诉服务器，请求来自哪里，仅仅是服务器名，不包含路径。 Access-Control-Request-Method: 预请求时，告诉服务器实际的请求方式 Access-Control-Request-Headers: 预请求时，告诉服务器，实际请求所携带的自定义Header 3、参考资料 MDN HTTP access control (CORS) MDN HTTP访问控制(CORS)]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>转载</tag>
        <tag>cors</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsonp解决跨域问题的原理]]></title>
    <url>%2Fposts%2F39860%2F</url>
    <content type="text"><![CDATA[介绍 Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。 ———— 菜鸟教程-jsonp 原理script标签的 src 不受同源策略影响，允许跨域。但需要借助服务端的配合。 示例 前端 index.html 1234567891011121314151617181920212223242526&lt;body&gt; &lt;h1&gt;天气查询&lt;/h1&gt; &lt;input type="text" id="city" placeholder="请输入城市名称"&gt; &lt;input type="button" id="btn" value="查询"&gt; &lt;script&gt; window.onload = function() &#123; // 创建方法用来获取跨域数据（名称随意） window["foo"] = function(data) &#123; // 打印获取的数据 console.log(data); &#125; const btn = document.querySelector("#btn"); btn.onclick = function() &#123; // 获取用户输入城市名 const = city = document.querySelector("#city").value; // 动态创建script标签 const script = document.createElement("script"); // 把回调函数foo的名称 以及 城市名 传递给后端 script.src = `http://127.0.0.1:8084/weather.php?callback=foo&amp;city=$&#123;city&#125;`; const body = document.querySelector("body"); body.appendChild(script); &#125; &#125; &lt;/script&gt;&lt;/body&gt; 后端 weather.php 1234567891011&lt;?php // 获取前端回调函数名和城市名 $cb = $_GET["callback"]; $city = $_GET["city"]; if ($city == "shanghai") &#123; // 调用前端已经定义的函数，把数据当做参数传递给 foo echo $cb."('上海晴，无风')"; &#125; else &#123; echo $cb."('没有查询到你所在城市天气')"; &#125;?&gt; 这样一来当前端请求 http://127.0.0.1:8084/weather.php?callback=foo&amp;city=${city} 后，后端返回的内容就应该类似这种格式： 1foo('上海晴，无风'); 本质就是在调用前端已经定义好的 foo 方法，这样就能够获取到后端返回给我们的数据了。 注意事项由于 jsonp 解决跨域问题本质上是后端返回一个方法调用。所以不是任何接口都支持 jsonp 来获取到数据的，一旦接口不支持，返回的不是方法调用格式（foo(data)）而是 json 格式（{“msg”: “success”, “data”: {…}}）的话，就说明我们无法通过 jsonp 获取到数据。 第三方接口跨域数据获取一旦第三方接口返回的是 json 格式的字符串，我们就无法通过 ajax 或者 jsonp 的方式获取跨域数据。这种情况下我们只能通过自己的服务器当做中转站帮我们前端获取三方接口数据了，因为服务端之间是不存在跨域问题的，所以出现这种情况后，你可以让公司的后端帮帮忙，写一个接口去获取三方接口数据，并暴露一个接口让你能够获取到数据~]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript坑之一map参数传递（转载）]]></title>
    <url>%2Fposts%2F8767%2F</url>
    <content type="text"><![CDATA[转载文章博客源：JavaScript坑之一map参数传递 map()方法定义在JavaScript的Array中，他是一个高阶函数。我们向这个函数传入我们自己定义的回调函数（callback），然后map会对数组当中每一个元素去调用回调函数。 通常，我们只在回调函数里用一个参数，因为大多数回调函数只需要一个参数，或者一个必须参数和多个可选参数。这样的习惯会有时导致很诡异的行为。 1['1', '2', '3'].map(parseInt); //[1, NaN, NaN] 我们所希望看到的结果其实是[1, 2, 3]，原因是parseInt一般我们用的时候都是习惯性用一个参数，但他可以接收两个参数，第二个参数用来做基数。而map向回调函数传参有三个，数组中的元素，元素的下标和这个数组。第三个参数被parseInt忽略掉，前两个参数被接收。parseInt(‘0’, 0); //基数为0，或者undefined，用10进制 parseInt(‘1’, 1); //没有1进制，返回NaN parseInt(‘2’, 2); //二进制不能出现2，返回NaN 这里关键是要知道回调函数接收的参数有三个，那么如何解决上面的问题呢？ 1234function myParseInt(intString)&#123; return parseInt(intString, 10);&#125;['1', '2'].map(myParseInt); 或者，用更简单的写法 1['1', '2'].map(str =&gt; parseInt(str)); 或者，最简单的写法 1['1', '2'].map(Number)]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transform3D转换（二）]]></title>
    <url>%2Fposts%2F14243%2F</url>
    <content type="text"><![CDATA[在我当初了解到 transform 后的一段时间，其实是不知道它能够让元素实现3d转换的。直到有一天在逛 codepen 时，我发现了下面这个demo： See the Pen CSS3 Transforms 3D Perspective Carousel by JingW (@JingW) on CodePen. p.s. 原作者地址在这儿：https://codepen.io/Hubson/pen/XmrEGX OS：我靠，还能这样玩儿？赶紧查查如何实现的。（点我重现查找过程） 然后就发现了张鑫旭老师的 这篇文章 。算是给我打开了新世界的大门~ 原来现在的CSS都这么强大了，要知道几年前我在学 .NET 时就接触过HTML和CSS，那个时候不还是满屏div，没啥特效的时代嘛。 扯远了，言归正传。首先来看下面这个图（copy上面文章来的~）： 这个图就是咱们3d变形所依赖的坐标系。要想理解这张图，需要一点空间想象力。我们人在看这个坐标系时，是从左下角的眼睛处从 +Z 往 -Z 里面看的。可以把这个眼睛简单的想象成你自己，由网格组成的正方形平面相当于你在屏幕上创建的一个正方形div元素。那么当你设置 transform: translate(200px, 0) 时，你的元素将会向 +X 方向前进，也就是平常在2d变换中的向右移动。现在应该理解了吧~ rotateX, rotateY, rotateZrotateXrotateX就是沿着 x 轴进行3d旋转。 在下面示例中，我们实现让一个元素沿着它的x轴旋转180°。为了让效果看起来更加明显，我把该元素分成了上下两个部分，并在中间留出了缝隙，以便当做X轴看待，当鼠标移入该元素后，它便“沿着” x 轴旋转180°： See the Pen transform3d-rotateX by JingW (@JingW) on CodePen. rotateY用和上面类似的方式，我们实现 rotateY 的3d旋转效果，让元素沿着 y 轴进行3d旋转： See the Pen transform3d-rotateY by JingW (@JingW) on CodePen. rotateZ还记得那根 z 轴嘛，当我们垂直于屏幕看向元素时，z 轴在我们眼里就是一个“点”。所以当我们使用 rotateZ 来旋转元素时，元素会沿着 z 轴进行旋转，就是下方元素中间的“点”： See the Pen transform3d-rotateZ by JingW (@JingW) on CodePen. perspective 透视这个属性英文直译过来就是 透视、视角的意思。 电脑显示屏是个2d平面，要想让元素在一个2d平面上有立体感（3d效果），就得利用这个 perspective 透视属性。perspective 可以让一个2d平面在转换过程中呈现出3d效果。 不知道大家有没有注意到上面有关 rotateY 下的demo，虽说是沿着元素 y 轴进行旋转，但一点3d立体效果都没有，要知道在现实生活中，如果一张卡片沿着它宽度一半儿的 y 轴进行旋转，肯定有近大远小的透视效果，即离我们近的一面越来越大，离我们远的一面越来越小。如果还没有明白，看了下面的示例就知道了（鼠标移入body就能触发旋转~）： See the Pen transform3d-perspective by JingW (@JingW) on CodePen. 这下是不是明显多啦？其实这都全靠了 perspective 透视，它允许我们为场景添加深度感，原理就是使 z 轴在靠近观察者的元素看起来更大，而更远的元素看起来更小。也就是上面提到的“近大远小”。 我们来看看下面这张图： 上图中蓝色圆圈表示三维空间中的元素，字母 d 表示透视的值，即观看者的眼睛和屏幕之间的距离。字母 Z 表示元素在 z 轴上的位置。元素在 z 轴上越远，相对于观察者的外观越小，它越接近，就看起来越大。这就是三维空间中透视的效果。 perspective VS perspective()perspective有两种写法，一种是直接写在要使用3d转换的父元素身上（如上一个demo）：12345678910111213/* 父容器 */.contaienr &#123; /* 将透视属性写在父容器 */ perspective: 1000px;&#125;/* 需要3d转换的子元素 */.box &#123; transition: transform 1s;&#125;/* 触发转换 */.container:hover box &#123; transform: rotateY(180deg);&#125; 在这种写法下，一旦“舞台（浏览器显示区域）”上有多个元素都进行了3d转换，可能效果就与你的预想不太一样，靠近“舞台”两边的元素会“歪着”进行旋转： See the Pen transform3d-perspective2 by JingW (@JingW) on CodePen. 这是为什么呢？答案是因为默认我们观察者的“眼睛”是处于“舞台”正中央的前方的（这个前方是以“舞台”的视角），所以靠近我们观察者左前方的（观察者视角）卡片，在沿着 x 轴做旋转时，就是“歪着”的；同理观察者右前方卡片也是如此。 那么如果你想让它们都与正中央的卡片一样效果的旋转呢？这就引出了第二种写法：perspective() 。该属性写在3d转换元素本身上，而不是在其父元素上了：12345678.box &#123; transition: transform 1s;&#125;.container:hover .box &#123; /* 1. 沿着x轴旋转180° */ /* 2. 给3d旋转元素本身添加 perspective 透视 */ transform: perspective(500px) rotateX(180deg);&#125; 效果如下： See the Pen transform3d-perspective3 by JingW (@JingW) on CodePen. perspective-origin语法：12perspective-origin: 50% 50%; /* 默认值，表示观察者在“舞台”正中央的上方 */perspective-origin: left center; /* 表示观察者在“舞台”最左边且垂直居中的上方 */ 该属性用于定义观察者观看三维空间时的位置所在。默认情况下为x轴50%、y轴50%。也就是“舞台（屏幕）”正中央的上方。 读者可以尝试用鼠标拖动下方demo中的按钮“camera”到“舞台”的各个位置，然后看看三张卡片的3d转换效果。当你在拖动“camera”改变它的位置时，也就等同于改变了 perspective-origin 的位置。例如当你把按钮“camera”拖动到左上角，就相当于设置了 perspective-origin: left top。 See the Pen transform3d-perspective-origin by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transform转换（一）]]></title>
    <url>%2Fposts%2F45420%2F</url>
    <content type="text"><![CDATA[介绍 Transform属性应用于元素的2D或3D转换。这个属性允许你将元素旋转，缩放，移动，倾斜等。 ———— 出自 菜鸟教程 这次我们讨论的都是2D转换，3D的后面我会单独出一篇~ scale 缩放这个属性用来放大或缩小元素的大小。语法示例如下：123456div &#123; transition: transform 1s; /* 给div的transform属性添加过渡效果 */&#125;div:hover &#123; transform: scale(1.5); /* 让元素放大为原始大小的1.5倍 */&#125; See the Pen transform scale by JingW (@JingW) on CodePen. translate 位移该属性用来让元素向上/向下/向左/向右进行位移。 示例：123456div &#123; transition: transform 1s;&#125;div:hover &#123; transform: translate(20px, 20px);&#125; See the Pen LvbqKb by JingW (@JingW) on CodePen. rotate 旋转该属性让元素能够顺时针或逆时针旋转指定的度数。 示例：123456div &#123; transition: transform 1s;&#125;div:hover &#123; transform: rotate(720deg); /* 元素顺时针旋转720度 */&#125; See the Pen transform rotate by JingW (@JingW) on CodePen. skew 倾斜该属性能够让元素基于x, y轴倾斜转换 示例：12345678div &#123; transition: transform 1s;&#125;div:hover &#123; transform: skew(45deg, 45deg); /* transform: skewX(25deg); transform: skewY(10deg); */&#125; See the Pen transform skew by JingW (@JingW) on CodePen. 注意： 如果仔细观察上面的示例，当鼠标移入box后，不但整个box进行了倾斜，里面的子元素和文本内容也会发生倾斜。如果不希望里面的内容发生变化，可以使用相反的skew值将其恢复： See the Pen transform skew2 by JingW (@JingW) on CodePen. transform-origin 变形原点该属性可以配合 transform 属性一起使用，它允许我们指定元素转换的位置原点。默认情况原点位于元素的中心。 例如刚刚上面在讲到 rotate 属性时，我们的旋转是以中心为原点的。但你在某些情况下可能并不想让元素围绕中心旋转，而是左上角旋转，就可以用到该属性。 语法示例：1234567div &#123; transform-origin: left top; transition: transform 1s;&#125;div:hover &#123; transform: rotate(720deg);&#125; See the Pen transform transform-origin by JingW (@JingW) on CodePen. 变换组合有时候我们可能想要一个元素既旋转又位移，那么我们就可以使用 transform 的简写语法： 123456div &#123; transition: transform 1s;&#125;div:hover &#123; transform: rotate(90deg) scale(1.5);&#125; See the Pen ZZBNmN by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于浏览器的CSS前缀]]></title>
    <url>%2Fposts%2F496%2F</url>
    <content type="text"><![CDATA[突然想起来的，先占个坑，有空再更…]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宏任务&微任务]]></title>
    <url>%2Fposts%2F20664%2F</url>
    <content type="text"><![CDATA[先Mark一下，抽空再写…1234567891011121314151617181920212223242526console.log('sync1');setTimeout(function () &#123; console.log('setTimeout1')&#125;, 0);var promise = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; console.log('setTimeoutPromise') &#125;, 0); console.log('promise'); resolve();&#125;);promise.then(() =&gt; &#123; console.log('pro_then'); setTimeout(() =&gt; &#123; console.log('pro_timeout'); &#125;, 0)&#125;)setTimeout(function () &#123; console.log('last_setTimeout')&#125;, 0);console.log('sync2');]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS中的连等赋值操作]]></title>
    <url>%2Fposts%2F24177%2F</url>
    <content type="text"><![CDATA[金三银四正是面试的好时候，有不少学员面试后在前端群里分享JS面试题，我正巧没事儿翻到一题做做看，发现答案与我自己的预期大相径庭，当时我就震惊了，在chrome控制台打印了下结果，还真是我错了。没错，就是下面这道连等赋值题： 12345var a = &#123; name: 'a'&#125;;a.x = a = &#123;&#125;; 问：此刻的 a.x 是多少。 当时我简单的分析了下，由于 a 赋值给了一个新对象，接着又把 a 赋值给了 a.x ，那理所当然 a.x 不就是 {} 嘛。然而答案却是出乎意料的 undefined … 想了半天还是感觉理解不了，我就google了下，发现了这篇文章：千万不要在JS中使用连等赋值操作 。看完后理解了。 这道题的核心在于知道JS是如何执行 a.x = a = {} 这行代码的，分两步：一是确定 a 是什么，二是代码执行顺序是从右向左的。 我们一步步看，第一行代码 var a = {name: &#39;a&#39;} ，这句话应该都没什么疑问，我们把 a 的地址假设为 AAA 。 然后就是 a.x = a = {} ，按照步骤来，先确定 a 是什么，在还没有赋值操作前，a.x 的 a 指向 AAA，中间的 a 也是指向 AAA ，新创建的对象 {} 地址假设为 BBB 。然后代码从右向左执行，a = {} ，所以中间的 a 指向了新地址 BBB ；接着 a.x = a ，此刻的 a.x 的 a 仍然是 AAA（因为在赋值前就已经确定了 a 的地址），赋值后原地址 AAA 的对象就变成了 {name: ‘a’, x: {}} 这里的x指向的就是新对象地址 BBB 。 上述操作结束后再来问 a.x 的值是什么，此刻的 a 已经在 a = {} 这一步赋值操作后指向了新的地址 BBB ，所以此刻的 a 是空对象 {} ，而空对象是没有 x 属性的，所以输出 undefined 。 是不是有点绕？这种题出出来真是挺看JS功底的，它考察了你对JS编译原理的理解与掌握情况。借用上面博客里博主的一句话作为收尾：尽量不要使用JS的连续赋值操作，除非真的了解它的内部机制及可能会产生的后果。]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vuex的基本使用]]></title>
    <url>%2Fposts%2F19311%2F</url>
    <content type="text"><![CDATA[什么是 VuexVuex 是一个专为 Vue.js 应用程序开发的状态管理工具。 准备工作首先使用 vue-cli 脚手架工具新建一个项目： 1vue create vuex-demo src文件夹下的目录结构： 1234567src├── App.vue├── assets│ └── logo.png├── components│ └── HelloWorld.vue└── main.js # 入口文件 安装 vuex命令行下执行： 1npm i vuex 然后在入口文件引入 vuex ： 12import Vuex from 'vuex'Vue.use(Vuex) 一个例子为了了解 vuex 到底做了什么事情、解决了哪些问题。我们先来实现一个简单的 demo ，有一个标签显示数字，两个按钮分别做数字的 +1 和 -1 操作。 我们先在 src/components/ 下的 Normal.vue 组件中使用纯 Vue 版本编写代码： Normal.vue 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id="normal"&gt; &lt;p&gt;&#123;&#123;count&#125;&#125; &lt;button @click="inc"&gt; + &lt;/button&gt; &lt;button @click="dec"&gt; - &lt;/button&gt; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; count: 0 &#125; &#125;, methods: &#123; inc() &#123; this.count++ &#125;, dec() &#123; this.count-- &#125; &#125;,&#125;&lt;/script&gt; 然后在 src/App.vue 中引入并使用该组件： 1234567891011121314&lt;template&gt; &lt;div id="app"&gt; &lt;Normal&gt;&lt;/Normal&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Normal from '@/components/Normal'export default &#123; components: &#123; Normal, &#125;&#125;&lt;/script&gt; 命令行执行 npm run serve 就能运行 App 了。 如上的代码的含义是：两个 button 标签绑定函数，当点击的时候分别调用 inc 和 dec 方法，接着会调用 vue 中的 methods 的对应的方法。然后会让 data 中的 count 属性值发生改变，改变后会把最新值渲染到视图中。 现在我们来看看使用 vuex 的方式来实现如上 demo ： src下新建 vuex/store.js 123456789101112131415import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)// 注意是new【Vuex.Store】实例而不是【Vuex】export const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; inc: state =&gt; state.count++, dec: state =&gt; state.count-- &#125;&#125;) main.js 中引入 1234567...import store from '@/vuex/store'...new Vue(&#123; render: h =&gt; h(App), store&#125;).$mount('#app') 在 src/components/ 下新建 SWVuex.vue 组件 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id="vuex"&gt; &lt;p&gt;&#123;&#123;count&#125;&#125; &lt;button @click="inc"&gt;+&lt;/button&gt; &lt;button @click="dec"&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; computed: &#123; count() &#123; return this.$store.state.count &#125; &#125;, methods: &#123; inc() &#123; this.$store.commit('inc') &#125;, dec() &#123; this.$store.commit('dec') &#125; &#125;, &#125;&lt;/script&gt; 在 App.vue 中使用 SWVuex 组件 1234567891011121314&lt;template&gt; &lt;div id="app"&gt; &lt;SWVuex&gt;&lt;/SWVuex&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import SWVuex from '@/components/SWVuex'export default &#123; components: &#123; SWVuex &#125;&#125;&lt;/script&gt; 两者比较 需要引用 vuex 。 methods 的方法不变，但是方法内的逻辑不在函数内进行，而是让 store 对象去处理。 count 数据不再是一个 data 函数返回的对象的属性了。而是通过 store 方法内的计算字段返回的。 回到 store 对象上来，store 对象是 Vuex.Store 的实例。在 store 内分为 state 对象和 mutations 对象，其中 state 存放的是状态，比如 count 属性就是它的状态值，而 mutations 则是一个会引发状态改变的所有方法。 什么是状态管理模式简单的理解就是统一管理和维护各个 vue 组件的可变化状态。 我们明白 vue 是单向数据流的，那么它的状态管理一般包含如下几部分： state：驱动应用的数据（一般指 data 中返回的数据） view：一般指模板，以声明的方式将 state 的数据映射到视图 actions：响应在 view 上的用户输入导致的状态变化 但是当我们的应用遇到多个组件共享状态时候，那么单向数据流可能不太满足我们的需求，比如： 组件的多层嵌套 多个视图依赖同一个状态 上面这些情况确实能在不使用 vuex 的情况下实现，但往往会导致写出无法维护的代码。因此我们可以把组件的共享状态提取出来、全局管理，因此 vuex 产生了。 Vuex 的优点最主要解决了组件之间共享同一状态的问题。可以把组件的共享状态提取出来，作为全局来管理。 什么情况下才推荐使用 Vuex大型单页应用！！！如果你的项目不够大，足够简单，最好不要使用 Vuex ，一个简单的 global event bus 就足够所需了。 State 对象状态的访问通过 computed 计算属性直接赋值12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div id="vuex"&gt; &lt;p&gt;通过 $store.state 方式获取：&#123;&#123;$store.state.count&#125;&#125;&lt;/p&gt; &lt;p&gt;通过 computed 计算属性赋值：&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;p&gt; &lt;button @click="inc"&gt;+&lt;/button&gt; &lt;button @click="dec"&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; computed: &#123; count() &#123; return this.$store.state.count &#125; &#125;, methods: &#123; inc() &#123; this.$store.commit('inc') &#125;, dec() &#123; this.$store.commit('dec') &#125; &#125;, &#125;&lt;/script&gt; 借助 mapState 辅助函数对象形式123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id="vuex"&gt; &lt;p&gt;通过 $store.state 方式获取：&#123;&#123;$store.state.count&#125;&#125;&lt;/p&gt; &lt;p&gt;通过 computed 计算属性赋值：&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;p&gt; &lt;button @click="inc"&gt;+&lt;/button&gt; &lt;button @click="dec"&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState&#125; from 'vuex' export default &#123; computed: mapState(&#123; count: state =&gt; state.count &#125;), methods: &#123; inc() &#123; this.$store.commit('inc') &#125;, dec() &#123; this.$store.commit('dec') &#125; &#125;, &#125;&lt;/script&gt; 数组形式12// 数组中的 count 必须和 store.js 中定义的常量 count 同名，因为这是直接访问 state 的 countcomputed: mapState(['count']) Getters 计算过滤操作有时候我们需要从 store 的 state 中派生出一些状态，比如在使用 store 中的 state 之前，我们会对 state 中的某些字段进行过滤——让 count 字段都进行加 10 这样的数据操作；但是如果有多个组件需要用到这个操作的话，那么我们就需要复制这个函数，或者抽取到一个共享函数内，然后多处导入这个函数，但是这上面两种方式都不是太好，因为我们现在有更好的方式来解决它。 Vuex 允许我们在 store 中定义 getters，getters 的返回值会根据它的依赖被缓存起来，且只有当他的依赖值发生改变了才会重新计算。 现在我们对 store.js 文件中的 count 进行一个计算属性的操作，在它每次输出之前，加上20。 如下代码有两个按钮，一个加5，一个减5，那么在加5或者减5之前，先加20，然后再进行加5或者5操作。代码如下： store.js 12345678910111213141516171819import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; inc: (state, num) =&gt; state.count += num, dec: (state, num) =&gt; state.count -= num &#125;, getters: &#123; myCount(state) &#123; return state.count + 20 &#125; &#125;&#125;) SWVuex.vue 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div id="vuex"&gt; &lt;p&gt;通过 $store.state 方式获取：&#123;&#123;$store.state.count&#125;&#125;&lt;/p&gt; &lt;p&gt;通过 computed 计算属性赋值：&#123;&#123;myCount&#125;&#125;&lt;/p&gt; &lt;p&gt; &lt;p&gt;使用 $store.commit('inc', 5) 方式调用&lt;/p&gt; &lt;!-- $store.commit('inc', 5) 第一个参数是方法名，第二个是参数 --&gt; &lt;button @click="$store.commit('inc', 5)"&gt;+&lt;/button&gt; &lt;button @click="$store.commit('dec', 5)"&gt;-&lt;/button&gt; &lt;/p&gt; &lt;div&gt; &lt;p&gt;使用mapMutations修改状态：&lt;/p&gt; &lt;p&gt; &lt;button @click="inc(10)"&gt;+&lt;/button&gt; &lt;button @click="dec(10)"&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState, mapGetters, mapMutations&#125; from 'vuex' export default &#123; computed: &#123; // mapState(['count']) 此处的 count 必须和 store.js // state 中的 count 同名，因为这是直接访问 state 的 count ...mapState(['count']), // mapGetters 辅助函数， // 可以将 store 中的 getter 映射到局部计算属性 myCount ...mapGetters(['myCount']) &#125;, methods: &#123; ...mapMutations(['inc', 'dec']) &#125;, &#125;&lt;/script&gt; Mutations 修改状态Mutations 是修改 vuex 中的 store 的唯一方法。每个 mutations 都有一个字符串的事件类型(type)和一个回调函数(handler)。这个回调函数就是我们进行更改的地方。它也会接受 state 作为第一个参数。 回顾上面的 store.js 中有关 mutations 的代码： 1234mutations: &#123; inc: (state, num) =&gt; state.count += num, dec: (state, num) =&gt; state.count -= num&#125;, 当我们点击页面上的按钮后会触发事件并执行方法，方法中又会调用 $store.commit(type, args) 来传入参数改变 state 数据。 Actions 异步修改状态Actions 和 Mutations 类似，但它用来异步修改 state 的状态。而 Mutations 则是同步修改 state 的状态。 我们在 store.js 中声明 actions，actions 可以调用 mutations 的方法的。代码如下： store.js 1234567891011// 增加两个 actions 方法actions: &#123; incAction(context) &#123; console.log(context) // 调用 mutations 中的 inc 方法，并传参数5 context.commit('inc', 5) &#125;, decAction(context) &#123; context.commit('dec', 5) &#125;&#125; 上方代码中的参数 context 指上下文，即 store 本身。 然后在 SWVuex.vue 中通过 this.$store.dispatch(action方法名, 参数) 的方式调用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div id="vuex"&gt; &lt;p&gt;通过 $store.state 方式获取：&#123;&#123;$store.state.count&#125;&#125;&lt;/p&gt; &lt;p&gt;通过 computed 计算属性赋值：&#123;&#123;myCount&#125;&#125;&lt;/p&gt; &lt;div&gt; &lt;p&gt;使用 $store.commit('inc', 5) 方式调用&lt;/p&gt; &lt;!-- $store.commit('inc', 5) 第一个参数是方法名，第二个是参数 --&gt; &lt;button @click="$store.commit('inc', 5)"&gt;+&lt;/button&gt; &lt;button @click="$store.commit('dec', 5)"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;使用mapMutations修改状态：&lt;/p&gt; &lt;p&gt; &lt;button @click="inc(10)"&gt;+&lt;/button&gt; &lt;button @click="dec(10)"&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;actions的异步操作&lt;/p&gt; &lt;button @click="incAction"&gt; + &lt;/button&gt; &lt;button @click="decAction"&gt; - &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState, mapGetters, mapMutations&#125; from 'vuex' export default &#123; computed: &#123; // mapState(['count']) 此处的 count 必须和 store.js // state 中的 count 同名，因为这是直接访问 state 的 count ...mapState(['count']), // mapGetters 辅助函数， // 可以将 store 中的 getter 映射到局部计算属性 myCount ...mapGetters(['myCount']) &#125;, methods: &#123; ...mapMutations(['inc', 'dec']), incAction() &#123; this.$store.dispatch('incAction') &#125;, decAction() &#123; this.$store.dispatch('decAction') &#125;, &#125;, &#125;&lt;/script&gt; 当然，除了使用 this.$store.dispatch() 的方式以外，还可以借助 mapActions 来简化代码： 1234567// 新加 mapActionsimport &#123;mapState, mapGetters, mapMutations, mapActions&#125; from 'vuex'...methods: &#123; ...mapMutations(['inc', 'dec']), ...mapActions(['incAction', 'decAction']) // +&#125;,]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底理解cookie-session-token(转载)]]></title>
    <url>%2Fposts%2F29493%2F</url>
    <content type="text"><![CDATA[发展史1、很久很久以前，Web 基本上就是文档的浏览而已， 既然是浏览，作为服务器， 不需要记录谁在某一段时间里都浏览了什么文档，每次请求都是一个新的HTTP协议， 就是请求加响应， 尤其是我不用记住是谁刚刚发了HTTP请求， 每个请求对我来说都是全新的。这段时间很嗨皮 2、但是随着交互式Web应用的兴起，像在线购物网站，需要登录的网站等等，马上就面临一个问题，那就是要管理会话，必须记住哪些人登录系统， 哪些人往自己的购物车中放商品， 也就是说我必须把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，所以想出的办法就是给大家发一个会话标识(session id), 说白了就是一个随机的字串，每个人收到的都不一样， 每次大家向我发起HTTP请求的时候，把这个字符串给一并捎过来， 这样我就能区分开谁是谁了 3、这样大家很嗨皮了，可是服务器就不嗨皮了，每个人只需要保存自己的session id，而服务器要保存所有人的session id ！ 如果访问服务器多了， 就得由成千上万，甚至几十万个。 这对服务器说是一个巨大的开销 ， 严重的限制了服务器扩展能力， 比如说我用两个机器组成了一个集群， 小F通过机器A登录了系统， 那session id会保存在机器A上， 假设小F的下一次请求被转发到机器B怎么办？ 机器B可没有小F的 session id啊。 有时候会采用一点小伎俩： session sticky ， 就是让小F的请求一直粘连在机器A上， 但是这也不管用， 要是机器A挂掉了， 还得转到机器B去。 那只好做session 的复制了， 把session id 在两个机器之间搬来搬去， 快累死了。 后来有个叫Memcached的支了招： 把session id 集中存储到一个地方， 所有的机器都来访问这个地方的数据， 这样一来，就不用复制了， 但是增加了单点失败的可能性， 要是那个负责session 的机器挂了， 所有人都得重新登录一遍， 估计得被人骂死。 也尝试把这个单点的机器也搞出集群，增加可靠性， 但不管如何， 这小小的session 对我来说是一个沉重的负担 4、于是有人就一直在思考， 我为什么要保存这可恶的session呢， 只让每个客户端去保存该多好？ 可是如果不保存这些session id , 怎么验证客户端发给我的session id 的确是我生成的呢？ 如果不去验证，我们都不知道他们是不是合法登录的用户， 那些不怀好意的家伙们就可以伪造session id , 为所欲为了。 嗯，对了，关键点就是验证 ！ 比如说， 小F已经登录了系统， 我给他发一个令牌(token)， 里边包含了小F的 user id， 下一次小F 再次通过Http 请求访问我的时候， 把这个token 通过Http header 带过来不就可以了。 不过这和session id没有本质区别啊， 任何人都可以可以伪造， 所以我得想点儿办法， 让别人伪造不了。 那就对数据做一个签名吧， 比如说我用HMAC-SHA256 算法，加上一个只有我才知道的密钥， 对数据做一个签名， 把这个签名和数据一起作为token ， 由于密钥别人不知道， 就无法伪造token了。 这个token 我不保存， 当小F把这个token 给我发过来的时候，我再用同样的HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名， 和token 中的签名做个比较， 如果相同， 我就知道小F已经登录过了，并且可以直接取到小F的user id , 如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者： 对不起，没有认证。 Token 中的数据是明文保存的（虽然我会用Base64做下编码， 但那不是加密）， 还是可以被别人看到的， 所以我不能在其中保存像密码这样的敏感信息。 当然， 如果一个人的token 被别人偷走了， 那我也没办法， 我也会认为小偷就是合法用户， 这其实和一个人的session id 被别人偷走是一样的。 这样一来， 我就不保存session id 了， 我只是生成token , 然后验证token ， 我用我的CPU计算时间获取了我的session 存储空间 ！ 解除了session id这个负担， 可以说是无事一身轻， 我的机器集群现在可以轻松地做水平扩展， 用户访问量增大， 直接加机器就行。 这种无状态的感觉实在是太好了！ Cookiecookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。 cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。 Sessionsession 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。 session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。 服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。 Token在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。 以下几点特性会让你在程序中使用基于Token的身份验证 无状态、可扩展 支持移动设备 跨程序调用 安全 那些使用基于Token的身份验证的大佬们 大部分你见到过的API和Web应用都使用tokens。例如Facebook, Twitter, Google+, GitHub等。 Token的起源在介绍基于Token的身份验证的原理与优势之前，不妨先看看之前的认证都是怎么做的。 基于服务器的验证我们都是知道HTTP协议是无状态的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。 在这之前，程序都是通过在服务端存储的登录信息来辨别请求的。这种方式一般都是通过存储Session来完成。 下图展示了基于服务器验证的原理 随着Web，应用程序，已经移动端的兴起，这种验证的方式逐渐暴露出了问题。尤其是在可扩展性方面。 基于服务器验证方式暴露的一些问题 Session：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。 可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。 CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。 CSRF(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。 在这些问题中，可扩展行是最突出的。因此我们有必要去寻求一种更有行之有效的方法。 基于Token的验证原理基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。 这种概念解决了在服务端存储信息时的许多问题 NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。 基于Token的身份验证的过程如下: 用户通过用户名和密码发送请求。 程序验证。 程序返回一个签名的token 给客户端。 客户端储存token,并且每次用于每次发送请求。 服务端验证token并返回数据。 每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control-Allow-Origin: ，让服务器能接受到来自所有域的请求。需要主要的是，在ACAO头部标明(designating)时，不得带有像HTTP认证，客户端SSL证书和cookies的证书。 实现思路： 用户登录校验，校验成功后就返回Token给客户端。 客户端收到数据后保存在客户端 客户端每次访问API是携带Token到服务器端。 服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码 当我们在程序中认证了信息并取得token之后，我们便能通过这个Token做许多的事情。 我们甚至能基于创建一个基于权限的token传给第三方应用程序，这些第三方程序能够获取到我们的数据（当然只有在我们允许的特定的token） Tokens的优势无状态、可扩展 在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。 如果我们将已验证的用户的信息保存在Session中，则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。用户量大时，可能会造成一些拥堵。 但是不要着急。使用tokens之后这些问题都迎刃而解，因为tokens自己hold住了用户的验证信息。 安全性 请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。 token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。 可扩展性 Tokens能够创建与其它程序共享权限的程序。例如，能将一个随便的社交帐号和自己的大号(Fackbook或是Twitter)联系起来。当通过服务登录Twitter(我们将这个过程Buffer)时，我们可以将这些Buffer附到Twitter的数据流上(we are allowing Buffer to post to our Twitter stream)。 使用tokens时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问它们的数据，我们可以通过建立自己的API，得出特殊权限的tokens。 多平台跨域 我们提前先来谈论一下CORS(跨域资源共享)，对应用程序和服务进行扩展的时候，需要介入各种各种的设备和应用程序。 Having our API just serve data, we can also make the design choice to serve assets from a CDN. This eliminates the issues that CORS brings up after we set a quick header configuration for our application. 只要用户有一个通过了验证的token，数据和资源就能够在任何域上被请求到。 1Access-Control-Allow-Origin: *]]></content>
      <categories>
        <category>后端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>cookie</tag>
        <tag>session</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于sequelize的数据库迁移]]></title>
    <url>%2Fposts%2F16051%2F</url>
    <content type="text"><![CDATA[数据库迁移有时候我们也希望能够跟踪数据库的更改，像 git 一样在各个不同时期的数据库状态之间进行切换。或者能通过一套工具将数据库迁移到本机，让我们在家也能进行测试开发，而不用依赖公司的测试环境。这些特性，作为今天的主角 sequelize-cli 都能提供给我们。 npm链接请 点击这里。 安装首先创建项目，项目名随意，创建完毕后cd到项目根目录，老规矩命令行 npm init -y 创建 package.json ，然后输入安装一步到位：npm i sequelize mysql2 sequelize-cli 。 注意： sequelize-cli 依赖 sequelize，sequelize 依赖 mysql2 安装完毕后我们可以测试下是否可用，根目录命令行输入： 1./node_modules/.bin/sequelize 看见命令行输出类似下方提示代表安装成功： 1234567891011121314151617181920212223242526sequelize [命令]命令： sequelize db:migrate Run pending migrations sequelize db:migrate:schema:timestamps:add Update migration table to have timestamps sequelize db:migrate:status List the status of all migrations sequelize db:migrate:undo Reverts a migration sequelize db:migrate:undo:all Revert all migrations ran sequelize db:seed Run specified seeder sequelize db:seed:undo Deletes data from the database sequelize db:seed:all Run every seeder sequelize db:seed:undo:all Deletes data from the database sequelize db:create Create database specified by configuration sequelize db:drop Drop database specified by configuration sequelize init Initializes project sequelize init:config Initializes configuration sequelize init:migrations Initializes migrations sequelize init:models Initializes models sequelize init:seeders Initializes seeders sequelize migration:generate Generates a new migration file [aliases: migration:create] sequelize model:generate Generates a model and its migration [aliases: model:create] sequelize seed:generate Generates a new seed file [aliases: seed:create]选项： --help 显示帮助信息 [布尔] --version 显示版本号 [布尔] 使用初始化目前我们项目的树形结构为： 1234.├── node_modules├── package-lock.json└── package.json 接着根目录命令行输入 ./node_modules/.bin/sequelize init 来初始化 sequelize 项目，该命令会帮我们创建如下目录：12345678.├── config # 包含数据库的配置文件├── migrations # 包含所有迁移文件（e.g. 数据库、表的创建，字段的增加）跟数据库结构有关的操作都存放在这里├── models # 包含项目中的所有模型（e.g. Users, Message）├── node_modules├── seeders # 包含所有种子文件（e.g. 表中的数据）├── package-lock.json└── package.json config首先我们来看下 config 目录下的 config.json 文件。它里面包含了数据库的的基本配置，默认分为 development（开发） 、test（测试） 和 production（生产） 环境。当然你也可以删除或新增环境，比如新增一个在家编写代码所使用的 home 环境。 db:createsequelize-cli 默认读取 development 模式下的数据库配置来创建数据库，所以接下来就用它来配置：12345678"development": &#123; "username": "root", // 数据库用户名 "password": "root", // 数据库密码 "database": "database_development", // 需要创建的数据库名 "host": "127.0.0.1", // 主机 "port": 8889, // 端口号 "dialect": "mysql" // 使用的数据库类型&#125;, 配置完毕后在根目录下的命令行输入 ./node_modules/.bin/sequelize db:create。当你看到如下输出就代表创建数据库成功：123Loaded configuration file "config/config.json".Using environment "development".Database sw_sequelize_development created. db:drop能添加就能删除，我们可以键入 ./node_modules/.bin/sequelize db:drop 命令来删除数据库。当你看到命令行输出下面内容就代表删除成功：123Loaded configuration file "config/config.json".Using environment "development".Database sw_sequelize_development dropped. 模式切换前面已经说了，sequelize-cli 默认读取 development 模式下的数据库配置。那如果我现在想切到 test 模式下该怎么办呢？ 变更环境变量首先得切换服务器环境变量，MacOS下（其他系统切换命令见下方链接）使用 export NODE_ENV=test 来切换到 test 模式，然后使用 echo $NODE_ENV 查看是否已经切换成功，接着就可以再次执行 ./node_modules/.bin/sequelize db:create 命令，创建 test 模式下的数据库了： 123456789101112$ export NODE_ENV=test$ echo $NODE_ENVtest./node_modules/.bin/sequelize db:createSequelize CLI [Node: 9.0.0, CLI: 5.4.0, ORM: 5.3.3]Loaded configuration file "config/config.json".Using environment "test".Database sw_sequelize_test created. 各系统下NodeJS环境变量修改 还原环境变量如果想回到默认的 development 模式，MacOS下直接键入命令 export NODE_ENV= 就OK啦。 models创建模型我们通过 model:generate 或者 model:create 来创建模型文件，它一共需要两个参数，分别是： –name: 模型名称（必须） –attributes: 字段列表（必须） 回到我们的项目，在根目录执行下面命令来创建一个 User 模型文件： 1./node_modules/.bin/sequelize model:create --name User --attributes username:STRING 执行完毕后命令行会有类似下方输出：1234Sequelize CLI [Node: 9.0.0, CLI: 5.4.0, ORM: 5.3.3]New model was created at .../你的项目名/models/user.js .New migration was created at .../你的项目名/migrations/20190316035632-User.js 所以 model:create 命令执行后帮我们创建了两个文件，一个是用来定义 User 模型的文件 user.js :12345678910'use strict';module.exports = (sequelize, DataTypes) =&gt; &#123; const User = sequelize.define('User', &#123; username: DataTypes.STRING &#125;, &#123;&#125;); User.associate = function(models) &#123; // associations can be defined here &#125;; return User;&#125;; 一个是 migrations 迁移文件夹下的 用来创建 User 表 的文件：12345678910111213141516171819202122232425262728'use strict';module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; // 创建名为 Users 的数据表 return queryInterface.createTable('Users', &#123; id: &#123; allowNull: false, autoIncrement: true, primaryKey: true, type: Sequelize.INTEGER &#125;, username: &#123; type: Sequelize.STRING &#125;, createdAt: &#123; allowNull: false, type: Sequelize.DATE &#125;, updatedAt: &#123; allowNull: false, type: Sequelize.DATE &#125; &#125;); &#125;, down: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.dropTable('Users'); &#125;&#125;; 其中 models 文件夹下文件，例如生成的 user.js 模型文件是给程序用的；migrations 和 seeders 文件夹下的文件是个 cli 用的。 总结下来，model:create 命令帮我们做了两件事情： 创建 User 模型 创建跟模型对应的 Users 数据表文件，方便用此文件在数据库中创建 Users 表 migrations刚刚我们已经创建了一个 User 模型和用来创建 Users 表的脚本执行文件。下面就可以开始执行迁移了。首先我们重温何为执行迁移： 所谓迁移，就是对数据库进行结构的创建、升级（修改）等操作 执行迁移db:migrate执行迁移的命令为 db:migrate，我们直接在项目根目录下运行： 1./node_modules/.bin/sequelize db:migrate （如果在此之前你运行过 db:drop 命令来删除数据库，记得再重新执行一次 db:create，否则会导致创建表失败）。执行成功的输出类似下面文字： 123456Sequelize CLI [Node: 9.0.0, CLI: 5.4.0, ORM: 5.3.3]Loaded configuration file "config/config.json".Using environment "development".== 20190316035632-create-user: migrating ========= 20190316035632-create-user: migrated (0.047s) 此时刷新下你的本地数据库，就会发现之前空空如也的数据库中多了个 users 表和 sequelizemeta 表： users 表被创建出来我们能理解，重点说一下这个 sequelizemeta 表，其实它是用来记录已经被执行过的迁移脚本的，避免我们重复执行已经执行过的脚本。 db:migrate:status我们可以通过 db:migrate:status 命令来查看当前迁移脚本的执行状态： 1./node_modules/.bin/sequelize db:migrate:status 执行完毕后的打印结果为： 123Loaded configuration file "config/config.json".Using environment "development".up 20190316035632-create-user.js 这个 up ，表示我们已经执行该脚本。此时我们可以删掉 sequelizemeta 表中的记录，然后再次执行 db:migrate:status ，会发现输出的 up 已变为 down ，表示我们从未执行过该脚本。由此可知 db:migrate:status 会通过 sequelizemeta 表中的记录来判断脚本是否被执行过。而当我们已经执行过某些脚本后再次执行 db:migrate ，那些已经执行过的脚本就不会再次重复执行了： 123Loaded configuration file "config/config.json".Using environment "development".No migrations were executed, database schema was already up to date. db:migrate:undo除了上面的新增数据表操作，我们还可以进行撤销操作。执行 ./node_modules/.bin/sequelize db:migrate:status 命令后 sequelize-cli 会帮我们撤销掉上一次（最近一次）的迁移操作，比如我们的 sequelizemeta表中记录了两条迁移操作（假设创建了 user 和 message 表）： 1220190316035632-create-user.js20190316035921-create-message.js 那么执行 undo 后就会把最近的一次迁移，也就是 *-message.js 从表中移除，并且在数据库中删除 message 表。而这个删除操作，其实是执行了迁移文件下对应表的删除代码： 123down: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.dropTable('Messages');&#125; db:migrate:undo:all当执行 ./node_modules/.bin/sequelize db:migrate:undo:all 命令后，能帮我们撤销所有的迁移操作。 db:migrate:undo: –name此命令能帮我们撤销具体指定的迁移脚本，例如执行下面命令会撤销名称为 20190316035632-create-user 的脚本操作：1./node_modules/.bin/sequelize db:migrate:undo --name 20190316035632-create-user 执行完毕后再来刷新我们的数据库，就会发现 user 表已被删除，只留下了 message 表。 字段添加与删除随着业务的增长，我们很有可能需要扩充数据表的字段。例如我们需要给 user 表添加一个 username 字段，那么我们就可以键入以下命令来创建一个 migration : 1./node_modules/.bin/sequelize migration:create --name UserAddAge 执行完上述操作后我们能在 migrations 文件夹中看到新创建的 UserAddAge 文件，打开后代码如下：1234567891011121314151617181920212223'use strict';module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; /* Add altering commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.createTable('users', &#123; id: Sequelize.INTEGER &#125;); */ &#125;, down: (queryInterface, Sequelize) =&gt; &#123; /* Add reverting commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.dropTable('users'); */ &#125;&#125;; 我们要做的，就是在 up 和 down 方法中填入数据库操作逻辑的代码，up 方法中有注释作提示，让我们返回一个类型为 Promise 的对象，还给出了示例。因为我们要给数据表添加字段，所以使用 addColumn 方法： 123456789return queryInterface.addColumn( 'users', // 被添加字段的表名称 'age', // 需要添加的字段名称 &#123; type: Sequelize.TINYINT, allowNull: false, defaultValue: 0, &#125;, // 字段属性) 这样我们就可以给 user 表添加上 age 字段了。 p.s. 之所以代码中填写 users ，是因为 sequelize-cli 帮我们创建表是会自动给表名称加 s 。 能添加就能删除，删除操作我们在 down 方法中编写： 1234return queryInterface.removeColumn( 'users', 'age'); UserAddAge.js 文件完整代码：123456789101112131415161718192021222324252627282930313233343536'use strict';module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; /* Add altering commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.createTable('users', &#123; id: Sequelize.INTEGER &#125;); */ return queryInterface.addColumn( 'users', 'age', &#123; type: Sequelize.TINYINT, allowNull: false, defaultValue: 0, &#125; ) &#125;, down: (queryInterface, Sequelize) =&gt; &#123; /* Add reverting commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.dropTable('users'); */ return queryInterface.removeColumn( 'users', 'age' ); &#125;&#125;; 编写完毕后我们运行 ./node_modules/.bin/sequelize db:migrate 来重新执行一遍所有迁移，刷新 user 表后就能看见新增字段 age 了。 最后你还可以执行 ./node_modules/.bin/sequelize db:migrate:undo 来确认 down 方法正常工作，从而让 user 表删除刚刚添加的 age 字段。 文档参考：更多 QueryInterface 操作 seeders除了数据库结构的添加修改删除操作以外，我们通常还会给各种表批量添加一些假数据。这个时候就要用到 seeders 里的种子文件了。比方说现在要给 user 表批量添加一些数据，则可以执行下面代码：1./node_modules/.bin/sequelize seed:create --name userTest 执行完毕后你会发现在 seeders 文件夹下多了一个类似 20190316090425-userTest.js 的文件。 批量添加我们可以在里面编写代码让 cli 帮助我们批量添加数据：12345678910111213141516171819202122232425262728293031323334353637'use strict';module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; /* Add altering commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.bulkInsert('People', [&#123; name: 'John Doe', isBetaMember: false &#125;], &#123;&#125;); */ return queryInterface.bulkInsert('users', [ &#123; username: '狄仁杰', age: 56 &#125;, &#123; username: '李元芳', age: 27 &#125; ]); &#125;, down: (queryInterface, Sequelize) =&gt; &#123; /* Add reverting commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.bulkDelete('People', null, &#123;&#125;); */ return queryInterface.bulkDelete('users', null, &#123;&#125;); &#125;&#125;; 种子文件的执行方式有两种： db:seed 种子文件名 来运行指定种子文件 db:seed:all 来运行所有种子文件 知道执行方法后我们来运行下面命令： 1./node_modules/.bin/sequelize db:seed:all 执行成功后刷新我们的 user 表，就会发现数据已经被批量添加进去了。 批量删除命令行输入并执行： ./node_modules/.bin/sequelize db:seed:undo:all 便可以批量删除刚刚添加进 user 表中的数据。 记录种子数据的存储我们知道 migrations 迁移是会被记录的（数据库的 sequelizemeta 表中），但默认情况下，种子数据的存储不会被记录下来。但官方同样提供了 方法 来记录种子数据的存储。我们可以通过在配置文件中使用 seederStorage 来记录存储： JSON记录 config/config.json 12345"development": &#123; ... "seederStorage": "json", // 存储类型 "seederStoragePath": "userTestData.json" // 存储路径（当前项目根目录下）&#125;, p.s. 上方注释在 copy 到自己项目时需要删除，否则报错。 接着我们执行 ./node_modules/.bin/sequelize db:seed:undo:all 先删除数据表中数据，然后再执行 ./node_modules/.bin/sequelize db:seed:all 重新添加一次种子数据。你就会发现项目根目录下多出来了一个叫做 userTestData.json 的文件，里面记录了已经执行过的种子文件名：123[ "20190316090425-userTest.js"] sequelize记录p.s. 如果你已经用上面json记录的方式记录过种子文件的存储，再想要尝试用sequelize玩一遍的话，首先得执行一遍 ./node_modules/.bin/sequelize db:seed:undo:all 哦。 123456"development": &#123; ... "seederStorage": "sequelize", // 存储类型 "seederStoragePath": "userTestData.json", // 存储路径（当前项目根目录下） "seederStorageTableName": "userTestData" // 存储的表名&#125;, 编写完上述代码后你可以执行下面命令： 1./node_modules/.bin/sequelize db:seed:all 执行完毕后刷新数据库，就能在数据库中发现 userTestData 表，里面记录了已经执行完毕的种子文件 20190316090425-userTest.js 版本安装的 sequelize 和 mysql2 的版本为：1234"dependencies": &#123; "sequelize": "^5.3.3", "sequelize-cli": "^5.4.0"&#125; 资源 QueryInterface 操作]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
        <category>Sequelize</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>SQL</tag>
        <tag>Sequelize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minification 压缩与 Gzip 压缩的区别（翻译）]]></title>
    <url>%2Fposts%2F53167%2F</url>
    <content type="text"><![CDATA[原链接：https://css-tricks.com/the-difference-between-minification-and-gzipping/作者：Chris Coyier 这两种方法都针对你网站上的资源（比如 .css 文件和 .js 文件）所使用。它们都用来压缩文件大小，使服务器和浏览器之间的网络更加通畅，提高网页性能。网络是网页的速度瓶颈所在，而压缩文件大小能够改善这一点。 但这两者也截然不同。如果之前你并不知道这一点，那么你应当花时间来了解它。 Minification 能够删除空格符（whitespace）、注释符（comments）、无用的分号（semicolons）或是减少 hex 代码的长度………诸如此类。剩下的文件依然是有效代码。你不必尝试读取它或是使用它，它并没有违反任何规则。就像对原始文件那样，浏览器可以读取它和使用它。 Minification 能够创建你最终使用的新文件。比如当你创建了一个名为 style.css 的文件之后，你可以把它压缩为 style.min.css。 Gizpping 能识别所有重复的字符串，并使用指代该字符串第一个实例的指针来代替。Julia Evans 曾想出一个绝佳的方法来解释这一点（点击这里查阅她发布的内容和视频）。下面是一首诗的第一段： 123456Once upon a midnight dreary, while I &#123;pon&#125;dered weak an&#123;d wea&#125;&#123;ry,&#125;Over many&#123; a &#125;quaint&#123; and &#125;curious volume of forgotten lore,W&#123;hile I &#125;nodded, n&#123;ear&#125;ly napping, su&#123;dde&#125;n&#123;ly &#125;th&#123;ere&#125; ca&#123;me &#125;a t&#123;apping,&#125;As&#123; of &#125;so&#123;me o&#125;ne gent&#123;ly &#125;r&#123;apping, &#125;&#123;rapping&#125; at my chamb&#123;er &#125;door.`'Tis&#123; some &#125;visitor,'&#123; I &#125;mu&#123;tte&#125;r&#123;ed, &#125;`t&#123;apping at my chamber door&#125; -O&#123;nly th&#125;is,&#123; and &#125;no&#123;thi&#125;&#123;ng &#125;m&#123;ore&#125;. Gzip 识别出括弧里的文字都是重复的，因此将会使用指针来代替它们，这样这些文字占用的空间将会比原来更小。 对于减少文件大小、尤其是代码而言，这种方法十分高效，因为代码中有大量重复的内容。设想一下一个 HTML 文件里有多少个 &lt;div，一个 CSS 文件里又有多少 {。 你也可以创建某个文件的 Gzip 压缩版本，比如 style.css.zip。但你一般不会这样做，浏览器也不知道应该如何使用这个文件。 在网页中，Gzip 压缩直接通过服务器完成。因此你要做的是配置服务器。一旦完成配置，Gzip 压缩将会自动进行，你无需再做任何工作。服务器会压缩文件，并通过网络传送文件。浏览器则接受文件，并在使用之前进行解压。我从未听谁提到过压缩和解压的成本，因此在这里我假设这些成本可以忽略不计，并且我们获得的受益远大于成本。 点击这里查看如何在 Apache 服务器中进行配置，这里使用了 mod_deflate 模块。H5BP 也为所有常见的服务器提供了服务器配置，包括 Gzipping。 示例我们将用到 Bootstrap 中常见的 CSS 文件。 通过 Minification 来压缩这个 CSS 文件，你将节省 17% 的空间，而使用 Gzipping 能够节省 85%，将两种方法结合使用节省的空间是 86%。 下面是使用 DevTools 检查工作状况时的理想情况： Gzip压缩 要高效得多，而将两种方法结合起来更为理想。Gzip 压缩节省的空间大概是 Minification 压缩的五倍。然而，通过 Minification 压缩，你也可以获得一些帮助，不过在构建步骤时你需要耗费一些额外的力气。 同样有证据证明浏览器在读取和解析 Minification 压缩的文件时速度更快： 正如预期的那样，除了缩短网络传输时间以外，Minification 压缩还有助于解析和加载。这也许是因为缺少注释符和额外的空白符。 微软也开始为此优化它们的语法分析器： 因此，在 Window 10 和 Microsoft Edge 中，我们新添加了快速路径，改善了在 Chakra 的 JIT 编译器中嵌入和优化部分探视程序的体验，以保证压缩代码的运行速度不低于原始版本。通过这些改变，通过 UglifyJS 压缩过的个体代码模式的性能提高了 20% 到 50%。 缓存资源同样与这段对话相关，没有什么比一个不需要请求任何资源的浏览器速度更快了！关于这一点，网上或者书中还有许多相关知识，不过很快我们也许会发布一些有关使用技巧的内容。]]></content>
      <categories>
        <category>后端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>gzip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack4 如何优雅打包缓存文件（转载）]]></title>
    <url>%2Fposts%2F57458%2F</url>
    <content type="text"><![CDATA[一般来说，对于静态资源，我们都希望浏览器能够进行缓存，那样以后进入页面就可以直接使用缓存资源，页面直接直逼火箭速度打开，既提高了用户的体验也节省了宽带资源。 当然浏览器缓存方法有很多种，这里只简单讨论下 webpack 利用 hash 方式修改文件名，以达到缓存目的。 webpack hashwebpack 内置了多种可使用 hash，官网解释分别如下： hash：the hash of the module identifier chunkHash：the hash of the chunk content contentHash：the hash of extracted content 注：hash 的默认长度为 20 个字符，可通过 output.hashDigestLength 全局配置，或使用 [hash:16] 方式配置，还可以通过 output.hashDigest 配置何时生成 hash。 那么问题来了，这么多种 hash 该如何选择呢？ 实战 hash基础的配置文件如下（基于webpack 4，入口文件分别为 index 和 detail，其中每个文件中引入了一个图片）： 1234567891011module.exports = &#123; mode: 'none', // 设置为 none，避免 development 或 production 默认设置的一些影响 entry: &#123; index: './src/index.js', detail: './src/detail.js', &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'dist') &#125;&#125; hash（the hash of the module identifier）首先，我们来解释下 the module identifier。webpack 默认为给各个模块分配一个 id 以作标识，用来处理模块之间的依赖关系。而默认的 id 命名规则是根据模块引入的顺序，赋予一个整数(1、2、3……)。如下图就是使用 hash 的打包，index 和 detail 作为 entry 的两个入口，可以看到其 hash 值是一样的，而另外两个图片的 hash 值是不同的。 由于该 hash 是基于整个 module identifier 序列计算得到的，所以 JS 或 CSS 文件如果使用该 hash，则所有值都一样，而任意增添或删减一个模块的依赖，都会对整个 id 序列造成影响，从而改变 hash 值。这样的话 JS 或 CSS 文件是不适合使用该 hash 值的。 当然对于图片、字体、PDF 等资源该 hash 还是可以生成一个唯一值的。 runtime &amp; manifest假如我们什么都不改动，只是重新跑一次构建，会惊奇的发现 index 和 detail 的 hash 值居然变了（图片的 hash 是不变的），如下图： 这究竟是怎么回事呢？webpack 官方解释为： This is because webpack includes certain boilerplate, specifically the runtime and manifest, in the entry chunk. 为了解决这个不稳定的因素，webpack 4 提供了一个配置可以直接把 boilerplate 给单独抽离出来，配置如下： 123 optimization: &#123; runtimeChunk: 'single'&#125; 这样我们就能得到一个 runtime 的 js 文件，如下图： chunkhash（the hash of the chunk content）现在我们把 hash 改成 chunkhash ，如下： 1234output: &#123; filename: '[name].[chunkhash].js', path: path.resolve(__dirname, 'dist')&#125; 重新跑下构建，会发现打包出来的三个 JS 文件的 chunkhash 值是不一样的了，如下： 现在我们在 index 文件中再引入一个 JS 模块，重新打包如下： 我们会发现 index 和 detail 文件的 chunkhash 都变了，这就奇怪了，按理来说 detail 文件我们根本没有改变啊，为什么它的 chunkhash 值变了呢？ 其实根本原因还是 module identifier，因为 index 新引入的模块改变了以后所有模块的 id 值，所以 detail 文件中引入的模块 id 值发生了改变，于是 detail 的 chunkhash 也随着发生改变。 解决方案是将默认的数字 id 命名规则换成路径的方式。webpack 4 中当 mode 为 development 会默认启动 123optimization: &#123; namedModules: true&#125; 当然如果是生产环境的话，全路径是有点太长，所以我们可以换成使用HashedModuleIdsPlugin 插件来根据路径生成的 hash 作为 module identifier。 123plugins: [ new webpack.HashedModuleIdsPlugin(),], 这样最后 chunkhash 改变的就只有修改的文件了，也达到了我们想要的效果。 contenthash（the hash of extracted content）现在我们将 CSS 样式单独抽离生成文件（使用了 MiniCssExtractPlugin 插件），会发现其 chunkhash 值跟该 entry 的 js 文件的 chunkhash 是一样的，如下图： 现在如果只改变 CSS 文件，会发现对应的 entry JS 和 CSS 文件的 chunkhash 都会改变。（注意：可能以前 ExtractTextWebpackPlugin 不会改变，所以只能对抽离的 CSS 文件使用 contenthash）。 反正不管同时变或不变，可能都不是我们想要的效果，我们需要应该是改变了什么就反应到什么文件上。而不是 CSS 和 JS 文件的 chunkhash 同时改变或不变，无法区分 CSS 和 JS 的更新。 所以这里抽离出来的 CSS 文件将使用 contenthash，以区分 CSS 文件和 JS 文件的更新。 Chunks ID然而这还没有结束，还有个问题，那就是目前我们的 chunks ID 还是以自增的数字命名的，这当我们的 entry 文件发生改变（新增或删除）的时候，原先的 chunks ID 就有可能发生变化。于是我们也需要把数字改掉就好，webpack 4 在 optimization 新增了一个 namedChunks 配置，该配置开发环境为 true，生产环境为 false，所以在生产环境的时候我们为了构建稳定的 hash 时，还是需要把该选项设置为 true，如下： 123456module.exports = &#123; //... optimization: &#123; namedChunks: true &#125;&#125;; 总结为了一份理想的缓存文件，我们需要做这些事情： 抽离 boilerplate（[runtime &amp; manifest） 将 module identifier 默认的数字标识方式转成使用路径标识 JS 文件使用 chunkhash 抽离的 CSS 样式文件使用 contenthash gif|png|jpe?g|eot|woff|ttf|svg|pdf 等使用 hash 设置 namedChunks 为 true 原文地址Webpack4 如何优雅打包缓存文件]]></content>
      <categories>
        <category>前端</category>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sequelize框架进阶]]></title>
    <url>%2Fposts%2F3278%2F</url>
    <content type="text"><![CDATA[传送门 Sequelize框架入门 前言上一篇入门讲到了 Sequelize框架 的基本用法，比如实现简单的增删查改。原本打算一篇文章写到底的，但感觉内容太多，对读者不太友好，就另开了这篇文章。 虽然标题写着“进阶”，但其实有标题党的以为。这篇文章仍然着手于框架的使用，不涉及源码。大纲见侧边栏的目录，我们直接开始吧~ 连表查询准备工作既然是连表查询，至少得有两个表吧。所以我们还需要另外新建一张表，这里起名为 message 表，表结构如下： 其中 uid 对应用户的 id 。下面是两表的数据： 接着我们新建一个 app2.js 文件，引入之前 app.js 中的部分代码（连接数据库+UserModel）以及创建一个 MessageModel 模型：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const Sequelize = require('sequelize');const sequelize = new Sequelize("miaov", "root", "root", &#123; host: "127.0.0.1", port: 8889, dialect: "mysql"&#125;);try &#123; sequelize.authenticate(); console.log('数据库连接成功!');&#125; catch (err) &#123; console.log('连接失败');&#125;const UserModel = sequelize.define('User', &#123; id: &#123; type: Sequelize.INTEGER(11), allowNull: false, autoIncrement: true, primaryKey: true, &#125;, username: &#123; type: Sequelize.STRING(50), allowNull: false, defaultValue: '', &#125;, age: &#123; type: Sequelize.TINYINT(3), allowNull: false, &#125;, gender: &#123; type: Sequelize.ENUM(['men', 'women', 'other']), allowNull: false, defaultValue: 'men', &#125;,&#125;, &#123; timestamps: false, tableName: 'users',&#125;);const MessageModel = sequelize.define('Message', &#123; id: &#123; type: Sequelize.INTEGER(11), primaryKey: true, allowNull: false, autoIncrement: true, &#125;, uid: &#123; type: Sequelize.INTEGER(11), allowNull: false, defaultValue: 0, &#125;, content: &#123; type: Sequelize.STRING(255), allowNull: false, defaultValue: '', &#125;&#125;, &#123; timestamps: false, freezeTableName: true, // 默认 false 将自动修改表名为复数，true 表示不修改表名，与数据库表名同步 tableName: 'message'&#125;); 需求+普通做法我们这次的需求是获取某条留言的所有数据，其中包含 留言本身的数据 + 该留言的用户数据 ，先来看最“耿直”的做法： 123456789101112131415161718(async () =&gt; &#123; let data = &#123;&#125;; // 根据 id 查找 message let message = await MessageModel.findByPk(1); // 根据 message 的 uid 反查出发布这条 message 的 user let user = await UserModel.findByPk(message.get('uid')); Object.assign(data, &#123; id: message.id, uid: message.uid, content: message.content, username: user.username, age: user.age, gender: user.gender, &#125;); console.log(data);&#125;)(); BelongsTo除了上面这种做法外，我们还可以使用 sequelize 提供的 BelongsTo 来关联两个模型进行查询。 思考一下我们的 users 和 message 表，从 message 的角度来讲，一条留言属于一个用户发布的，是一对一的关系。而 BelongsTo 关联的含义就是 A 属于 B。那我们应该怎么写代码呢？步骤如下： 首先在模型中给关联的字段定义外键关系 1234references: &#123; model: 关联的外键表模型, e.g. UserModel key: 关联的外键表的字段, e.g. id&#125; 在调用 belongsTo 或 hasMany 等方法的时候，通过第二个参数设置对象 123&#123; foreignKey: 当前关联表的字段, e.g. uid&#125; 没有完全理解上面的步骤也没关系，直接上代码更加清晰：1234567891011121314151617181920212223242526272829const MessageModel = sequelize.define('Message', &#123; ..., uid: &#123; // 第一步：在模型中给关联的字段定义外键关系 ... references: &#123; model: UserModel, // 关联的外键表模型 key: 'id', // 关联的外键表的字段 &#125; &#125;, ...&#125;, ...);(async () =&gt; &#123; // 第二步：声明两表关系及外键 // 下面方法翻译过来：留言属于用户 MessageModel.belongsTo(UserModel, &#123; foreignKey: 'uid' // 声明自己（message）的外键是 uid &#125;); let data = await MessageModel.findByPk(1, &#123; include: [UserModel] // 表述查出的 message 记录中包含有对应的 user &#125;); console.log(` 留言id：$&#123;data.id&#125; 留言人名称：$&#123;data.User.username&#125; 留言内容：$&#123;data.content&#125; `);&#125;)(); HasMany这次我们换个角度，来通过某个用户查找他/她所有的留言。稍微想一下，一个用户是可以发布多条留言的，所以从 users 角度来讲，跟 message 是一对多的关系。而 sequelize 也提供了处理这种关系的方法，那就是 HasMany。直接上代码：123456789101112131415161718(async () =&gt; &#123; // users 拥有 UserModel.hasMany(MessageModel, &#123; foreignKey: 'uid', &#125;); let data = await UserModel.findByPk(3, &#123; include: [MessageModel] &#125;); console.log(` id为 $&#123;data.id&#125; 的留言人 $&#123;data.username&#125; 的留言内容： `); data.Messages.forEach(m =&gt; &#123; console.log(` $&#123;m.content&#125;`); &#125;);&#125;)(); 版本安装的 sequelize 和 mysql2 的版本为：1234"dependencies": &#123; "mysql2": "^1.6.5", "sequelize": "^5.3.1"&#125;]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
        <category>Sequelize</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>SQL</tag>
        <tag>Sequelize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sequelize框架入门]]></title>
    <url>%2Fposts%2F1183%2F</url>
    <content type="text"><![CDATA[前言平常写前端项目时，为了更方便的获取“真实”的动态数据，也会新建几个数据库表来作支撑。但每每需要用Node搭建后端服务时，数据库的查询真的让人头疼，难倒不难，就是特别繁琐，即使封装了个查询sql用工具模块，在遇到稍复杂的查询语句时还是得写完整SQL。 我又是个比较懒的人，在经历了几次痛苦折磨后，我开始google有没有谁帮我们解决了数据库表字段与对象之间的关系映射。也就是我们通常所说的 ORM 。经过几番搜索，我找到了 Sequelize 框架。在了解它之前，我们先简单介绍下什么是 ORM ：（我知道不少人是不会点击上面链接查看详情的 :)） 介绍ORMORM 全称 Object Relational Mapping，翻译成中文就是 对象关系映射 。是对 SQL 查询语句的封装，让我们可以用面向对象的方式操作数据库，来更加优雅的生成安全、可维护的 SQL 代码。说白了，就是通过对象来映射和操作数据库。 Sequelize而今天的主角 Sequelize 则是一个基于 promise 的 Node.js 异步ORM框架。它能够支持多种数据库，包含但不限于 PostgreSQL, MySQL 和 MSSQL 。 官网地址：http://docs.sequelizejs.com/github：https://github.com/sequelize/sequelize 使用起步在本地新建文件夹，例如 sequelize-demo ，然后在项目根目录下运行命令行命名 npm init -y。运行完该命令后项目tree如下： 接着使用 npm 安装 sequelize：1npm i sequelize 连接数据库完成上述步骤以后，我们在根目录下新建一个 app.js 文件来使用 sequelize ，代码如下： 12345678910111213141516171819// 导入 sequelizeconst Sequelize = require('sequelize');// 新建 sequelize 实例const sequelize = new Sequelize('数据库名称', '数据库用户名', '数据库密码', &#123; // 其他的数据库连接配置 host: '127.0.0.1', // 主机，默认 localhost port: 8889, // 端口，默认 3306 dialect: 'mysql', // 数据库类型， 默认 mysql 【必填】 timezone: '+08:00' // 时区，默认会根据系统当前所在时区进行设置，格式：'+08:00' 或字符串格式 'Asia/Shanghai' 参考：http://php.net/manual/zh/timezones.php 【使用场景：一般情况下默认配置就好，但如果服务器在美国，但想存储中国时区，就需要明确指定 '+08:00' 了】&#125;);// 测试数据库的连接（返回的是一个Promise，记得 catch 捕获错误）try &#123; sequelize.authenticate(); console.log('数据库连接成功!');&#125; catch (err) &#123; console.log('连接失败'); &#125; 此时你可以尝试运行 app.js 文件，即在根目录下运行 node app.js 命令。正常情况下你会收到报错信息，类似这样： 意思是你需要安装 mysql2 ，这是因为 sequelize 虽然依赖了 mysql2 ，但却没有内置安装。所以接下来你得在项目根目录下运行如下代码来安装 mysql2：1npm i mysql2 安装完毕后再次运行 app.js ，就能连接数据库成功了：123$ node app.jsExecuting (default): SELECT 1+1 AS result数据库连接成功! 定义模型（Model） 所谓模型，就是用来描述数据库表字段信息的对象，每一个模型对象表示数据库中的一个表，后续对数据库的操作都是用过对应的模型对象来完成的。 接下来我们就要定义数据的模型了。在此之前，你还需要做一些准备工作。以我为例，我在数据库中新建了一个 users 表，表字段和类型如下： 然后定义出对应此表的数据模型：123456789101112131415161718192021222324252627// 定义模型（用对象的方式来描述数据库中的表）const UserModel = sequelize.define('User', &#123; // 描述表中对应的字段信息 id: &#123; // 每一个字段的信息 type: Sequelize.INTEGER(11), // 字段类型 allowNull: false, // 不允许为空 autoIncrement: true, // id自增长 primaryKey: true, // 设为主键 &#125;, username: &#123; type: Sequelize.STRING(50), allowNull: false, defaultValue: '', // 设置字段默认值 &#125;, age: &#123; type: Sequelize.TINYINT(3), allowNull: false, &#125;, gender: &#123; type: Sequelize.ENUM(['men', 'women', 'other']), // 这是个枚举类型字段，表示性别只能为“男”，“女”，“保密”中的其中一个，传入 ENUM 中的可以是逗号隔开的字符串，也可以是个数组：ENUM(['men', 'women']) or ENUM('men', 'women', 'other') allowNull: false, defaultValue: 'men', &#125;,&#125;, &#123; // 用来设置字段以外的其他信息 timestamps: false, // 是否给每条记录添加 createAt 和 updateAt 字段，并在添加新数据和更新数据的时候自动设置这两个字段的值，默认为 true tableName: 'users', // 该模型映射的真实表名&#125;); 注意：在定义模型时，字段名称可以和数据库表中的字段名称不相同，但如果你想另起一个别名，则需要在字段信息设置中加入 field 来关联真正的表字段名称。例如：12345userName: &#123; // &lt;-- 你起的别名 type: Sequelize.STRING(50), allowNull: false, field: 'username', // 关联数据库表中真正的字段名&#125;, 数据查询查询所有完成表模型的定义以后，我们就可以通过 findAll 来查询表数据了：1234567891011// 查询 users 表中所有数据UserModel.findAll().then(users =&gt; &#123; // 返回的 users 是个数组 users.forEach(user =&gt; &#123; // 循环的每个 user 都是个 Model 实例 // 该 Model 实例包含 get 方法，我们能通过它获取 username console.log(user.get('username')); &#125;);&#125;).catch(err =&gt; &#123; console.log(err);&#125;); 写完上面代码后，再次运行 app.js ，你就应该能够查询到数据了~p.s. 查询之前别忘了在数据库中插入一些数据。 条件查询除了查询全部数据，我们还可以使用 where 查询指定的数据：12345678910// 这次不用 .then 形式，而采用 async + await(async function() &#123; // 查找 username 为 '李元芳' 的唯一数据 let res = await UserModel.findOne(&#123; where: &#123; username: '李元芳' &#125; &#125;) console.dir(res);&#125;)(); 而类似大于小于这样的查询会稍显麻烦一点。例如我们来编写查询 users 表中年龄大于某个值的代码：123456789101112(async function () &#123; // 查找满足 age &gt; 24 的所有数据 let res = await UserModel.findAll(&#123; where: &#123; age: &#123; [Sequelize.Op.gt]: 24, &#125; &#125; &#125;) // 打印出符合条件的用户的 username console.dir(res.map(r =&gt; r.get('username')));&#125;)(); 多条件查询除了单一条件查询，我们还可以通过嵌套 or 或 and 运算符的集合来生成复杂条件语句。例如我们来查询 年龄小于25 或者 性别为男 的所有数据：1234567891011121314151617181920(async function () &#123; let &#123; Op &#125; = Sequelize; // 查找满足 age &lt; 25 或 gender = 'men' 的所有数据 let res = await UserModel.findAll(&#123; where: &#123; [Op.or]: [ &#123; age: &#123; [Sequelize.Op.lt]: 25, &#125; &#125;, &#123; gender: 'men' &#125; ] &#125; &#125;) // 打印出符合条件的用户的 username console.dir(res.map(r =&gt; r.get('username')));&#125;)(); 从上面几组查询语句我们可以看出，where 通常用 attribute: value 键值对获取一个对象，其中 value 可以是匹配等式的数据或其他运算符的键值对象。更多查询语法可在下方链接查询： Sequelize - Querying Sequelize - Querying（中文文档） 查询限制 limit, offset我们还能限制查询的数量：1234567(async () =&gt; &#123; // 只从表中查询两条数据 let res = await UserModel.findAll(&#123; limit: 2, &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;)(); 跳过前2条数据：123456(async () =&gt; &#123; let res = await UserModel.findAll(&#123; offset: 2, &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;)(); 跳过前2条数据并获取3条：1234567(async () =&gt; &#123; let res = await UserModel.findAll(&#123; offset: 2, limit: 3 &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;)(); 查询排序我们还可以将查询数据进行排序：123456789(async () =&gt; &#123; // 查询的结果按年龄高到低排序 let res = await UserModel.findAll(&#123; order: [ ['age', 'desc'] ] &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;)(); 查询记录有些时候我们可能只是想单纯的查询数据表中有多少条数据，这时可以用 count() 方法：js(async () =&gt; { // 查询 users 表中有多少条数据 let count = await UserModel.count(); console.log(count);})();12345678910或者使用 `findAndCountAll()` 方法在数据库中搜索多条记录，它能返回给我们**数据和总计数**：```js(async () =&gt; &#123; // 查询 users 表中的前两条数据，并返回 users 表中总记录数 let res = await UserModel.findAndCountAll(&#123; limit: 2, &#125;); console.log(res);&#125;)(); 查询结果的格式如下：123456&#123; count: 总记录数, rows: [ &#123;第一条记录&#125;, &#123;第二条记录&#125;, ... ]&#125; 这个方法对我们为前端提供分页功能很方便，count是符合条件的总记录数，而rows中可以是当前页数下的记录数。 数据增加既然能查，当然就能往数据库插入数据，在 sequelize 中，插入数据可以用 build 方法：123456789101112131415// 新建一条数据（除了build外，还可以通过 new UserModel(&#123;&#125;) 的形式创建一条记录）let wangwu = UserModel.build(&#123; username: '王五', age: 22, gender: 'men'&#125;);// **注意：** 通过 new 或 build 出来的对象不会立即同步到数据库中，// 需要使用后续的一些方法（例如 save ）来同步// 你还可以修改这条数据wangwu.set('age', 25);// 最后别忘了保存才能成功插入数据wangwu.save(); 如果运行后没报错，去数据库刷新表吧，数据已经成功的插入到 users 表了~ 数据修改实际开发中修改数据是再平常不过的了，比如修改一篇博客，更新自己的个人信息… 在 sequelize 中，我们这样修改数据：1234567// 查询id为2的用户数据UserModel.findByPk(2).then(user =&gt; &#123; // 查询到以后修改其 age 字段为 99 user.set('age', 99); // 修改后别忘了保存 user.save();&#125;); 注意： 在 Sequelize v5 版本以前，通过id查询数据的方法名为 findById ，从 v5 版本开始，更改为 findByPk 。其实想一下这样非常合理，以前的 findById 太主观了，要知道不一定每个表的主键都为 id ，所以更改为 findByPk 后，表示通过主键（Pk -&gt; PrimaryKey）查找，sequelize 会自动通过你在创建表模型时定义的主键字段查找。例如我们一开始在定义 User 模型时，就给 id 字段添加了 primaryKey: true, 属性。 除了 set + update 来更新数据以外，还可以使用 update() 方法做相同的事情：12345678(async function () &#123; // 先查询 let xiaohong = await UserModel.findByPk(3); // update方法相当于 set + save await xiaohong.update(&#123; age: 22, &#125;);&#125;)(); 数据删除如果想要删除一条数据，可以使用 destroy 方法：123456(async function () &#123; // 先查询 let wangwu = await UserModel.findByPk(4); // 对查询到的数据进行删除 wangwu.destroy();&#125;)(); 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194const Sequelize = require('sequelize');const sequelize = new Sequelize("miaov", "root", "root", &#123; // 其他的数据库连接配置 host: "127.0.0.1", // 主机 port: 8889, // 端口 dialect: "mysql" // 数据库类型&#125;);// 测试连接try &#123; sequelize.authenticate(); console.log('数据库连接成功!');&#125; catch (err) &#123; console.log('连接失败'); &#125;// 定义模型（用对象的方式来描述数据库中的表）const UserModel = sequelize.define('User', &#123; // 定义字段 id: &#123; // 对字段属性的定义 type: Sequelize.INTEGER(11), // 字段类型 allowNull: false, // 不允许为空 autoIncrement: true, // id自增长 primaryKey: true, // 设为主键 &#125;, username: &#123; type: Sequelize.STRING(50), allowNull: false, defaultValue: '', // 设置字段默认值 &#125;, age: &#123; type: Sequelize.TINYINT(3), allowNull: false, &#125;, gender: &#123; type: Sequelize.ENUM(['men', 'women', 'other']), allowNull: false, defaultValue: 'men', &#125;,&#125;, &#123; // 用来设置字段以外的其他信息 timestamps: false, // 是否给每条记录添加 createAt 和 updateAt 字段，并在添加新数据和更新数据的时候自动设置这两个字段的值，默认为 true tableName: 'users', // 该模型映射的真实表名&#125;);// 为了方便学习，使用一个函数包裹一组代码// 这样代码就不会运行了，从而避免干扰其他代码的执行// 如果想要此函数中代码执行，添加 `()` 就好// (function()&#123;...&#125;)(); &lt;-- 加上括号(function() &#123; // 查询 users 表中所有数据 UserModel.findAll().then(users =&gt; &#123; // 返回的 users 是个数组 users.forEach(user =&gt; &#123; // 循环的每个 user 都是个 Model 实例 // 该 Model 实例包含 get 方法，我们能通过它获取 username console.log(user.get('username')); &#125;); &#125;).catch(err =&gt; &#123; console.log(err); &#125;);&#125;);(async function() &#123; // 新建一条数据（除了build外，还可以通过 new UserModel() 的形式创建一条记录） let liyuanfang = UserModel.build(&#123; username: '李元芳', age: 09, gender: 'men' &#125;); // 修改数据 liyuanfang.set('age', 25); // 别忘了保存 await liyuanfang.save();&#125;);(function() &#123; // 查询id为2的用户数据 UserModel.findByPk(2).then(user =&gt; &#123; // 查询到以后修改其 age 字段为 99 user.set('age', 99); // 修改后别忘了保存 user.save(); &#125;);&#125;);(async function() &#123; // 先查询 let xiaohong = await UserModel.findByPk(3); // update方法相当于 set + save await xiaohong.update(&#123; age: 18 &#125;);&#125;);(async function () &#123; // 先查询 let wangwu = await UserModel.findByPk(4); // 对查询到的数据进行删除 wangwu.destroy();&#125;);(async function() &#123; // 查找 username 为 '李元芳' 的唯一数据 let res = await UserModel.findOne(&#123; where: &#123; username: '李元芳' &#125; &#125;) console.dir(res);&#125;);(async function () &#123; // 查找满足 age &gt; 24 的所有数据 let res = await UserModel.findAll(&#123; where: &#123; age: &#123; [Sequelize.Op.gt]: 24, &#125; &#125; &#125;) // 打印出符合条件的用户的 username console.dir(res.map(r =&gt; r.get('username')));&#125;);(async function () &#123; let &#123; Op &#125; = Sequelize; // 查找满足 age &lt; 25 或 gender = 'men' 的所有数据 let res = await UserModel.findAll(&#123; where: &#123; [Op.or]: [ &#123; age: &#123; [Sequelize.Op.lt]: 25, &#125; &#125;, &#123; gender: 'men' &#125; ] &#125; &#125;) // 打印出符合条件的用户的 username console.dir(res.map(r =&gt; r.get('username')));&#125;);(async () =&gt; &#123; // 只从表中查询两条数据 let res = await UserModel.findAll(&#123; limit: 2, &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;);(async () =&gt; &#123; // 跳过前2条数据 let res = await UserModel.findAll(&#123; offset: 2, &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;);(async () =&gt; &#123; // 跳过前2条数据并获取3条 let res = await UserModel.findAll(&#123; offset: 2, limit: 3 &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;);(async () =&gt; &#123; // 查询的结果按年龄高到低排序 let res = await UserModel.findAll(&#123; order: [ ['age', 'desc'] ] &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;);(async () =&gt; &#123; // 查询的结果按年龄高到低排序 let count = await UserModel.count(); console.log(count);&#125;);(async () =&gt; &#123; // 查询 users 表中的前两条数据，并返回 users 表中总记录数 let res = await UserModel.findAndCountAll(&#123; limit: 2, &#125;); console.log(res);&#125;)(); 版本安装的 sequelize 和 mysql2 的版本为：1234"dependencies": &#123; "mysql2": "^1.6.5", "sequelize": "^5.3.1"&#125; 资源 Sequelize Docs Sequelize Docs 中文版]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
        <category>Sequelize</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[animation动画（二）]]></title>
    <url>%2Fposts%2F20298%2F</url>
    <content type="text"><![CDATA[传送门 animation动画（一） animation动画（二） 老规矩，二系列来谈谈具体每个动画属性的含义和用法，算是一个对知识点的总结吧。 animation-name 动画名称CSS语法：animation-name: shrink 用来设置元素的动画名称。 animation-duration 持续时间CSS语法：animation-duration: 1s 用来指定动画在一个周期内所花费的时间。 animation-timing-function 运动曲线CSS语法：animation-timing-function: ease-in-out 用来设置元素的动画速度曲线，它的用法和 transition-timing-function 类似，想要了解详情的直接点这个链接吧。 DEMO See the Pen animation-timing-function by JingW (@JingW) on CodePen. animation-delay 动画延迟CSS语法：animation-delay: 1s 用来设置动画延迟多少秒/毫秒后才开始执行。正值（例如2s）将在2s后启动动画；负值（例如-2s）将立即执行动画，但是动画会从它的动画序列中的第2s位置处立即开始。 animation-iteration-count 循环次数CSS语法：animation-iteration-count: 1s 用来设置动画循环的次数，默认值是1，表示动画只播放一次。除了使用正整数来设置次数外，还可以将值设置为 infinite ，表示无限循环。 animation-direction 是否反向CSS语法：animation-direction: normal | reverse | alternate | alternate-reverse 用来设置动画在循环过程中是否反向运动，默认值为 normal ，即正常模式，动画会从第一帧播放到最后一帧；reverse 表示反向模式，动画会从最后一帧倒着播放到第一帧；alternate 设置动画先正向播放，第二次再从反向播放，交替进行，例如 animation 系列一中的案例；alternate-reverse 则是先让动画反向播放，第二次再正向播放，交替进行。 animation-fill-mode 动画填充模式CSS语法：animation-fill-mode: none | forwards | backwards | both 用来指定在动画执行之前和之后如何给动画的目标应用样式。这个属性在我第一次接触时没太理解，直到我看了 segmentfault 上的 这篇文章 。 在理解它之前，我们需要在脑海里有个概念，那就是一个动画是分为初始状态、等待期、动画执行期、完成期四个阶段的。而上面 animation-fill-mode 接收的四个值则分别对应： none 表示 等待期和完成期，元素样式都为初始状态样式，不受动画定义（@keyframes）的影响 forwards 表示等待期保持初始样式，完成期间保持最后一帧样式 backwards 表示等待期为第一帧样式，完成期跳转为初始样式 both 表示 等待期样式为第一帧样式，完成期保持最后一帧样式 单纯的文字不直观？相信下面的这个demo能让你豁然开朗： See the Pen animation-fill-mode by JingW (@JingW) on CodePen. animation-play-state 动画播放状态CSS语法：animation-play-state: running | paused 用来设置动画的播放或者暂停。比如希望在鼠标经过的时候，让动画先停止下来，鼠标移开之后再继续播放，就可以通过设置 .element:hover { animation-play-state: paused; } 来实现。下面是一个案例，在鼠标移入时钟后指针暂停旋转；移出后时钟继续旋转。 See the Pen animation-play-state闹钟示例 by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[animation动画（一）]]></title>
    <url>%2Fposts%2F31280%2F</url>
    <content type="text"><![CDATA[传送门 animation动画（一） animation动画（二） 介绍 CSS Animations 是CSS的一个模块，它定义了如何用关键帧来随时间推移对CSS属性的值进行动画处理。关键帧动画的行为可以通过指定它们的持续时间，它们的重复次数以及它们如何重复来控制。 ———— 出自 CSS Animations | MDN 语法1234/* 简写 */animation: 动画名称，一个周期所花费的时间，运动曲线（默认ease）， 动画延迟（默认0），播放次数（默认1）， 是否反向播放动画（默认normal），是否暂停动画（默认running） 就像在介绍中写到的那样，整个 animations 是个模块，包含很多属性来定义动画，比方说 animation-name 、animation-duration 和 animation-delay 等等。但本着快速上手的目的，第一篇文章主要围绕 animation 这个简写属性来讲，因为用它最直观，而且就经验来讲，日常使用最多的也是这个属性。 如何使用一个CSS3动画由两个基本项组成： 关键帧（Keyforames） - 用来定义动画的阶段和样式。 动画属性 - 分配关键帧（@keyframes）到一个特定的css元素，来定义它的动画方式。 我们围绕这两项讨论，并在这个过程中实现一个按钮不断放大缩小的动画效果： keyframes关键帧 keyframes 定义了动画在每个阶段的动画效果。它包括： 动画名称：定义动画的名称 动画阶段：整个动画阶段用百分比来表示。0% 表示动画的开始状态。100% 表示动画的结束状态。可以在其间添加多个中间状态，比如 20%，60%… 动画属性：给动画每个阶段定义的CSS属性 现在我们来编写一段 @keyframes 。动画名称命名为 shrink 。它只有简单的两个阶段： 第一阶段（0%）：元素的缩放比例为 1:1 第二阶段（100%）：元素的缩放比例为 1:0.8 12345678910@keyframes shrink &#123; 0% &#123; -webkit-transform: scale(1); transform: scale(1); &#125; 100% &#123; -webkit-transform: scale(0.8); transform: scale(0.8); &#125;&#125; 动画属性接着，我们给要设置动画的元素添加上动画属性。要使动画生效，我们至少要添加以下两个动画属性： animation-name: 动画的名称，在 @keyframes 中定义。 animation-duration: 动画的持续时间，以秒为单位（例如 5s）或毫秒（例如 200ms）。 12345678button &#123; /* 其他样式 */ ... /* 动画名称: shrink */ animation-name: shrink; /* 动画持续时间: 0.5秒 */ animation-duration: .5s;&#125; 这样我们就实现页面加载后，一个按钮从开始的原始大小，经过0.5s后变成了原始大小的0.8的动画效果。然而我们希望最终的效果是一个按钮的不断放大和缩小，交替进行。这就得添加 animation-iteration-count 和 animation-direction 两个动画属性了，它们一个用来定义元素动画的循环次数，一个用来定义动画在循环过程中是否反向运动： 1234567button &#123; ... /* 动画的循环次数: 无限次 */ animation-iteration-count: infinite; /* 循环是否反向：先正向后反向 */ animation-direction: alternate;&#125; 最终的简写形式如下： 1234button &#123; ... animation: shrink .5s linear alternate infinite;&#125; 完整效果： See the Pen animation-shrink by JingW (@JingW) on CodePen. 资源 📚 animation | 一个CSS3动画库 【推荐】 点我查看效果 magic | 另一个CSS3动画库 点我查看效果]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用JS实现翻转二叉树]]></title>
    <url>%2Fposts%2F50491%2F</url>
    <content type="text"><![CDATA[简介翻转二叉树就是把二叉树每一层的左右顺序颠倒过来。 示例 输入 12345 4 / \ 2 7 / \ / \1 3 6 9 输出 12345 4 / \ 7 2 / \ / \9 6 3 1 算法步骤如果根节点不为空，那么将左右子结点交换，然后将左右子结点进行递归调用。 代码实现1234567891011var invertTree = function(root) &#123; if (root !== null) &#123; var temp = root.left; root.left = root.right; root.right = temp; invertTree(root.left); invertTree(root.right); &#125; return root; &#125;;]]></content>
      <categories>
        <category>后端</category>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[有序表查找之二分查找]]></title>
    <url>%2Fposts%2F39853%2F</url>
    <content type="text"><![CDATA[简介二分查找又名折半查找。它的前提是所操作的数据集是一个有序的数据集。它的基本思想是：开始时，先找出有序集合中间的那个元素。如果此元素比要查找的元素大，就接着在较小的一个半区进行查找；反之，如果此元素比要找的元素小，就在较大的一个半区进行查找。在每个更小的数据集中重复这个查找过程，直到找到要查找的元素或者数据集不能再分割。 图解 适用场景二分查找可以应用于任何类型的数据，但前提是这些数据是按某种规则进行排序的。这使得它在处理那些频繁插入和删除操作的数据集时不太高效。因为执行完插入和删除操作后，无法保证数据集的有序性，在查找前还得先维护一个有序数据集，从而导致查找过程代价太高。此外，元素必须存储在连续的空间中。 因此，当待搜索的集合是相对静态的数据集时，此时使用二分查找是最好的选择。 代码示例（JS） 非递归实现 123456789101112131415161718192021var arr = [4, 9, 12, 13, 15, 33, 46, 49, 50, 77, 101];function binary_search(arr, target) &#123; var min = 0, max = arr.length; while (min &lt;= max) &#123; var mid = parseInt((min + max) / 2); if (target === arr[mid]) &#123; return mid; &#125; else if (target &gt; arr[mid]) &#123; min = mid + 1; &#125; else &#123; max = mid - 1; &#125; &#125; return -1;&#125;console.log(binary_search(arr, 33)); 递归实现 123456789101112131415161718192021var arr = [4, 9, 12, 13, 15, 33, 46, 49, 50, 77, 101];function binary_search(arr, min, max, target) &#123; if (min &gt; max) &#123; return -1; &#125; var mid = parseInt((min + max) / 2); if (target === arr[mid]) &#123; return mid; &#125; else if (target &gt; arr[mid]) &#123; min = mid + 1; return binary_search(arr, min, max, target); &#125; else &#123; max = mid - 1; return binary_search(arr, min, max, target); &#125;&#125;console.log(binary_search(arr, 0, arr.length - 1, 33));]]></content>
      <categories>
        <category>后端</category>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法]]></title>
    <url>%2Fposts%2F59937%2F</url>
    <content type="text"><![CDATA[冒泡排序冒泡排序是一种交换排序，基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。 算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 动图演示 ———— 动图来自《菜鸟教程》 说明：绿色表示当前正在比较的两个相邻元素；橘黄色表示已排完序的元素，不再参与后续的比较 代码实现（JS）123456789101112131415var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function myBubbleSort(arr) &#123; var len = arr.length, temp; for (var i = 0; i &lt; len - 1; i++) &#123; // 趟数 for (var j = 0; j &lt; len - 1 - i; j++) &#123; // 当前趟要比较的次数 if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两比较 temp = arr[j]; // 元素交换 arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; return arr;&#125; 代码与图片配合食用更加~ 选择排序选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。 算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第2步，直到所有元素均排序完毕。 动图演示 代码实现（JS）123456789101112131415161718var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function mySelectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; // 第 i 轮选择 minIndex = i; // 每轮开始假设起始元素为最小值 for (var j = i + 1; j &lt; len; j++) &#123; // 遍历剩余未排序元素 if (arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数 minIndex = j; // 将最小数的索引保存 &#125; &#125; temp = arr[i]; // 交换起始元素与真正的最小值 arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 配图： 插入排序插入排序的原理应该是最容易理解的，因为只要你打过扑克牌就应该能秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 算法步骤 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 动图演示 代码实现（JS）12345678910111213141516171819202122var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function myInsertSort(arr) &#123; var len = arr.length; var insertItem; // 要插入的元素 // 从数组的第二个元素开始循环将数组中的元素插入 for (var i = 1; i &lt; len; i++) &#123; insertItem = arr[i]; // 设置数组中的第2个元素为第一次遍历要插入的数据 var j = i - 1; // 已排序好数组的最后一个元素的索引 // 将已排好序的元素从最后一个往前依次与待插入元素比较， while (j &gt;= 0 &amp;&amp; insertItem &lt; arr[j]) &#123; // 如果要插入的元素小于第j个元素,就将第j个元素向后移动 arr[j + 1] = arr[j]; j--; &#125; // 直到要插入的元素不小于第j个元素,将insertNote插入到数组中 arr[j + 1] = insertItem; &#125; return arr;&#125; 12345678// 例如for循环中 i 等于 2 时，已排序完毕的元素为[3,44]，进入for循环 // 待插入元素为 arr[2]，也就是38; // j=i-1也就是2-1等于1 // while循环比较，待插入元素38是小于arr[j]（j=1）44 的 =&gt; 条件成立 // arr[j+1]要等于arr[j] =&gt; arr[2]要等于arr[1] =&gt; arr[2]=44 =&gt; 此刻数组前三个元素：[3,44,44] // j-- =&gt; j=1-1也就是0 // 再来一轮while比较，待插入元素38现在不小于arr[j] 也就是arr[0]的3，所以直接退出while循环 // arr[j+1]=insertItem =&gt; arr[1]=38 =&gt; 数组前三排序完毕：[3,38,44] 希尔排序希尔排序也是一种插入排序，它是简单插入排序的一个改进版，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。本文会以图解的方式详细介绍希尔排序的基本思想及其代码实现。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 算法步骤(示例)在此我们选择增量 gap=数组长度length/2，缩小增量继续以 gap = gap/2 的方式，这种增量选择我们可以用一个序列来表示：{n/2,(n/2)/2...1}，称为增量序列。当然，希尔排序的增量序列有很多种，这里采用的是比较常用的一种作为示例： 在上面这幅图中： 初始时，有一个大小为 10 的无序序列。 在第一趟排序中，我们设 gap1 = 10 / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。接下来，按照直接插入排序的方法对每个组进行排序。 在第二趟排序中，我们把上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。按照直接插入排序的方法对每个组进行排序。 在第三趟排序中，再次把 gap 缩小一半，即gap3 = gap2 / 2 = 1。 这样相隔距离为 1 的元素组成一组，即只有一组。按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。 注意：图中有两个相等数值的元素 5 和 5 。我们可以清楚的看到，在排序过程中，两个元素位置交换了。所以，希尔排序是不稳定的算法。 代码演示（JS）123456789101112131415161718192021222324var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function myShellSort(arr) &#123; var gap = Math.floor(arr.length / 2); while (1 &lt;= gap) &#123; // 把距离为 gap 的元素编为一个组，扫描所有组 for (var i = gap; i &lt; arr.length; i++) &#123; var j = 0; var temp = arr[i]; // 对距离为 gap 的元素组进行排序 for (j = i - gap; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j = j - gap) &#123; arr[j + gap] = arr[j]; &#125; arr[j + gap] = temp; &#125; console.log(`gap = $&#123;gap&#125;`); console.log(arr); gap = Math.floor(gap / 2); // 减小增量 &#125; return arr;&#125; 归并排序归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略（分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 可以看到这种结构很像一棵完全二叉树，下面的归并排序代码将会采用递归去实现（你也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为logn。 算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤 3 直到某一指针达到序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 图片演示图片来自博客《图解排序算法之归并排序》 代码实现123456789101112131415161718192021222324252627282930313233var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function mergeSort(arr) &#123; // 采用自上而下的递归方法 var len = arr.length; if (len &lt; 2) return arr; var middle = Math.floor(len / 2), // 将未排序数组拆分成两半分而治之 left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right) &#123; var result = []; while (left.length &amp;&amp; right.length) &#123; // 两边的起始元素相互比较，始终将小的一方的头元素弹出，并push到准备好的容器result中 if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result;&#125; 快速排序快速排序的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的元素均比另一部分记录的元素小，继而再分别对这两部分记录递归的进行同样的排序操作。 算法步骤 把数组中第一个元素当做一个基准值，称为“基准”（Pivot） 重新排序数列，把所有比基准值小的元素摆放在基准前面，所有比基准值大元素摆放在基准后面。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序； 分区（Partition）思路首先把未排序数组的第一个（最左边）元素设置为基准，把它的位置叫做 l ： 然后依次向后查看所有元素，在查看过程中，不断的调整后面元素的位置，使得后面的元素分为两部分，一部分都小于 v ；一部分都大于 v 。 我们用 j 来不断记录这两部分的分割线位置。而 e 就是我们要判断的下一个元素，用索引 i 来表示，i 会遍历每一个元素，来看该如何调整这个元素。 在下图中，我们用 arr[l+1 ... j] 来表示小于 v 的橙色部分，用 arr[j+1 ... i-1] 来表示大于 v 的紫色部分。 接下来就要看如何来调整下一个元素 e 的位置。分情况讨论： 当 e 大于 v 时，我们直接让 e 融入大于 v 的部分，并让 i++ 当 e 小于 v 时，我们让 e 和大于 v 部分的第一个元素交换位置。把 e 融入到小于 v 的部分。此时就需要让分隔线的索引位置 j++ ，相应的，索引 i 的位置也要 i++ 以便查看下一个元素。 以这样的步骤我们就能遍历完整个数组，如下图所示 现在还差最后一个步骤，那就是把基准值 v ，与小于 v 部分的最后一个元素交换位置。此刻 v 左边都小于它，v 右边都大于它，而 j 指向的就是基准值所在的位置。这样我们就完成了分区（Partition）操作。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function quickSort(arr, left, right) &#123; var len = arr.length, partitionIndex, // 分区索引 left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left &gt;= right) return; // 通过分区找到分隔点，再分别快排左右两部分 partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); return arr;&#125;function partition(arr, left, right) &#123; // 分区操作 var v = left, // 设定基准值（pivot） j = left; // arr[l+1...j] ; arr[j+1...i] for (var i = j + 1; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[v]) &#123; // 当前要判断元素 小于 基准元素时 j++; // 分隔点右移 swap(arr, i, j); // 让 当前元素 与大于 v 部分的第一个元素交换位置 &#125; // 此处不用写 else ，因为当大于基准元素时，直接i++就好， // 而i++，for循环已经帮我们做了 &#125; // 循环完毕后，交换基准值和小于v部分的最后一个元素的位置 swap(arr, v, j); return j;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;console.log(quickSort(arr, 0, arr.length)); 计数排序计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 算法步骤 找出待排序的数组中最大和最小的元素； 统计数组中每个值为 i 的元素出现的次数，存入数组 Count 的第 i 项； 对所有的计数累加（从 Count 中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素 i 放在新数组的第 Count(i) 项，每放一个元素就将 Count(i) 减去1。 代码实现123456789101112131415161718192021222324252627282930var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function countingSort(arr) &#123; var len = arr.length, Result = [], Count = [], min = max = arr[0]; // 查找最大最小值,并将arr数置入Count数组中,统计出现次数 for (var i = 0; i &lt; len; i++) &#123; min = min &lt;= arr[i] ? min : arr[i]; max = max &gt;= arr[i] ? max : arr[i]; Count[arr[i]] = Count[arr[i]] ? Count[arr[i]] + 1 : 1; &#125; // 从最小值-&gt;最大值,将计数逐项相加 for (var j = min; j &lt; max; j++) &#123; Count[j + 1] = (Count[j + 1] || 0) + (Count[j] || 0); &#125; // Count中,下标为arr数值,数据为arr数值出现次数;反向填充数据进入Result数据 for (var k = len - 1; k &gt;= 0; k--) &#123; // Result[位置] = arr数据 Result[Count[arr[k]] - 1] = arr[k]; // 减少Count数组中保存的计数 Count[arr[k]]--; &#125; return Result;&#125;console.log(countingSort(arr));]]></content>
      <categories>
        <category>后端</category>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue的生命周期函数]]></title>
    <url>%2Fposts%2F33186%2F</url>
    <content type="text"><![CDATA[创建期间的生命周期函数beforeCreate实例刚在内存中被创建出来，此时还没有初始化好 data 和 methods 属性。 作用执行 loading 动画。 created实例已经在内存中创建完毕，data 和 methods 等属性也已经创建完成。但此刻还没有开始编译模板。 作用 结束掉 loading 动画 做一些初始化工作，比如函数自执行，发起异步请求获取数据 beforeMount此刻已经完成了模板的编译，但还没有挂载到页面上。换句话说，此时页面中类似 的语法还没有被替换成真正的数据。 mounted此刻已经将编译好的模板挂载到了页面中指定的容器中显示。用户已经可以看到渲染好的页面了。 作用 由于此刻已经把模板挂载到了页面，所以能够在此钩子函数中获取 DOM 节点。 此函数中也能发起异步请求 运行期间的生命周期函数beforeUpdate状态更新之前执行此函数，此刻 data 中的状态值是最新的，但是界面上显示的数据还是旧的。因此此时还没有开始重新渲染 DOM 节点。 updated实例更新完毕后调用此函数，此刻 data 中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了。 销毁期间的生命周期函数beforeDestroy实例销毁之前调用。此刻实例仍然完全可用。 作用一切你想要在组件销毁之前做事，例如弹出确认窗：“你确认删除XXX吗？” destroyed实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transition过渡（二）]]></title>
    <url>%2Fposts%2F13167%2F</url>
    <content type="text"><![CDATA[传送门 transition过渡（一） transition过渡（二） 上篇文章是对 transition过渡 的一个简单介绍和使用。这篇文章就来聊聊具体属性的含义和用法。 transition-property 过渡属性从上一篇文章能够知道 transition-property 是拿来设置元素中参与过渡的属性的。它的可选值为： none 指所有属性都不参与过渡 all 指所有属性都参与过渡 [IDENT] 指定个别属性参与过渡 下面来看一个案例： 👇温馨提示：为了方便看效果，可点击 CSS 按钮折叠代码部分，仅显示页面 👇 See the Pen transition-property-demo1 by JingW (@JingW) on CodePen. 当你依次将鼠标移入上方演示demo中的三个按钮就会发现，都在各自下方显示出了一段文本。我们想要实现的，就是这段文本的显示需要有一个过渡效果，不要太生硬。最简单的一种实现方案就是鼠标移入按钮前，文本容器的 height: 0 ，鼠标移入后固定容器高度 height: 150px （第一个按钮效果就用的此方案）。但在实际情况中，往往文本是自适应的，高度无法确定，所以很自然的，我们会想到将 height: 150px 设置为 height: auto ，这样不就能够实现自适应高度的容器过渡了嘛，这就是第二个按钮的一套实现方案。但结果大家都知道了，文本容器不再拥有过渡的动画，而是直接从 0px 瞬间变化到 auto，这是为什么呢？ 答案：并不是所有的属性和属性值都能存在过渡动画。 这里特别需要注意的是，如果想要指定某个属性有过渡状态，就需要保证我们能够计算出过渡过程中每个时间点的属性值。比如，从 height: 0; 过渡到 height: 150px; ，过渡时间是 t ，那我们可以算出在 x 时刻的属性状态是 height: (150px-0)*x/t; 。（注：这里公式成立的前提是假设 transition-timing-function: linear; ，如果transition-timing-function 为其他值，一样可以计算，只不过算法不同）然而刚才第二种方案设置了 height: auto;，则在 x 时刻的属性状态为 height: (auto-0px)*x/t; ，显然，这种状态是不存在的、无法被计算的，因此在设置高度变成 auto 之后，也自然不会再有过渡动画了。 解决方案 第三个按钮的效果就是我们的一种解决方案，在默认状态下，我们不设置文本容器的 height: 0 ，而是用 transform: scale(1, 0); 来代替它，意思是在初始状态下，我们的文本容器比例为宽1:1，高1:0，换句话说，宽为我们设置的宽，但高度为0。在鼠标移入按钮后，用 transform: scale(1, 1); 来代替方案二中的 height: auto ，设置文本容器的宽高为1，这样就又能出现过渡动画了。 延伸 由此进行延伸，再比如日常中最常使用的控制元素显示隐藏的代码是 display: block; 和 display: none; ，这也是不存在过渡动画的，因此，可以调整改为使用 opacity: 1; 和 opacity: 0; 来替换。 transition-duration 过渡花费的时间这个属性没什么可讲的，用它来设置元素过渡的持续时间 transition-timing-function 效果曲线这个属性是设置过渡的动画类型的，换句话说，就是设置在过渡过程中元素值的变化速度。它的可选值包含这样几组： ease | linear | ease-in | ease-out | ease-in-out step-start | step-end | steps([, [ start | end ] ]?) cubic-bezier(, , , ) 预设的五个时间曲线 See the Pen transition-timing-function-五个预设时间曲线 by JingW (@JingW) on CodePen. 阶跃函数 step直接上案例吧，看完效果再来讲阶跃函数几个参数的具体含义： See the Pen transition-timing-function-阶跃函数 by JingW (@JingW) on CodePen. 实际体验了阶跃函数带来的效果后应该对其有个大概认知了吧。阶跃函数接收两个参数，第一个参数为正整数，指定阶跃函数的间隔数，你可以理解为把整个过渡过程拆成若干份儿；第二个参数可选，值为[ start | end ]，叫做跃点，指定是在每个间隔的起点还是终点发生阶跃变化，默认值为end。查看上面案例的css代码，你会发现两种 steps 的简写形式：step-start 和 step-end ，它们分别等同于：step-start = steps(1, start) 和 step-end = steps(1, end) 。 cubic-bezier 贝塞尔曲线函数贝塞尔曲线函数接收四个参数，取值范围是 0 到 1 之间的数值（包括0和1）。 贝塞尔曲线函数，其实定义的是 属性状态 与 时间 的一个关系函数。如下坐标轴所示： 上图坐标轴中横坐标是时间，纵坐标是属性状态，右上角的坐标是(1,1)。在时间曲线中的每一个点，表示的就是对应时刻下属性的取值，每个点的斜率表示的就是在这个时刻属性的变化速度，因此在时间曲线中斜率越小，也就是越平缓的地方，表示属性变化速度越慢；斜率越大，也就是越陡峭的地方，表示属性变化速度越快。如上图中开始跟结束的时候，斜率都比较小，而中间的阶段，斜率比较大，因此这个曲线表示的就是在变化过程中由慢到快再到慢的一个过程。 回到贝塞尔曲线函数接收的四个参数上，前两个是上图中红色点的坐标(x1,y1)，后两个是图中蓝色点的坐标(x2,y2)，也就是 cubic-bezier(x1, y1, x2, y2) 这样的形式。我们可以在 http://cubic-bezier.com/ 这个工具上来调整我们独特的贝塞尔曲线，通过拖拽红色跟蓝色点，可以形成不一样的贝塞尔曲线。我们发现，其实规定取值范围在[0,1]之间，针对的是x坐标，也就是时间，因为时间如果超过了这个范围，就会出现在同一个时刻对应了两个不同的属性状态，这个是没有意义的；而y坐标是可以超过这个范围的，如下我们通过拖拽两个点形成了这样一个曲线： 它表示的是在过渡过程中属性值会超过终止状态的设定值然后再回到终点位置，表现为回弹的效果。大家可以在 http://cubic-bezier.com/ 上自己拖动两个点尝试一下，最后点击 go 按钮查看效果。 上面两个图的demo效果： See the Pen transition-timing-function-贝塞尔曲线 by JingW (@JingW) on CodePen. transition-delay 延迟这个属性同样没啥讲的，用它来设置元素延迟过渡的时间。 transition 的不足 无法在页面加载的时候自动触发，因为只有当属性值发生改变的时候才会触发过渡动画。 无法重复播放过渡动画，除非再次触发过渡事件。 无法设置多种状态（keyframes 只有 from，to），只能从初始状态过渡到终止状态，无法再设置其他的状态。 transition 规则作用的是单个属性的过渡状态，不能涉及多个属性，即使定义了 transition: all 1s ease 0s; 这样的规则，其对应的每个属性过渡动画也都是相互独立，相当于是定义了很多个 transition 规则，而每个 transition 只作用于一个属性。 资源 Easing Functions Cheat Sheet cubic-bezier]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transition过渡（一）]]></title>
    <url>%2Fposts%2F24967%2F</url>
    <content type="text"><![CDATA[传送门 transition过渡（一） transition过渡（二） 介绍 CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。要实现这一点，必须规定两项内容： 指定要添加效果的CSS属性 指定效果的持续时间。 ———— 出自 菜鸟教程 语法12345678/* 分开写：*/transition-property: css属性名称;transition-duration: 过渡所花时间(默认0);transition-timing-function: 过渡的时间曲线(默认ease);transition-delay: 延迟时间(默认0);/* 简写形式： */transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0) 栗子 🌰单个属性的变化 —&gt; 按钮 :hover 效果下面的两个按钮，在鼠标移入时都被设置了 background: yellow; 样式。但只给第一个加上了 transition: background 2s; 属性，意思是如果背景发生变化，则给2s的过渡效果。 See the Pen XGvqMB by JingW (@JingW) on CodePen. 多个属性的变化 —&gt; 单独设置针对多个属性设置过渡效果，用逗号隔开就好。下面案例鼠标移入后，使正方形过渡到圆形，且颜色逐渐变浅，核心代码：1transition: background .5s ease-out, border-radius .5s ease-in; See the Pen transition-多属性 by JingW (@JingW) on CodePen. 多个属性的变化 -&gt; all如果要过渡的css属性较多，可以尝试使用 all 一步搞定。下面案例中将鼠标移入正方形盒子，会使其慢慢缩小为一个圆形，且颜色逐渐变深，核心代码：1transition: all .5s ease-out; See the Pen transition-多属性-all by JingW (@JingW) on CodePen. 实用 demo下拉导航菜单 See the Pen transition-下拉导航 by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5的自定义属性]]></title>
    <url>%2Fposts%2F39974%2F</url>
    <content type="text"><![CDATA[在 HTML5 中我们可以自定义属性，其格式为 data-*=&quot;&quot; 1234567891011121314&lt;div id="demo" data-my-name="sw" data-age="10"&gt;&lt;script&gt;/* Node.dataset 是以对象形式存在的，当我们为同一个 DOM 节点指定了多个自定义属性时， Node.dataset 则存储了所有的自定义属性的值。 */var demo = document.querySelector("#demo");//获取//注：当我们如下格式设置时，则需要以驼峰格式才能正确获取var name = demo.dataset['myName'];var age = demo.dataset['age'];//设置demo.dataset['name'] = 'web developer';&lt;script/&gt; 资源mdn - data-*]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何使用webpack4]]></title>
    <url>%2Fposts%2F47462%2F</url>
    <content type="text"><![CDATA[为什么要使用 webpack网页中引用的常见静态资源 类型 静态资源 JS .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS .css .less .sass .scss Images .jpg .png .gif .bmp .svg 字体文件（Fonts） .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 引入过多静态资源有什么问题？ 网页加载速度慢， 因此我们要发起很多的二次请求 还要处理错综复杂的依赖关系 如何解决上述两个问题 合并、压缩、精灵图、图片的 Base64 编码 可以使用 requireJS、也可以使用 webpack 来解决各个包之间的复杂依赖关系 如何完美实现上述的2种解决方案 使用 Gulp， 基于 task 任务 使用 webpack， 基于整个项目进行构建 借助于 webpack 这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能 简介webpack 是基于 Node.js 开发出来的一个前端项目打包工具。 安装 &amp; 初步使用 如果第一次安装，需要全局安装 『 webpack &amp;&amp; webpack-cli 』: 1npm install -g webpack webpack-cli 初始化项目 123456# 创建文件夹mkdir webpack4-demo# 进入cd webpack4-demo# 初始化npm init -y 以下面的目录结构创建文件 123456789101112├── package.json└── src ├── css │ └── index.css ├── images │ └── temp.png ├── index.html ├── js │ ├── a.js │ ├── b.js │ └── index.js └── main.js index.css 1234567body &#123; display: flex;&#125;ul li &#123; box-shadow: 2px 2px 2px rgba(31, 31, 31, 0.05);&#125; index.html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; js/a.js 1234567891011import b from './b'import $ from 'jquery'const a = &#123; init() &#123; console.log("我是 a 模块，现在被初始化了") &#125;, binit() &#123; b.init() &#125;&#125;export default a js/b.js 123456const b = &#123; init() &#123; console.log("我是 b 模块，现在被初始化了") &#125;&#125;export default b js/index.js 12345678910111213import $ from 'jquery'const index = &#123; // init后执行隔行变色的代码 init() &#123; // 设置偶数行背景色，索引从0开始，0是偶数 $('#list li:even').css('backgroundColor', 'lightblue') // 设置奇数行背景色 $('#list li:odd').css('backgroundColor', 'pink') &#125;&#125;export default index main.js 12345678910111213import a from './js/a'import b from './js/b'import index from './js/index'import './css/index.css'const main = () =&gt; &#123; console.log('入口函数 main 被调用了') a.init() a.binit() b.init() index.init()&#125;main() 项目根文件夹下执行命令 npm i webpack webpack-cli -D 使用 npm i jquery 安装 jQuery 类库 直接在页面上引用 main.js 会报错，因为浏览器不认识 import $ from &#39;jquery&#39; 这种JS语法，需要使用 webpack 进行处理，webpack 默认会把这种高级的语法转换为低级的浏览器能识别的语法： 12345678&lt;ul id="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;!-- 直接引入会报错 --&gt;&lt;script src="./main.js"&gt;&lt;/script&gt; 运行 webpack 入口文件路径 模式 运行 main.js 入口文件： 123webpack src/main.js --mode development # 开发环境或者webpack src/main.js --mode production # 生产环境 不过每次都要输入这个命令，非常麻烦，我们可以在package.json的scripts中加入两个指令成员： 1234"scripts": &#123; "dev": "webpack src/main.js --mode development", "build": "webpack src/main.js --mode production"&#125;, 以后只需要在命令行执行 npm run dev 便相当于执行 webpack --mode development ，执行 npm run build 便相当于执行 webpack --mode production。 使用配置文件简化打包命令 在项目根目录中创建 webpack.config.js 由于运行 webpack 命令的时候，webpack 需要指定入口文件和输出文件的路径，所以我们需要在 webpack.config.js 中配置这两个路径： 1234567891011121314151617// 导入处理路径的模块const path = require('path')// 导出一个配置对象，将来 webpack 在启动的时候，// 会默认来查找 webpack.config.js ，// 并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; // 配置入口文件，表示要使用 webpack 打包哪个文件 // 若不配置 webpack 将自动查找 src 目录下的 index.js 文件 entry: &#123; main: path.join(__dirname, './src/main.js') &#125;, output: &#123; filename: "[name].bundle.[hash].js", //输出文件名，[name]表示入口文件js名，[hash]会在后面生成随机hash值 path: path.join(__dirname, "./dist") //输出文件路径 &#125;&#125; 由于此时已经配置了入口文件，package.json 中的脚本命令就可简化为： 12"dev": "webpack --mode development","build": "webpack --mode production" 实现 webpack 实时打包构建webpack 提供了一个可选的本地开发服务器，这个本地服务器基于 node.js 构建，它是一个单独的插件，叫做 webpack-dev-server ，在 webpack 中进行配置之前需要单独安装它作为项目依赖。 devServer 作为 webpack 配置选项中的一项，以下是它的一些配置选项: contentBase ：设置服务器所读取文件的目录，当前我们设置为”./dist” port ：设置端口号，如果省略，默认为8080 inline ：设置为true，当源文件改变时会自动刷新页面 historyApiFallback ：设置为true，所有的跳转将指向index.html 由于每次重新修改代码之后，都需要手动运行 webpack 打包的命令，比较麻烦，所以使用 webpack-dev-server 来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行 npm i webpack-dev-server -D 安装到开发依赖 安装完成之后，修改之前在 package.json 中添加的 dev 指令： 1"dev": "webpack-dev-server --mode development" 运行指令 npm run dev ，发现可以进行实时打包，但是 dist 目录下并没有生成 main.bundle.js 文件，这是因为 webpack-dev-server 将打包好的文件放在了内存中。 把 bundle.js 放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 这个时候访问 webpack-dev-server 启动的 http://localhost:8080/ 网站，发现是一个文件夹的面板，需要点击到 src 目录下，才能打开我们的 index 首页，此时引用不到 main.bundle.js 文件，需要修改 index.html 中 script 的 src 属性为:&lt;script src=&quot;../main.bundle.js&quot;&gt;&lt;/script&gt; 为了能在访问 http://localhost:8080/ 的时候直接访问到 index 首页，可以使用 --contentBase src 指令来修改dev指令，指定启动的根目录： 1"dev": "webpack-dev-server --mode development --contentBase src", 插件（Plugins）插件（Plugins）是用来拓展 webpack 功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders 和 Plugins 常常被弄混，但是它们其实是完全不同的东西，可以这么来说，loaders 是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。 使用 html-webpack-plugin 插件配置启动页面由于使用 --contentBase 指令的过程比较繁琐，需要指定启动的目录，同时还需要修改 index.html 中 script 标签的 src 属性，所以推荐使用 html-webpack-plugin 插件配置启动页面。 运行 npm i html-webpack-plugin -D 安装到开发依赖 修改 webpack.config.js 配置文件如下： 123456789101112131415161718192021222324252627282930// 导入处理路径的模块const path = require('path')// 导入自动生成HTMl文件的插件const htmlWebpackPlugin = require('html-webpack-plugin')// 导出一个配置对象，将来 webpack 在启动的时候，// 会默认来查找 webpack.config.js ，// 并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; // 配置入口文件，表示要使用 webpack 打包哪个文件 // 若不配置 webpack 将自动查找 src 目录下的 index.js 文件 entry: &#123; main: path.join(__dirname, './src/main.js') &#125;, output: &#123; filename: "[name].bundle.js", //输出文件名，[name]表示入口文件js名 path: path.join(__dirname, "./dist") //输出文件路径 &#125;, plugins: [ // 添加plugins节点配置插件 new htmlWebpackPlugin(&#123; template: path.join(__dirname, './src/index.html'), //模板路径 filename: 'index.html', //自动生成的HTML文件的名称 minify: &#123; // 压缩HTML文件 removeComments: true, // 移除HTML中的注释 collapseWhitespace: true, // 删除空白符与换行符 minifyCSS: true // 压缩内联css &#125;, &#125;) ]&#125; 撤销 package.json 中 script 节点中的 dev 指令为：dev&quot;: &quot;webpack-dev-server --mode development&quot; 将 index.html 中 script 标签注释掉，因为 html-webpack-plugin 插件会自动把 main.bundle.js 注入到 index.html 页面中。 实现自动打开浏览器、热更新和配置浏览器的默认端口号方式1：修改 package.json 的 script 节点如下，其中 --open 表示自动打开浏览器， --port 4321 表示打开的端口号为 4321 ，--hot 表示启用浏览器热更新： 1"dev": "webpack-dev-server --open --port 4321 --hot --mode development", 方式2：(个人推荐) 修改 webpack.config.js 文件，新增 devServer 节点如下： 123456789devServer: &#123; inline: true, //打包后加入一个 websocket 客户端 hot: true, // 启用热更新 的 第1步 open: true, // 自动打开浏览器 contentBase: path.resolve(__dirname, 'dist'), // 指定托管的根目录，不注释的话，无法访问 src 以外的资源，比如 node_modules host: 'localhost', // 主机地址 port: 4321, // 设置启动时候的运行端口 compress: true // 开发服务器是否启动gzip等压缩 &#125;, 在头部引入 webpack 模块： 12// 启用热更新的 第2步const webpack = require('webpack') 在 plugins 节点下新增： 12// 启用热更新的第 3 步new webpack.HotModuleReplacementPlugin() Loadersloaders 是 webpack 最强大的功能之一，通过不同的 loader ，webpack 有能力调用外部的脚本或工具，实现对不同格式的文件的处理，例如把 scss 转为 css ，将 ES6 、ES7 等语法转化为当前浏览器能识别的语法，将 JSX 转化为 js 等多项功能。 loaders 需要单独安装并且需要在 webpack.config.js 中的 modules 配置项下进行配置，Loaders的配置包括以下几方面： test：一个用以匹配 loaders 所处理文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； options：为loaders提供额外的设置选项（可选） 打包 css 文件 运行npm i style-loader css-loader --D 修改 webpack.config.js 这个配置文件： 12345678module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125; //处理css文件的规则 ]&#125;, 注意：use 表示使用哪些模块来处理 test 所匹配到的文件；use 中相关 loader 模块的调用顺序是从后向前调用的。 打包 less 文件 如果你习惯使用 less ，可以执行命令 npm i less-loader less -D 来安装 less-loader 。 修改 webpack.config.js 配置文件： 1234&#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader']&#125;, //配置处理 .less 文件的第三方 loader 规则 打包 sass 文件 例如我平常习惯用 scss，所以会安装 sass-loader ：执行命令 npm i sass-loader node-sass --D 在 webpack.config.js 中添加处理 sass 文件的 loader 模块： 12345&#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader']&#125;,// 配置处理 .scss 文件的 第三方 loader 规则（npm i sass-loader后还需要 npm i node-sass，否则编译报错） 处理 css 中的图片路径 预备工作： 在 src/css/index.css 文件中给 body 添加：background-image: url(“../images/temp.png”); 此时保存会编译报错，因为 webpack 无法处理 css 中的路径（此案例中为——图片资源） 运行 npm i url-loader file-loader --D 在 webpack.config.js 中添加处理 url 路径的 loader 模块： 12345678910111213&#123; test: /\.(jpg|png|bmp|gif|jpeg)$/, use:[&#123; loader:'url-loader', options:&#123; outputPath:'images/',//输出到images文件夹 //是把小于500B的文件打成 Base64 的格式，写入JS // 如果不小于，url-loader 就会使用 file-loader 处理图片 // 所以必须安装file-loader limit:500 &#125; &#125;]&#125;, // 配置图片路径 处理 Bootstrap 字体的加载重要(更新)：webpack4后的 bootstrap 字体加载已经不能使用下面该方法，如何使用可以参考这篇博客：webpack 4.X版本的简单使用(处理js/css/less/scss/url(图片)/字体文件) 预备工作： index.html 写入 来展示字体图片 main.js 导入 import ‘bootstrap/dist/css/bootstrap.css’ 此时报错 在 webpack.config.js 中添加处理字体文件的 loader 模块： 1234&#123; test: /\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader'&#125;, // 处理 字体文件的 loader 提取css文件（插件！）先安装 mini-css-extract-plugin 包： 1npm install mini-css-extract-plugin -D 然后在 webpack.config.js 中修改对css文件处理的配置： 123456789101112131415161718// 提取cssvar MiniCssExtractPlugin = require("mini-css-extract-plugin")rules: [ &#123; test: /\.css$/, use: [ process.env.NODE_ENV === 'development' ? 'style-loader' : MiniCssExtractPlugin.loader, 'css-loader'] //处理css &#125;, ...]plugins: [ new MiniCssExtractPlugin(&#123; filename: 'style.css' &#125;), ...] 添加浏览器css前缀首先下载 loader ： 1npm i postcss-loader autoprefixer -D 然后根目录添加 postcss.config.js 1234567module.exports = &#123; plugins: &#123; 'autoprefixer': &#123; browsers: 'last 5 version' // 代表意思为每个主流浏览器的最后5个版本 &#125; &#125;&#125; 最后在 webpack.config.js 中添加配置： 12345678910111213141516rules: [ &#123; test: /\.css$/, use: [ process.env.NODE_ENV === 'development' ? 'style-loader' : MiniCssExtractPlugin.loader, &#123; loader: 'css-loader', options: &#123; importLoaders: 1 &#125; &#125;, "postcss-loader" ] //处理css &#125;, ...] 使用 babel 处理高级 JS 语法 在 main.js 文件中添加 ES6 代码： 123456789101112131415// class 关键字，是ES6中提供的新语法，是用来 实现 ES6 中面向对象编程的方式class Person &#123; // 使用 static 关键字，可以定义静态属性 // 所谓的静态属性，就是 可以直接通过 类名， 直接访问的属性 // 实例属性： 只能通过类的实例，来访问的属性，叫做实例属性 static info = &#123; name: 'zs', age: 20 &#125;&#125;// 访问 Person 类身上的 info 静态属性console.log(Person.info)// 在 webpack 中，默认只能处理 一部分 ES6 的新语法，一些更高级的ES6语法或者 ES7 语法，webpack 是处理不了的；这时候，就需要 借助于第三方的 loader，来帮助webpack 处理这些高级的语法，当第三方loader 把 高级语法转为 低级的语法之后，会把结果交给 webpack 去打包到 bundle.js 中// 通过 Babel ，可以帮我们将 高级的语法转换为 低级的语法 运行如下两套命令，安装两套包，去安装 Babel 相关的loader功能： 123456// 【相当于转换工具】npm i -D @babel/core babel-loader @babel/plugin-transform-runtime @babel/runtime @babel/plugin-proposal-class-properties// 【相当于字典】npm i -D @babel/preset-env// =====&gt; 「转换工具」根据「字典」将 es6 转换 打开 webpack 的配置文件，在 module 节点下的 rules 数组中，添加一个新的匹配规则： 12345&#123; test: /\.js$/, use: 'babel-loader', exclude: /node_modules/&#125; // 配置 Babel 来转换高级的ES语法 2.2 注意： 在配置 babel 的 loader 规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉：原因有俩： 2.2.1 如果 不排除 node_modules， 则Babel 会把 node_modules 中所有的 第三方 JS 文件，都打包编译，这样，会非常消耗CPU，同时，打包速度非常慢； 2.2.2 哪怕，最终，Babel 把 所有 node_modules 中的JS转换完毕了，但是，项目也无法正常运行！ 在项目的根目录中，新建一个叫做 .babelrc 的 Babel 配置文件，这个配置文件，属于 JSON 格式，所以，在写 .babelrc 配置的时候，必须符合 JSON 语法规范： 不能写注释，字符串必须用双引号： 123456789101112131415&#123; "presets": [ ["@babel/preset-env", &#123; "modules": false, "targets": &#123; "browsers": ["&gt; 1%", "last 2 versions", "not ie &lt;= 8"] &#125;, "useBuiltIns": "usage" &#125;] ], "plugins": [ "@babel/plugin-transform-runtime", "@babel/plugin-proposal-class-properties" ]&#125; webpack.config.js配置遇到Error: Cannot find module ‘@babel/core’问题 官方默认babel-loader | babel 对应的版本需要一致: 即babel-loader需要搭配最新版本babel 两种解决方案: 回退低版本 1npm install -D babel-loader@7 babel-core babel-preset-env 更新到最高版本: 1npm install -D babel-loader @babel/core @babel/preset-env webpack 压缩和优化css文件下载 optimize-css-assets-webpack-plugin 插件： 1npm i optimize-css-assets-webpack-plugin -D 在 webpack.config.js 中引入插件并添加配置： 12345678910111213141516// 压缩cssconst OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin')plugins: [ new OptimizeCssAssetsPlugin(&#123; assetNameRegExp: /\.css$/g, //一个正则表达式，指示应优化/最小化的资产的名称。提供的正则表达式针对配置中ExtractTextPlugin实例导出的文件的文件名运行，而不是源CSS文件的文件名。默认为/\.css$/g cssProcessor: require('cssnano'), //用于优化\最小化CSS的CSS处理器，默认为cssnano cssProcessorOptions: &#123; safe: true, discardComments: &#123; removeAll: true &#125; &#125;, //传递给cssProcessor的选项，默认为&#123;&#125; canPrint: true //一个布尔值，指示插件是否可以将消息打印到控制台，默认为true &#125;),] 压缩和优化js文件123456789101112131415161718yarn add webpack-parallel-uglify-plugin -Dconst WebpackParallelUglifyPlugin = require('webpack-parallel-uglify-plugin')plugins: [new WebpackParallelUglifyPlugin(&#123; uglifyJS: &#123; output: &#123; beautify: false, //不需要格式化 comments: false //不保留注释 &#125;, compress: &#123; warnings: false, // 在UglifyJs删除没有用到的代码时不输出警告 drop_console: true, // 删除所有的 `console` 语句，可以兼容ie浏览器 collapse_vars: true, // 内嵌定义了但是只用到一次的变量 reduce_vars: true // 提取出出现多次但是没有定义成变量去引用的静态值 &#125; &#125; &#125;)] 提取公共文件我们可看到 src/js/a.js 和 src/main.js 都引入了 src/js/b.js 文件，为什么要提取公共代码，简单来说，就是减少代码冗余，提高加载速度。和之前的 webpack 配置不一样： 1234567891011121314151617181920212223242526//之前配置// new webpack.optimize.SplitChunksPlugin(&#123;// name: 'common', // 如果还要提取公共代码,在新建一个实例// minChunks: 2, //重复两次之后就提取出来// chunks: ['index', 'a'] // 指定提取范围// &#125;),//现在配置optimization: &#123; splitChunks: &#123; cacheGroups: &#123; commons: &#123; // 抽离自己写的公共代码 chunks: "initial", name: "common", // 打包后的文件名，任意命名 minChunks: 2,//最小引用2次 minSize: 0 // 只要超出0字节就生成一个新包 &#125;, vendor: &#123; // 抽离第三方插件 test: /node_modules/, // 指定是node_modules下的第三方包 chunks: 'initial', name: 'vendor', // 打包后的文件名，任意命名 // 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包 priority: 10 &#125;, &#125; &#125;&#125;, Source Maps 调试配置作为开发，代码调试当然少不了，那么问题来了，经过打包后的文件，你是不容易找到出错的地方的，Source Map就是用来解决这个问题的。 通过如下配置，我们会在打包时生成对应于打包文件的 .map 文件，使得编译后的代码可读性更高，更易于调试。 123456// webpack.config.js...module.exports = &#123; ... devtool: 'source-map' // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度&#125; 配置好后，我们再次运行 npm run build 进行打包，这时我们会发现在 dist 文件夹中多出了一个 bundle.js.map 如果我们的代码有 bug ，在浏览器的调试工具中会提示错误出现的位置，这就是 devtool: &#39;source-map&#39; 配置项的作用。 开发环境 VS 生产环境npm run devnpm run dev 是我们开发环境下打包的文件，当然由于 devServer 帮我们把文件放到内存中了，所以并不会输出打包后的 dist 文件夹。 npm run build通过 npm run build 之后会生成一个dist目录文件夹，里面有我们打包后的文件。 清理/dist文件夹(CleanwebpackPlugin)你可能已经注意到，在我们删掉 /dist 文件夹之前，由于前面的代码示例遗留，导致我们的 /dist 文件夹比较杂乱。webpack 会生成文件，然后将这些文件放置在 /dist 文件夹中，但是 webpack 无法追踪到哪些文件是实际在项目中用到的。 通常，在每次构建前清理 /dist 文件夹，是比较推荐的做法，因此只会生成用到的文件，这时候就用到 CleanWebpackPlugin 插件了。 123456789101112npm i clean-webpack-plugin -D// webpack.config.js...const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;); // 引入CleanWebpackPlugin插件module.exports = &#123; ... plugins: [ ... new CleanWebpackPlugin(), // 以前括号里面要传入数组([dist])来指定要删除的目录，新版 CleanWebpackPlugin 不需要传任何参数了 ]&#125; 插件的使用方法都是一样的，首先引入，然后new一个实例，实例可传入参数。 现在我们运行 npm run build 后就会发现，webpack 会先将 /dist 文件夹删除，然后再生产新的 /dist 文件夹。 webpack4.x 相关资源 webpack4.x最详细入门讲解 从基础到实战 手摸手带你掌握新版Webpack4.0详解 教你看文档 webpack3 与 webpack4 使用差异 webpack4.x开发环境配置]]></content>
      <categories>
        <category>前端</category>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie与session区别]]></title>
    <url>%2Fposts%2F63891%2F</url>
    <content type="text"><![CDATA[保存状态cookie 是通过在客户端记录信息确定用户身份的，而 session 则通过在服务器端记录信息来确定用户身份。下面是网上找到的两张图，能够对 cookie 以及 session 在客户端与服务端传递的过程有个较清晰的认识： 使用方式cookie机制： 默认情况下，cookie 保存在内存中，浏览器关闭就没了；设置过期时间后，cookie 保存在硬盘上，关闭浏览器仍然存在，直到过期时间结束才消失。 cookie 以文本形式保存在客户端，每次请求时都带上它。 session机制： 每次请求，服务器会检查是否有 sessionid 有，服务器根据 id 返回对应 session 对象 无，服务器创建新的 session 对象，并把 sessionid 在本次响应中返回给客户端。 通常使用 cookie 方式存储 sessionid 到客户端 用户禁用 cookie 时，则服务端可以使用URL重写，可以通过 response.encodeURL(url) 进行实现 存储方式 cookie 只能保存字符串类型，以文本的方式 session 能支持任何类型的对象 存储大小 cookie单个不超过4kb session没限制]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记]]></title>
    <url>%2Fposts%2F51696%2F</url>
    <content type="text"><![CDATA[前言之前对算法和数据结构没有一个系统的学习，从今天开始抽空啃啃书吧。就从这本程杰老师的《大话数据结构》起步。 p.s. 原笔记是存放在幕布上的，文字版看着不舒服可以 点击这里 看思维导图版。 数据结构绪论 基本概念和术语 数据 定义：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的集合符号。 总结：数据即符号，必备条件： 可以输入到计算机中 能被计算机程序处理 举例： MP3是声音数据 图片是图像数据 #数据对象 定义：是性质相同的数据元素的集合，是数据的子集 举例： 人（都有姓名、生日等相同的数据项） #数据元素 定义：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被成为记录。 举例： 人类中的人 畜类中的牛马羊 #数据项 定义：一个数据元素可以由若干个数据项组成 举例： 人的姓名、年龄、性别 数据结构 定义：是相互之间存在一种或多种特定关系的数据元素的集合 #逻辑结构 定义：指数据对象中数据元素之间的相互关系 类型 #集合结构 同属于一个集合的数据元素 #线性结构 数据元素之间是一对一的关系 #树形结构 数据元素之间存在一对多的层次关系 #图形结构 数据元素是多对多的关系 用示意图表示数据逻辑结构时的注意点： 每个数据元素是一个结点，用圆圈表示 元素之间的逻辑关系用连线表示，如果此关系是有方向的，那么用箭头连线表示 #物理结构 定义：是指数据的逻辑结构在计算机中的存储形式 #顺序存储结构 定义：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的 #链式存储结构 定义：是把数据元素存放在任意的存储单元里，这组存储单元可以使连续的，也可以是不连续的。 注意：数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置 算法 基本特性：输入、输出、有穷性、确定性和可行性 设计要求：正确性、可读性、健壮性、高效和低存储量 度量方法：事后统计（不科学、不准确）、事前分析估算 ✅ 时间复杂度 概念 计算公式：T(n) = O(f(n)) T(n)： 语句总的执行次数 n： 问题规模 f(n)： 问题规模 n 的某个函数 表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同 大O记法 定义：用大写O()来体现时间复杂度，简称为大O记法 推导大O阶方法： \1. 用常数 1 取代运行时间中的所有加法常数 \2. 在修改后的运行次数函数中，只保留最高阶项 \3. 如果最高阶项存在且不是 1，则去除与这个项相乘的常数 \4. 得到的结果就是大 O 阶 常数阶 举例：高斯算法 此算法运行次数函数是 f(n)=3 推导：把常数项 3 改为 1 =&gt; 它没有最高阶 =&gt; 复杂度：O(1) 线性阶 推导：循环体中代码需要执行 n 次 =&gt; 复杂度：O(n) 对数阶 推导：每次 count 乘以 2 后，就距离 n 更近一分。换句话说，有多少个 2 相乘后大于 n，则会退出循环。由 2^x=n 得到 x=log(2)n。所以此循环复杂度：O(logn) 平方阶 举例1 推导：两层循环，每层循环 n 次 =&gt; 复杂度：O(n^2) 如果把外层 n 改为 m，则复杂度：O(m✘n) 举例2 复杂度：O(n^2) 常见时间复杂度 常见时间复杂度所耗费的时间从小到大： 空间复杂度 概念 计算公式：S(n) = O(f(n)) S(n)：计算算法所耗的存储空间 n： 问题规模 f(n)： 问题规模 n 所占存储空间的函数 当不用限定词地使用“复杂度”时，指的都是时间复杂度 心得 明白算法的时间复杂度估算很重要，不要以“CPU越来越快，不用考虑算法优劣”为借口。愚公移山固然可敬，但发明炸药和推土机更加实在和聪明 线性表 定义：零个或多个数据元素的有限序列 关键点： 是一个有顺序的序列 若元素存在多个，则第一个无前驱，最后一个无后继，中间部分都有且只有一个前驱和后继 线性表是有限的 举例： 幼儿园小朋友按次序排队，各自都知道他前面人是谁，方便清点人数，知道谁不在 一年的星座列表 顺序存储结构 定义：用一段地址连续的存储单元一次存储线性表的数据元素 三个重要属性： 存储空间的起始位置 线性表的最大存储容量 线性表的当前长度 数据长度与线性表长度区别 数据长度：（例如一个数组的长度）是存放线性表的存储空间的长度，一般不变 线性表长度：是线性表中数据元素的个数，随着插入与删除，这个量是可变的 在任意时刻，线性表长度应该 小于等于 数据长度 时间复杂度： 插入或删除最后一个元素为 O(1) 插入或删除第一个元素为O(n) 优缺点 优点： 无需为了表示表中元素之间的逻辑关系而增加额外的存储空间 可以快速地存取表中任意位置的元素 缺点： 插入和删除操作需要移动大量元素 当线性表长度变化较大时，难以确定存储空间的容量 造成存储空间的“碎片” 链式存储结构 定义：是把数据元素存放在任意的存储单元里，这组存储单元可以使连续的，也可以是不连续的。 与顺序结构不同，在链式结构中，除了要存储数据信息外，还要存储它后继元素的存储地址 单链表 定义：一个链式结构的，每个结点中只包含一个指针域的链表叫做单链表 单链表结构与顺序存储结构的优缺点 对比： 存储分配方式： 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素 时间性能： 查找： 顺序存储结构 O(1) 单链表 O(n) 插入与删除： 顺序存储结构需要移动表长一半的元素，时间为 O(n) 单链表在找出某位置的指针后，插入和删除时间仅为 O(1) 空间性能： 顺序存储结构需要预分配存储空间，分大了浪费，分小了容易溢出 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制 结论： 若线性表需要频繁查找，很少进行插入和删除操作，宜采用顺序存储结构 若需要频繁插入和删除，宜采用单链表结构 当线性表中的元素个数变化较大或根本不知道多大时，宜采用单链表结构，这样不用考虑存储空间的大小问题。 若事先知道大致长度，比如一年12个月，一周7天，宜采用顺序存储结构 实际应用： 用户注册的个人信息，除了注册时插入数据外，绝大多数情况都是读取，所以宜采用顺序存储结构 游戏中玩家的武器装备列表，随着游戏推进，玩家可能随时增加或删除，所以宜采用单链表结构 静态链表 背景：有些编程高级语言（e.g. Basic, Fortran）没有指针，这样链表结构就没法实现。 解决方案：用数组来代替指针，来描述单链表 实现：让数组元素都由两个数据域组成，data和cur。data用来存储数据元素，cur（游标）相当于单链表中的next指针，存放该元素的后继在数组中的下标。 定义：这种用数组描述的链表叫做静态链表。这种描述方法起名为游标实现法。 举例： 将 “甲乙丙丁戊己庚”存入静态链表： 优缺点： 优点： 再插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。 缺点： 没有解决连续存储分配带来的表长难以确定的问题 失去了顺序存储结构随机存储的特性 循环链表 定义：将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。 双向链表 定义：双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。 栈与队列 栈 定义：栈是限定仅在表尾进行插入和删除操作的线性表 描述：我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈又称为后进先出（Last In First Out）的线性表，简称 LIFO 结构。 举例：浏览器的前进后退，Photoshop 的前进撤销。 栈的顺序存储结构 操作： 栈的插入操作（push 压），叫作进栈，也称压栈、入栈。类似子弹入弹夹。 栈的删除操作（pop 弹），叫作出栈，也称弹栈。类似子弹出夹。 两栈共享空间 理解：两个相同类型的栈，为它们各自开辟了数组空间，极有可能第一个栈满，再进栈就溢出了，而另一个栈还有很多存储空间空闲。所以我们完全可以用一个数组来存储两个栈。 做法：数组的两个端点，让一个栈的栈底为数组的始端（下标0），另一个栈为栈的末端（n-1）。两栈如果增加元素，就是两端向中间延伸。 关键思路： \1. 两个top是数组两端的栈顶指针，只要它俩不见面，两个栈就都可以一直使用。 \2. 栈1为空时，就是top1等于-1时；当top2等于n时，即是栈2为空时。 \3. 何时栈满：top1等于n-1时栈1满；top2等于0时，栈2满，所以推导出，top1+1==top2为栈满 栈的链式存储结构 栈顶存放位置： 由于单链表有头指针，而栈顶指针也是必须的，所以把它俩合二为一，将栈顶放在单链表的头部。 不需要头结点： 都已经有了栈顶在头部，所以单链表的头结点也失去了意义，所以不需要头结点。 示意图： 栈的应用 #递归 #四则运算表达式求值 队列 定义：队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表 描述：队列是一种先进先出（First In First Out）的线性表，简称 FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。 举例：键盘的输入，记事本上的输出。 队列的顺序存储结构 缺点： 由于从队头出，导致后面元素都得向前移动，时间复杂度 O(n) 解决： 循环队列 让头尾相接 队列的链式存储结构 顺序存储和链式存储的选择 可以确定队列长度最大值时，建议循环队列 无法预估队列长度时，使用链队列 串 定义：是由零个或多个字符组成的有限序列，又名字符串 算法 朴素的模式匹配算法 从头开始依次往后比较【不推荐】 KMP模式匹配算法 数 定义： 树是 n(n&gt;=0) 个结点的有限集。n=0 时称为空树。在任意一棵非空树中： \1. 有且仅有一个特定的称为根（Root）的结点 \2. 当 n &gt; 1 时，其余结点可分为 m(m &gt; 0) 个互不相交的有限集 T1、T2 … 、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree） 结点分类 定义：结点拥有的子树数称为结点的度。度为 0 的结点称为叶结点或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根结点外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。下面树结点的度的最大值是结点 D 的度，为 3，所以树的度也为 3 。 结点间关系 树的其他相关概念 结点的层次 从根开始定义起，根为第一层。 树中结点的最大层次称为树的深度或高度，下图树深度为 4 树与线性表结构的对比 阿萨德 二叉树 定义：二叉树是 n(n&gt;=0)个结点的有限集合，该集合或为空集（称为空二叉树），或由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。 特点： 每个结点最多有两棵子树 左子树和右子树是有顺序的，次序不能任意颠倒 即使树中某结点只有一棵树，也要区分左右子树 特殊二叉树 #斜树 定义： 所有结点都在左子树的二叉树叫左斜树 所有结点都在右子树的二叉树叫右斜树 这种特殊树和线性表结构一样，所以线性表结构可以理解为是树的一种特殊形式 #满二叉树 #完全二叉树 定义：对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i (i &lt;= i &lt;= n) 的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中的位置完全相同，则这课二叉树称为完全二叉树。 如何判定：在看树时，心中默默给每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空挡，就说明不是完全二叉树，否则就是。 下面几个都不是： 9跟11之间有空挡 5跟8，9之间有空挡 9跟12之间有空挡 存储结构 二叉树顺序存储结构（适用于完全二叉树） 二叉链表 遍历二叉树 #二叉树遍历方法 前序遍历 遍历顺序：ABDGHCEIF 中序遍历 遍历顺序：GDHBAEICF 后序遍历 遍历顺序：GHDBIEFCA 层序遍历 遍历顺序：ABCDEFGHI 图]]></content>
      <categories>
        <category>后端</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决0.1+0.2不等于0.3的问题]]></title>
    <url>%2Fposts%2F21245%2F</url>
    <content type="text"><![CDATA[为何会出现此问题？总结一句话：这是因为二进制模拟十进制进行运算时的精度问题。 具体可查看 0.1 + 0.2不等于0.3？为什么JavaScript有这种“骚”操作？ 这篇掘金文章。 如何解决Number.EPSILON第一种方法是利用 Number.EPSILON ，这个值无限接近于0。0.1+0.2的精度误差在这个值的范围内：12345function numbersEqual(a,b)&#123; return Math.abs(a-b)&lt;Number.EPSILON;&#125;var a=0.1+0.2， b=0.3;console.log(numbersEqual(a,b)); //true 内置函数toFixed利用 parseFloat + 内置函数toFixed：123456function formatNum(num, fixed = 10) &#123; // a.toFixed(fixed) 先转为小数点10位的字符串 "0.3000000000" return parseFloat(a.toFixed(fixed)) // 然后通过parseFloat转为浮点数&#125;var a = 0.1 + 0.2;console.log(formatNum(a)); //0.3 内置函数toPrecision我平常用此函数来计算精度，具体可参考 Number.prototype.toPrecision() | MDN：123// 内置函数toPrecision(中文：精确，精度)// 参数是精度.比如5.1234，传2返回5.1，传1返回5；0.2+0.1传2返回0.30(0.1 + 0.2).toPrecision(10) == 0.3 // true]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise用法]]></title>
    <url>%2Fposts%2F7878%2F</url>
    <content type="text"><![CDATA[Promise是什么Promise 是一种异步编程的解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。 诞生的原因异步网络请求的回调地狱，而且我们还得对每次请求的结果进行一些处理，代码会更加臃肿。一张图完美诠释：不够？再加一张： Promise的三种状态 pedding 等待（默认状态。异步代码执行完毕后会转换为以下两种状态） resolve 成功 reject 失败 基本用法语法 Promise: 构造函数 接受一个参数：callback，我们把要执行的异步任务放置在这个callback中 then: Promise对象下的一个方法：该方法在Promise对象的状态发生改变的时候触发then的回调 12345678910111213//defined Promise async functionfunction asyncFun()&#123; return new Promise((resolve, reject) =&gt; &#123; if (resolve) &#123; resolve(/*resolve parameter*/); &#125;else&#123; reject(new Error(/*Error*/)); &#125; &#125;)&#125;//use Promise&amp;thenasyncFun().then(/*function*/).then(/*function*/)... Promise特性立即执行12345678910111213141516let p = new Promise((resolve, reject) =&gt; &#123; // 当Promise被实例化的时候，callback的异步任务就会被执行 console.log("一个Promise对象被创建出来"); resolve("success");&#125;);console.log("flag");p.then((data) =&gt; &#123; console.log(data);&#125;);// 执行结果：// 一个Promise对象被创建出来// flag// success 状态不可逆1234567891011let p = new Promise((resolve, reject) =&gt; &#123; resolve("success"); reject("reject");&#125;);p.then((data) =&gt; &#123; console.log(data);&#125;);// 执行结果：// success 链式调用12345678910111213141516171819let p = new Promise((resolve, reject) =&gt; &#123; // 通过传入的resolve, reject，去改变当前Promise任务的状态 // resolve, reject 是两个函数，调用 resolve ，会把状态改成 resolved ，调用 reject 函数会把状态改成 rejected setTimeout(() =&gt; &#123; console.log(1); reject(); &#125;, 1000);&#125;);// then接受两个参数：这两个参数都是回调，当对应的 promise 对象的状态变成了resolved，那么 then 的第一个 callback 就会被执行，如果状态变成了 rejected ，那么 then 的第二个 callback 就会被执行p.then(() =&gt; &#123; console.log('成功');&#125;, () =&gt; &#123; console.log('失败');&#125; );// 执行结果：// 1// 失败 then的回调异步性1234567891011121314151617let p = new Promise((resolve, reject) =&gt; &#123; console.log("我是Promise的callback中的代码"); setTimeout(() =&gt; &#123; resolve("我1s后才会被执行"); &#125;, 1000);&#125;);p.then((data) =&gt; &#123; console.log(data);&#125;);console.log("我是主线程中的同步代码");// 执行结果：// 我是Promise的callback中的代码// 我是主线程中的同步代码// 我1s后才会被执行 解释：Promise 的 callback 回调函数中的代码是立即执行的（setTimeout 这个定时器也是立即执行的，只是函数内的 resolve 被延迟1s执行，跟 Promise 本身的立即执行没关系），但 then 方法中的回调函数执行则是异步的，因此，&quot;我1s后才会被执行&quot; 会在最后输出。 异常的捕获Promise的异常有两种方法可以捕获，一种是 then 的第二个回调；一种 .catch() 来捕获前一个 Promise 抛出的错误。 123456789101112let p = new Promise((resolve, reject) =&gt; &#123; reject("error");&#125;);p.then(data =&gt; &#123; console.log("success")&#125;, error =&gt; &#123; console.log(error);&#125;);// 执行结果：// error 123456789101112let p = new Promise((resolve, reject) =&gt; &#123; reject("error");&#125;);p.then(data =&gt; &#123; console.log("success")&#125;).catch(error =&gt; &#123; console.log("catch:" + error);&#125;);// 执行结果：// catch:error Promise.all 和 Promise.racePromise.allPromise.all 接收一个参数，它必须是可以迭代的，例如数组。它通常用来处理一些并发的异步操作，即它们的结果互不干扰，但是又需要异步执行。当所有 Promise 都成功的时候，整个 Promise.all 才成功。成功调用后返回一个数组，数组的值是有序的，顺序就是传入参数的数组顺序： 成功的情况 123456789101112let arr = [1, 2, 3];let tasks = arr.map(num =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(num * 5); &#125;);&#125;);Promise.all(tasks).then(data =&gt; &#123; // 有序输出 console.log(arr); // [1, 2, 3] console.log(data); // [5, 10, 15]&#125;); 失败的情况 1234567891011121314151617let arr = [1, 2, 3];let tasks = arr.map(num =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; if (num === 3) &#123; reject('rejected'); &#125; resolve(num * 5); &#125;);&#125;);Promise.all(tasks).then(data =&gt; &#123; // 这里不会执行 console.log(arr); console.log(data);&#125;).catch(err =&gt; &#123; console.log(err); // rejected&#125;); Promise.racePromise.race 和 Promise.all 类似，都接收一个可以迭代的参数，但是不同之处是 Promise.race 的状态变化不是全部受参数内的状态影响，一旦参数内有一个值的状态发生的改变，那么该 Promise 的状态就是改变的状态。就跟 race 单词的字面意思一样，谁跑的快谁赢。 12345678910111213141516171819let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 300, 'p1 doned');&#125;);var p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 50, 'p2 doned');&#125;);var p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(reject, 100, 'p3 rejected');&#125;);Promise.race([p1, p2, p3]).then(data =&gt; &#123; // 显然p2更快，所以状态变成了fulfilled // 如果p3更快，那么状态就会变成rejected console.log(data); // p2 doned&#125;).catch(function(err) &#123; console.log(err); // 不执行&#125;);]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let和const和var的区别]]></title>
    <url>%2Fposts%2F37021%2F</url>
    <content type="text"><![CDATA[const 和 let 异同不同点 let 定义变量可以只声明不赋值 const 定义常量声明时必须赋值，一旦定义不可轻易改变 相同点解决 var 没有块作用域,、变量提升、可以重复声明的问题。 let 和 const 有自己的块作用域, 不存在变量提升问题, 同一块作用域中不可重复声明（会报错）。 let/const 和 var 区别 var 有变量提升，let/const 没有 let/const 的作用域是块，而 var 的作用域是函数 let/const 有暂时性死区，只要 let/const 声明的变量，在未声明之前使用或者赋值都会报错（ReferenceError） let/const 不能被重复定义]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数中的rest参数]]></title>
    <url>%2Fposts%2F29820%2F</url>
    <content type="text"><![CDATA[什么是 REST 参数REST参数翻译过来就是剩余参数，MDN上的定义是： 剩余参数语法允许我们将一个不定数量的参数表示为一个数组。 示例说明123456789101112131415161718192021function sum(...theArgs) &#123; return theArgs.reduce((previous, current) =&gt; &#123; return previous + current; &#125;);&#125;console.log(sum(1, 2, 3));// expected output: 6console.log(sum(1, 2, 3, 4));// expected output: 10// 下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们function multiply(multiplier, ...theArgs) &#123; return theArgs.map(function (element) &#123; return multiplier * element; &#125;);&#125;var arr = multiply(2, 1, 2, 3); console.log(arr); // [2, 4, 6] rest 参数和 arguments 对象的区别剩余参数和 arguments对象之间的区别主要有三个： 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。 arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。 arguments对象还有一些附加的属性 （如callee属性）。 arguments.callee 属性包含当前正在执行的函数。]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中如何实现继承]]></title>
    <url>%2Fposts%2F2751%2F</url>
    <content type="text"><![CDATA[组合继承（原型链 + 借用构造函数）12345678910111213141516171819202122232425262728// 组合继承:原型继承+借用（调用）构造函数继承function Person(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex;&#125;Person.prototype.sayHi = function () &#123; console.log("Hello world");&#125;;function Student(name, age, sex, score) &#123; // 借用构造函数 Person.call(this,name,age,sex); this.score = score;&#125;// 改变原型指向----继承// 我们让 Student.prototype 指向一个Person的实例对象// 这个对象的__proto__指向的是Person.prototype// 所以我们就可以借助这个实例对象拿到sayHi方法，实现继承Student.prototype=new Person();Student.prototype.eat = function () &#123; console.log("吃东西");&#125;;var stu = new Student("Lance", 20, "男", "100分");stu.sayHi();var stu2 = new Student("Jerry", 19, "男", "101分");stu2.eat();//属性和方法都被继承了 寄生组合继承（组合继承升级版）123456789101112131415161718192021222324252627282930function object(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); // 创建了父类原型的浅复制 prototype.constructor = subType; // 修正原型的构造函数 subType.prototype = prototype; // 将子类的原型替换为这个原型&#125; function SuperType(name)&#123; this.name = name; this.colors = ["red", "blue", "green"];&#125; SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;; function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;// 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; alert(this.age);&#125; ES6继承写法12345678910class Person &#123; constructor(name, age) &#123;this.name=name;this.age=age&#125; sayHi() &#123;&#125;&#125;class Student extends Person &#123; constructor(name, age, weight) &#123; super(name, age); this.weight = weight; &#125; run() &#123;&#125;&#125; 在原型链继承时，为什么不直接 Student.prototype = Person.prototype ？因为对象的赋值只是引用的赋值, 上面两者都指向同一个内存地址，只要随便通过1个途径就能修改该内存地址的对象，这样子类就无法单独扩展方法，而且会影响父类。 组合继承的缺点缺点就是调用了两次父类的构造函数。第一次给子类的原型添加了父类构造函数中的属性方法；第二次又给子类的构造函数添加了父类的构造函数的属性方法，从而覆盖了子类原型中的同名参数。这种被覆盖的情况造成了性能上的浪费：1234567891011121314function SuperType() &#123; this.name = 'parent'; this.arr = [1, 2, 3];&#125; SuperType.prototype.say = function() &#123; console.log('this is parent')&#125; function SubType() &#123; SuperType.call(this) // 第二次调用SuperType&#125; SubType.prototype = new SuperType() // 第一次调用SuperType]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对this指向的判定]]></title>
    <url>%2Fposts%2F33207%2F</url>
    <content type="text"><![CDATA[对 this 的理解对于this指向的判定，时刻记住下面两点就好： 普通函数的 this 指向是在函数的执行期间绑定的，换句话说 this 总是指向函数的直接调用者 箭头函数的 this 指向是在函数创建期间就绑定好了的，指向的是创建该箭头函数所在的作用域对象 普通函数中的this这里直接引用 You-Dont-Know-JS 中对 this 的判定步骤： 函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。var bar = new foo() 函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。var bar = foo.call( obj2 ) 函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。var bar = obj1.foo() 否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。var bar = foo() 常见this指向 普通函数中this ——&gt; window 构造函数中this ——&gt; new出来的实例对象 方法中的this ——&gt; 实例对象 原型中的方法中的this ——&gt; 实例对象 定时器中的this ——&gt; window]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的遍历方法]]></title>
    <url>%2Fposts%2F64478%2F</url>
    <content type="text"><![CDATA[下面是总结的数组遍历的常见方法 for循环 标准for循环 forEach((当前值, 当前索引, 当前数组) =&gt; {…}, [, 绑定的this])` 无法中途退出循环，只能用 return 退出本次回调，进行下一次回调 它总是返回 undefined 值，即使你 return 了一个值 for…in（不推荐）会把继承链的对象属性都会遍历一遍，而且数组遍历不一定按次序 for-in 循环返回的是所有能通过对象访问的、可枚举的属性 for (variable of iterable)（ES6）可迭代Array，Map，Set，String等（迭代的是值value） 在 for..of 中如果遍历中途要退出，可以使用 break 退出循环 ES5 map (不改变原数组) 会给原数组中的每个元素都按顺序调用一次 callback 函数 reduce (不改变原数组) 数组中的前项和后项做某种计算,并累计最终值。 123456789// 语法：// arr.reduce(function(total, currentValue, currentIndex, arr), initialValue)// callback 参数// (累积器, 当前元素, 当前元素索引, 当前数组)// initialValue:指定第一次回调 的第一个参数var wallets = [4, 7.8, 3]var totalMoney = wallets.reduce(function (countedMoney, curMoney) &#123; return countedMoney + curMoney;&#125;, 0) filter (不改变原数组) 1234var arr = [2, 3, 4, 5, 6]var morearr = arr.filter(function (number) &#123; return number &gt; 3&#125;) // [4,5,6] every (不改变原数组) 测试数组的所有元素是否都通过了指定函数的测试 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测 如果所有元素都满足条件，则返回 true 1234var arr = [1,2,3,4,5]var result = arr.every(function (item, index) &#123; return item &gt; 2&#125;) // false some (不改变原数组) 测试是否至少有一个元素通过 callback 中的条件。对于放在空数组上的任何条件，此方法返回 false 如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测 如果没有满足条件的元素，则返回false 12345678// some(callback, thisArg)// callback:// (当前元素, 当前索引, 调用some的数组)var arr = [1,2,3,4,5]var result = arr.some(function (item,index) &#123; return item &gt; 3&#125;) // true ES6 find() &amp; findIndex() 根据条件找到数组成员 find 定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回 undefined findIndex 定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 123456789101112// 语法let new_array = arr.find(function(currentValue, index, arr), thisArg)let new_array = arr.findIndex(function(currentValue, index, arr), thisArg)// 这两个方法都可以识别NaN,弥补了indexOf的不足// findlet a = [1, 4, -5, 10].find((n) =&gt; n &lt; 0); // 返回元素-5let b = [1, 4, -5, 10,NaN].find((n) =&gt; Object.is(NaN, n)); // 返回元素NaN// findIndexlet a = [1, 4, -5, 10].findIndex((n) =&gt; n &lt; 0); // 返回索引2let b = [1, 4, -5, 10,NaN].findIndex((n) =&gt; Object.is(NaN, n)); // 返回索引4 keys() &amp; values() &amp; entries() 遍历键名、遍历键值、遍历键名+键值 三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值 1234567891011121314151617181920// 语法array.keys() array.values() array.entries()for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b"]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[null 和 undefined 的区别]]></title>
    <url>%2Fposts%2F63928%2F</url>
    <content type="text"><![CDATA[含义 null 表示一个对象是“没有值”的值，也就是值为“空” undefined 表示一个变量声明了没有初始化(赋值) 类型 undefined 的类型(typeof)是 undefined null 的类型(typeof)是 object 双等三等另外，在验证 null 时，一定要使用 === ，因为 == 无法分辨 null 和 undefined ：12null == undefined // true null === undefined // false 总结undefined 变量提升：只声明未定义默认值就是 undefined 严格模式下：没有明确的执行主体，this 就是 undefined 对象没有这个属性名，属性值是 undefined 函数定义形参不传值，默认就是 undefined 函数没有返回值（没有 return 或者 return; ），默认返回的就是 undefined 数组越界取值也是 undefined （arr=[1,2]; arr[10] =&gt; undefined） … null 手动设置变量的值或者对象某个属性值为null（此时不赋值，后面会赋值） 在 JS 的 DOM 元素获取中，如果没有获取到指定的元素对象，结果一般都是null Object.prototype.proto 的值也是 null 正则捕获的时候，如果没有捕获到结果，默认也是null … 其他Javascript会将未赋值的变量默认值设为undefined；Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对闭包的理解]]></title>
    <url>%2Fposts%2F29980%2F</url>
    <content type="text"><![CDATA[什么是闭包我一直认为，MDN是前端学习的在线指南。只要有不懂的语法，或者不懂的概念，查找资料的首选就应该是它。虽然早些年做iOS开发的时候就就接触过闭包，但如今已经忘得一干二净，所以在想要了解闭包的时候，第一件事就是在MDN中搜索。其中给到了一个闭包的例子： 12345678910function makeFunc() &#123; var name = "Mozilla"; // name 是一个被 init 创建的局部变量 function displayName() &#123; // displayName() 是内部函数,一个闭包 alert(name); // 使用了父函数中声明的变量 &#125; return displayName; // 返回 displayName 这个函数&#125;var myFunc = makeFunc();myFunc(); // 当执行myFunc时，其实调用了displayName，会弹窗显示"Mozilla" 在上面这个例子中，一个函数套了一个函数，且这个内部函数使用到了外部函数中的变量，这个时候就形成了闭包。有什么用呢？其中一个用处就如上面代码所示，能够让 makeFunc 函数外面也能访问 name 这个局部变量。换句话说，闭包缓存了数据，延长了作用域链。 Kyle Simpson编写的You-Dont-Know-JS中对闭包的总结我觉得很精髓： 闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。 闭包的特性 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 闭包的用途读取正确的值一个经典的例子，给 ul&gt;li 下面的每个 li 节点添加点击事件，让其弹出当前 li 元素的索引：1234567891011121314&lt;ul id="testUL"&gt; &lt;li&gt; index = 0&lt;/li&gt; &lt;li&gt; index = 1&lt;/li&gt; &lt;li&gt; index = 2&lt;/li&gt; &lt;li&gt; index = 3&lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var nodes = document.getElementsByTagName("li"); for (var i = 0; i &lt; nodes.length; i += 1) &#123; nodes[i].onclick = function () &#123; console.log(i); &#125; &#125;&lt;/script&gt; 运行上述代码后就会发现，每次打印的结果都显示为4，而不是真正的索引值。这是因为点击事件的匿名函数发生在for循环之后，而for循环执行完毕时 i 的值就为4，所以点谁都是同样的结果。那么这个时候就能通过立即执行函数 + 闭包的方法解决此问题： 1234567891011&lt;script type="text/javascript"&gt; var nodes = document.getElementsByTagName("li"); for (var i = 0; i &lt; nodes.length; i += 1) &#123; nodes[i].onclick = (function (i) &#123; // 1. IIFE创建一个函数作用域 return function () &#123; // 4. 返回这个匿名函数，延长作用域链 // 3. 内部嵌套的匿名函数使用到了IIFE的参数i，形成闭包 console.log(i); &#125; &#125;)(i); // 2. 给IIFE传递每次for循环的i &#125;&lt;/script&gt; 这个时候触发click事件，打印的值就是li元素的索引了。 高级排他这个例子有点像上面的，现在我们要个需求：在一个 ul li 列表中，鼠标移入时高亮当前li标签，移除之前li标签的高亮状态。 常规写法如下： 12345678910111213141516// 假设给li添加active类可以让标签高亮window.onload = function() &#123; let list = document.querySelectorAll('li') // 遍历每个标签 for (let i = 0; i &lt; list.length; i++) &#123; const li = list[i] li.onmouseover = function() &#123; // mouseover触发后遍历整个列表，将所有标签class设为空 for (let j = 0; j &lt; list.length; j++) &#123; list[j].className = '' &#125; // 最后给当前li标签添加active this.className = 'active' &#125; &#125; &#125; 上面的代码能够实现功能，然而一旦列表非常长性能就不高，所以可以利用闭包来缓存li标签的索引，使其与标签一一对应： 123456789101112131415161718window.onload = function() &#123; let list = document.querySelectorAll('li') // 记录上一次选中的li标签的对应索引 let preActiveIndex = 0 for (let i = 0; i &lt; list.length; i++) &#123; (function(j) &#123; const li = list[i] li.onmouseover = function() &#123; // 清除上次li标签的高亮 list[preActiveIndex].className = '' // 设置当前位高亮 this.className = 'active' // 赋值 preActiveIndex = j &#125; &#125;)(i) &#125;&#125; 模块化开发在团队开发中，为了避免命名冲突通常不同成员会把自己的代码单独封装起来，最后return一个对象出去，挂载到window上。这样其他人也可以使用，而且能在一定程度上避免命名冲突： 1234567891011121314151617(function(w) &#123; var money = 1000; function get() &#123; money *= 10 console.log("赚了一笔钱，总资产：" + money + "元") &#125; function send() &#123; money-- console.log("花了一笔钱，总资产：" + money + "元") &#125; // 向外暴露对象 w.myTools = &#123; get, set &#125;&#125;)(window) 函数节流防抖在日常开发中，我们也经常用到函数节流与防抖，通常我们会将它们封装为函数，这样可以在需要的地方直接调用使用，还不会污染全局： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;防抖节流&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="input" type="text"&gt; &lt;!-- 函数防抖 --&gt; &lt;script&gt; function debounce(fn, delay) &#123; var timer = null return function() &#123; var ctx = this, args = arguments if (timer) &#123; window.clearTimeout(timer) &#125; timer = setTimeout(function() &#123; fn.apply(ctx, args) timer = null &#125;, delay); &#125; &#125; // 搜索框做函数防抖避免用户高频输入内容 input.addEventListener('input', debounce(function(e) &#123; console.log(e.target.value) &#125;, 500)) &lt;/script&gt; &lt;!-- 函数节流 --&gt; &lt;script&gt; function throttle(fn, delay) &#123; var canUse = true return function() &#123; var ctx = this, args = arguments if (canUse) &#123; fn.apply(ctx, args) canUse = false setTimeout(() =&gt; &#123; canUse = true &#125;, delay); &#125; &#125; &#125; // 对于像onresize这样的高频事件，可以使用函数节流让其回调函数中的代码隔一段时间再次执行 window.onresize = throttle(function(e) &#123; input.value = Math.random() * 100 &#125;, 1000) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 内存泄漏其实闭包并不会造成内存泄漏，现在的垃圾回收机制已经很成熟了。但早期的IE（ie4-ie6）版本里，对宿主对象（也就是document对象）采用是引用计数的垃圾回收机制，闭包导致内存泄漏的一个原因就是这个算法的一个缺陷。循环引用会导致没法回收，这个循环引用只限定于有宿主对象参与的循环引用，而js对象之间即使形成循环引用，也不会产生内存泄漏，因为对js对象的回收算法不是计数的方式： 12345678910111213141516171819202122232425function closure()&#123; var oDiv = document.getElementById('oDiv');//oDiv用完之后一直驻留在内存中 oDiv.onclick = function () &#123; alert('oDiv.innerHTML');//这里用oDiv导致内存泄露 &#125;;&#125;// 以上代码创建了一个作为 div 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。// 由于匿名函数保存了一个对closure()的活动对象的引用，因此就会导致无法减少 div 的引用数。// 只要匿名函数存在，element 的引用数至少也是1，因此它所占用的内存就永远不会被回收closure();//最后应将oDiv解除引用来避免内存泄露function closure()&#123; var oDiv = document.getElementById('oDiv'); var test = oDiv.innerHTML; oDiv.onclick = function () &#123; alert(test); &#125;; oDiv = null;&#125;// 解决办法: 把 oDiv.innerHTML 的一个副本保存在一个变量中，// 从而消除闭包中该变量的循环引用,同时将 oDiv 变量设为null。 所以我们要保持良好的编程习惯，在使用完闭包后记得释放内存： 123456789101112function fn1() &#123; var arr = new Array(9999999999999) function fn2() &#123; console.log(arr) &#125; return fn2&#125;var f = fn1()f() // 调用完后没有释放，arr就会一直在内存中占着，导致内存泄漏// 记得释放f = null]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组有哪些常用方法]]></title>
    <url>%2Fposts%2F21501%2F</url>
    <content type="text"><![CDATA[改变原数组的方法splice() 添加/删除数组元素 splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目 array.splice(index,howmany,item1,…..,itemX) index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX： 可选。向数组添加的新项目。 返回值: 如果有元素被删除,返回包含被删除项目的新数组。 删除元素1234567// 从数组下标0开始，删除3个元素let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0, 3); // [1,2,3]console.log(a); // [4,5,6,7]// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7let item = a.splice(-1, 3); // [7] 删除并添加123456789// 从数组下标0开始，删除3个元素，并添加元素'添加'let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0,3,'添加'); // [1,2,3]console.log(a); // ['添加',4,5,6,7]// 从数组最后第二个元素开始，删除3个元素，并添加两个元素'添加1'、'添加2'let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-2,3,'添加1','添加2'); // [6,7]console.log(b); // [1,2,3,4,5,'添加1','添加2'] 不删除只添加1234567let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0,0,'添加1','添加2'); // [] 没有删除元素，返回空数组console.log(a); // ['添加1','添加2',1,2,3,4,5,6,7]let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-1,0,'添加1','添加2'); // [] 没有删除元素，返回空数组console.log(b); // [1,2,3,4,5,6,'添加1','添加2',7] 在最后一个元素的前面添加两个元素 sort() 数组排序 定义: sort()方法对数组元素进行排序，并返回这个数组。 参数可选: 规定排序顺序的比较函数。 默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用toString()方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。 不传参1234567// 字符串排列 看起来很正常var a = ["Banana", "Orange", "Apple", "Mango"];a.sort(); // ["Apple","Banana","Mango","Orange"]// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的var a = [10, 1, 3, 20,25,8];console.log(a.sort()) // [1,10,20,25,3,8]; 比较函数的两个参数： sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素： 若比较函数返回值&lt;0，那么a将排到b的前面; 若比较函数返回值=0，那么a 和 b 相对位置不变； 若比较函数返回值&gt;0，那么b 排在a 将的前面； 数字升降序12345678910var array = [10, 1, 3, 4, 20, 4, 25, 8]; array.sort(function(a,b)&#123; return a-b;&#125;);console.log(array); // [1,3,4,4,8,10,20,25];array.sort(function(a,b)&#123; return b-a;&#125;);console.log(array); // [25,20,10,8,4,4,3,1]; pop() 删除一个数组中的最后的一个元素 定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。 123let a = [1,2,3];let item = a.pop(); // 3console.log(a); // [1,2] shift() 删除数组的第一个元素 定义: shift()方法删除数组的第一个元素，并返回这个元素。 123let a = [1,2,3];let item = a.shift(); // 1console.log(a); // [2,3] push() 向数组的末尾添加元素 定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 参数: item1, item2, …, itemX ,要添加到数组末尾的元素 123let a = [1,2,3];let item = a.push('末尾', '233'); // 5console.log(a); // [1,2,3,'末尾', '233'] unshift() 定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。 参数: item1, item2, …, itemX ,要添加到数组开头的元素 123let a = [1, 2, 3];let item = a.unshift('开头', '开头2'); // 5console.log(a); // [ '开头', '开头2', 1, 2, 3 ] reverse() 颠倒数组中元素的顺序 定义: reverse() 方法用于颠倒数组中元素的顺序。 123let a = [1,2,3];a.reverse(); console.log(a); // [3,2,1] 不改变原数组的方法slice() 浅拷贝数组的元素 定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。 语法：array.slice(begin, end); 12345678910111213let a= ['hello','world'];let b=a.slice(0,1); // ['hello']// 新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。// 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。a[0]='改变原数组';console.log(a,b); // ['改变原数组','world'] ['hello']let a= [&#123;name:'OBKoro1'&#125;];let b=a.slice();console.log(b,a); // [&#123;"name":"OBKoro1"&#125;] [&#123;"name":"OBKoro1"&#125;]// a[0].name='改变原数组';// console.log(b,a); // [&#123;"name":"改变原数组"&#125;] [&#123;"name":"改变原数组"&#125;] join() 数组转字符串 定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。 语法: array.join(str) 12345678910111213let a= ['hello','world'];let str=a.join(); // 'hello,world'let str2=a.join('+'); // 'hello+world'let a= [['OBKoro1','23'],'test'];let str1=a.join(); // OBKoro1,23,testlet b= [&#123;name:'OBKoro1',age:'23'&#125;,'test'];let str2 = b.join(); // [object Object],test// 对象转字符串推荐JSON.stringify(obj);// 结论：// join()/toString()方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),// 如果是对象的话，对象会被转为[object Object]字符串。 join() 数组转字符串 定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。 语法: array.join(str) 12345678910111213let a= ['hello','world'];let str=a.join(); // 'hello,world'let str2=a.join('+'); // 'hello+world'let a= [['OBKoro1','23'],'test'];let str1=a.join(); // OBKoro1,23,testlet b= [&#123;name:'OBKoro1',age:'23'&#125;,'test'];let str2 = b.join(); // [object Object],test// 对象转字符串推荐JSON.stringify(obj);// 结论：// join()/toString()方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),// 如果是对象的话，对象会被转为[object Object]字符串。 concat 定义： 方法用于合并两个或多个数组，返回一个新数组。 语法：var newArr =oldArray.concat(arrayX,arrayX,……,arrayX) 参数：arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。 1234567891011121314let a = [1, 2, 3];let b = [4, 5, 6];//连接两个数组let newVal=a.concat(b); // [1,2,3,4,5,6]// 连接三个数组let c = [7, 8, 9]let newVal2 = a.concat(b, c); // [1,2,3,4,5,6,7,8,9]// 添加元素let newVal3 = a.concat('添加元素',b, c,'再加一个'); // [1,2,3,"添加元素",4,5,6,7,8,9,"再加一个"]// 合并嵌套数组 会浅拷贝嵌套数组let d = [1,2 ];let f = [3,[4]];let newVal4 = d.concat(f); // [1,2,3,[4]] ES6扩展运算符...合并数组123let a = [2, 3, 4, 5]let b = [ 4,...a, 4, 4]console.log(a,b); // [2, 3, 4, 5] [4,2,3,4,5,4,4] indexOf() 查找数组是否存在某个元素，返回下标 定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 p.s. 字符串也有此方法，要注意当 ‘lance’.indexOf(‘’) 一个空字符串时，返回0而不是-1 语法：array.indexOf(searchElement,fromIndex) 参数： searchElement(必须):被查找的元素 fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。 严格相等的搜索: 数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等===搜索元素，即数组元素要完全匹配才能搜索成功。 注意：indexOf()不能识别NaN 1234let a=['啦啦',2,4,24,NaN]console.log(a.indexOf('啦')); // -1 console.log(a.indexOf('NaN')); // -1 console.log(a.indexOf('啦啦')); // 0 lastIndexOf() 查找指定元素在数组中的最后一个位置 定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找） 语法：arr.lastIndexOf(searchElement,fromIndex) 参数: searchElement(必须): 被查找的元素 fromIndex(可选): 逆向查找开始位置，默认值数组的 长度-1，即查找整个数组。 关于fromIndex有三个规则: 正值。如果该值大于或等于数组的长度，则整个数组会被查找。 负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找) 负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 12345let a=['OB',4,'Koro1',1,2,'Koro1',3,4,5,'Koro1']; // 数组长度为10// let b=a.lastIndexOf('Koro1',4); // 从下标4开始往前找 返回下标2// let b=a.lastIndexOf('Koro1',100); // 大于或数组的长度 查找整个数组 返回9// let b=a.lastIndexOf('Koro1',-11); // -1 数组不会被查找let b=a.lastIndexOf('Koro1',-9); // 从第二个元素4往前查找，没有找到 返回-1 ES7 includes() 查找数组是否包含某个元素 返回布尔 定义： 返回一个布尔值，表示某个数组是否包含给定的值 语法：array.includes(searchElement,fromIndex=0) 参数： searchElement(必须):被查找的元素 fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。 includes方法是为了弥补indexOf方法的缺陷而出现的: indexOf方法不能识别NaN indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观 12345let a=['OB','Koro1',1,NaN];// let b=a.includes(NaN); // true 识别NaN// let b=a.includes('Koro1',100); // false 超过数组长度 不搜索// let b=a.includes('Koro1',-3); // true 从倒数第三个元素开始搜索 // let b=a.includes('Koro1',-100); // true 负值绝对值超过数组长度，搜索整个数组]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去除图片上下左右间隙]]></title>
    <url>%2Fposts%2F31251%2F</url>
    <content type="text"><![CDATA[情景当在定宽父容器下有多张图片顺序排列时，图片的上下左右之间都有间隙： See the Pen KEBmRP by JingW (@JingW) on CodePen. 原因 左右：因为 img 是 inline-block 元素，元素代码之间有『换行（回车），空格，tab』时会产生左右间隙。 上下：行内元素默认与父容器基线对齐，而基线与父容器底部有一定间隙，所以上下图片间有间隙。 解决方案 移除上下间隙： img本身设置 display: block; 父元素设置 font-size: 0; （基线与字体大小有关，字体为零，基线间就没距离了） img本身设置 vertical-align: bottom;（让inline-block 的 img 与每行的底部对齐） 移除左右间距： 行内元素间不要有换行，连成一行写消除间隙（阅读性差，不推荐） 第一行img结尾写上 &lt;!-- ，第二行img开头跟上 --&gt; 。即利用注释消除间距 父元素 font-size: 0]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何清除浮动]]></title>
    <url>%2Fposts%2F12906%2F</url>
    <content type="text"><![CDATA[为什么要清除浮动其实浮动（e.g. float: left;）本质上是用来做文字混排的，但却被我们拿来做布局，这个时候虽然实现了某些效果，但也带来了不少副作用。 由于浮动元素不再占有原文档流的位置，所以它会对后续元素的排版带来影响（无视浮动元素，就当它不存在过）。因此我们很多时候要做的，就是消除浮动元素造成的影响。清除浮动的本质主要是为了解决父元素因为子元素浮动造成的内部高度为0的问题。 clear清除浮动的核心css属性是 clear ，基本语法如下： 123选择器: &#123; clear: 属性值;&#125; 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 清除浮动常见方案额外标记法在浮动元素后面添加一个空标签，例如： 12&lt;div style="float: left;"&gt;&lt;/div&gt;&lt;div style="clear: both;"&gt;&lt;/div&gt; 优点：通俗易懂，书写方便缺点：加入了过多的没有实际含义的额外标签，结构化差。 父元素添加overflow通过触发BFC达到清除浮动的效果。（p.s. 对bfc不了解可以看这篇文章） 123.parent &#123; overflow: hidden;&#125; 优点：代码简洁缺点：超出的内容会被隐藏 before和after双伪元素方案1234567891011.clearfix:before,.clearfix:after &#123; content:""; display: table; /* 触发BFC清除浮动 */&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 优点：代码简洁缺点：IE6-7不支持:after，需要使用 zoom: 1 触发 hasLayout 使用after伪元素（我平常使用的）1234567891011.clearfix::after &#123; content: "."; display: block; height: 0; visibility: hidden; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; /* IE6、7 专有 */ 使用方式：给浮动元素的父元素添加一个class类：clearfix优点：一次书写多处使用，并且符合闭合浮动思想，结构语义化正确缺点：IE6-7不支持:after，需要使用 zoom: 1 触发 hasLayout注意：content:&quot;.&quot; 内容尽量不为空，可以跟一个小点，否则在firefox 7.0前的版本会生成空格 :after 和 ::after 的区别:before、:after 在旧版本里是伪元素，CSS3的规范里 “:” 用来表示伪类，”::” 用来表示伪元素，但是在高版本浏览器下 :before、:after 会被自动识别为 ::before、::after ，这样做的目的是用来做兼容处理。 相同点伪类对象，用来设置对象前的内容:before 和 ::before 写法是等效的 不同点:before 是 css2 的写法，::before 是 css3 的写法:before 兼容性比 ::before要好 注意伪类元素必须要配合 content 属性一起使用，否则无效伪类元素是css渲染层加入的，不能通过js来操作]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>清除浮动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC的理解与应用]]></title>
    <url>%2Fposts%2F9722%2F</url>
    <content type="text"><![CDATA[定义先上MDN上对 BFC 的定义： 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 ———— BFC | MDN 不知道别人看完这段定义有何感受，反正我是懵逼的。不过我在这儿还是建议各位认真阅读上面给出的MDN链接至少两遍，这能让你对一个陌生的概念有一个基本的认知。 理解这里谈下我对BFC的理解：BFC其实是一个独立的，与外界隔离了的容器，容器里面的子元素不会影响到外面的元素，外面的也同样不会影响到容器内部的元素。我们可以利用这个特性，来解决一些布局上的问题。 BFC触发条件BFC的触发条件有很多，想要知道所有细节可以移步上面给出的 MDN 链接。这里我只列出一些常见触发条件： 根元素（HTML元素） 浮动元素（float不为none） 绝对定位元素（position 为 absolute 或 fixed） display 为 block, inline-block, flex, inline-flex, list-item, table overflow 值不为 visible 的块元素 BFC布局特性对于一个BFC容器来说： 内部相邻的两个元素垂直方向上的 margin 会发生重叠 不会与外界的浮动元素产生交集，而是紧贴浮动元素的边缘 元素从容器的顶端开始垂直地一个接一个地排列 每一个元素的左外边缘（margin-left）会触碰到容器的左边缘（border-left）（如果设置了容器内部的元素从右到左的格式排布，则触碰的是右边缘） 在计算它的高度时，还会检测内部浮动或者定位元素的高度 实际应用清除浮动利用BFC “在计算它的高度时，还会检测内部浮动或者定位元素的高度” 这条特性，我们可以触发父元素的BFC来清除子元素浮动带来的影响。常见的用法是给父元素设置 overflow: hidden 样式（如果考虑IE6版本，还需设置 zoom: 1，因为IE6不支持 overflow: hidden 来清除浮动）： See the Pen 利用BFC清除浮动 by JingW (@JingW) on CodePen. 解决外边距合并问题如果看上面标题不知道在说什么，请很戳这里了解详情。由于属于同一个BFC的两个相邻盒子的垂直margin会发生重叠，那么我们可以隔离开这两个元素，让它们不属于同一个BFC，这样就不会发生margin重叠了。 See the Pen 解决外边距合并问题 by JingW (@JingW) on CodePen. 两栏布局，右边宽度自适应我们常常在开发中有这样类似的需求：两栏布局，左边定宽，右边自适应。这时我们就可以利用BFC特性来实现需求：左边设置定宽+左浮动；右边给自己加上 overflow: hidden 。原理就是：给元素设置BFC后，为了和浮动元素不产生任何交集，它会顺着浮动元素的边缘形成自己的封闭上下文。直接上代码看效果： See the Pen 利用BFC实现两栏布局 by JingW (@JingW) on CodePen. 以上是我对BFC的一些理解以及实际应用，希望能够帮助大家了解BFC这个听起来摸不着头脑的东西。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三栏布局方案(圣杯+双飞翼)]]></title>
    <url>%2Fposts%2F55613%2F</url>
    <content type="text"><![CDATA[圣杯布局步骤一 - HTML框架搭建 &amp; 初始化CSS首先把基本框架搭起来（注意中间部分放最前面）： 12345&lt;div class="container"&gt; &lt;div class="center"&gt;我是中间&lt;/div&gt; &lt;div class="left"&gt;我是左边&lt;/div&gt; &lt;div class="right"&gt;我是右边&lt;/div&gt;&lt;/div&gt; 接下来是初始化样式。left, right宽度分别设置为100px和200px；然后设置container的 padding-left: 100px + padding-right: 200px 来占据两侧填充；center宽度设为100%，这样能够自适应剩下的宽度。再让所有子元素左浮动。代码如下： 12345678910111213141516171819202122232425.container &#123; padding: 0 200px 0 100px; /* 左边100， 右边200*/ background-color: #e1e1e1; height: 300px; /* 为了看效果，给个300px把高度撑起来 */&#125;.left, .center, .right &#123; float: left; height: 100%;&#125;.center &#123; width: 100%; /* 占据父元素剩下的宽度*/ background-color: lightblue;&#125;.left &#123; width: 100px; background-color: pink;&#125;.right &#123; width: 200px; background-color: yellow;&#125; 此时的页面效果： 步骤二 - 让left占据最左列为了让left能越过center，我们先给它设置一个 -100% 的左边距。这个100%是在container中的宽度，也就是center的宽度： 123456.left &#123; margin-left: -100%; width: 100px; /*为了看left和center的重叠效果，暂时bgc设为半透明*/ background-color: rgba(255,204,204,.6);&#125; 页面效果： 此时，我们已经让left从“第二行”升到了“第一行”，为了让它靠到最左侧，不与center重叠，可以给它设置相对定位，然后给个 left: -100px ，让它定位到container最左侧： 123456789.left &#123; /* 设置相对定位 */ position: relative; /* 靠到最左侧 */ left: -100px; margin-left: -100%; width: 100px; background-color: pink;&#125; 页面效果： 步骤三 - 让right占据最右列定位好了left，也是时候让right呆在最右边来填充位置了，我们继续使用负margin： 12345.right &#123; width: 200px; margin-right: -200px; background-color: yellow;&#125; 页面效果： 步骤四 - 给container设置min-width看起来已经实现了不是吗？但我们还差最后一步，给container设置一个 min-width: 100px （就是左列的宽度），否则当浏览器缩小到一定程度时，这个布局可能会被破坏。原因简单来讲就是：“由于设置了相对定位，所以当left原来的位置和right的位置产生重叠时，由于浮动的原因一行放不下就会换行”。所以布局就被打乱了。 123456.container &#123; min-width: 100px; background-color: #e1e1e1; padding: 0 200px 0 100px; height: 300px;&#125; 完整代码 + 最终效果这样，我们就实现了圣杯布局，完整代码和效果见下： See the Pen 三栏布局 - 圣杯布局 by JingW (@JingW) on CodePen. 双飞翼布局如果上面圣杯布局你已经理解并自己实践了一遍，那么这里的双飞翼布局你也应该不再话下。跟着我一起撸一遍代码吧。 步骤一 - HTML框架搭建 &amp; 初始化CSS首先搭建html，仔细观察下方代码你会发现，双飞翼布局在html上面有一点和圣杯布局有差别，那就是双飞翼在center里又套了一个div。到后面你就会知道这样设置的目的。 12345&lt;div class="container"&gt; &lt;div class="center"&gt;&lt;div&gt;我是中间&lt;/div&gt;&lt;/div&gt; &lt;div class="left"&gt;我是左边&lt;/div&gt; &lt;div class="right"&gt;我是右边&lt;/div&gt;&lt;/div&gt; 然后编写初始样式。left定宽100；right定宽200；left, right, center全部设置左浮动。其他例如设置颜色高度等等直接看下方代码： 1234567891011121314151617181920212223.container &#123; background-color: #e1e1e1; height: 300px;&#125;.center &#123; background-color: lightblue;&#125;.left &#123; width: 100px; background-color: pink;&#125;.right &#123; width: 200px; background-color: yellow;&#125;.left, .center, .right &#123; float: left; height: 100%;&#125; 效果如下： 步骤二 - 设置center为100%宽将center的宽度设为100%，这样会把left，right“挤”到第二行： 1234.center &#123; width: 100%; background-color: lightblue;&#125; 效果如下： 步骤三 - 分别让left,right回到最左边和最右边接着，给left设置 margin-left: -100% 回到最左边，给right设置 margin-left: -200px 回到最右边。此时center和left,right都有重叠区域，为了看效果，设置了半透明背景颜色。 1234567891011.left &#123; width: 100px; margin-left: -100%; background-color: pink;&#125;.right &#123; width: 200px; margin-left: -200px; background-color: yellow;&#125; 效果如下： 步骤四 - 给center的子div设置左右margin其实上面的效果图已经实现了三栏布局中间自适应。但有个问题是center左右部分区域会被遮挡，这个时候在步骤一提到的center子div的作用就体现出来了，我们可以给它设置一个左右的margin值，分别等于left的宽和right的宽，消除掉重叠的副作用。 1234.center div &#123; /* 左margin100，右margin200 */ margin: 0 200px 0 100px;&#125; 效果如下： 步骤五 - 给container设置min-width最后，给container设置一个min-width，让container最小宽度不小于left宽+right宽 12345.container &#123; min-width: 300px; background-color: #e1e1e1; height: 300px;&#125; 大功告成~ 完整代码 + 最终效果 See the Pen 三栏布局 - 双飞翼布局 by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两栏布局方案汇总]]></title>
    <url>%2Fposts%2F44541%2F</url>
    <content type="text"><![CDATA[记录下常见的两栏布局方式。 左边定宽，右边自适应模拟table父元素 display: table ，子元素左右 table-cell ，左边定宽。 See the Pen 两栏布局（左定右自适应）模拟table by JingW (@JingW) on CodePen. 左浮 + 右Margin子元素的左边浮动脱标，右边设置 margin-left: 左边元素宽度 See the Pen 两栏布局（左定右自适应）子元素绝对定位 by JingW (@JingW) on CodePen. 左浮 + 右BFC子元素左边设置浮动+定宽，右边子元素设置 overflow: hidden 触发自身BFC See the Pen 两栏布局（左定右自适应）左浮 + 右BFC by JingW (@JingW) on CodePen. 子绝父相子绝父相，左边 top, left: 0，右边 top, right: 0，left等于左边宽度。 See the Pen 两栏布局（左定右自适应）子绝父相 by JingW (@JingW) on CodePen. flex布局父元素 display: flex ，左边定宽，右边 flex: 1。 See the Pen 两栏布局（左定右自适应）flex by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垂直居中方案汇总]]></title>
    <url>%2Fposts%2F12733%2F</url>
    <content type="text"><![CDATA[这里汇总了常见的元素居中方案。 水平居中行内元素水平居中核心：给父元素添加 text-align: center See the Pen 行内元素水平居中 by JingW (@JingW) on CodePen. 块级元素水平居中核心：子元素自身 margin: 0 auto; See the Pen 块元素水平居中 by JingW (@JingW) on CodePen. 多个div水平居中传统方案核心：父元素设置 text-align: center ，子元素设置 inline-block See the Pen 多个div水平居中 - 传统方案 by JingW (@JingW) on CodePen. Flex方案核心：父元素 display: flex + justify-content: center + align-items: center See the Pen 多个div水平居中-flex by JingW (@JingW) on CodePen. 水平垂直居中table自带水平垂直居中核心：使用 table&gt;tr&gt;td 布局 See the Pen div水平垂直居中 - table by JingW (@JingW) on CodePen. 模拟table核心：父元素 display: table ，子元素 display: table-cell + vertical-align: middle See the Pen div水平垂直居中 - 模拟table by JingW (@JingW) on CodePen. 子绝父相 + 子元素 margin:auto核心：子元素相对于父元素绝对定位，top、right、bottom、left 都设为0，margi设为auto See the Pen div水平垂直居中 - 子绝父相 + Margin Auto by JingW (@JingW) on CodePen. 子绝父相 + 负margin核心：子元素相对于父元素绝对定位，top、left设为50%，margin相对自身宽/高一半 See the Pen div水平垂直居中 - 子绝父相 + 负Margin by JingW (@JingW) on CodePen. 子绝父相 + translate核心：子元素相对于父元素绝对定位，top、left设为50%，此时子元素左上角在父元素中心，然后让子元素向左上角位移自身宽度的一半 See the Pen div水平垂直居中 - 子绝父相 + translate by JingW (@JingW) on CodePen. Flex布局父元素 display: flex，justify-content 和 align-items 都设为 center 实现垂直居中 See the Pen div水平垂直居中 - flex by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对HTML语义化的理解]]></title>
    <url>%2Fposts%2F2906%2F</url>
    <content type="text"><![CDATA[对HTML语义化的理解核心：用正确的标签做正确的事情 利与开发：方便代码的阅读和维护 利于SEO：方便爬虫根据 语义标签 确定 页面结构 和 关键字 的权重 常见语义化标签一图胜千言： 元素细节： &lt;main&gt; 存放每个页面独有的内容。每个页面上只能用一次 &lt;main&gt;，且直位于 &lt;body&gt;中。最好不要把它嵌套进其它元素。 &lt;article&gt; 包围的内容即一篇文章，与页面其它部分无关（比如一篇博文）。 &lt;section&gt; 与 &lt;article&gt; 类似，但 &lt;section&gt; 更适用于组织页面使其按功能（比如迷你地图、一组文章标题和摘要）分块。一般的最佳用法是：以 标题 作为开头；也可以把一篇 &lt;article&gt; 分成若干部分并分别置于不同的 &lt;section&gt; 中，也可以把一个区段 &lt;section&gt; 分成若干部分并分别置于不同的 &lt;article&gt; 中，取决于上下文。 &lt;aside&gt; 包含一些间接信息（术语条目、作者简介、相关链接，等等）。 &lt;header&gt; 是简介形式的内容。如果它是 &lt;body&gt; 的子元素，那么就是网站的全局页眉。如果它是 &lt;article&gt; 或&lt;section&gt; 的子元素，那么它是这些部分特有的页眉（此 &lt;header&gt; 非彼 标题）。 &lt;nav&gt; 包含页面主导航功能。其中不应包含二级链接等内容。 &lt;footer&gt; 包含了页面的页脚部分。 来源：文档与网站架构]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>语义化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo搭建个人博客]]></title>
    <url>%2Fposts%2F43303%2F</url>
    <content type="text"><![CDATA[介绍利用 Hexo 在 GitHub 上搭建个人博客。 准备工作你的电脑需要安装下面两个应用程序： NodeJS 如何安装 Git 如何安装 重要步骤安装Hexo安装文档 插件安装 hexo-abbrlink 介绍 &amp;&amp; 此插件诞生原因 hexo-deployer-git 将本地博客部署到GitHub 如何安装和使用 hexo-server npm install hexo-server –save 服务器模块。在启动期间，Hexo 会监视文件变动并自动更新 使用第三方主题 Next Yilia 创建分类功能运行： 1hexo new page &quot;categories&quot; p.s. 命名为categories原因是 categories 在next主题中是一个关键词对应着分类。 在主站根目录下,也就是你hexo的目录下找到 /source/categories/index.md，打开后的效果类似下方代码： 123456---title: categories #本页标题date: 2019-03-13 23:02:50 #创建日期type: "categories" #分类属于comments: false #如果有启用多说 或者 Disqus评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false--- 接着在 themes 主题文件夹下找到 next 文件夹，修改 _config.yml 文件： 123456menu: home: / || home # 地址路径 | 导航栏对应的图标 about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 然后在命令行输入添加文章命令： 1hexo new '你想要创建的文章名称' 根目录(主站目录下)/source/_posts/上一步创建的文章名称.md，双击打开： 123456---title: 文章标题date: 2019-03-13 23:13:23tags: html #属于哪个标签categories: interview #属于哪个分类--- 参考：分类和标签p.s. 如果想要实现父子分类，可以查看上方链接的评论 创建标签功能打开命令行，进入博客所在文件夹。执行命令：1hexo new page tags 成功后会有一个路径提示1INFO Created: ~/Documents/blog/source/tags/index.md 找到对应的文件打开1234---title: 标签date: 2019-03-14 00:02:05--- 添加type: “tags”到内容中，添加后是这样的：12345---title: 标签date: 2019-03-14 00:03:52type: 'tags'--- 打开你的文章页面：123456---title: jQuery对表单的操作及更多应用date: 2019-03-14 00:03:55categories: 前端 tags: jQuery #如果想要多个标签可以 tags: [jQuery, 表格, 表单验证]--- 不蒜子统计功能NexT主题集成了不蒜子统计功能，在NexT配置文件中找到关键词 busuanzi_count: ，把 enable 设置为 true p.s. 除此之外，如果设置为true后仍然无效，且打开控制台显示js报错。有可能是不蒜子链接失效的原因，需要在Next主题配置文件位置：1themes\next\layout\_third-party\analytics\busuanzi-counter.swig 修改script链接为：1&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 评论功能使用 Valine 参考： 评论系统从Disqus到Valine Valine - 一款快速、简洁且高效的无后端评论系统。 常用配置 Hexo瞎折腾系列(4) - 站点首页不显示文章全文 常用命令12345678910111213141516171819// npm全局安装Hexonpm install -g hexo-cli // 新建Hexo项目hexo init &lt;folder&gt;cd &lt;folder&gt;npm install// 新建文章hexo new '文章名'// 启动服务器hexo server -p 5000// 生成静态文件hexo generate --watch// 部署hexo clean &amp;&amp; hexo deploy 相关配置及资源 Hexo+NexT 打造一个炫酷博客 这应该是最全的hexo博客搭建以及next美化教程 给hexo添加Valine评论功能 hexo next 解决unpkg.com加载慢 LeanCloud Hexo搭建GitHub博客—打造炫酷的NexT主题–高级(四) Hexo NexT主题代码块添加复制功能 修改hexo博客next主题文章页面宽度]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端vscode插件配置]]></title>
    <url>%2Fposts%2F11039%2F</url>
    <content type="text"><![CDATA[外观配置 主题：Chester Atom 图标：VSCode Great Icons 字体：Fira Code 预览 用户设置（User Settings）1234567&#123; "editor.fontSize": 16, "workbench.colorTheme": "Chester Atom", "editor.fontFamily": "Fira Code", "emmet.triggerExpansionOnTab": true, "editor.fontLigatures": true&#125; 风格检查 ESLint StyleLint MarkdownLint Prettier 编码效率代码片段 HTML Snippets Javascript (ES6) Code Snippets Javascript Patterns Snippets Document This，一键给代码中的类、函数加上注释，支持函数声明、函数表达式、箭头函数等； 自动补全 Auto Close Tag，在打开标签并且键入 &lt;/ 的时候，能自动补全要闭合的标签； Auto Rename Tag，在修改标签名时，能在你修改开始（结束）标签的时候修改对应的结束（开始）标签。 Path Intellisense，文件路径补全，在你用任何方式引入文件系统中的路径时提供智能提示和自动完成。 NPM Intellisense，NPM 依赖补全，在你引入任何 node_modules 里面的依赖包时提供智能提示和自动完成。 IntelliSense for CSS class names，CSS 类名补全，会自动扫描整个项目里面的 CSS 类名并在你输入类名时做智能提示。 Emmet，VSCode 已经内置，官方介绍文档参见。 代码补全 Code Runner 功能增强 Color Highlight，识别代码中的颜色，包括各种颜色格式。 Bracket Pair Colorizer，识别代码中的各种括号，并且标记上不同的颜色，方便你扫视到匹配的括号。 Settings Sync，基于 Gist 实现 VSCode 用户配置、快捷键配置、已安装插件列表等的备份和恢复功能，配置过程有详细精确的操作步骤文档。生成的备份 Gist 默认是私密的，如果你想设置为共享的，也可以一键切换。 外观增强 TODO Highlight维护时间稍长的代码仓库免不了会有各种 TODO、FIXME、HACK 之类的标记，TODO Highlight 能够帮我们把这些关键词高亮出来，在你翻阅代码时非常醒目，就像是在大声提醒你尽快把他解决掉。支持自定义配置需要高亮的关键词，实际使用比较坑的地方是，TODO、FIXME 之类的后面必须加上冒号，否则无法高亮。]]></content>
      <categories>
        <category>前端</category>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
</search>
