<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[null 和 undefined 的区别]]></title>
    <url>%2Fposts%2F63928%2F</url>
    <content type="text"><![CDATA[含义 null 表示一个对象是“没有值”的值，也就是值为“空” undefined 表示一个变量声明了没有初始化(赋值) 类型 undefined 的类型(typeof)是 undefined null 的类型(typeof)是 object 其他Javascript会将未赋值的变量默认值设为undefined；Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。 另外，在验证 null 时，一定要使用 === ，因为 == 无法分辨 null 和 undefined ：12null == undefined // true null === undefined // false]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对闭包的理解]]></title>
    <url>%2Fposts%2F29980%2F</url>
    <content type="text"><![CDATA[什么是闭包我一直认为，MDN是前端学习的在线指南。只要有不懂的语法，或者不懂的概念，查找资料的首选就应该是它。虽然早些年做iOS开发的时候就就接触过闭包，但如今已经忘得一干二净，所以在想要了解闭包的时候，第一件事就是在MDN中搜索。其中给到了一个闭包的例子： 12345678910function makeFunc() &#123; var name = "Mozilla"; // name 是一个被 init 创建的局部变量 function displayName() &#123; // displayName() 是内部函数,一个闭包 alert(name); // 使用了父函数中声明的变量 &#125; return displayName; // 返回 displayName 这个函数&#125;var myFunc = makeFunc();myFunc(); // 当执行myFunc时，其实调用了displayName，会弹窗显示"Mozilla" 在上面这个例子中，一个函数套了一个函数，且这个内部函数使用到了外部函数中的变量，这个时候就形成了闭包。有什么用呢？其中一个用处就如上面代码所示，能够让 makeFunc 函数外面也能访问 name 这个局部变量。换句话说，闭包缓存了数据，延长了作用域链。 Kyle Simpson编写的You-Dont-Know-JS中对闭包的总结我觉得很精髓： 闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。 闭包的特性 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 闭包的用途缓存数据，延长作用域链一个经典的例子，给 ul&gt;li 下面的每个 li 节点添加点击事件，让其弹出当前 li 元素的索引：1234567891011121314&lt;ul id="testUL"&gt; &lt;li&gt; index = 0&lt;/li&gt; &lt;li&gt; index = 1&lt;/li&gt; &lt;li&gt; index = 2&lt;/li&gt; &lt;li&gt; index = 3&lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var nodes = document.getElementsByTagName("li"); for (var i = 0; i &lt; nodes.length; i += 1) &#123; nodes[i].onclick = function () &#123; console.log(i); &#125; &#125;&lt;/script&gt; 运行上述代码后就会发现，每次打印的结果都显示为4，而不是真正的索引值。这是因为点击事件的匿名函数发生在for循环之后，而for循环执行完毕时 i 的值就为4，所以点谁都是同样的结果。那么这个时候就能通过立即执行函数 + 闭包的方法解决此问题：1234567891011&lt;script type="text/javascript"&gt; var nodes = document.getElementsByTagName("li"); for (var i = 0; i &lt; nodes.length; i += 1) &#123; nodes[i].onclick = (function (i) &#123; // 1. IIFE创建一个函数作用域 return function () &#123; // 4. 返回这个匿名函数，延长作用域链 // 3. 内部嵌套的匿名函数使用到了IIFE的参数i，形成闭包 console.log(i); &#125; &#125;)(i); // 2. 给IIFE传递每次for循环的i &#125;&lt;/script&gt; 这个时候触发click事件，打印的值就是li元素的索引了。 用闭包模拟私有变量和方法使用闭包定义能访问私有函数和私有变量的公有函数（也叫做模块模式） 123456789101112131415161718192021222324var counter = (function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125;; &#125;)(); // 立即执行函数console.log(counter.value()); // logs 0counter.increment();counter.increment();console.log(counter.value()); // logs 2counter.decrement();console.log(counter.value()); // logs 1 环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。它俩都无法在匿名函数外部直接访问。必须通过匿名包装器返回的对象的三个公共函数访问。 内存泄漏其实闭包并不会造成内存泄漏，现在的垃圾回收机制已经很成熟了。但早期的IE（ie4-ie6）版本里，对宿主对象（也就是document对象）采用是引用计数的垃圾回收机制，闭包导致内存泄漏的一个原因就是这个算法的一个缺陷。循环引用会导致没法回收，这个循环引用只限定于有宿主对象参与的循环引用，而js对象之间即使形成循环引用，也不会产生内存泄漏，因为对js对象的回收算法不是计数的方式：12345678910111213141516171819202122232425function closure()&#123; var oDiv = document.getElementById('oDiv');//oDiv用完之后一直驻留在内存中 oDiv.onclick = function () &#123; alert('oDiv.innerHTML');//这里用oDiv导致内存泄露 &#125;;&#125;// 以上代码创建了一个作为 div 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。// 由于匿名函数保存了一个对closure()的活动对象的引用，因此就会导致无法减少 div 的引用数。// 只要匿名函数存在，element 的引用数至少也是1，因此它所占用的内存就永远不会被回收closure();//最后应将oDiv解除引用来避免内存泄露function closure()&#123; var oDiv = document.getElementById('oDiv'); var test = oDiv.innerHTML; oDiv.onclick = function () &#123; alert(test); &#125;; oDiv = null;&#125;// 解决办法: 把 oDiv.innerHTML 的一个副本保存在一个变量中，// 从而消除闭包中该变量的循环引用,同时将 oDiv 变量设为null。]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组有哪些常用方法]]></title>
    <url>%2Fposts%2F21501%2F</url>
    <content type="text"><![CDATA[改变原数组的方法splice() 添加/删除数组元素 splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目 array.splice(index,howmany,item1,…..,itemX) index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX： 可选。向数组添加的新项目。 返回值: 如果有元素被删除,返回包含被删除项目的新数组。 删除元素1234567// 从数组下标0开始，删除3个元素let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0, 3); // [1,2,3]console.log(a); // [4,5,6,7]// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7let item = a.splice(-1, 3); // [7] 删除并添加123456789// 从数组下标0开始，删除3个元素，并添加元素'添加'let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0,3,'添加'); // [1,2,3]console.log(a); // ['添加',4,5,6,7]// 从数组最后第二个元素开始，删除3个元素，并添加两个元素'添加1'、'添加2'let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-2,3,'添加1','添加2'); // [6,7]console.log(b); // [1,2,3,4,5,'添加1','添加2'] 不删除只添加1234567let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0,0,'添加1','添加2'); // [] 没有删除元素，返回空数组console.log(a); // ['添加1','添加2',1,2,3,4,5,6,7]let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-1,0,'添加1','添加2'); // [] 没有删除元素，返回空数组console.log(b); // [1,2,3,4,5,6,'添加1','添加2',7] 在最后一个元素的前面添加两个元素 sort() 数组排序 定义: sort()方法对数组元素进行排序，并返回这个数组。 参数可选: 规定排序顺序的比较函数。 默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用toString()方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。 不传参1234567// 字符串排列 看起来很正常var a = ["Banana", "Orange", "Apple", "Mango"];a.sort(); // ["Apple","Banana","Mango","Orange"]// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的var a = [10, 1, 3, 20,25,8];console.log(a.sort()) // [1,10,20,25,3,8]; 比较函数的两个参数： sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素： 若比较函数返回值&lt;0，那么a将排到b的前面; 若比较函数返回值=0，那么a 和 b 相对位置不变； 若比较函数返回值&gt;0，那么b 排在a 将的前面； 数字升降序12345678910var array = [10, 1, 3, 4, 20, 4, 25, 8]; array.sort(function(a,b)&#123; return a-b;&#125;);console.log(array); // [1,3,4,4,8,10,20,25];array.sort(function(a,b)&#123; return b-a;&#125;);console.log(array); // [25,20,10,8,4,4,3,1]; pop() 删除一个数组中的最后的一个元素 定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。 123let a = [1,2,3];let item = a.pop(); // 3console.log(a); // [1,2] shift() 删除数组的第一个元素 定义: shift()方法删除数组的第一个元素，并返回这个元素。 123let a = [1,2,3];let item = a.shift(); // 1console.log(a); // [2,3] push() 向数组的末尾添加元素 定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 参数: item1, item2, …, itemX ,要添加到数组末尾的元素 123let a = [1,2,3];let item = a.push('末尾', '233'); // 5console.log(a); // [1,2,3,'末尾', '233'] unshift() 定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。 参数: item1, item2, …, itemX ,要添加到数组开头的元素 123let a = [1, 2, 3];let item = a.unshift('开头', '开头2'); // 5console.log(a); // [ '开头', '开头2', 1, 2, 3 ] reverse() 颠倒数组中元素的顺序 定义: reverse() 方法用于颠倒数组中元素的顺序。 123let a = [1,2,3];a.reverse(); console.log(a); // [3,2,1] 不改变原数组的方法slice() 浅拷贝数组的元素 定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。 语法：array.slice(begin, end); 12345678910111213let a= ['hello','world'];let b=a.slice(0,1); // ['hello']// 新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。// 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。a[0]='改变原数组';console.log(a,b); // ['改变原数组','world'] ['hello']let a= [&#123;name:'OBKoro1'&#125;];let b=a.slice();console.log(b,a); // [&#123;"name":"OBKoro1"&#125;] [&#123;"name":"OBKoro1"&#125;]// a[0].name='改变原数组';// console.log(b,a); // [&#123;"name":"改变原数组"&#125;] [&#123;"name":"改变原数组"&#125;] join() 数组转字符串 定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。 语法: array.join(str) 12345678910111213let a= ['hello','world'];let str=a.join(); // 'hello,world'let str2=a.join('+'); // 'hello+world'let a= [['OBKoro1','23'],'test'];let str1=a.join(); // OBKoro1,23,testlet b= [&#123;name:'OBKoro1',age:'23'&#125;,'test'];let str2 = b.join(); // [object Object],test// 对象转字符串推荐JSON.stringify(obj);// 结论：// join()/toString()方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),// 如果是对象的话，对象会被转为[object Object]字符串。 join() 数组转字符串 定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。 语法: array.join(str) 12345678910111213let a= ['hello','world'];let str=a.join(); // 'hello,world'let str2=a.join('+'); // 'hello+world'let a= [['OBKoro1','23'],'test'];let str1=a.join(); // OBKoro1,23,testlet b= [&#123;name:'OBKoro1',age:'23'&#125;,'test'];let str2 = b.join(); // [object Object],test// 对象转字符串推荐JSON.stringify(obj);// 结论：// join()/toString()方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),// 如果是对象的话，对象会被转为[object Object]字符串。 concat 定义： 方法用于合并两个或多个数组，返回一个新数组。 语法：var newArr =oldArray.concat(arrayX,arrayX,……,arrayX) 参数：arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。 1234567891011121314let a = [1, 2, 3];let b = [4, 5, 6];//连接两个数组let newVal=a.concat(b); // [1,2,3,4,5,6]// 连接三个数组let c = [7, 8, 9]let newVal2 = a.concat(b, c); // [1,2,3,4,5,6,7,8,9]// 添加元素let newVal3 = a.concat('添加元素',b, c,'再加一个'); // [1,2,3,"添加元素",4,5,6,7,8,9,"再加一个"]// 合并嵌套数组 会浅拷贝嵌套数组let d = [1,2 ];let f = [3,[4]];let newVal4 = d.concat(f); // [1,2,3,[4]] ES6扩展运算符...合并数组123let a = [2, 3, 4, 5]let b = [ 4,...a, 4, 4]console.log(a,b); // [2, 3, 4, 5] [4,2,3,4,5,4,4] indexOf() 查找数组是否存在某个元素，返回下标 定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 p.s. 字符串也有此方法，要注意当 ‘lance’.indexOf(‘’) 一个空字符串时，返回0而不是-1 语法：array.indexOf(searchElement,fromIndex) 参数： searchElement(必须):被查找的元素 fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。 严格相等的搜索: 数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等===搜索元素，即数组元素要完全匹配才能搜索成功。 注意：indexOf()不能识别NaN 1234let a=['啦啦',2,4,24,NaN]console.log(a.indexOf('啦')); // -1 console.log(a.indexOf('NaN')); // -1 console.log(a.indexOf('啦啦')); // 0 lastIndexOf() 查找指定元素在数组中的最后一个位置 定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找） 语法：arr.lastIndexOf(searchElement,fromIndex) 参数: searchElement(必须): 被查找的元素 fromIndex(可选): 逆向查找开始位置，默认值数组的 长度-1，即查找整个数组。 关于fromIndex有三个规则: 正值。如果该值大于或等于数组的长度，则整个数组会被查找。 负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找) 负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 12345let a=['OB',4,'Koro1',1,2,'Koro1',3,4,5,'Koro1']; // 数组长度为10// let b=a.lastIndexOf('Koro1',4); // 从下标4开始往前找 返回下标2// let b=a.lastIndexOf('Koro1',100); // 大于或数组的长度 查找整个数组 返回9// let b=a.lastIndexOf('Koro1',-11); // -1 数组不会被查找let b=a.lastIndexOf('Koro1',-9); // 从第二个元素4往前查找，没有找到 返回-1 ES7 includes() 查找数组是否包含某个元素 返回布尔 定义： 返回一个布尔值，表示某个数组是否包含给定的值 语法：array.includes(searchElement,fromIndex=0) 参数： searchElement(必须):被查找的元素 fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。 includes方法是为了弥补indexOf方法的缺陷而出现的: indexOf方法不能识别NaN indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观 12345let a=['OB','Koro1',1,NaN];// let b=a.includes(NaN); // true 识别NaN// let b=a.includes('Koro1',100); // false 超过数组长度 不搜索// let b=a.includes('Koro1',-3); // true 从倒数第三个元素开始搜索 // let b=a.includes('Koro1',-100); // true 负值绝对值超过数组长度，搜索整个数组]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去除图片上下左右间隙]]></title>
    <url>%2Fposts%2F31251%2F</url>
    <content type="text"><![CDATA[情景当在定宽父容器下有多张图片顺序排列时，图片的上下左右之间都有间隙： See the Pen KEBmRP by JingW (@JingW) on CodePen. 原因 左右：因为 img 是 inline-block 元素，元素代码之间有『换行（回车），空格，tab』时会产生左右间隙。 上下：行内元素默认与父容器基线对齐，而基线与父容器底部有一定间隙，所以上下图片间有间隙。 解决方案 移除上下间隙： img本身设置 display: block; 父元素设置 font-size: 0; （基线与字体大小有关，字体为零，基线间就没距离了） img本身设置 vertical-align: bottom;（让inline-block 的 img 与每行的底部对齐） 移除左右间距： 行内元素间不要有换行，连成一行写消除间隙（阅读性差，不推荐） 第一行img结尾写上 &lt;!-- ，第二行img开头跟上 --&gt; 。即利用注释消除间距 父元素 font-size: 0]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何清除浮动]]></title>
    <url>%2Fposts%2F12906%2F</url>
    <content type="text"><![CDATA[为什么要清除浮动其实浮动（e.g. float: left;）本质上是用来做文字混排的，但却被我们拿来做布局，这个时候虽然实现了某些效果，但也带来了不少副作用。 由于浮动元素不再占有原文档流的位置，所以它会对后续元素的排版带来影响（无视浮动元素，就当它不存在过）。因此我们很多时候要做的，就是消除浮动元素造成的影响。清除浮动的本质主要是为了解决父元素因为子元素浮动造成的内部高度为0的问题。 clear清除浮动的核心css属性是 clear ，基本语法如下： 123选择器: &#123; clear: 属性值;&#125; 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 清除浮动常见方案额外标记法在浮动元素后面添加一个空标签，例如： 12&lt;div style="float: left;"&gt;&lt;/div&gt;&lt;div style="clear: both;"&gt;&lt;/div&gt; 优点：通俗易懂，书写方便缺点：加入了过多的没有实际含义的额外标签，结构化差。 父元素添加overflow通过触发BFC达到清除浮动的效果。（p.s. 对bfc不了解可以看这篇文章） 123.parent &#123; overflow: hidden;&#125; 优点：代码简洁缺点：超出的内容会被隐藏 before和after双伪元素方案1234567891011.clearfix:before,.clearfix:after &#123; content:""; display: table; /* 触发BFC清除浮动 */&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 优点：代码简洁缺点：IE6-7不支持:after，需要使用 zoom: 1 触发 hasLayout 使用after伪元素（我平常使用的）1234567891011.clearfix::after &#123; content: "."; display: block; height: 0; visibility: hidden; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; /* IE6、7 专有 */ 使用方式：给浮动元素的父元素添加一个class类：clearfix优点：一次书写多处使用，并且符合闭合浮动思想，结构语义化正确缺点：IE6-7不支持:after，需要使用 zoom: 1 触发 hasLayout注意：content:&quot;.&quot; 内容尽量不为空，可以跟一个小点，否则在firefox 7.0前的版本会生成空格 :after 和 ::after 的区别:before、:after 在旧版本里是伪元素，CSS3的规范里 “:” 用来表示伪类，”::” 用来表示伪元素，但是在高版本浏览器下 :before、:after 会被自动识别为 ::before、::after ，这样做的目的是用来做兼容处理。 相同点伪类对象，用来设置对象前的内容:before 和 ::before 写法是等效的 不同点:before 是 css2 的写法，::before 是 css3 的写法:before 兼容性比 ::before要好 注意伪类元素必须要配合 content 属性一起使用，否则无效伪类元素是css渲染层加入的，不能通过js来操作]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>清除浮动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC的理解与应用]]></title>
    <url>%2Fposts%2F9722%2F</url>
    <content type="text"><![CDATA[定义先上MDN上对 BFC 的定义： 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 ———— BFC | MDN 不知道别人看完这段定义有何感受，反正我是懵逼的。不过我在这儿还是建议各位认真阅读上面给出的MDN链接至少两遍，这能让你对一个陌生的概念有一个基本的认知。 理解这里谈下我对BFC的理解：BFC其实是一个独立的，与外界隔离了的容器，容器里面的子元素不会影响到外面的元素，外面的也同样不会影响到容器内部的元素。我们可以利用这个特性，来解决一些布局上的问题。 BFC触发条件BFC的触发条件有很多，想要知道所有细节可以移步上面给出的 MDN 链接。这里我只列出一些常见触发条件： 根元素（HTML元素） 浮动元素（float不为none） 绝对定位元素（position 为 absolute 或 fixed） display 为 block, inline-block, flex, inline-flex, list-item, table overflow 值不为 visible 的块元素 BFC布局特性对于一个BFC容器来说： 内部相邻的两个元素垂直方向上的 margin 会发生重叠 不会与外界的浮动元素产生交集，而是紧贴浮动元素的边缘 元素从容器的顶端开始垂直地一个接一个地排列 每一个元素的左外边缘（margin-left）会触碰到容器的左边缘（border-left）（如果设置了容器内部的元素从右到左的格式排布，则触碰的是右边缘） 在计算它的高度时，还会检测内部浮动或者定位元素的高度 实际应用清除浮动利用BFC “在计算它的高度时，还会检测内部浮动或者定位元素的高度” 这条特性，我们可以触发父元素的BFC来清除子元素浮动带来的影响。常见的用法是给父元素设置 overflow: hidden 样式（如果考虑IE6版本，还需设置 zoom: 1，因为IE6不支持 overflow: hidden 来清除浮动）： See the Pen 利用BFC清除浮动 by JingW (@JingW) on CodePen. 解决外边距合并问题如果看上面标题不知道在说什么，请很戳这里了解详情。由于属于同一个BFC的两个相邻盒子的垂直margin会发生重叠，那么我们可以隔离开这两个元素，让它们不属于同一个BFC，这样就不会发生margin重叠了。 See the Pen 解决外边距合并问题 by JingW (@JingW) on CodePen. 两栏布局，右边宽度自适应我们常常在开发中有这样类似的需求：两栏布局，左边定宽，右边自适应。这时我们就可以利用BFC特性来实现需求：左边设置定宽+左浮动；右边给自己加上 overflow: hidden 。原理就是：给元素设置BFC后，为了和浮动元素不产生任何交集，它会顺着浮动元素的边缘形成自己的封闭上下文。直接上代码看效果： See the Pen 利用BFC实现两栏布局 by JingW (@JingW) on CodePen. 以上是我对BFC的一些理解以及实际应用，希望能够帮助大家了解BFC这个听起来摸不着头脑的东西。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三栏布局方案(圣杯+双飞翼)]]></title>
    <url>%2Fposts%2F55613%2F</url>
    <content type="text"><![CDATA[圣杯布局步骤一 - HTML框架搭建 &amp; 初始化CSS首先把基本框架搭起来（注意中间部分放最前面）： 12345&lt;div class="container"&gt; &lt;div class="center"&gt;我是中间&lt;/div&gt; &lt;div class="left"&gt;我是左边&lt;/div&gt; &lt;div class="right"&gt;我是右边&lt;/div&gt;&lt;/div&gt; 接下来是初始化样式。left, right宽度分别设置为100px和200px；然后设置container的 padding-left: 100px + padding-right: 200px 来占据两侧填充；center宽度设为100%，这样能够自适应剩下的宽度。再让所有子元素左浮动。代码如下： 12345678910111213141516171819202122232425.container &#123; padding: 0 200px 0 100px; /* 左边100， 右边200*/ background-color: #e1e1e1; height: 300px; /* 为了看效果，给个300px把高度撑起来 */&#125;.left, .center, .right &#123; float: left; height: 100%;&#125;.center &#123; width: 100%; /* 占据父元素剩下的宽度*/ background-color: lightblue;&#125;.left &#123; width: 100px; background-color: pink;&#125;.right &#123; width: 200px; background-color: yellow;&#125; 此时的页面效果： 步骤二 - 让left占据最左列为了让left能越过center，我们先给它设置一个 -100% 的左边距。这个100%是在container中的宽度，也就是center的宽度： 123456.left &#123; margin-left: -100%; width: 100px; /*为了看left和center的重叠效果，暂时bgc设为半透明*/ background-color: rgba(255,204,204,.6);&#125; 页面效果： 此时，我们已经让left从“第二行”升到了“第一行”，为了让它靠到最左侧，不与center重叠，可以给它设置相对定位，然后给个 left: -100px ，让它定位到container最左侧： 123456789.left &#123; /* 设置相对定位 */ position: relative; /* 靠到最左侧 */ left: -100px; margin-left: -100%; width: 100px; background-color: pink;&#125; 页面效果： 步骤三 - 让right占据最右列定位好了left，也是时候让right呆在最右边来填充位置了，我们继续使用负margin： 12345.right &#123; width: 200px; margin-right: -200px; background-color: yellow;&#125; 页面效果： 步骤四 - 给container设置min-width看起来已经实现了不是吗？但我们还差最后一步，给container设置一个 min-width: 100px （就是左列的宽度），否则当浏览器缩小到一定程度时，这个布局可能会被破坏。原因简单来讲就是：“由于设置了相对定位，所以当left原来的位置和right的位置产生重叠时，由于浮动的原因一行放不下就会换行”。所以布局就被打乱了。 123456.container &#123; min-width: 100px; background-color: #e1e1e1; padding: 0 200px 0 100px; height: 300px;&#125; 完整代码 + 最终效果这样，我们就实现了圣杯布局，完整代码和效果见下： See the Pen 三栏布局 - 圣杯布局 by JingW (@JingW) on CodePen. 双飞翼布局如果上面圣杯布局你已经理解并自己实践了一遍，那么这里的双飞翼布局你也应该不再话下。跟着我一起撸一遍代码吧。 步骤一 - HTML框架搭建 &amp; 初始化CSS首先搭建html，仔细观察下方代码你会发现，双飞翼布局在html上面有一点和圣杯布局有差别，那就是双飞翼在center里又套了一个div。到后面你就会知道这样设置的目的。 12345&lt;div class="container"&gt; &lt;div class="center"&gt;&lt;div&gt;我是中间&lt;/div&gt;&lt;/div&gt; &lt;div class="left"&gt;我是左边&lt;/div&gt; &lt;div class="right"&gt;我是右边&lt;/div&gt;&lt;/div&gt; 然后编写初始样式。left定宽100；right定宽200；left, right, center全部设置左浮动。其他例如设置颜色高度等等直接看下方代码： 1234567891011121314151617181920212223.container &#123; background-color: #e1e1e1; height: 300px;&#125;.center &#123; background-color: lightblue;&#125;.left &#123; width: 100px; background-color: pink;&#125;.right &#123; width: 200px; background-color: yellow;&#125;.left, .center, .right &#123; float: left; height: 100%;&#125; 效果如下： 步骤二 - 设置center为100%宽将center的宽度设为100%，这样会把left，right“挤”到第二行： 1234.center &#123; width: 100%; background-color: lightblue;&#125; 效果如下： 步骤三 - 分别让left,right回到最左边和最右边接着，给left设置 margin-left: -100% 回到最左边，给right设置 margin-left: -200px 回到最右边。此时center和left,right都有重叠区域，为了看效果，设置了半透明背景颜色。 1234567891011.left &#123; width: 100px; margin-left: -100%; background-color: pink;&#125;.right &#123; width: 200px; margin-left: -200px; background-color: yellow;&#125; 效果如下： 步骤四 - 给center的子div设置左右margin其实上面的效果图已经实现了三栏布局中间自适应。但有个问题是center左右部分区域会被遮挡，这个时候在步骤一提到的center子div的作用就体现出来了，我们可以给它设置一个左右的margin值，分别等于left的宽和right的宽，消除掉重叠的副作用。 1234.center div &#123; /* 左margin100，右margin200 */ margin: 0 200px 0 100px;&#125; 效果如下： 步骤五 - 给container设置min-width最后，给container设置一个min-width，让container最小宽度不小于left宽+right宽 12345.container &#123; min-width: 300px; background-color: #e1e1e1; height: 300px;&#125; 大功告成~ 完整代码 + 最终效果 See the Pen 三栏布局 - 双飞翼布局 by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两栏布局方案汇总]]></title>
    <url>%2Fposts%2F44541%2F</url>
    <content type="text"><![CDATA[记录下常见的两栏布局方式。 左边定宽，右边自适应模拟table父元素 display: table ，子元素左右 table-cell ，左边定宽。 See the Pen 两栏布局（左定右自适应）模拟table by JingW (@JingW) on CodePen. 左浮 + 右Margin子元素的左边浮动脱标，右边设置 margin-left: 左边元素宽度 See the Pen 两栏布局（左定右自适应）子元素绝对定位 by JingW (@JingW) on CodePen. 左浮 + 右BFC子元素左边设置浮动+定宽，右边子元素设置 overflow: hidden 触发自身BFC See the Pen 两栏布局（左定右自适应）左浮 + 右BFC by JingW (@JingW) on CodePen. 子绝父相子绝父相，左边 top, left: 0，右边 top, right: 0，left等于左边宽度。 See the Pen 两栏布局（左定右自适应）子绝父相 by JingW (@JingW) on CodePen. flex布局父元素 display: flex ，左边定宽，右边 flex: 1。 See the Pen 两栏布局（左定右自适应）flex by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垂直居中方案汇总]]></title>
    <url>%2Fposts%2F12733%2F</url>
    <content type="text"><![CDATA[这里汇总了常见的元素居中方案。 水平居中行内元素水平居中核心：给父元素添加 text-align: center See the Pen 行内元素水平居中 by JingW (@JingW) on CodePen. 块级元素水平居中核心：子元素自身 margin: 0 auto; See the Pen 块元素水平居中 by JingW (@JingW) on CodePen. 多个div水平居中传统方案核心：父元素设置 text-align: center ，子元素设置 inline-block See the Pen 多个div水平居中 - 传统方案 by JingW (@JingW) on CodePen. Flex方案核心：父元素 display: flex + justify-content: center + align-items: center See the Pen 多个div水平居中-flex by JingW (@JingW) on CodePen. 水平垂直居中table自带水平垂直居中核心：使用 table&gt;tr&gt;td 布局 See the Pen div水平垂直居中 - table by JingW (@JingW) on CodePen. 模拟table核心：父元素 display: table ，子元素 display: table-cell + vertical-align: middle See the Pen div水平垂直居中 - 模拟table by JingW (@JingW) on CodePen. 子绝父相 + 子元素 margin:auto核心：子元素相对于父元素绝对定位，top、right、bottom、left 都设为0，margi设为auto See the Pen div水平垂直居中 - 子绝父相 + Margin Auto by JingW (@JingW) on CodePen. 子绝父相 + 负margin核心：子元素相对于父元素绝对定位，top、left设为50%，margin相对自身宽/高一半 See the Pen div水平垂直居中 - 子绝父相 + 负Margin by JingW (@JingW) on CodePen. 子绝父相 + translate核心：子元素相对于父元素绝对定位，top、left设为50%，此时子元素左上角在父元素中心，然后让子元素向左上角位移自身宽度的一半 See the Pen div水平垂直居中 - 子绝父相 + translate by JingW (@JingW) on CodePen. Flex布局父元素 display: flex，justify-content 和 align-items 都设为 center 实现垂直居中 See the Pen div水平垂直居中 - flex by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对HTML语义化的理解]]></title>
    <url>%2Fposts%2F2906%2F</url>
    <content type="text"><![CDATA[对HTML语义化的理解核心：用正确的标签做正确的事情 利与开发：方便代码的阅读和维护 利于SEO：方便爬虫根据 语义标签 确定 页面结构 和 关键字 的权重 常见语义化标签一图胜千言： 元素细节： &lt;main&gt; 存放每个页面独有的内容。每个页面上只能用一次 &lt;main&gt;，且直位于 &lt;body&gt;中。最好不要把它嵌套进其它元素。 &lt;article&gt; 包围的内容即一篇文章，与页面其它部分无关（比如一篇博文）。 &lt;section&gt; 与 &lt;article&gt; 类似，但 &lt;section&gt; 更适用于组织页面使其按功能（比如迷你地图、一组文章标题和摘要）分块。一般的最佳用法是：以 标题 作为开头；也可以把一篇 &lt;article&gt; 分成若干部分并分别置于不同的 &lt;section&gt; 中，也可以把一个区段 &lt;section&gt; 分成若干部分并分别置于不同的 &lt;article&gt; 中，取决于上下文。 &lt;aside&gt; 包含一些间接信息（术语条目、作者简介、相关链接，等等）。 &lt;header&gt; 是简介形式的内容。如果它是 &lt;body&gt; 的子元素，那么就是网站的全局页眉。如果它是 &lt;article&gt; 或&lt;section&gt; 的子元素，那么它是这些部分特有的页眉（此 &lt;header&gt; 非彼 标题）。 &lt;nav&gt; 包含页面主导航功能。其中不应包含二级链接等内容。 &lt;footer&gt; 包含了页面的页脚部分。 来源：文档与网站架构]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>语义化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo搭建个人博客]]></title>
    <url>%2Fposts%2F43303%2F</url>
    <content type="text"><![CDATA[介绍利用 Hexo 在 GitHub 上搭建个人博客。 准备工作你的电脑需要安装下面两个应用程序： NodeJS 如何安装 Git 如何安装 重要步骤安装Hexo安装文档 插件安装 hexo-abbrlink 介绍 &amp;&amp; 此插件诞生原因 hexo-deployer-git 将本地博客部署到GitHub 如何安装和使用 hexo-server npm install hexo-server –save 服务器模块。在启动期间，Hexo 会监视文件变动并自动更新 使用第三方主题 Next Yilia 创建分类功能运行： 1hexo new page &quot;categories&quot; p.s. 命名为categories原因是 categories 在next主题中是一个关键词对应着分类。 在主站根目录下,也就是你hexo的目录下找到 /source/categories/index.md，打开后的效果类似下方代码： 123456---title: categories #本页标题date: 2019-03-13 23:02:50 #创建日期type: "categories" #分类属于comments: false #如果有启用多说 或者 Disqus评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false--- 接着在 themes 主题文件夹下找到 next 文件夹，修改 _config.yml 文件： 123456menu: home: / || home # 地址路径 | 导航栏对应的图标 about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 然后在命令行输入添加文章命令： 1hexo new '你想要创建的文章名称' 根目录(主站目录下)/source/_posts/上一步创建的文章名称.md，双击打开： 123456---title: 文章标题date: 2019-03-13 23:13:23tags: html #属于哪个标签categories: interview #属于哪个分类--- 参考：分类和标签p.s. 如果想要实现父子分类，可以查看上方链接的评论 创建标签功能打开命令行，进入博客所在文件夹。执行命令：1hexo new page tags 成功后会有一个路径提示1INFO Created: ~/Documents/blog/source/tags/index.md 找到对应的文件打开1234---title: 标签date: 2019-03-14 00:02:05--- 添加type: “tags”到内容中，添加后是这样的：12345---title: 标签date: 2019-03-14 00:03:52type: 'tags'--- 打开你的文章页面：123456---title: jQuery对表单的操作及更多应用date: 2019-03-14 00:03:55categories: 前端 tags: jQuery #如果想要多个标签可以 tags: [jQuery, 表格, 表单验证]--- 不蒜子统计功能NexT主题集成了不蒜子统计功能，在NexT配置文件中找到关键词 busuanzi_count: ，把 enable 设置为 true p.s. 除此之外，如果设置为true后仍然无效，且打开控制台显示js报错。有可能是不蒜子链接失效的原因，需要在Next主题配置文件位置：1themes\next\layout\_third-party\analytics\busuanzi-counter.swig 修改script链接为：1&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 评论功能使用 Valine 参考： 评论系统从Disqus到Valine Valine - 一款快速、简洁且高效的无后端评论系统。 常用配置 Hexo瞎折腾系列(4) - 站点首页不显示文章全文 常用命令12345678910111213141516171819// npm全局安装Hexonpm install -g hexo-cli // 新建Hexo项目hexo init &lt;folder&gt;cd &lt;folder&gt;npm install// 新建文章hexo new '文章名'// 启动服务器hexo server -p 5000// 生成静态文件hexo generate --watch// 部署hexo clean &amp;&amp; hexo deploy 相关配置及资源 Hexo+NexT 打造一个炫酷博客 这应该是最全的hexo博客搭建以及next美化教程 给hexo添加Valine评论功能 LeanCloud Hexo搭建GitHub博客—打造炫酷的NexT主题–高级(四)]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
