<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS严格模式vs非严格模式]]></title>
    <url>%2Fposts%2F15966%2F</url>
    <content type="text"><![CDATA[前言以下为《JavaScript高级程序设计（第3版）》中有关 严格模式 的笔记。 介绍“严格模式” 是 ECMAScript5 最早引入的概念。可以在函数内部选择进行较为严格的全局或局部的错误条件检测。使用严格模式的好处是可以提早知道代码中存在的错误，及时捕获一些可能导致编程错误的 ECMAScript 行为。 如何使用在JS文件代码的顶部或者函数中输入下面字符串来开启严格模式： 12345678"use strict";orfunction fn() &#123; "use strict"; ...&#125; 严格模式 VS 非严格模式变量在严格模式下，不允许意外的创建全局变量： 12345// 未声明变量message = "Hello world";// 非严格模式: 创建全局变量// 严格模式: 抛出 ReferenceError 不能对变量调用 delete 操作符： 123456var color = "red";// 删除变量delete color;// 非严格模式: 静默失败// 严格模式: 抛出 ReferenceError 严格模式下对变量名也有限制。 不能使用 implements、interface、let、package、 private、protected、public、static 和 yield 作为变量名。这些都是保留字，将来的 ECMAScript 版本中可能会用到它们。在严格模式下，用以上标识符作为变量名会导致语法错误。 对象在严格模式下操作对象比在非严格模式下更容易导致错误。一般来说，非严格模式下会静默失败的 情形，在严格模式下就会抛出错误。因此，在开发中使用严格模式会加大早发现错误的可能性。 在下列情形下操作对象的属性会导致错误: 为只读属性赋值会抛出 TypeError; 对不可配置的(nonconfigurable)的属性使用 delete 操作符会抛出 TypeError; 为不可扩展的(nonextensible)的对象添加属性会抛出 TypeError。 使用对象的另一个限制与通过对象字面量声明对象有关。在使用对象字面量时，属性名必须唯一。 例如： 12345678// 重名属性var person = &#123; name: "Nicholas", name: "Greg"&#125;;// 非严格模式: 没有错误，以第二个属性为准// 严格模式: 抛出语法错误 函数函数的命名参数严格模式要求命名函数的参数必须唯一。例如： 1234567// 重名参数function sum(num, num) &#123; // do something&#125;// 非严格模式: 没有错误，只能访问第二个参数//严格模式: 抛出语法错误 在非严格模式下，这个函数声明不会抛出错误。通过参数名只能访问第二个参数，要访问第一个参数必须通过 arguments 对象。 argumentsarguments 对象的行为所不同。 在非严格模式下，修改命名参数的值也会反映到 arguments 对象中。 而严格模式下这两个值是完全独立的。 例如： 1234567// 修改命名参数的值function showValue(value) &#123; value = "Foo"; alert(value); //"Foo" alert(arguments[0]); // 非严格模式: "Foo" &lt;---&gt; 严格模式: "Hi"&#125;showValue("Hi"); 以上代码中，函数 showValue() 只有一个命名参数 value。调用这个函数时传入了一个参数”Hi”， 这个值赋给了 value。而在函数内部，value 被改为”Foo”。在非严格模式下，这个修改也会改变 arguments[0] 的值，但在严格模式下，arguments[0] 的值仍然是传入的值。 另一个变化是淘汰了 arguments.callee 和 arguments.caller。在非严格模式下，这两个属性一个引用函数本身，一个引用调用函数。而在严格模式下，访问哪个属性都会抛出 TypeError。 例如： 123456789101112// 访问 arguments.calleefunction factorial(num)&#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) &#125;&#125;var result = factorial(5);// 非严格模式: 没有问题// 严格模式: 抛出 TypeError 类似地，尝试读写函数的 caller 属性，也会导致抛出 TypeError。所以，对于上面的例子而言， 访问 factorial.caller 也会抛出错误。 函数名与变量类似，严格模式对函数名也做出了限制，不允许用 implements、interface、let、package、private、protected、public、static 和 yield 作为函数名。 函数声明的位置只能在脚本的顶级和在函数内部声明函数。也就是说，在 if 语句中声明函数会导致语法错误： 12345678//在 if 语句中声明函数if (true)&#123; function doSomething() &#123; //... &#125;&#125;// 非严格模式: 将函数提升到 if 语句外部// 严格模式: 抛出语法错误 eval()eval在包含上下文中不再创建变量或函数。例如： 1234567//使用 eval() 创建变量function doSomething() &#123; eval("var x=10"); alert(x);&#125;// 非严格模式: 弹出对话框显示 10// 严格模式: 调用 alert(x) 时会抛出 ReferenceError 如果是在非严格模式下，以上代码会在函数 doSomething() 中创建一个局部变量 x，然后 alert() 还会显示该变量的值。但在严格模式下，在 doSomething() 函数中调用 eval() 不会创建变量 x，因此 调用 alert() 会导致抛出 ReferenceError，因为 x 没有定义。 可以在 eval() 中声明变量和函数，但这些变量或函数只能在被求值的特殊作用域中有效，随后就 将被销毁。因此，以下代码可以运行，没有问题： 123"use strict";var result = eval("var x=10, y=11; x+y");alert(result); //21 这里在 eval() 中声明了变量 x 和 y，然后将它们加在一起，返回了它们的和。于是，result 变 量的值是 21，即 x 和 y 相加的结果。而在调用 alert() 时，尽管 x 和 y 已经不存在了，result 变量的值仍然是有效的。 eval 与 arguments严格模式已经明确禁止使用 eval 和 arguments 作为标识符，也不允许读写它们的值。例如： 12345// 把 eval 和 arguments 作为变量引用var eval = 10;var arguments = "Hello world!";// 非严格模式: 没问题，不出错// 严格模式: 抛出语法错误 在非严格模式下，可以重写 eval，也可以给 arguments 赋值。但在严格模式下，这样做会导致语 法错误。不能将它们用作标识符，意味着以下几种使用方式都会抛出语法错误： 使用var声明 赋予另一个值 尝试修改包含的值，如使用++ 用作函数名 用作命名的函数参数 在 try-catch 语句中用作例外名 抑制 this在非严格模式下使用函数的 apply() 或 call() 方法时，null 或 undefined 值会被转换为全局对象。而在严格模式下，函数的 this 值始终是指定的值，无论指定的是什么值。例如： 12345678//访问属性var color = "red";function displayColor() &#123; alert(this.color);&#125;displayColor.call(null);// 非严格模式: 访问全局属性// 严格模式: 抛出错误，因为 this 的值为 null 以上代码向 displayColor.call() 中传入了 null，如果在是非严格模式下，这意味着函数的 this 值是全局对象。结果就是弹出对话框显示”red”。而在严格模式下，这个函数的 this 的值是 null，因 此在访问 null 的属性时就会抛出错误。 其他变化with抛弃了 with 语句。非严格模式下的 with 语句能够改变解析标识符的路径，但在严格模式下，with 被简化掉了。因此，在严格模式下使用 with 会导致语法错误。例如： 123456//with 的语句用法with(location) &#123; alert(href);&#125;// 非严格模式: 允许// 严格模式: 抛出语法错误 八进制字面量严格模式也去掉了 JavaScript 中的八进制字面量。以 0 开头的八进制字面量过去经常会导致很多错 误。在严格模式下，八进制字面量已经成为无效的语法了。例如： 1234//使用八进制字面量var value = 010;// 非严格模式: 值为 8// 严格模式: 抛出语法错误 ECMAScript5 也修改了严格模式下 parseInt() 的行为。如今，八进制字面量在严格模式下会被当作以 0 开头的十进制字面量。例如： 1234//使用 parseInt() 解析八进制字面量var value = parseInt("010");// 非严格模式: 值为 8// 严格模式: 值为 10]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue+Koa实现cookie传输]]></title>
    <url>%2Fposts%2F26486%2F</url>
    <content type="text"><![CDATA[后端登录接口设置 cookie： 1234567891011121314router.post('/login', async ctx =&gt; &#123; ... let user = &#123; username: 'Lance', age: 20, ... &#125; ctx.cookies.set('username', user.username), &#123; // httpOnly：表示当前设置的cookie是否允许客户端进行操作（js） // 默认true，表示这个cookie能用于http协议的数据传输，但不允许js操作和篡改 httpOnly: false, &#125;); ...&#125;); 读取浏览器自动带上的cookie： 123456router.post(&apos;/like&apos;, async ctx =&gt; &#123; ... // 从cookie中读取 username let username = ctx.cookies.get(&apos;username&apos;); ...&#125;); 文档：Koa - response 前端123456789101112131415161718created() &#123; // 从cookie中获取用户信息cookie // 如果有cookie if (document.cookie) &#123; // cookie = "uid=1; username=admin;" =&gt; ['uid=1', 'username=admin'] let arr1 = document.cookie.split("; "); let cookiesArr = arr1.map(item =&gt; &#123; // item = "uid=1" =&gt; ['uid', 1] let arr2 = item.split("="); return &#123; [arr2[0]]: arr2[1] &#125; &#125;); // &#123;uid: "6", username: "YWRtaW4"&#125; let cookie = Object.assign(&#123;&#125;, ...cookiesArr); ... &#125;&#125;, 后端cookie的加密在 app.js 中添加密钥： 123const app = new Koa();// 密钥app.keys = ['sw_lance']; 然后在 routers/main.js 路由中的cookie设置中增加一个字段： 1234// 设置cookiectx.cookies.set('username', user.username, &#123; signed: true, // 使用加密方式处理&#125;); 这样就能加密了，但在前端chrome下查看cookie会发现，虽然有了加密cookie，但明文的cookie仍然在： 后端session加密首先仍然要在 app.js 中添加密钥： 1234const app = new Koa();// 密钥app.keys = ['sw_lance'];npm i koa-session 在 app.js 中引入： 123456789101112131415const session = require("koa-session")const app = new Koa();// 密钥app.keys = ['sw_lance'];const CONFIG = &#123; key: 'koa:sess', maxAge: 86400000, autoCommit: true, overwrite: true, httpOnly: true, signed: true, rolling: false, renew: false,&#125;;app.use(Session(CONFIG, app)); 在 routers/main.js 的 login API中种下cookie和session： 1234567891011router.post('/login', async ctx =&gt; &#123; ... // uid用下面的session存，username没那么重要，可以用cookie ctx.cookies.set('username', new Buffer(user.get('username')).toString('base64'), &#123; httpOnly: false, signed: true, // maxAge: 10000, &#125;); // uid用session存 ctx.session.uid = user.get('id');&#125;); 在 routers/main.js 的 like API中获取session： 123router.post('/like', async ctx =&gt; &#123; let uid = ctx.session.uid;&#125;);]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>koa</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios异步请求跨域解决方案]]></title>
    <url>%2Fposts%2F15391%2F</url>
    <content type="text"><![CDATA[场景 后端 127.0.0.1（默认80）；前端 127.0.0.1:8081 在 vue 开发过程中使用 axios 发起 POST 请求： 123456axios(&#123; method: 'GET', url: 'http://127.0.0.1'&#125;).then(data =&gt; &#123;&#125;); 会报跨域错误： 原因是浏览器同源策略，只有 同协议、同域名、同端口 三同的地址才能互相通过 AJAX 的方式请求。而上面情形虽然协议（http）和域名（127.0.0.1）都相同，但端口不同（80 和 8081），所以无法正常请求。 解决方案方案一服务端添加响应头，以 Koa 为例，在 app.js 中添加响应头： 1234app.use(async (ctx, next) =&gt; &#123; ctx.set("Access-Control-Allow-Origin", "*"); await next();&#125;); 这样设置会允许任何来源（*）的跨域。 但往往后端的某些接口是需要身份验证的，比如用户对文章、商品之类的进行评论或点赞，就需要用户登录才能操作。这种情况下就需要使用到 cookie 或者 session ，所以还得设置 Access-Control-Allow-Credentials 为 true ，表示在 CORS 请求中允许客户端发送 cookie 。然而一旦这样设置，Access-Control-Allow-Origin 就不能再是通配符 * ，必须指定具体的域，所以服务端最终的 header 设置为： 12345app.use(async (ctx, next) =&gt; &#123; ctx.set("Access-Control-Allow-Origin", "http://127.0.0.1:8081"); ctx.set("Access-Control-Allow-Credentials", true); await next();&#125;); 后端这样设置后，前端就能够实现跨域请求了。 方案二如果服务端不加 ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); 这一段。可以在 @vue-cli 中 配置代理 。也就是 前端设置代理 的解决方案。 原理利用后端不存在跨域问题，而让vue服务器代为获取数据。因为启动vue项目本质上也是用 node 启了个服务器（127.0.0.1:8080），配置了代理后，就不再是浏览器直接请求我们在 axios 中配置的 http://127.0.0.1/（默认80端口） ，而是用vue启动的这个服务器去请求 http://127.0.0.1/ 这个接口，由于后端相互之前请求不存在跨域问题，所以能获取数据，获取后给到前端。 在前端项目根目录下新建 vue.config.js 文件： 1234567891011121314module.exports = &#123; devServer: &#123; proxy: &#123; // 前端 axios 发这样的请求：http://127.0.0.1:8081/api/ (8081是启动vue项目时的端口)，会被此处捕获，然后代为请求真正的服务器API地址 `http://127.0.0.1` '/api': &#123; target: 'http://127.0.0.1', // 此处是服务端API接口，不写端口默认80 changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125; &#125;, &#125; &#125;&#125; 前端发送 POST 跨域请求上面也提到了，前端有时候往往不止需要发送 GET 请求，POST 请求也是常有的事儿。所以还需要对 Axios 进行如下配置： vue 项目下的 main.js 中全局配置 axios 123456import axios from 'axios';axios.defaults.baseURL = 'http://127.0.0.1';axios.defaults.withCredentials = true; // 让 ajax 携带 cookieaxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; // 设置post请求的头部格式Vue.prototype.$ajax = axios 由于需要把请求时的数据序列化为url的形式，所以要下载 qs 包 1npm i qs 在具体页面中发送 POST 请求 123456789101112import qs from 'qs'let loginInfo = &#123; username: '', password: '',&#125;,this.$ajax(&#123;(&#123; method: 'post', url: 'http://127.0.0.1/login', data: qs.stringify(login_info),&#125;)]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CORS详解（转载）]]></title>
    <url>%2Fposts%2F52542%2F</url>
    <content type="text"><![CDATA[转载文章博客源：CORS详解 关于CORS说到CORS，就不得不先了解跨站HTTP请求（Cross-site HTTP request）。 跨域HTTP请求是指发起请求的资源所在域不同于该请求所指向资源所在的域的HTTP请求。 正如大家所知，出于安全考虑，浏览器会限制脚本中发起的跨站请求。使用XMLHttpRequest发起HTTP请求必须遵守同源策略。 具体而言，Web 应用程序能且只能使用 XMLHttpRequest 对象向其加载的源域名发起 HTTP 请求，而不能向任何其它域名发起请求。 由于Web应用技术越来越丰富，我们非常渴望在不丢失安全的前提下，能够实现跨站请求。特别是现在的Web程序结构，一般是HTML+REST API。在之前的实现中，我们一般采用jsonp来发起跨站请求，这其实是利用了html标签的特点。 W3C的Web应用工作组推荐了一种新的机制，即跨域资源共享（Cross-Origin Resource Sharing），也就是当前我们提到的CORS。 CORS的核心，就是让服务器来确定是否允许跨域访问。 1、典型场景1.1、简单请求什么是简单请求？全部满足以下条件的请求可以称之为简单请求： 只使用GET、HEAD或者POST请求方法。如果是POST，则数据类型（Content-Type）只能是application/x-www-form-urlencodeed、multipart/form-data、text/plain中的一种。 没有使用自定义的请求头（如x-token） 按照这个规则，那我们的能实现跨域请求的情况如下： Server代码： 12345678910111213'use strict';var http = require('http');var server = http.createServer((req, res) =&gt; &#123; //之后设置了Access-Control-Allow-Origin，才会允许跨域 res.setHeader('Access-Control-Allow-Origin', '*'); res.write('abc'); res.end();&#125;);server.listen(10000, () =&gt; &#123; console.log('started.');&#125;); Client代码： 1234567891011121314151617181920212223242526var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readyState === XMLHttpRequest.DONE)&#123; console.log('Result：', xhr.responseText); &#125;&#125;//场景一：GET请求，不需要Header，允许跨域xhr.open('GET', 'http://localhost:10000/', true);xhr.send();//场景二： POST请求，需要设置为指定Header（不设置content-type也可），允许跨域xhr.open('POST', 'http://localhost:10000/', true);//此处value必须是text/plain或者application/x-www-form-urlencoded或者multipart/form-data。//此处也可以不设置xhr.setRequestHeader('Content-Type', 'text/plain');xhr.send();//场景三：DELETE请求（不允许跨域）xhr.open('DELETE', 'http://localhost:10000/', true);xhr.send();//场景四：POST请求，有自定义Header（不允许跨域）xhr.open('POST', 'http://localhost:10000/', true);xhr.setRequestHeader('x-token', 'a');xhr.send(); 1.2、预请求不同于简单请求，预请求要求必须先发送一个OPTIONS请求给站点，来查明该站点是否允许跨域请求，这样做的原因是为了避免跨站请求可能对目的站点的数据造成的损坏。 如果请求满足以下任一条件，则会产生预请求： 请求以GET、HEAD、POST之外的方法发起。或者，使用POST，但数据类型为application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。（注：之前的版本只有text/plain可以不用发起预请求）。 使用了自定义请求头。 按照如上规则，我们来列举几个应用场景： Server端代码： 123456789101112131415161718'use strict';var http = require('http');var server = http.createServer((req, res) =&gt; &#123; //之后设置了Access-Control-Allow-Origin，才会允许跨域 res.setHeader('Access-Control-Allow-Origin', '*'); res.setHeader('Access-Control-Allow-Methods', 'POST, DELETE, GET'); res.setHeader('Access-Control-Allow-Headers', 'x-token'); //设置预请求缓存1天，1天内再次请求，可以跳过预请求 //此功能需要客户端缓存支持，如果客户端禁用缓存，那么每次都会预请求 res.setHeader('Access-Control-Max-Age', 60 * 60 * 24); res.write('abc'); res.end();&#125;);server.listen(10000, () =&gt; &#123; console.log('started.');&#125;); Client端代码： 123456789101112131415161718192021222324var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readyState === XMLHttpRequest.DONE)&#123; console.log('Result：', xhr.responseText); &#125;&#125;//场景一：DELETE请求，发送OPTIONS，匹配，允许跨域xhr.open('DELETE', 'http://localhost:10000/', true);xhr.send();//场景二：PUT请求，发送OPTIONS，不匹配，不允许跨域xhr.open('PUT', 'http://localhost:10000/', true);xhr.send();//场景三：DELETE请求匹配，使用自定义Header不匹配，不允许跨域xhr.open('DELETE', 'http://localhost:10000/', true);xhr.setRequestHeader('x-token1', 'aa');xhr.send();//场景四：POST请求，匹配的自定义Header，允许跨域xhr.open('POST', 'http://localhost:10000/', true);xhr.setRequestHeader('x-token', 'a');xhr.send(); 1.3、带凭证的请求一般来说，对于跨站请求，浏览器是不会发送凭证（HTTP Cookies和验证信息）的。如果要发送带凭证的信息，只需要给XMLHttpRequest设置一个特殊的属性withCredentials = true，通过这种方式，浏览器就允许发送凭证信息。 带凭证的请求可能是简单请求，也可以是会有预请求。是否允许跨域，会先判断简单请求和预请求的规则，然后还会带上带凭证的请求自己的规则。 在带凭证的请求中，后端的响应必须包含HeaderAccess-Control-Allow-Credentials=true，同时Header Access-Control-Allow-Origin，不能再使用*号这种匹配符。 具体示例如下： 服务端代码： 123456789101112131415161718'use strict';var http = require('http');var server = http.createServer((req, res) =&gt; &#123; //要处理带凭证的请求，此Header不能使用*。 res.setHeader('Access-Control-Allow-Origin', 'http://10.16.85.170:8000'); res.setHeader('Access-Control-Allow-Methods', 'POST, DELETE, GET'); res.setHeader('Access-Control-Allow-Headers', 'x-token'); res.setHeader('Access-Control-Max-Age', 60 * 60 * 24); //只有设置了该Header，才允许带凭证的请求。 res.setHeader('Access-Control-Allow-Credentials', true); res.write('abc'); res.end();&#125;);server.listen(10000, () =&gt; &#123; console.log('started.');&#125;); 客户端代码： 1234567891011var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readyState === XMLHttpRequest.DONE)&#123; console.log('Result：', xhr.responseText); &#125;&#125;//优先满足预请求，然后满足凭证请求，允许跨域。xhr.open('POST', 'http://localhost:10000/', true);xhr.withCredentials = true;xhr.setRequestHeader('x-token', 'a');xhr.send(); 2、HTTP响应头2.1、 后端HTTP响应头此处列举后端有关CORS的响应头： Access-Control-Allow-Origin： | 允许的域名，只能有一个值。比如“”或“abc.com”，”a.com,b.com”这种不允许 Access-Control-Expose-Headers: 允许的白名单Header，多个用逗号隔开 Access-Control-Max-Age: 预请求缓存时间，单位秒，禁用缓存时无效哦！ Access-Control-Allow-Credentials: true | false 是否允许带凭证的请求，如果为true，则Origin只能是具体的值 Access-Control-Allow-Methods: 允许的请求类型，多个用逗号隔开 Access-Control-Allow-Headers: 在实际请求中，允许的自定义header，多个用逗号隔开 2.2、 浏览器发出跨域请求的响应头此处列举出浏览器在发送跨域请求时，会带上的响应头： Origin: 告诉服务器，请求来自哪里，仅仅是服务器名，不包含路径。 Access-Control-Request-Method: 预请求时，告诉服务器实际的请求方式 Access-Control-Request-Headers: 预请求时，告诉服务器，实际请求所携带的自定义Header 3、参考资料 MDN HTTP access control (CORS) MDN HTTP访问控制(CORS)]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>cors</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsonp解决跨域问题的原理]]></title>
    <url>%2Fposts%2F39860%2F</url>
    <content type="text"><![CDATA[介绍 Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。 ———— 菜鸟教程-jsonp 原理script标签的 src 不受同源策略影响，允许跨域。但需要借助服务端的配合。 示例 前端 index.html 1234567891011121314151617181920212223242526&lt;body&gt; &lt;h1&gt;天气查询&lt;/h1&gt; &lt;input type="text" id="city" placeholder="请输入城市名称"&gt; &lt;input type="button" id="btn" value="查询"&gt; &lt;script&gt; window.onload = function() &#123; // 创建方法用来获取跨域数据（名称随意） window["foo"] = function(data) &#123; // 打印获取的数据 console.log(data); &#125; const btn = document.querySelector("#btn"); btn.onclick = function() &#123; // 获取用户输入城市名 const = city = document.querySelector("#city").value; // 动态创建script标签 const script = document.createElement("script"); // 把回调函数foo的名称 以及 城市名 传递给后端 script.src = `http://127.0.0.1:8084/weather.php?callback=foo&amp;city=$&#123;city&#125;`; const body = document.querySelector("body"); body.appendChild(script); &#125; &#125; &lt;/script&gt;&lt;/body&gt; 后端 weather.php 1234567891011&lt;?php // 获取前端回调函数名和城市名 $cb = $_GET["callback"]; $city = $_GET["city"]; if ($city == "shanghai") &#123; // 调用前端已经定义的函数，把数据当做参数传递给 foo echo $cb."('上海晴，无风')"; &#125; else &#123; echo $cb."('没有查询到你所在城市天气')"; &#125;?&gt; 这样一来当前端请求 http://127.0.0.1:8084/weather.php?callback=foo&amp;city=${city} 后，后端返回的内容就应该类似这种格式： 1foo('上海晴，无风'); 本质就是在调用前端已经定义好的 foo 方法，这样就能够获取到后端返回给我们的数据了。 注意事项由于 jsonp 解决跨域问题本质上是后端返回一个方法调用。所以不是任何接口都支持 jsonp 来获取到数据的，一旦接口不支持，返回的不是方法调用格式（foo(data)）而是 json 格式（{“msg”: “success”, “data”: {…}}）的话，就说明我们无法通过 jsonp 获取到数据。 第三方接口跨域数据获取一旦第三方接口返回的是 json 格式的字符串，我们就无法通过 ajax 或者 jsonp 的方式获取跨域数据。这种情况下我们只能通过自己的服务器当做中转站帮我们前端获取三方接口数据了，因为服务端之间是不存在跨域问题的，所以出现这种情况后，你可以让公司的后端帮帮忙，写一个接口去获取三方接口数据，并暴露一个接口让你能够获取到数据~]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transform3D转换（二）]]></title>
    <url>%2Fposts%2F14243%2F</url>
    <content type="text"><![CDATA[在我当初了解到 transform 后的一段时间，其实是不知道它能够让元素实现3d转换的。直到有一天在逛 codepen 时，我发现了下面这个demo： See the Pen CSS3 Transforms 3D Perspective Carousel by JingW (@JingW) on CodePen. p.s. 原作者地址在这儿：https://codepen.io/Hubson/pen/XmrEGX OS：我靠，还能这样玩儿？赶紧查查如何实现的。（点我重现查找过程） 然后就发现了张鑫旭老师的 这篇文章 。算是给我打开了新世界的大门~ 原来现在的CSS都这么强大了，要知道几年前我在学 .NET 时就接触过HTML和CSS，那个时候不还是满屏div，没啥特效的时代嘛。 扯远了，言归正传。首先来看下面这个图（copy上面文章来的~）： 这个图就是咱们3d变形所依赖的坐标系。要想理解这张图，需要一点空间想象力。我们人在看这个坐标系时，是从左下角的眼睛处从 +Z 往 -Z 里面看的。可以把这个眼睛简单的想象成你自己，由网格组成的正方形平面相当于你在屏幕上创建的一个正方形div元素。那么当你设置 transform: translate(200px, 0) 时，你的元素将会向 +X 方向前进，也就是平常在2d变换中的向右移动。现在应该理解了吧~ rotateX, rotateY, rotateZrotateXrotateX就是沿着 x 轴进行3d旋转。 在下面示例中，我们实现让一个元素沿着它的x轴旋转180°。为了让效果看起来更加明显，我把该元素分成了上下两个部分，并在中间留出了缝隙，以便当做X轴看待，当鼠标移入该元素后，它便“沿着” x 轴旋转180°： See the Pen transform3d-rotateX by JingW (@JingW) on CodePen. rotateY用和上面类似的方式，我们实现 rotateY 的3d旋转效果，让元素沿着 y 轴进行3d旋转： See the Pen transform3d-rotateY by JingW (@JingW) on CodePen. rotateZ还记得那根 z 轴嘛，当我们垂直于屏幕看向元素时，z 轴在我们眼里就是一个“点”。所以当我们使用 rotateZ 来旋转元素时，元素会沿着 z 轴进行旋转，就是下方元素中间的“点”： See the Pen transform3d-rotateZ by JingW (@JingW) on CodePen. perspective 透视这个属性英文直译过来就是 透视、视角的意思。 电脑显示屏是个2d平面，要想让元素在一个2d平面上有立体感（3d效果），就得利用这个 perspective 透视属性。perspective 可以让一个2d平面在转换过程中呈现出3d效果。 不知道大家有没有注意到上面有关 rotateY 下的demo，虽说是沿着元素 y 轴进行旋转，但一点3d立体效果都没有，要知道在现实生活中，如果一张卡片沿着它宽度一半儿的 y 轴进行旋转，肯定有近大远小的透视效果，即离我们近的一面越来越大，离我们远的一面越来越小。如果还没有明白，看了下面的示例就知道了（鼠标移入body就能触发旋转~）： See the Pen transform3d-perspective by JingW (@JingW) on CodePen. 这下是不是明显多啦？其实这都全靠了 perspective 透视，它允许我们为场景添加深度感，原理就是使 z 轴在靠近观察者的元素看起来更大，而更远的元素看起来更小。也就是上面提到的“近大远小”。 我们来看看下面这张图： 上图中蓝色圆圈表示三维空间中的元素，字母 d 表示透视的值，即观看者的眼睛和屏幕之间的距离。字母 Z 表示元素在 z 轴上的位置。元素在 z 轴上越远，相对于观察者的外观越小，它越接近，就看起来越大。这就是三维空间中透视的效果。 perspective VS perspective()perspective有两种写法，一种是直接写在要使用3d转换的父元素身上（如上一个demo）：12345678910111213/* 父容器 */.contaienr &#123; /* 将透视属性写在父容器 */ perspective: 1000px;&#125;/* 需要3d转换的子元素 */.box &#123; transition: transform 1s;&#125;/* 触发转换 */.container:hover box &#123; transform: rotateY(180deg);&#125; 在这种写法下，一旦“舞台（浏览器显示区域）”上有多个元素都进行了3d转换，可能效果就与你的预想不太一样，靠近“舞台”两边的元素会“歪着”进行旋转： See the Pen transform3d-perspective2 by JingW (@JingW) on CodePen. 这是为什么呢？答案是因为默认我们观察者的“眼睛”是处于“舞台”正中央的前方的（这个前方是以“舞台”的视角），所以靠近我们观察者左前方的（观察者视角）卡片，在沿着 x 轴做旋转时，就是“歪着”的；同理观察者右前方卡片也是如此。 那么如果你想让它们都与正中央的卡片一样效果的旋转呢？这就引出了第二种写法：perspective() 。该属性写在3d转换元素本身上，而不是在其父元素上了：12345678.box &#123; transition: transform 1s;&#125;.container:hover .box &#123; /* 1. 沿着x轴旋转180° */ /* 2. 给3d旋转元素本身添加 perspective 透视 */ transform: perspective(500px) rotateX(180deg);&#125; 效果如下： See the Pen transform3d-perspective3 by JingW (@JingW) on CodePen. perspective-origin语法：12perspective-origin: 50% 50%; /* 默认值，表示观察者在“舞台”正中央的上方 */perspective-origin: left center; /* 表示观察者在“舞台”最左边且垂直居中的上方 */ 该属性用于定义观察者观看三维空间时的位置所在。默认情况下为x轴50%、y轴50%。也就是“舞台（屏幕）”正中央的上方。 读者可以尝试用鼠标拖动下方demo中的按钮“camera”到“舞台”的各个位置，然后看看三张卡片的3d转换效果。当你在拖动“camera”改变它的位置时，也就等同于改变了 perspective-origin 的位置。例如当你把按钮“camera”拖动到左上角，就相当于设置了 perspective-origin: left top。 See the Pen transform3d-perspective-origin by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transform转换（一）]]></title>
    <url>%2Fposts%2F45420%2F</url>
    <content type="text"><![CDATA[介绍 Transform属性应用于元素的2D或3D转换。这个属性允许你将元素旋转，缩放，移动，倾斜等。 ———— 出自 菜鸟教程 这次我们讨论的都是2D转换，3D的后面我会单独出一篇~ scale 缩放这个属性用来放大或缩小元素的大小。语法示例如下：123456div &#123; transition: transform 1s; /* 给div的transform属性添加过渡效果 */&#125;div:hover &#123; transform: scale(1.5); /* 让元素放大为原始大小的1.5倍 */&#125; See the Pen transform scale by JingW (@JingW) on CodePen. translate 位移该属性用来让元素向上/向下/向左/向右进行位移。 示例：123456div &#123; transition: transform 1s;&#125;div:hover &#123; transform: translate(20px, 20px);&#125; See the Pen LvbqKb by JingW (@JingW) on CodePen. rotate 旋转该属性让元素能够顺时针或逆时针旋转指定的度数。 示例：123456div &#123; transition: transform 1s;&#125;div:hover &#123; transform: rotate(720deg); /* 元素顺时针旋转720度 */&#125; See the Pen transform rotate by JingW (@JingW) on CodePen. skew 倾斜该属性能够让元素基于x, y轴倾斜转换 示例：12345678div &#123; transition: transform 1s;&#125;div:hover &#123; transform: skew(45deg, 45deg); /* transform: skewX(25deg); transform: skewY(10deg); */&#125; See the Pen transform skew by JingW (@JingW) on CodePen. 注意： 如果仔细观察上面的示例，当鼠标移入box后，不但整个box进行了倾斜，里面的子元素和文本内容也会发生倾斜。如果不希望里面的内容发生变化，可以使用相反的skew值将其恢复： See the Pen transform skew2 by JingW (@JingW) on CodePen. transform-origin 变形原点该属性可以配合 transform 属性一起使用，它允许我们指定元素转换的位置原点。默认情况原点位于元素的中心。 例如刚刚上面在讲到 rotate 属性时，我们的旋转是以中心为原点的。但你在某些情况下可能并不想让元素围绕中心旋转，而是左上角旋转，就可以用到该属性。 语法示例：1234567div &#123; transform-origin: left top; transition: transform 1s;&#125;div:hover &#123; transform: rotate(720deg);&#125; See the Pen transform transform-origin by JingW (@JingW) on CodePen. 变换组合有时候我们可能想要一个元素既旋转又位移，那么我们就可以使用 transform 的简写语法： 123456div &#123; transition: transform 1s;&#125;div:hover &#123; transform: rotate(90deg) scale(1.5);&#125; See the Pen ZZBNmN by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于浏览器的CSS前缀]]></title>
    <url>%2Fposts%2F496%2F</url>
    <content type="text"><![CDATA[突然想起来的，先占个坑，有空再更…]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宏任务&微任务]]></title>
    <url>%2Fposts%2F20664%2F</url>
    <content type="text"><![CDATA[先Mark一下，抽空再写…1234567891011121314151617181920212223242526console.log('sync1');setTimeout(function () &#123; console.log('setTimeout1')&#125;, 0);var promise = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; console.log('setTimeoutPromise') &#125;, 0); console.log('promise'); resolve();&#125;);promise.then(() =&gt; &#123; console.log('pro_then'); setTimeout(() =&gt; &#123; console.log('pro_timeout'); &#125;, 0)&#125;)setTimeout(function () &#123; console.log('last_setTimeout')&#125;, 0);console.log('sync2');]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于sequelize的数据库迁移]]></title>
    <url>%2Fposts%2F16051%2F</url>
    <content type="text"><![CDATA[数据库迁移有时候我们也希望能够跟踪数据库的更改，像 git 一样在各个不同时期的数据库状态之间进行切换。或者能通过一套工具将数据库迁移到本机，让我们在家也能进行测试开发，而不用依赖公司的测试环境。这些特性，作为今天的主角 sequelize-cli 都能提供给我们。 npm链接请 点击这里。 安装首先创建项目，项目名随意，创建完毕后cd到项目根目录，老规矩命令行 npm init -y 创建 package.json ，然后输入安装一步到位：npm i sequelize mysql2 sequelize-cli 。 注意： sequelize-cli 依赖 sequelize，sequelize 依赖 mysql2 安装完毕后我们可以测试下是否可用，根目录命令行输入： 1./node_modules/.bin/sequelize 看见命令行输出类似下方提示代表安装成功： 1234567891011121314151617181920212223242526sequelize [命令]命令： sequelize db:migrate Run pending migrations sequelize db:migrate:schema:timestamps:add Update migration table to have timestamps sequelize db:migrate:status List the status of all migrations sequelize db:migrate:undo Reverts a migration sequelize db:migrate:undo:all Revert all migrations ran sequelize db:seed Run specified seeder sequelize db:seed:undo Deletes data from the database sequelize db:seed:all Run every seeder sequelize db:seed:undo:all Deletes data from the database sequelize db:create Create database specified by configuration sequelize db:drop Drop database specified by configuration sequelize init Initializes project sequelize init:config Initializes configuration sequelize init:migrations Initializes migrations sequelize init:models Initializes models sequelize init:seeders Initializes seeders sequelize migration:generate Generates a new migration file [aliases: migration:create] sequelize model:generate Generates a model and its migration [aliases: model:create] sequelize seed:generate Generates a new seed file [aliases: seed:create]选项： --help 显示帮助信息 [布尔] --version 显示版本号 [布尔] 使用初始化目前我们项目的树形结构为： 1234.├── node_modules├── package-lock.json└── package.json 接着根目录命令行输入 ./node_modules/.bin/sequelize init 来初始化 sequelize 项目，该命令会帮我们创建如下目录：12345678.├── config # 包含数据库的配置文件├── migrations # 包含所有迁移文件（e.g. 数据库、表的创建，字段的增加）跟数据库结构有关的操作都存放在这里├── models # 包含项目中的所有模型（e.g. Users, Message）├── node_modules├── seeders # 包含所有种子文件（e.g. 表中的数据）├── package-lock.json└── package.json config首先我们来看下 config 目录下的 config.json 文件。它里面包含了数据库的的基本配置，默认分为 development（开发） 、test（测试） 和 production（生产） 环境。当然你也可以删除或新增环境，比如新增一个在家编写代码所使用的 home 环境。 db:createsequelize-cli 默认读取 development 模式下的数据库配置来创建数据库，所以接下来就用它来配置：12345678"development": &#123; "username": "root", // 数据库用户名 "password": "root", // 数据库密码 "database": "database_development", // 需要创建的数据库名 "host": "127.0.0.1", // 主机 "port": 8889, // 端口号 "dialect": "mysql" // 使用的数据库类型&#125;, 配置完毕后在根目录下的命令行输入 ./node_modules/.bin/sequelize db:create。当你看到如下输出就代表创建数据库成功：123Loaded configuration file "config/config.json".Using environment "development".Database sw_sequelize_development created. db:drop能添加就能删除，我们可以键入 ./node_modules/.bin/sequelize db:drop 命令来删除数据库。当你看到命令行输出下面内容就代表删除成功：123Loaded configuration file "config/config.json".Using environment "development".Database sw_sequelize_development dropped. 模式切换前面已经说了，sequelize-cli 默认读取 development 模式下的数据库配置。那如果我现在想切到 test 模式下该怎么办呢？ 变更环境变量首先得切换服务器环境变量，MacOS下（其他系统切换命令见下方链接）使用 export NODE_ENV=test 来切换到 test 模式，然后使用 echo $NODE_ENV 查看是否已经切换成功，接着就可以再次执行 ./node_modules/.bin/sequelize db:create 命令，创建 test 模式下的数据库了： 123456789101112$ export NODE_ENV=test$ echo $NODE_ENVtest./node_modules/.bin/sequelize db:createSequelize CLI [Node: 9.0.0, CLI: 5.4.0, ORM: 5.3.3]Loaded configuration file "config/config.json".Using environment "test".Database sw_sequelize_test created. 各系统下NodeJS环境变量修改 还原环境变量如果想回到默认的 development 模式，MacOS下直接键入命令 export NODE_ENV= 就OK啦。 models创建模型我们通过 model:generate 或者 model:create 来创建模型文件，它一共需要两个参数，分别是： –name: 模型名称（必须） –attributes: 字段列表（必须） 回到我们的项目，在根目录执行下面命令来创建一个 User 模型文件： 1./node_modules/.bin/sequelize model:create --name User --attributes username:STRING 执行完毕后命令行会有类似下方输出：1234Sequelize CLI [Node: 9.0.0, CLI: 5.4.0, ORM: 5.3.3]New model was created at .../你的项目名/models/user.js .New migration was created at .../你的项目名/migrations/20190316035632-User.js 所以 model:create 命令执行后帮我们创建了两个文件，一个是用来定义 User 模型的文件 user.js :12345678910'use strict';module.exports = (sequelize, DataTypes) =&gt; &#123; const User = sequelize.define('User', &#123; username: DataTypes.STRING &#125;, &#123;&#125;); User.associate = function(models) &#123; // associations can be defined here &#125;; return User;&#125;; 一个是 migrations 迁移文件夹下的 用来创建 User 表 的文件：12345678910111213141516171819202122232425262728'use strict';module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; // 创建名为 Users 的数据表 return queryInterface.createTable('Users', &#123; id: &#123; allowNull: false, autoIncrement: true, primaryKey: true, type: Sequelize.INTEGER &#125;, username: &#123; type: Sequelize.STRING &#125;, createdAt: &#123; allowNull: false, type: Sequelize.DATE &#125;, updatedAt: &#123; allowNull: false, type: Sequelize.DATE &#125; &#125;); &#125;, down: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.dropTable('Users'); &#125;&#125;; 其中 models 文件夹下文件，例如生成的 user.js 模型文件是给程序用的；migrations 和 seeders 文件夹下的文件是个 cli 用的。 总结下来，model:create 命令帮我们做了两件事情： 创建 User 模型 创建跟模型对应的 Users 数据表文件，方便用此文件在数据库中创建 Users 表 migrations刚刚我们已经创建了一个 User 模型和用来创建 Users 表的脚本执行文件。下面就可以开始执行迁移了。首先我们重温何为执行迁移： 所谓迁移，就是对数据库进行结构的创建、升级（修改）等操作 执行迁移db:migrate执行迁移的命令为 db:migrate，我们直接在项目根目录下运行： 1./node_modules/.bin/sequelize db:migrate （如果在此之前你运行过 db:drop 命令来删除数据库，记得再重新执行一次 db:create，否则会导致创建表失败）。执行成功的输出类似下面文字： 123456Sequelize CLI [Node: 9.0.0, CLI: 5.4.0, ORM: 5.3.3]Loaded configuration file "config/config.json".Using environment "development".== 20190316035632-create-user: migrating ========= 20190316035632-create-user: migrated (0.047s) 此时刷新下你的本地数据库，就会发现之前空空如也的数据库中多了个 users 表和 sequelizemeta 表： users 表被创建出来我们能理解，重点说一下这个 sequelizemeta 表，其实它是用来记录已经被执行过的迁移脚本的，避免我们重复执行已经执行过的脚本。 db:migrate:status我们可以通过 db:migrate:status 命令来查看当前迁移脚本的执行状态： 1./node_modules/.bin/sequelize db:migrate:status 执行完毕后的打印结果为： 123Loaded configuration file "config/config.json".Using environment "development".up 20190316035632-create-user.js 这个 up ，表示我们已经执行该脚本。此时我们可以删掉 sequelizemeta 表中的记录，然后再次执行 db:migrate:status ，会发现输出的 up 已变为 down ，表示我们从未执行过该脚本。由此可知 db:migrate:status 会通过 sequelizemeta 表中的记录来判断脚本是否被执行过。而当我们已经执行过某些脚本后再次执行 db:migrate ，那些已经执行过的脚本就不会再次重复执行了： 123Loaded configuration file "config/config.json".Using environment "development".No migrations were executed, database schema was already up to date. db:migrate:undo除了上面的新增数据表操作，我们还可以进行撤销操作。执行 ./node_modules/.bin/sequelize db:migrate:status 命令后 sequelize-cli 会帮我们撤销掉上一次（最近一次）的迁移操作，比如我们的 sequelizemeta表中记录了两条迁移操作（假设创建了 user 和 message 表）： 1220190316035632-create-user.js20190316035921-create-message.js 那么执行 undo 后就会把最近的一次迁移，也就是 *-message.js 从表中移除，并且在数据库中删除 message 表。而这个删除操作，其实是执行了迁移文件下对应表的删除代码： 123down: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.dropTable('Messages');&#125; db:migrate:undo:all当执行 ./node_modules/.bin/sequelize db:migrate:undo:all 命令后，能帮我们撤销所有的迁移操作。 db:migrate:undo: –name此命令能帮我们撤销具体指定的迁移脚本，例如执行下面命令会撤销名称为 20190316035632-create-user 的脚本操作：1./node_modules/.bin/sequelize db:migrate:undo --name 20190316035632-create-user 执行完毕后再来刷新我们的数据库，就会发现 user 表已被删除，只留下了 message 表。 字段添加与删除随着业务的增长，我们很有可能需要扩充数据表的字段。例如我们需要给 user 表添加一个 username 字段，那么我们就可以键入以下命令来创建一个 migration : 1./node_modules/.bin/sequelize migration:create --name UserAddAge 执行完上述操作后我们能在 migrations 文件夹中看到新创建的 UserAddAge 文件，打开后代码如下：1234567891011121314151617181920212223'use strict';module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; /* Add altering commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.createTable('users', &#123; id: Sequelize.INTEGER &#125;); */ &#125;, down: (queryInterface, Sequelize) =&gt; &#123; /* Add reverting commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.dropTable('users'); */ &#125;&#125;; 我们要做的，就是在 up 和 down 方法中填入数据库操作逻辑的代码，up 方法中有注释作提示，让我们返回一个类型为 Promise 的对象，还给出了示例。因为我们要给数据表添加字段，所以使用 addColumn 方法： 123456789return queryInterface.addColumn( 'users', // 被添加字段的表名称 'age', // 需要添加的字段名称 &#123; type: Sequelize.TINYINT, allowNull: false, defaultValue: 0, &#125;, // 字段属性) 这样我们就可以给 user 表添加上 age 字段了。 p.s. 之所以代码中填写 users ，是因为 sequelize-cli 帮我们创建表是会自动给表名称加 s 。 能添加就能删除，删除操作我们在 down 方法中编写： 1234return queryInterface.removeColumn( 'users', 'age'); UserAddAge.js 文件完整代码：123456789101112131415161718192021222324252627282930313233343536'use strict';module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; /* Add altering commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.createTable('users', &#123; id: Sequelize.INTEGER &#125;); */ return queryInterface.addColumn( 'users', 'age', &#123; type: Sequelize.TINYINT, allowNull: false, defaultValue: 0, &#125; ) &#125;, down: (queryInterface, Sequelize) =&gt; &#123; /* Add reverting commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.dropTable('users'); */ return queryInterface.removeColumn( 'users', 'age' ); &#125;&#125;; 编写完毕后我们运行 ./node_modules/.bin/sequelize db:migrate 来重新执行一遍所有迁移，刷新 user 表后就能看见新增字段 age 了。 最后你还可以执行 ./node_modules/.bin/sequelize db:migrate:undo 来确认 down 方法正常工作，从而让 user 表删除刚刚添加的 age 字段。 文档参考：更多 QueryInterface 操作 seeders除了数据库结构的添加修改删除操作以外，我们通常还会给各种表批量添加一些假数据。这个时候就要用到 seeders 里的种子文件了。比方说现在要给 user 表批量添加一些数据，则可以执行下面代码：1./node_modules/.bin/sequelize seed:create --name userTest 执行完毕后你会发现在 seeders 文件夹下多了一个类似 20190316090425-userTest.js 的文件。 批量添加我们可以在里面编写代码让 cli 帮助我们批量添加数据：12345678910111213141516171819202122232425262728293031323334353637'use strict';module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; /* Add altering commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.bulkInsert('People', [&#123; name: 'John Doe', isBetaMember: false &#125;], &#123;&#125;); */ return queryInterface.bulkInsert('users', [ &#123; username: '狄仁杰', age: 56 &#125;, &#123; username: '李元芳', age: 27 &#125; ]); &#125;, down: (queryInterface, Sequelize) =&gt; &#123; /* Add reverting commands here. Return a promise to correctly handle asynchronicity. Example: return queryInterface.bulkDelete('People', null, &#123;&#125;); */ return queryInterface.bulkDelete('users', null, &#123;&#125;); &#125;&#125;; 种子文件的执行方式有两种： db:seed 种子文件名 来运行指定种子文件 db:seed:all 来运行所有种子文件 知道执行方法后我们来运行下面命令： 1./node_modules/.bin/sequelize db:seed:all 执行成功后刷新我们的 user 表，就会发现数据已经被批量添加进去了。 批量删除命令行输入并执行： ./node_modules/.bin/sequelize db:seed:undo:all 便可以批量删除刚刚添加进 user 表中的数据。 记录种子数据的存储我们知道 migrations 迁移是会被记录的（数据库的 sequelizemeta 表中），但默认情况下，种子数据的存储不会被记录下来。但官方同样提供了 方法 来记录种子数据的存储。我们可以通过在配置文件中使用 seederStorage 来记录存储： JSON记录 config/config.json 12345"development": &#123; ... "seederStorage": "json", // 存储类型 "seederStoragePath": "userTestData.json" // 存储路径（当前项目根目录下）&#125;, p.s. 上方注释在 copy 到自己项目时需要删除，否则报错。 接着我们执行 ./node_modules/.bin/sequelize db:seed:undo:all 先删除数据表中数据，然后再执行 ./node_modules/.bin/sequelize db:seed:all 重新添加一次种子数据。你就会发现项目根目录下多出来了一个叫做 userTestData.json 的文件，里面记录了已经执行过的种子文件名：123[ "20190316090425-userTest.js"] sequelize记录p.s. 如果你已经用上面json记录的方式记录过种子文件的存储，再想要尝试用sequelize玩一遍的话，首先得执行一遍 ./node_modules/.bin/sequelize db:seed:undo:all 哦。 123456"development": &#123; ... "seederStorage": "sequelize", // 存储类型 "seederStoragePath": "userTestData.json", // 存储路径（当前项目根目录下） "seederStorageTableName": "userTestData" // 存储的表名&#125;, 编写完上述代码后你可以执行下面命令： 1./node_modules/.bin/sequelize db:seed:all 执行完毕后刷新数据库，就能在数据库中发现 userTestData 表，里面记录了已经执行完毕的种子文件 20190316090425-userTest.js 版本安装的 sequelize 和 mysql2 的版本为：1234"dependencies": &#123; "sequelize": "^5.3.3", "sequelize-cli": "^5.4.0"&#125; 资源 QueryInterface 操作]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
        <category>Sequelize</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>SQL</tag>
        <tag>Sequelize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sequelize框架进阶]]></title>
    <url>%2Fposts%2F3278%2F</url>
    <content type="text"><![CDATA[传送门 Sequelize框架入门 前言上一篇入门讲到了 Sequelize框架 的基本用法，比如实现简单的增删查改。原本打算一篇文章写到底的，但感觉内容太多，对读者不太友好，就另开了这篇文章。 虽然标题写着“进阶”，但其实有标题党的以为。这篇文章仍然着手于框架的使用，不涉及源码。大纲见侧边栏的目录，我们直接开始吧~ 连表查询准备工作既然是连表查询，至少得有两个表吧。所以我们还需要另外新建一张表，这里起名为 message 表，表结构如下： 其中 uid 对应用户的 id 。下面是两表的数据： 接着我们新建一个 app2.js 文件，引入之前 app.js 中的部分代码（连接数据库+UserModel）以及创建一个 MessageModel 模型：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const Sequelize = require('sequelize');const sequelize = new Sequelize("miaov", "root", "root", &#123; host: "127.0.0.1", port: 8889, dialect: "mysql"&#125;);try &#123; sequelize.authenticate(); console.log('数据库连接成功!');&#125; catch (err) &#123; console.log('连接失败');&#125;const UserModel = sequelize.define('User', &#123; id: &#123; type: Sequelize.INTEGER(11), allowNull: false, autoIncrement: true, primaryKey: true, &#125;, username: &#123; type: Sequelize.STRING(50), allowNull: false, defaultValue: '', &#125;, age: &#123; type: Sequelize.TINYINT(3), allowNull: false, &#125;, gender: &#123; type: Sequelize.ENUM(['men', 'women', 'other']), allowNull: false, defaultValue: 'men', &#125;,&#125;, &#123; timestamps: false, tableName: 'users',&#125;);const MessageModel = sequelize.define('Message', &#123; id: &#123; type: Sequelize.INTEGER(11), primaryKey: true, allowNull: false, autoIncrement: true, &#125;, uid: &#123; type: Sequelize.INTEGER(11), allowNull: false, defaultValue: 0, &#125;, content: &#123; type: Sequelize.STRING(255), allowNull: false, defaultValue: '', &#125;&#125;, &#123; timestamps: false, freezeTableName: true, // 默认 false 将自动修改表名为复数，true 表示不修改表名，与数据库表名同步 tableName: 'message'&#125;); 需求+普通做法我们这次的需求是获取某条留言的所有数据，其中包含 留言本身的数据 + 该留言的用户数据 ，先来看最“耿直”的做法： 123456789101112131415161718(async () =&gt; &#123; let data = &#123;&#125;; // 根据 id 查找 message let message = await MessageModel.findByPk(1); // 根据 message 的 uid 反查出发布这条 message 的 user let user = await UserModel.findByPk(message.get('uid')); Object.assign(data, &#123; id: message.id, uid: message.uid, content: message.content, username: user.username, age: user.age, gender: user.gender, &#125;); console.log(data);&#125;)(); BelongsTo除了上面这种做法外，我们还可以使用 sequelize 提供的 BelongsTo 来关联两个模型进行查询。 思考一下我们的 users 和 message 表，从 message 的角度来讲，一条留言属于一个用户发布的，是一对一的关系。而 BelongsTo 关联的含义就是 A 属于 B。那我们应该怎么写代码呢？步骤如下： 首先在模型中给关联的字段定义外键关系 1234references: &#123; model: 关联的外键表模型, e.g. UserModel key: 关联的外键表的字段, e.g. id&#125; 在调用 belongsTo 或 hasMany 等方法的时候，通过第二个参数设置对象 123&#123; foreignKey: 当前关联表的字段, e.g. uid&#125; 没有完全理解上面的步骤也没关系，直接上代码更加清晰：1234567891011121314151617181920212223242526272829const MessageModel = sequelize.define('Message', &#123; ..., uid: &#123; // 第一步：在模型中给关联的字段定义外键关系 ... references: &#123; model: UserModel, // 关联的外键表模型 key: 'id', // 关联的外键表的字段 &#125; &#125;, ...&#125;, ...);(async () =&gt; &#123; // 第二步：声明两表关系及外键 // 下面方法翻译过来：留言属于用户 MessageModel.belongsTo(UserModel, &#123; foreignKey: 'uid' // 声明自己（message）的外键是 uid &#125;); let data = await MessageModel.findByPk(1, &#123; include: [UserModel] // 表述查出的 message 记录中包含有对应的 user &#125;); console.log(` 留言id：$&#123;data.id&#125; 留言人名称：$&#123;data.User.username&#125; 留言内容：$&#123;data.content&#125; `);&#125;)(); HasMany这次我们换个角度，来通过某个用户查找他/她所有的留言。稍微想一下，一个用户是可以发布多条留言的，所以从 users 角度来讲，跟 message 是一对多的关系。而 sequelize 也提供了处理这种关系的方法，那就是 HasMany。直接上代码：123456789101112131415161718(async () =&gt; &#123; // users 拥有 UserModel.hasMany(MessageModel, &#123; foreignKey: 'uid', &#125;); let data = await UserModel.findByPk(3, &#123; include: [MessageModel] &#125;); console.log(` id为 $&#123;data.id&#125; 的留言人 $&#123;data.username&#125; 的留言内容： `); data.Messages.forEach(m =&gt; &#123; console.log(` $&#123;m.content&#125;`); &#125;);&#125;)(); 版本安装的 sequelize 和 mysql2 的版本为：1234"dependencies": &#123; "mysql2": "^1.6.5", "sequelize": "^5.3.1"&#125;]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
        <category>Sequelize</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>SQL</tag>
        <tag>Sequelize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sequelize框架入门]]></title>
    <url>%2Fposts%2F1183%2F</url>
    <content type="text"><![CDATA[前言平常写前端项目时，为了更方便的获取“真实”的动态数据，也会新建几个数据库表来作支撑。但每每需要用Node搭建后端服务时，数据库的查询真的让人头疼，难倒不难，就是特别繁琐，即使封装了个查询sql用工具模块，在遇到稍复杂的查询语句时还是得写完整SQL。 我又是个比较懒的人，在经历了几次痛苦折磨后，我开始google有没有谁帮我们解决了数据库表字段与对象之间的关系映射。也就是我们通常所说的 ORM 。经过几番搜索，我找到了 Sequelize 框架。在了解它之前，我们先简单介绍下什么是 ORM ：（我知道不少人是不会点击上面链接查看详情的 :)） 介绍ORMORM 全称 Object Relational Mapping，翻译成中文就是 对象关系映射 。是对 SQL 查询语句的封装，让我们可以用面向对象的方式操作数据库，来更加优雅的生成安全、可维护的 SQL 代码。说白了，就是通过对象来映射和操作数据库。 Sequelize而今天的主角 Sequelize 则是一个基于 promise 的 Node.js 异步ORM框架。它能够支持多种数据库，包含但不限于 PostgreSQL, MySQL 和 MSSQL 。 官网地址：http://docs.sequelizejs.com/github：https://github.com/sequelize/sequelize 使用起步在本地新建文件夹，例如 sequelize-demo ，然后在项目根目录下运行命令行命名 npm init -y。运行完该命令后项目tree如下： 接着使用 npm 安装 sequelize：1npm i sequelize 连接数据库完成上述步骤以后，我们在根目录下新建一个 app.js 文件来使用 sequelize ，代码如下： 12345678910111213141516171819// 导入 sequelizeconst Sequelize = require('sequelize');// 新建 sequelize 实例const sequelize = new Sequelize('数据库名称', '数据库用户名', '数据库密码', &#123; // 其他的数据库连接配置 host: '127.0.0.1', // 主机，默认 localhost port: 8889, // 端口，默认 3306 dialect: 'mysql', // 数据库类型， 默认 mysql 【必填】 timezone: '+08:00' // 时区，默认会根据系统当前所在时区进行设置，格式：'+08:00' 或字符串格式 'Asia/Shanghai' 参考：http://php.net/manual/zh/timezones.php 【使用场景：一般情况下默认配置就好，但如果服务器在美国，但想存储中国时区，就需要明确指定 '+08:00' 了】&#125;);// 测试数据库的连接（返回的是一个Promise，记得 catch 捕获错误）try &#123; sequelize.authenticate(); console.log('数据库连接成功!');&#125; catch (err) &#123; console.log('连接失败'); &#125; 此时你可以尝试运行 app.js 文件，即在根目录下运行 node app.js 命令。正常情况下你会收到报错信息，类似这样： 意思是你需要安装 mysql2 ，这是因为 sequelize 虽然依赖了 mysql2 ，但却没有内置安装。所以接下来你得在项目根目录下运行如下代码来安装 mysql2：1npm i mysql2 安装完毕后再次运行 app.js ，就能连接数据库成功了：123$ node app.jsExecuting (default): SELECT 1+1 AS result数据库连接成功! 定义模型（Model） 所谓模型，就是用来描述数据库表字段信息的对象，每一个模型对象表示数据库中的一个表，后续对数据库的操作都是用过对应的模型对象来完成的。 接下来我们就要定义数据的模型了。在此之前，你还需要做一些准备工作。以我为例，我在数据库中新建了一个 users 表，表字段和类型如下： 然后定义出对应此表的数据模型：123456789101112131415161718192021222324252627// 定义模型（用对象的方式来描述数据库中的表）const UserModel = sequelize.define('User', &#123; // 描述表中对应的字段信息 id: &#123; // 每一个字段的信息 type: Sequelize.INTEGER(11), // 字段类型 allowNull: false, // 不允许为空 autoIncrement: true, // id自增长 primaryKey: true, // 设为主键 &#125;, username: &#123; type: Sequelize.STRING(50), allowNull: false, defaultValue: '', // 设置字段默认值 &#125;, age: &#123; type: Sequelize.TINYINT(3), allowNull: false, &#125;, gender: &#123; type: Sequelize.ENUM(['men', 'women', 'other']), // 这是个枚举类型字段，表示性别只能为“男”，“女”，“保密”中的其中一个，传入 ENUM 中的可以是逗号隔开的字符串，也可以是个数组：ENUM(['men', 'women']) or ENUM('men', 'women', 'other') allowNull: false, defaultValue: 'men', &#125;,&#125;, &#123; // 用来设置字段以外的其他信息 timestamps: false, // 是否给每条记录添加 createAt 和 updateAt 字段，并在添加新数据和更新数据的时候自动设置这两个字段的值，默认为 true tableName: 'users', // 该模型映射的真实表名&#125;); 注意：在定义模型时，字段名称可以和数据库表中的字段名称不相同，但如果你想另起一个别名，则需要在字段信息设置中加入 field 来关联真正的表字段名称。例如：12345userName: &#123; // &lt;-- 你起的别名 type: Sequelize.STRING(50), allowNull: false, field: 'username', // 关联数据库表中真正的字段名&#125;, 数据查询查询所有完成表模型的定义以后，我们就可以通过 findAll 来查询表数据了：1234567891011// 查询 users 表中所有数据UserModel.findAll().then(users =&gt; &#123; // 返回的 users 是个数组 users.forEach(user =&gt; &#123; // 循环的每个 user 都是个 Model 实例 // 该 Model 实例包含 get 方法，我们能通过它获取 username console.log(user.get('username')); &#125;);&#125;).catch(err =&gt; &#123; console.log(err);&#125;); 写完上面代码后，再次运行 app.js ，你就应该能够查询到数据了~p.s. 查询之前别忘了在数据库中插入一些数据。 条件查询除了查询全部数据，我们还可以使用 where 查询指定的数据：12345678910// 这次不用 .then 形式，而采用 async + await(async function() &#123; // 查找 username 为 '李元芳' 的唯一数据 let res = await UserModel.findOne(&#123; where: &#123; username: '李元芳' &#125; &#125;) console.dir(res);&#125;)(); 而类似大于小于这样的查询会稍显麻烦一点。例如我们来编写查询 users 表中年龄大于某个值的代码：123456789101112(async function () &#123; // 查找满足 age &gt; 24 的所有数据 let res = await UserModel.findAll(&#123; where: &#123; age: &#123; [Sequelize.Op.gt]: 24, &#125; &#125; &#125;) // 打印出符合条件的用户的 username console.dir(res.map(r =&gt; r.get('username')));&#125;)(); 多条件查询除了单一条件查询，我们还可以通过嵌套 or 或 and 运算符的集合来生成复杂条件语句。例如我们来查询 年龄小于25 或者 性别为男 的所有数据：1234567891011121314151617181920(async function () &#123; let &#123; Op &#125; = Sequelize; // 查找满足 age &lt; 25 或 gender = 'men' 的所有数据 let res = await UserModel.findAll(&#123; where: &#123; [Op.or]: [ &#123; age: &#123; [Sequelize.Op.lt]: 25, &#125; &#125;, &#123; gender: 'men' &#125; ] &#125; &#125;) // 打印出符合条件的用户的 username console.dir(res.map(r =&gt; r.get('username')));&#125;)(); 从上面几组查询语句我们可以看出，where 通常用 attribute: value 键值对获取一个对象，其中 value 可以是匹配等式的数据或其他运算符的键值对象。更多查询语法可在下方链接查询： Sequelize - Querying Sequelize - Querying（中文文档） 查询限制 limit, offset我们还能限制查询的数量：1234567(async () =&gt; &#123; // 只从表中查询两条数据 let res = await UserModel.findAll(&#123; limit: 2, &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;)(); 跳过前2条数据：123456(async () =&gt; &#123; let res = await UserModel.findAll(&#123; offset: 2, &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;)(); 跳过前2条数据并获取3条：1234567(async () =&gt; &#123; let res = await UserModel.findAll(&#123; offset: 2, limit: 3 &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;)(); 查询排序我们还可以将查询数据进行排序：123456789(async () =&gt; &#123; // 查询的结果按年龄高到低排序 let res = await UserModel.findAll(&#123; order: [ ['age', 'desc'] ] &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;)(); 查询记录有些时候我们可能只是想单纯的查询数据表中有多少条数据，这时可以用 count() 方法：js(async () =&gt; { // 查询 users 表中有多少条数据 let count = await UserModel.count(); console.log(count);})();12345678910或者使用 `findAndCountAll()` 方法在数据库中搜索多条记录，它能返回给我们**数据和总计数**：```js(async () =&gt; &#123; // 查询 users 表中的前两条数据，并返回 users 表中总记录数 let res = await UserModel.findAndCountAll(&#123; limit: 2, &#125;); console.log(res);&#125;)(); 查询结果的格式如下：123456&#123; count: 总记录数, rows: [ &#123;第一条记录&#125;, &#123;第二条记录&#125;, ... ]&#125; 这个方法对我们为前端提供分页功能很方便，count是符合条件的总记录数，而rows中可以是当前页数下的记录数。 数据增加既然能查，当然就能往数据库插入数据，在 sequelize 中，插入数据可以用 build 方法：123456789101112131415// 新建一条数据（除了build外，还可以通过 new UserModel(&#123;&#125;) 的形式创建一条记录）let wangwu = UserModel.build(&#123; username: '王五', age: 22, gender: 'men'&#125;);// **注意：** 通过 new 或 build 出来的对象不会立即同步到数据库中，// 需要使用后续的一些方法（例如 save ）来同步// 你还可以修改这条数据wangwu.set('age', 25);// 最后别忘了保存才能成功插入数据wangwu.save(); 如果运行后没报错，去数据库刷新表吧，数据已经成功的插入到 users 表了~ 数据修改实际开发中修改数据是再平常不过的了，比如修改一篇博客，更新自己的个人信息… 在 sequelize 中，我们这样修改数据：1234567// 查询id为2的用户数据UserModel.findByPk(2).then(user =&gt; &#123; // 查询到以后修改其 age 字段为 99 user.set('age', 99); // 修改后别忘了保存 user.save();&#125;); 注意： 在 Sequelize v5 版本以前，通过id查询数据的方法名为 findById ，从 v5 版本开始，更改为 findByPk 。其实想一下这样非常合理，以前的 findById 太主观了，要知道不一定每个表的主键都为 id ，所以更改为 findByPk 后，表示通过主键（Pk -&gt; PrimaryKey）查找，sequelize 会自动通过你在创建表模型时定义的主键字段查找。例如我们一开始在定义 User 模型时，就给 id 字段添加了 primaryKey: true, 属性。 除了 set + update 来更新数据以外，还可以使用 update() 方法做相同的事情：12345678(async function () &#123; // 先查询 let xiaohong = await UserModel.findByPk(3); // update方法相当于 set + save await xiaohong.update(&#123; age: 22, &#125;);&#125;)(); 数据删除如果想要删除一条数据，可以使用 destroy 方法：123456(async function () &#123; // 先查询 let wangwu = await UserModel.findByPk(4); // 对查询到的数据进行删除 wangwu.destroy();&#125;)(); 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194const Sequelize = require('sequelize');const sequelize = new Sequelize("miaov", "root", "root", &#123; // 其他的数据库连接配置 host: "127.0.0.1", // 主机 port: 8889, // 端口 dialect: "mysql" // 数据库类型&#125;);// 测试连接try &#123; sequelize.authenticate(); console.log('数据库连接成功!');&#125; catch (err) &#123; console.log('连接失败'); &#125;// 定义模型（用对象的方式来描述数据库中的表）const UserModel = sequelize.define('User', &#123; // 定义字段 id: &#123; // 对字段属性的定义 type: Sequelize.INTEGER(11), // 字段类型 allowNull: false, // 不允许为空 autoIncrement: true, // id自增长 primaryKey: true, // 设为主键 &#125;, username: &#123; type: Sequelize.STRING(50), allowNull: false, defaultValue: '', // 设置字段默认值 &#125;, age: &#123; type: Sequelize.TINYINT(3), allowNull: false, &#125;, gender: &#123; type: Sequelize.ENUM(['men', 'women', 'other']), allowNull: false, defaultValue: 'men', &#125;,&#125;, &#123; // 用来设置字段以外的其他信息 timestamps: false, // 是否给每条记录添加 createAt 和 updateAt 字段，并在添加新数据和更新数据的时候自动设置这两个字段的值，默认为 true tableName: 'users', // 该模型映射的真实表名&#125;);// 为了方便学习，使用一个函数包裹一组代码// 这样代码就不会运行了，从而避免干扰其他代码的执行// 如果想要此函数中代码执行，添加 `()` 就好// (function()&#123;...&#125;)(); &lt;-- 加上括号(function() &#123; // 查询 users 表中所有数据 UserModel.findAll().then(users =&gt; &#123; // 返回的 users 是个数组 users.forEach(user =&gt; &#123; // 循环的每个 user 都是个 Model 实例 // 该 Model 实例包含 get 方法，我们能通过它获取 username console.log(user.get('username')); &#125;); &#125;).catch(err =&gt; &#123; console.log(err); &#125;);&#125;);(async function() &#123; // 新建一条数据（除了build外，还可以通过 new UserModel() 的形式创建一条记录） let liyuanfang = UserModel.build(&#123; username: '李元芳', age: 09, gender: 'men' &#125;); // 修改数据 liyuanfang.set('age', 25); // 别忘了保存 await liyuanfang.save();&#125;);(function() &#123; // 查询id为2的用户数据 UserModel.findByPk(2).then(user =&gt; &#123; // 查询到以后修改其 age 字段为 99 user.set('age', 99); // 修改后别忘了保存 user.save(); &#125;);&#125;);(async function() &#123; // 先查询 let xiaohong = await UserModel.findByPk(3); // update方法相当于 set + save await xiaohong.update(&#123; age: 18 &#125;);&#125;);(async function () &#123; // 先查询 let wangwu = await UserModel.findByPk(4); // 对查询到的数据进行删除 wangwu.destroy();&#125;);(async function() &#123; // 查找 username 为 '李元芳' 的唯一数据 let res = await UserModel.findOne(&#123; where: &#123; username: '李元芳' &#125; &#125;) console.dir(res);&#125;);(async function () &#123; // 查找满足 age &gt; 24 的所有数据 let res = await UserModel.findAll(&#123; where: &#123; age: &#123; [Sequelize.Op.gt]: 24, &#125; &#125; &#125;) // 打印出符合条件的用户的 username console.dir(res.map(r =&gt; r.get('username')));&#125;);(async function () &#123; let &#123; Op &#125; = Sequelize; // 查找满足 age &lt; 25 或 gender = 'men' 的所有数据 let res = await UserModel.findAll(&#123; where: &#123; [Op.or]: [ &#123; age: &#123; [Sequelize.Op.lt]: 25, &#125; &#125;, &#123; gender: 'men' &#125; ] &#125; &#125;) // 打印出符合条件的用户的 username console.dir(res.map(r =&gt; r.get('username')));&#125;);(async () =&gt; &#123; // 只从表中查询两条数据 let res = await UserModel.findAll(&#123; limit: 2, &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;);(async () =&gt; &#123; // 跳过前2条数据 let res = await UserModel.findAll(&#123; offset: 2, &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;);(async () =&gt; &#123; // 跳过前2条数据并获取3条 let res = await UserModel.findAll(&#123; offset: 2, limit: 3 &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;);(async () =&gt; &#123; // 查询的结果按年龄高到低排序 let res = await UserModel.findAll(&#123; order: [ ['age', 'desc'] ] &#125;); console.log(res.map(r =&gt; r.get('username')));&#125;);(async () =&gt; &#123; // 查询的结果按年龄高到低排序 let count = await UserModel.count(); console.log(count);&#125;);(async () =&gt; &#123; // 查询 users 表中的前两条数据，并返回 users 表中总记录数 let res = await UserModel.findAndCountAll(&#123; limit: 2, &#125;); console.log(res);&#125;)(); 版本安装的 sequelize 和 mysql2 的版本为：1234"dependencies": &#123; "mysql2": "^1.6.5", "sequelize": "^5.3.1"&#125; 资源 Sequelize Docs Sequelize Docs 中文版]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
        <category>Sequelize</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[animation动画（二）]]></title>
    <url>%2Fposts%2F20298%2F</url>
    <content type="text"><![CDATA[传送门 animation动画（一） animation动画（二） 老规矩，二系列来谈谈具体每个动画属性的含义和用法，算是一个对知识点的总结吧。 animation-name 动画名称CSS语法：animation-name: shrink 用来设置元素的动画名称。 animation-duration 持续时间CSS语法：animation-duration: 1s 用来指定动画在一个周期内所花费的时间。 animation-timing-function 运动曲线CSS语法：animation-timing-function: ease-in-out 用来设置元素的动画速度曲线，它的用法和 transition-timing-function 类似，想要了解详情的直接点这个链接吧。 DEMO See the Pen animation-timing-function by JingW (@JingW) on CodePen. animation-delay 动画延迟CSS语法：animation-delay: 1s 用来设置动画延迟多少秒/毫秒后才开始执行。正值（例如2s）将在2s后启动动画；负值（例如-2s）将立即执行动画，但是动画会从它的动画序列中的第2s位置处立即开始。 animation-iteration-count 循环次数CSS语法：animation-iteration-count: 1s 用来设置动画循环的次数，默认值是1，表示动画只播放一次。除了使用正整数来设置次数外，还可以将值设置为 infinite ，表示无限循环。 animation-direction 是否反向CSS语法：animation-direction: normal | reverse | alternate | alternate-reverse 用来设置动画在循环过程中是否反向运动，默认值为 normal ，即正常模式，动画会从第一帧播放到最后一帧；reverse 表示反向模式，动画会从最后一帧倒着播放到第一帧；alternate 设置动画先正向播放，第二次再从反向播放，交替进行，例如 animation 系列一中的案例；alternate-reverse 则是先让动画反向播放，第二次再正向播放，交替进行。 animation-fill-mode 动画填充模式CSS语法：animation-fill-mode: none | forwards | backwards | both 用来指定在动画执行之前和之后如何给动画的目标应用样式。这个属性在我第一次接触时没太理解，直到我看了 segmentfault 上的 这篇文章 。 在理解它之前，我们需要在脑海里有个概念，那就是一个动画是分为初始状态、等待期、动画执行期、完成期四个阶段的。而上面 animation-fill-mode 接收的四个值则分别对应： none 表示 等待期和完成期，元素样式都为初始状态样式，不受动画定义（@keyframes）的影响 forwards 表示等待期保持初始样式，完成期间保持最后一帧样式 backwards 表示等待期为第一帧样式，完成期跳转为初始样式 both 表示 等待期样式为第一帧样式，完成期保持最后一帧样式 单纯的文字不直观？相信下面的这个demo能让你豁然开朗： See the Pen animation-fill-mode by JingW (@JingW) on CodePen. animation-play-state 动画播放状态CSS语法：animation-play-state: running | paused 用来设置动画的播放或者暂停。比如希望在鼠标经过的时候，让动画先停止下来，鼠标移开之后再继续播放，就可以通过设置 .element:hover { animation-play-state: paused; } 来实现。下面是一个案例，在鼠标移入时钟后指针暂停旋转；移出后时钟继续旋转。 See the Pen animation-play-state闹钟示例 by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[animation动画（一）]]></title>
    <url>%2Fposts%2F31280%2F</url>
    <content type="text"><![CDATA[传送门 animation动画（一） animation动画（二） 介绍 CSS Animations 是CSS的一个模块，它定义了如何用关键帧来随时间推移对CSS属性的值进行动画处理。关键帧动画的行为可以通过指定它们的持续时间，它们的重复次数以及它们如何重复来控制。 ———— 出自 CSS Animations | MDN 语法1234/* 简写 */animation: 动画名称，一个周期所花费的时间，运动曲线（默认ease）， 动画延迟（默认0），播放次数（默认1）， 是否反向播放动画（默认normal），是否暂停动画（默认running） 就像在介绍中写到的那样，整个 animations 是个模块，包含很多属性来定义动画，比方说 animation-name 、animation-duration 和 animation-delay 等等。但本着快速上手的目的，第一篇文章主要围绕 animation 这个简写属性来讲，因为用它最直观，而且就经验来讲，日常使用最多的也是这个属性。 如何使用一个CSS3动画由两个基本项组成： 关键帧（Keyforames） - 用来定义动画的阶段和样式。 动画属性 - 分配关键帧（@keyframes）到一个特定的css元素，来定义它的动画方式。 我们围绕这两项讨论，并在这个过程中实现一个按钮不断放大缩小的动画效果： keyframes关键帧 keyframes 定义了动画在每个阶段的动画效果。它包括： 动画名称：定义动画的名称 动画阶段：整个动画阶段用百分比来表示。0% 表示动画的开始状态。100% 表示动画的结束状态。可以在其间添加多个中间状态，比如 20%，60%… 动画属性：给动画每个阶段定义的CSS属性 现在我们来编写一段 @keyframes 。动画名称命名为 shrink 。它只有简单的两个阶段： 第一阶段（0%）：元素的缩放比例为 1:1 第二阶段（100%）：元素的缩放比例为 1:0.8 12345678910@keyframes shrink &#123; 0% &#123; -webkit-transform: scale(1); transform: scale(1); &#125; 100% &#123; -webkit-transform: scale(0.8); transform: scale(0.8); &#125;&#125; 动画属性接着，我们给要设置动画的元素添加上动画属性。要使动画生效，我们至少要添加以下两个动画属性： animation-name: 动画的名称，在 @keyframes 中定义。 animation-duration: 动画的持续时间，以秒为单位（例如 5s）或毫秒（例如 200ms）。 12345678button &#123; /* 其他样式 */ ... /* 动画名称: shrink */ animation-name: shrink; /* 动画持续时间: 0.5秒 */ animation-duration: .5s;&#125; 这样我们就实现页面加载后，一个按钮从开始的原始大小，经过0.5s后变成了原始大小的0.8的动画效果。然而我们希望最终的效果是一个按钮的不断放大和缩小，交替进行。这就得添加 animation-iteration-count 和 animation-direction 两个动画属性了，它们一个用来定义元素动画的循环次数，一个用来定义动画在循环过程中是否反向运动： 1234567button &#123; ... /* 动画的循环次数: 无限次 */ animation-iteration-count: infinite; /* 循环是否反向：先正向后反向 */ animation-direction: alternate;&#125; 最终的简写形式如下： 1234button &#123; ... animation: shrink .5s linear alternate infinite;&#125; 完整效果： See the Pen animation-shrink by JingW (@JingW) on CodePen. 资源 📚 animation | 一个CSS3动画库 【推荐】 点我查看效果 magic | 另一个CSS3动画库 点我查看效果]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transition过渡（二）]]></title>
    <url>%2Fposts%2F13167%2F</url>
    <content type="text"><![CDATA[传送门 transition过渡（一） transition过渡（二） 上篇文章是对 transition过渡 的一个简单介绍和使用。这篇文章就来聊聊具体属性的含义和用法。 transition-property 过渡属性从上一篇文章能够知道 transition-property 是拿来设置元素中参与过渡的属性的。它的可选值为： none 指所有属性都不参与过渡 all 指所有属性都参与过渡 [IDENT] 指定个别属性参与过渡 下面来看一个案例： 👇温馨提示：为了方便看效果，可点击 CSS 按钮折叠代码部分，仅显示页面 👇 See the Pen transition-property-demo1 by JingW (@JingW) on CodePen. 当你依次将鼠标移入上方演示demo中的三个按钮就会发现，都在各自下方显示出了一段文本。我们想要实现的，就是这段文本的显示需要有一个过渡效果，不要太生硬。最简单的一种实现方案就是鼠标移入按钮前，文本容器的 height: 0 ，鼠标移入后固定容器高度 height: 150px （第一个按钮效果就用的此方案）。但在实际情况中，往往文本是自适应的，高度无法确定，所以很自然的，我们会想到将 height: 150px 设置为 height: auto ，这样不就能够实现自适应高度的容器过渡了嘛，这就是第二个按钮的一套实现方案。但结果大家都知道了，文本容器不再拥有过渡的动画，而是直接从 0px 瞬间变化到 auto，这是为什么呢？ 答案：并不是所有的属性和属性值都能存在过渡动画。 这里特别需要注意的是，如果想要指定某个属性有过渡状态，就需要保证我们能够计算出过渡过程中每个时间点的属性值。比如，从 height: 0; 过渡到 height: 150px; ，过渡时间是 t ，那我们可以算出在 x 时刻的属性状态是 height: (150px-0)*x/t; 。（注：这里公式成立的前提是假设 transition-timing-function: linear; ，如果transition-timing-function 为其他值，一样可以计算，只不过算法不同）然而刚才第二种方案设置了 height: auto;，则在 x 时刻的属性状态为 height: (auto-0px)*x/t; ，显然，这种状态是不存在的、无法被计算的，因此在设置高度变成 auto 之后，也自然不会再有过渡动画了。 解决方案 第三个按钮的效果就是我们的一种解决方案，在默认状态下，我们不设置文本容器的 height: 0 ，而是用 transform: scale(1, 0); 来代替它，意思是在初始状态下，我们的文本容器比例为宽1:1，高1:0，换句话说，宽为我们设置的宽，但高度为0。在鼠标移入按钮后，用 transform: scale(1, 1); 来代替方案二中的 height: auto ，设置文本容器的宽高为1，这样就又能出现过渡动画了。 延伸 由此进行延伸，再比如日常中最常使用的控制元素显示隐藏的代码是 display: block; 和 display: none; ，这也是不存在过渡动画的，因此，可以调整改为使用 opacity: 1; 和 opacity: 0; 来替换。 transition-duration 过渡花费的时间这个属性没什么可讲的，用它来设置元素过渡的持续时间 transition-timing-function 效果曲线这个属性是设置过渡的动画类型的，换句话说，就是设置在过渡过程中元素值的变化速度。它的可选值包含这样几组： ease | linear | ease-in | ease-out | ease-in-out step-start | step-end | steps([, [ start | end ] ]?) cubic-bezier(, , , ) 预设的五个时间曲线 See the Pen transition-timing-function-五个预设时间曲线 by JingW (@JingW) on CodePen. 阶跃函数 step直接上案例吧，看完效果再来讲阶跃函数几个参数的具体含义： See the Pen transition-timing-function-阶跃函数 by JingW (@JingW) on CodePen. 实际体验了阶跃函数带来的效果后应该对其有个大概认知了吧。阶跃函数接收两个参数，第一个参数为正整数，指定阶跃函数的间隔数，你可以理解为把整个过渡过程拆成若干份儿；第二个参数可选，值为[ start | end ]，叫做跃点，指定是在每个间隔的起点还是终点发生阶跃变化，默认值为end。查看上面案例的css代码，你会发现两种 steps 的简写形式：step-start 和 step-end ，它们分别等同于：step-start = steps(1, start) 和 step-end = steps(1, end) 。 cubic-bezier 贝塞尔曲线函数贝塞尔曲线函数接收四个参数，取值范围是 0 到 1 之间的数值（包括0和1）。 贝塞尔曲线函数，其实定义的是 属性状态 与 时间 的一个关系函数。如下坐标轴所示： 上图坐标轴中横坐标是时间，纵坐标是属性状态，右上角的坐标是(1,1)。在时间曲线中的每一个点，表示的就是对应时刻下属性的取值，每个点的斜率表示的就是在这个时刻属性的变化速度，因此在时间曲线中斜率越小，也就是越平缓的地方，表示属性变化速度越慢；斜率越大，也就是越陡峭的地方，表示属性变化速度越快。如上图中开始跟结束的时候，斜率都比较小，而中间的阶段，斜率比较大，因此这个曲线表示的就是在变化过程中由慢到快再到慢的一个过程。 回到贝塞尔曲线函数接收的四个参数上，前两个是上图中红色点的坐标(x1,y1)，后两个是图中蓝色点的坐标(x2,y2)，也就是 cubic-bezier(x1, y1, x2, y2) 这样的形式。我们可以在 http://cubic-bezier.com/ 这个工具上来调整我们独特的贝塞尔曲线，通过拖拽红色跟蓝色点，可以形成不一样的贝塞尔曲线。我们发现，其实规定取值范围在[0,1]之间，针对的是x坐标，也就是时间，因为时间如果超过了这个范围，就会出现在同一个时刻对应了两个不同的属性状态，这个是没有意义的；而y坐标是可以超过这个范围的，如下我们通过拖拽两个点形成了这样一个曲线： 它表示的是在过渡过程中属性值会超过终止状态的设定值然后再回到终点位置，表现为回弹的效果。大家可以在 http://cubic-bezier.com/ 上自己拖动两个点尝试一下，最后点击 go 按钮查看效果。 上面两个图的demo效果： See the Pen transition-timing-function-贝塞尔曲线 by JingW (@JingW) on CodePen. transition-delay 延迟这个属性同样没啥讲的，用它来设置元素延迟过渡的时间。 transition 的不足 无法在页面加载的时候自动触发，因为只有当属性值发生改变的时候才会触发过渡动画。 无法重复播放过渡动画，除非再次触发过渡事件。 无法设置多种状态（keyframes 只有 from，to），只能从初始状态过渡到终止状态，无法再设置其他的状态。 transition 规则作用的是单个属性的过渡状态，不能涉及多个属性，即使定义了 transition: all 1s ease 0s; 这样的规则，其对应的每个属性过渡动画也都是相互独立，相当于是定义了很多个 transition 规则，而每个 transition 只作用于一个属性。 资源 Easing Functions Cheat Sheet cubic-bezier]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transition过渡（一）]]></title>
    <url>%2Fposts%2F24967%2F</url>
    <content type="text"><![CDATA[传送门 transition过渡（一） transition过渡（二） 介绍 CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。要实现这一点，必须规定两项内容： 指定要添加效果的CSS属性 指定效果的持续时间。 ———— 出自 菜鸟教程 语法12345678/* 分开写：*/transition-property: css属性名称;transition-duration: 过渡所花时间(默认0);transition-timing-function: 过渡的时间曲线(默认ease);transition-delay: 延迟时间(默认0);/* 简写形式： */transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0) 栗子 🌰单个属性的变化 —&gt; 按钮 :hover 效果下面的两个按钮，在鼠标移入时都被设置了 background: yellow; 样式。但只给第一个加上了 transition: background 2s; 属性，意思是如果背景发生变化，则给2s的过渡效果。 See the Pen XGvqMB by JingW (@JingW) on CodePen. 多个属性的变化 —&gt; 单独设置针对多个属性设置过渡效果，用逗号隔开就好。下面案例鼠标移入后，使正方形过渡到圆形，且颜色逐渐变浅，核心代码：1transition: background .5s ease-out, border-radius .5s ease-in; See the Pen transition-多属性 by JingW (@JingW) on CodePen. 多个属性的变化 -&gt; all如果要过渡的css属性较多，可以尝试使用 all 一步搞定。下面案例中将鼠标移入正方形盒子，会使其慢慢缩小为一个圆形，且颜色逐渐变深，核心代码：1transition: all .5s ease-out; See the Pen transition-多属性-all by JingW (@JingW) on CodePen. 实用 demo下拉导航菜单 See the Pen transition-下拉导航 by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5的自定义属性]]></title>
    <url>%2Fposts%2F39974%2F</url>
    <content type="text"><![CDATA[在 HTML5 中我们可以自定义属性，其格式为 data-*=&quot;&quot; 1234567891011121314&lt;div id="demo" data-my-name="sw" data-age="10"&gt;&lt;script&gt;/* Node.dataset 是以对象形式存在的，当我们为同一个 DOM 节点指定了多个自定义属性时， Node.dataset 则存储了所有的自定义属性的值。 */var demo = document.querySelector("#demo");//获取//注：当我们如下格式设置时，则需要以驼峰格式才能正确获取var name = demo.dataset['myName'];var age = demo.dataset['age'];//设置demo.dataset['name'] = 'web developer';&lt;script/&gt; 资源mdn - data-*]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何使用webpack4]]></title>
    <url>%2Fposts%2F47462%2F</url>
    <content type="text"><![CDATA[为什么要使用 webpack网页中引用的常见静态资源 类型 静态资源 JS .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS .css .less .sass .scss Images .jpg .png .gif .bmp .svg 字体文件（Fonts） .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 引入过多静态资源有什么问题？ 网页加载速度慢， 因此我们要发起很多的二次请求 还要处理错综复杂的依赖关系 如何解决上述两个问题 合并、压缩、精灵图、图片的 Base64 编码 可以使用 requireJS、也可以使用 webpack 来解决各个包之间的复杂依赖关系 如何完美实现上述的2种解决方案 使用 Gulp， 基于 task 任务 使用 webpack， 基于整个项目进行构建 借助于 webpack 这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能 简介webpack 是基于 Node.js 开发出来的一个前端项目打包工具。 安装 &amp; 初步使用 如果第一次安装，需要全局安装 『 webpack &amp;&amp; webpack-cli 』: 1npm install -g webpack webpack-cli 运行 npm init -y 初始化项目 创建项目目录结构 123456789101112├── dist├── package-lock.json├── package.json└── src ├── css │ └── index.css ├── images │ └── cheer.gif（各位自行更换） ├── index.html ├── js │ └── index.js └── main.js 项目根文件夹下 npm i webpack webpack-cli -D 使用 npm i jquery -D 安装 jQuery 类库 index.js 中包含的元素： 123456&lt;ul id="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt; 创建 main.js 并书写隔行变色的代码逻辑： 1234567// 导入jquery类库import $ from 'jquery'// 设置偶数行背景色，索引从0开始，0是偶数$('#list li:even').css('backgroundColor','lightblue');// 设置奇数行背景色$('#list li:odd').css('backgroundColor','pink'); 直接在页面上引用 main.js 会报错，因为浏览器不认识 import 这种高级的JS语法，需要使用 webpack 进行处理，webpack 默认会把这种高级的语法转换为低级的浏览器能识别的语法 运行 webpack 入口文件路径 模式 对 main.js 进行处理： 123webpack src/main.js --mode development或者webpack src/main.js --mode production 不过每次都要输入这个命令，非常麻烦，我们可以在package.json的scripts中加入两个指令成员： 12"dev": "webpack src/main.js --mode development","build": "webpack src/main.js --mode production" 以后只需要在命令行执行npm run dev便相当于执行webpack --mode development，执行npm run build便相当于执行webpack --mode production。 使用配置文件简化打包命令 在项目根目录中创建webpack.config.js 由于运行 webpack 命令的时候，webpack 需要指定入口文件和输出文件的路径，所以我们需要在 webpack.config.js 中配置这两个路径： 1234567891011121314// 导入处理路径的模块const path = require('path')// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; // 入口，表示，要使用 webpack 打包哪个文件 entry: path.join(__dirname, './src/main.js'), output: &#123; // 指定 打包好的文件，输出到哪个目录中去 path: path.join(__dirname, './dist/'), // 输出的文件的名称 filename: 'bundle.js', &#125;&#125; 由于此时已经配置了入口文件，package.json 中的dev以及build可简化为： 12"dev": "webpack --mode development","build": "webpack --mode production" 实现 webpack 实时打包构建webpack 提供了一个可选的本地开发服务器，这个本地服务器基于 node.js 构建，它是一个单独的组件，在 webpack 中进行配置之前需要单独安装它作为项目依赖： 1npm i webpack-dev-server -D devServer 作为 webpack 配置选项中的一项，以下是它的一些配置选项: contentBase ：设置服务器所读取文件的目录，当前我们设置为”./dist” port ：设置端口号，如果省略，默认为8080 inline ：设置为true，当源文件改变时会自动刷新页面 historyApiFallback ：设置为true，所有的跳转将指向index.html 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用 webpack-dev-server 来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行 npm i webpack-dev-server -D 安装到开发依赖 安装完成之后，修改之前在 package.json 中添加的dev指令： 1"dev": "webpack-dev-server" 在 webpack.config.js 中配置mode为development： 1234module.exports = &#123; ..., mode: 'development'&#125; 运行指令 webpack-dev-server ，发现可以进行实时打包，但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中。 把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 这个时候访问webpack-dev-server启动的 http://localhost:8080/ 网站，发现是一个文件夹的面板，需要点击到 src 目录下，才能打开我们的 index 首页，此时引用不到 bundle.js 文件，需要修改 index.html 中 script 的 src 属性为:&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 为了能在访问 http://localhost:8080/ 的时候直接访问到 index 首页，可以使用 --contentBase src 指令来修改dev指令，指定启动的根目录： 1"dev": "webpack-dev-server --contentBase src", 插件（Plugins）插件（Plugins）是用来拓展 webpack 功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders 和 Plugins 常常被弄混，但是它们其实是完全不同的东西，可以这么来说，loaders 是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。 使用 html-webpack-plugin 插件配置启动页面由于使用 --contentBase 指令的过程比较繁琐，需要指定启动的目录，同时还需要修改 index.html 中 script 标签的 src 属性，所以推荐使用 html-webpack-plugin 插件配置启动页面。 运行 npm i html-webpack-plugin -D 安装到开发依赖 修改 webpack.config.js 配置文件如下： 1234567891011121314151617181920212223// 导入处理路径的模块const path = require('path')// 导入自动生成HTMl文件的插件const htmlwebpackPlugin = require('html-webpack-plugin');// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; // 入口，表示，要使用 webpack 打包哪个文件 entry: path.join(__dirname, './src/main.js'), output: &#123; // 指定 打包好的文件，输出到哪个目录中去 path: path.join(__dirname, './dist/'), // 输出的文件的名称 filename: 'bundle.js', &#125;, plugins: [ // 添加plugins节点配置插件 new htmlwebpackPlugin(&#123; template: path.join(__dirname, './src/index.html'), //模板路径 filename: 'index.html' //自动生成的HTML文件的名称 &#125;) ], mode: 'development'&#125; 修改 package.json 中 script 节点中的dev指令如下：dev&quot;: &quot;webpack-dev-server&quot; 将 index.html 中 script 标签注释掉，因为 html-webpack-plugin 插件会自动把 bundle.js 注入到 index.html 页面中。 实现自动打开浏览器、热更新和配置浏览器的默认端口号方式1：修改 package.json 的 script 节点如下，其中 --open 表示自动打开浏览器， --port 4321 表示打开的端口号为 4321 ，--hot 表示启用浏览器热更新： 1"dev": "webpack-dev-server --open --port 4321 --hot", 方式2：(个人推荐) 修改webpack.config.js文件，新增devServer节点如下： 123456devServer: &#123; hot: true, // 启用热更新 的 第1步 open: true, // 自动打开浏览器 port: 4321, // 设置启动时候的运行端口 // contentBase: 'src', // 指定托管的根目录，不注释的话，无法访问src以外的资源，比如node_modules&#125;, 在头部引入webpack模块： 12// 启用热更新的 第2步const webpack = require('webpack') 在 plugins 节点下新增： 12// 启用热更新的第 3 步new webpack.HotModuleReplacementPlugin() Loadersloaders 是 webpack 最强大的功能之一，通过不同的 loader ，webpack 有能力调用外部的脚本或工具，实现对不同格式的文件的处理，例如把 scss 转为 css ，将 ES6 、ES7 等语法转化为当前浏览器能识别的语法，将 JSX 转化为 js 等多项功能。 loaders 需要单独安装并且需要在 webpack.config.js 中的 modules 配置项下进行配置，Loaders的配置包括以下几方面： test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； options：为loaders提供额外的设置选项（可选） 使用 webpack 打包 css 文件 运行npm i style-loader css-loader --D 修改webpack.config.js这个配置文件： 12345678module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125; //处理css文件的规则 ]&#125;, 注意：use 表示使用哪些模块来处理 test 所匹配到的文件；use 中相关 loader 模块的调用顺序是从后向前调用的； 使用 webpack 打包 less 文件 运行npm i less-loader less -D 修改webpack.config.js配置文件： 1234&#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader']&#125;, //配置处理 .less 文件的第三方 loader 规则 使用 webpack 打包 sass 文件 运行 npm i sass-loader node-sass --D 在 webpack.config.js 中添加处理 sass 文件的 loader 模块： 12345&#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader']&#125;, // 配置处理 .scss 文件的 第三方 loader 规则（npm i sass-loader后还需要 npm i node-sass，否则编译报错） 使用 webpack 处理 css 中的路径 预备工作： 在 index.html 文件中 添加： 在 index.css 文件中 添加： .second { width: 300px; height: 150px; background-image: url(‘../images/你的图片文件’); background-size: cover; } 此时保存会编译报错，因为webpack无法处理css中的路径（此案例中为——图片资源） 运行 npm i url-loader --D (p.s. 不需要装 file-loader ，因为 url-loader 内置了它) 在 webpack.config.js 中添加处理 url 路径的 loader 模块： 1234&#123; test: /\.(jpg|png|bmp|gif|jpeg)$/, use: 'url-loader'&#125;, // 配置图片路径 可以通过 limit 指定进行 base64 编码的图片大小；只有小于指定字节（byte）的图片才会进行 base64 编码： 12345&#123; test: /\.(jpg|png|bmp|gif|jpeg)$/, use: 'url-loader?limit=7631&amp;name=[hash:8]-[name].[ext]' &#125;, // 配置图片路径 // limit 给定的值，是图片的大小，单位是 byte， 如果我们引用的 图片，大于或等于给定的 limit值，则不会被转为base64格式的字符串， 如果 图片小于给定的 limit 值，则会被转为 base64的字符串 使用 webpack 处理 boostrap 字体的加载重要(更新)：webpack4后的bootstrap字体加载已经不能使用下面该方法，如何使用可以参考这篇博客：webpack 4.X版本的简单使用(处理js/css/less/scss/url(图片)/字体文件) 预备工作： index.html 写入 来展示字体图片 main.js 导入 import ‘bootstrap/dist/css/bootstrap.css’ 此时报错 在 webpack.config.js 中添加处理字体文件的 loader 模块： 1234&#123; test: /\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader'&#125;, // 处理 字体文件的 loader 使用 babel 处理高级 JS 语法 在 main.js 文件中添加 ES6 代码： 123456789101112131415// class 关键字，是ES6中提供的新语法，是用来 实现 ES6 中面向对象编程的方式class Person &#123; // 使用 static 关键字，可以定义静态属性 // 所谓的静态属性，就是 可以直接通过 类名， 直接访问的属性 // 实例属性： 只能通过类的实例，来访问的属性，叫做实例属性 static info = &#123; name: 'zs', age: 20 &#125;&#125;// 访问 Person 类身上的 info 静态属性console.log(Person.info)// 在 webpack 中，默认只能处理 一部分 ES6 的新语法，一些更高级的ES6语法或者 ES7 语法，webpack 是处理不了的；这时候，就需要 借助于第三方的 loader，来帮助webpack 处理这些高级的语法，当第三方loader 把 高级语法转为 低级的语法之后，会把结果交给 webpack 去打包到 bundle.js 中// 通过 Babel ，可以帮我们将 高级的语法转换为 低级的语法 运行如下两套命令，安装两套包，去安装 Babel 相关的loader功能： 123456// 【相当于转换工具】npm i -D @babel/core babel-loader @babel/plugin-transform-runtime @babel/runtime @babel/plugin-proposal-class-properties// 【相当于字典】npm i -D @babel/preset-env// =====&gt; 「转换工具」根据「字典」将 es6 转换 打开 webpack 的配置文件，在 module 节点下的 rules 数组中，添加一个新的匹配规则： 12345&#123; test: /\.js$/, use: 'babel-loader', exclude: /node_modules/&#125; // 配置 Babel 来转换高级的ES语法 2.2 注意： 在配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉：原因有俩： 2.2.1 如果 不排除 node_modules， 则Babel 会把 node_modules 中所有的 第三方 JS 文件，都打包编译，这样，会非常消耗CPU，同时，打包速度非常慢； 2.2.2 哪怕，最终，Babel 把 所有 node_modules 中的JS转换完毕了，但是，项目也无法正常运行！ 在项目的根目录中，新建一个叫做 .babelrc 的 Babel 配置文件，这个配置文件，属于 JSON 格式，所以，在写 .babelrc 配置的时候，必须符合 JSON 语法规范： 不能写注释，字符串必须用双引号： 123456789101112131415&#123; "presets": [ ["@babel/preset-env", &#123; "modules": false, "targets": &#123; "browsers": ["&gt; 1%", "last 2 versions", "not ie &lt;= 8"] &#125;, "useBuiltIns": "usage" &#125;] ], "plugins": [ "@babel/plugin-transform-runtime", "@babel/plugin-proposal-class-properties" ]&#125; webpack.config.js配置遇到Error: Cannot find module ‘@babel/core’问题 官方默认babel-loader | babel 对应的版本需要一致: 即babel-loader需要搭配最新版本babel 两种解决方案: 回退低版本 1npm install -D babel-loader@7 babel-core babel-preset-env 更新到最高版本: 1npm install -D babel-loader @babel/core @babel/preset-env webpack Source Maps 调试配置作为开发，代码调试当然少不了，那么问题来了，经过打包后的文件，你是不容易找到出错的地方的，Source Map就是用来解决这个问题的。 通过如下配置，我们会在打包时生成对应于打包文件的 .map 文件，使得编译后的代码可读性更高，更易于调试。 123456// webpack.config.js...module.exports = &#123; ... devtool: &apos;source-map&apos; // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度&#125; 配置好后，我们再次运行 npm run build 进行打包，这时我们会发现在 dist 文件夹中多出了一个 bundle.js.map 如果我们的代码有 bug ，在浏览器的调试工具中会提示错误出现的位置，这就是 devtool: &#39;source-map&#39; 配置项的作用。 开发环境 VS 生产环境npm run devnpm run dev 是我们开发环境下打包的文件，当然由于 devServer 帮我们把文件放到内存中了，所以并不会输出打包后的 dist 文件夹。 npm run build通过 npm run build 之后会生成一个dist目录文件夹，里面有我们打包后的文件。 清理/dist文件夹(CleanwebpackPlugin)你可能已经注意到，在我们删掉/dist文件夹之前，由于前面的代码示例遗留，导致我们的 /dist 文件夹比较杂乱。webpack 会生成文件，然后将这些文件放置在 /dist 文件夹中，但是 webpack 无法追踪到哪些文件是实际在项目中用到的。 通常，在每次构建前清理 /dist 文件夹，是比较推荐的做法，因此只会生成用到的文件，这时候就用到 CleanwebpackPlugin 插件了。 123456789101112npm i clean-webpack-plugin -D// webpack.config.js...const CleanwebpackPlugin = require(&apos;clean-webpack-plugin&apos;); // 引入CleanwebpackPlugin插件module.exports = &#123; ... plugins: [ ... new CleanwebpackPlugin([&apos;dist&apos;]), // 所要清理的文件夹名称 ]&#125; 插件的使用方法都是一样的，首先引入，然后new一个实例，实例可传入参数。 现在我们运行 npm run build 后就会发现，webpack 会先将 /dist 文件夹删除，然后再生产新的 /dist 文件夹。 webpack4.x相关资源 webpack4.x最详细入门讲解 webpack3与webpack4使用差异 webpack4.x开发环境配置]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie与session区别]]></title>
    <url>%2Fposts%2F63891%2F</url>
    <content type="text"><![CDATA[保存状态cookie 是通过在客户端记录信息确定用户身份的，而 session 则通过在服务器端记录信息来确定用户身份。下面是网上找到的两张图，能够对 cookie 以及 session 在客户端与服务端传递的过程有个较清晰的认识： 使用方式cookie机制： 默认情况下，cookie 保存在内存中，浏览器关闭就没了；设置过期时间后，cookie 保存在硬盘上，关闭浏览器仍然存在，直到过期时间结束才消失。 cookie 以文本形式保存在客户端，每次请求时都带上它。 session机制： 每次请求，服务器会检查是否有 sessionid 有，服务器根据 id 返回对应 session 对象 无，服务器创建新的 session 对象，并把 sessionid 在本次响应中返回给客户端。 通常使用 cookie 方式存储 sessionid 到客户端 用户禁用 cookie 时，则服务端可以使用URL重写，可以通过 response.encodeURL(url) 进行实现 存储方式 cookie 只能保存字符串类型，以文本的方式 session 能支持任何类型的对象 存储大小 cookie单个不超过4kb session没限制]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记]]></title>
    <url>%2Fposts%2F51696%2F</url>
    <content type="text"><![CDATA[前言之前对算法和数据结构没有一个系统的学习，从今天开始抽空啃啃书吧。就从这本程杰老师的《大话数据结构》起步。 p.s. 原笔记是存放在幕布上的，文字版看着不舒服可以 点击这里 看思维导图版。 基本概念和术语 数据 定义：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的集合符号。 总结：数据即符号，必备条件： 可以输入到计算机中 能被计算机程序处理 举例： MP3是声音数据 图片是图像数据 #数据对象 定义：是性质相同的数据元素的集合，是数据的子集 举例： 人（都有姓名、生日等相同的数据项） #数据元素 定义：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被成为记录。 举例： 人类中的人 畜类中的牛马羊 #数据项 定义：一个数据元素可以由若干个数据项组成 举例： 人的姓名、年龄、性别 数据结构 定义：是相互之间存在一种或多种特定关系的数据元素的集合 #逻辑结构 定义：指数据对象中数据元素之间的相互关系 类型 #集合结构 同属于一个集合的数据元素 #线性结构 数据元素之间是一对一的关系 #树形结构 数据元素之间存在一对多的层次关系 #图形结构 数据元素是多对多的关系 用示意图表示数据逻辑结构时的注意点： 每个数据元素是一个结点，用圆圈表示 元素之间的逻辑关系用连线表示，如果此关系是有方向的，那么用箭头连线表示 #物理结构 定义：是指数据的逻辑结构在计算机中的存储形式 #顺序存储结构 定义：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的 #链式存储结构 定义：是把数据元素存放在任意的存储单元里，这组存储单元可以使连续的，也可以是不连续的。 注意：数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置]]></content>
      <categories>
        <category>后端</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决0.1+0.2不等于0.3的问题]]></title>
    <url>%2Fposts%2F21245%2F</url>
    <content type="text"><![CDATA[为何会出现此问题？总结一句话：这是因为二进制模拟十进制进行运算时的精度问题。 具体可查看 0.1 + 0.2不等于0.3？为什么JavaScript有这种“骚”操作？ 这篇掘金文章。 如何解决Number.EPSILON第一种方法是利用 Number.EPSILON ，这个值无限接近于0。0.1+0.2的精度误差在这个值的范围内：12345function numbersEqual(a,b)&#123; return Math.abs(a-b)&lt;Number.EPSILON;&#125;var a=0.1+0.2， b=0.3;console.log(numbersEqual(a,b)); //true 内置函数toFixed利用 parseFloat + 内置函数toFixed：123456function formatNum(num, fixed = 10) &#123; // a.toFixed(fixed) 先转为小数点10位的字符串 "0.3000000000" return parseFloat(a.toFixed(fixed)) // 然后通过parseFloat转为浮点数&#125;var a = 0.1 + 0.2;console.log(formatNum(a)); //0.3 内置函数toPrecision我平常用此函数来计算精度，具体可参考 Number.prototype.toPrecision() | MDN：123// 内置函数toPrecision(中文：精确，精度)// 参数是精度.比如5.1234，传2返回5.1，传1返回5；0.2+0.1传2返回0.30(0.1 + 0.2).toPrecision(10) == 0.3 // true]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise用法]]></title>
    <url>%2Fposts%2F7878%2F</url>
    <content type="text"><![CDATA[Promise是什么Promise 是一种异步编程的解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。 诞生的原因异步网络请求的回调地狱，而且我们还得对每次请求的结果进行一些处理，代码会更加臃肿。一张图完美诠释：不够？再加一张： Promise的三种状态 pedding 等待（默认状态。异步代码执行完毕后会转换为以下两种状态） resolve 成功 reject 失败 基本用法语法 Promise: 构造函数 接受一个参数：callback，我们把要执行的异步任务放置在这个callback中 then: Promise对象下的一个方法：该方法在Promise对象的状态发生改变的时候触发then的回调 12345678910111213//defined Promise async functionfunction asyncFun()&#123; return new Promise((resolve, reject) =&gt; &#123; if (resolve) &#123; resolve(/*resolve parameter*/); &#125;else&#123; reject(new Error(/*Error*/)); &#125; &#125;)&#125;//use Promise&amp;thenasyncFun().then(/*function*/).then(/*function*/)... Promise特性立即执行12345678910111213141516let p = new Promise((resolve, reject) =&gt; &#123; // 当Promise被实例化的时候，callback的异步任务就会被执行 console.log("一个Promise对象被创建出来"); resolve("success");&#125;);console.log("flag");p.then((data) =&gt; &#123; console.log(data);&#125;);// 执行结果：// 一个Promise对象被创建出来// flag// success 状态不可逆1234567891011let p = new Promise((resolve, reject) =&gt; &#123; resolve("success"); reject("reject");&#125;);p.then((data) =&gt; &#123; console.log(data);&#125;);// 执行结果：// success 链式调用12345678910111213141516171819let p = new Promise((resolve, reject) =&gt; &#123; // 通过传入的resolve, reject，去改变当前Promise任务的状态 // resolve, reject 是两个函数，调用 resolve ，会把状态改成 resolved ，调用 reject 函数会把状态改成 rejected setTimeout(() =&gt; &#123; console.log(1); reject(); &#125;, 1000);&#125;);// then接受两个参数：这两个参数都是回调，当对应的 promise 对象的状态变成了resolved，那么 then 的第一个 callback 就会被执行，如果状态变成了 rejected ，那么 then 的第二个 callback 就会被执行p.then(() =&gt; &#123; console.log('成功');&#125;, () =&gt; &#123; console.log('失败');&#125; );// 执行结果：// 1// 失败 then的回调异步性1234567891011121314151617let p = new Promise((resolve, reject) =&gt; &#123; console.log("我是Promise的callback中的代码"); setTimeout(() =&gt; &#123; resolve("我1s后才会被执行"); &#125;, 1000);&#125;);p.then((data) =&gt; &#123; console.log(data);&#125;);console.log("我是主线程中的同步代码");// 执行结果：// 我是Promise的callback中的代码// 我是主线程中的同步代码// 我1s后才会被执行 解释：Promise 的 callback 回调函数中的代码是立即执行的（setTimeout 这个定时器也是立即执行的，只是函数内的 resolve 被延迟1s执行，跟 Promise 本身的立即执行没关系），但 then 方法中的回调函数执行则是异步的，因此，&quot;我1s后才会被执行&quot; 会在最后输出。 异常的捕获Promise的异常有两种方法可以捕获，一种是 then 的第二个回调；一种 .catch() 来捕获前一个 Promise 抛出的错误。 123456789101112let p = new Promise((resolve, reject) =&gt; &#123; reject("error");&#125;);p.then(data =&gt; &#123; console.log("success")&#125;, error =&gt; &#123; console.log(error);&#125;);// 执行结果：// error 123456789101112let p = new Promise((resolve, reject) =&gt; &#123; reject("error");&#125;);p.then(data =&gt; &#123; console.log("success")&#125;).catch(error =&gt; &#123; console.log("catch:" + error);&#125;);// 执行结果：// catch:error Promise.all 和 Promise.racePromise.allPromise.all 接收一个参数，它必须是可以迭代的，例如数组。它通常用来处理一些并发的异步操作，即它们的结果互不干扰，但是又需要异步执行。当所有 Promise 都成功的时候，整个 Promise.all 才成功。成功调用后返回一个数组，数组的值是有序的，顺序就是传入参数的数组顺序： 成功的情况 123456789101112let arr = [1, 2, 3];let tasks = arr.map(num =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(num * 5); &#125;);&#125;);Promise.all(tasks).then(data =&gt; &#123; // 有序输出 console.log(arr); // [1, 2, 3] console.log(data); // [5, 10, 15]&#125;); 失败的情况 1234567891011121314151617let arr = [1, 2, 3];let tasks = arr.map(num =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; if (num === 3) &#123; reject('rejected'); &#125; resolve(num * 5); &#125;);&#125;);Promise.all(tasks).then(data =&gt; &#123; // 这里不会执行 console.log(arr); console.log(data);&#125;).catch(err =&gt; &#123; console.log(err); // rejected&#125;); Promise.racePromise.race 和 Promise.all 类似，都接收一个可以迭代的参数，但是不同之处是 Promise.race 的状态变化不是全部受参数内的状态影响，一旦参数内有一个值的状态发生的改变，那么该 Promise 的状态就是改变的状态。就跟 race 单词的字面意思一样，谁跑的快谁赢。 12345678910111213141516171819let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 300, 'p1 doned');&#125;);var p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 50, 'p2 doned');&#125;);var p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(reject, 100, 'p3 rejected');&#125;);Promise.race([p1, p2, p3]).then(data =&gt; &#123; // 显然p2更快，所以状态变成了fulfilled // 如果p3更快，那么状态就会变成rejected console.log(data); // p2 doned&#125;).catch(function(err) &#123; console.log(err); // 不执行&#125;);]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let和const和var的区别]]></title>
    <url>%2Fposts%2F37021%2F</url>
    <content type="text"><![CDATA[const 和 let 异同不同点 let 定义变量可以只声明不赋值 const 定义常量声明时必须赋值，一旦定义不可轻易改变 相同点解决 var 没有块作用域,、变量提升、可以重复声明的问题。 let 和 const 有自己的块作用域, 不存在变量提升问题, 同一块作用域中不可重复声明（会报错）。 let/const 和 var 区别 var 有变量提升，let/const 没有 let/const 的作用域是块，而 var 的作用域是函数 let/const 有暂时性死区，只要 let/const 声明的变量，在未声明之前使用或者赋值都会报错（ReferenceError） let/const 不能被重复定义]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数中的rest参数]]></title>
    <url>%2Fposts%2F29820%2F</url>
    <content type="text"><![CDATA[什么是 REST 参数REST参数翻译过来就是剩余参数，MDN上的定义是： 剩余参数语法允许我们将一个不定数量的参数表示为一个数组。 示例说明123456789101112131415161718192021function sum(...theArgs) &#123; return theArgs.reduce((previous, current) =&gt; &#123; return previous + current; &#125;);&#125;console.log(sum(1, 2, 3));// expected output: 6console.log(sum(1, 2, 3, 4));// expected output: 10// 下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们function multiply(multiplier, ...theArgs) &#123; return theArgs.map(function (element) &#123; return multiplier * element; &#125;);&#125;var arr = multiply(2, 1, 2, 3); console.log(arr); // [2, 4, 6] rest 参数和 arguments 对象的区别剩余参数和 arguments对象之间的区别主要有三个： 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。 arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。 arguments对象还有一些附加的属性 （如callee属性）。 arguments.callee 属性包含当前正在执行的函数。]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中如何实现继承]]></title>
    <url>%2Fposts%2F2751%2F</url>
    <content type="text"><![CDATA[组合继承（原型链 + 借用构造函数）12345678910111213141516171819202122232425262728// 组合继承:原型继承+借用（调用）构造函数继承function Person(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex;&#125;Person.prototype.sayHi = function () &#123; console.log("Hello world");&#125;;function Student(name, age, sex, score) &#123; // 借用构造函数 Person.call(this,name,age,sex); this.score = score;&#125;// 改变原型指向----继承// 我们让 Student.prototype 指向一个Person的实例对象// 这个对象的__proto__指向的是Person.prototype// 所以我们就可以借助这个实例对象拿到sayHi方法，实现继承Student.prototype=new Person();Student.prototype.eat = function () &#123; console.log("吃东西");&#125;;var stu = new Student("Lance", 20, "男", "100分");stu.sayHi();var stu2 = new Student("Jerry", 19, "男", "101分");stu2.eat();//属性和方法都被继承了 寄生组合继承（组合继承升级版）123456789101112131415161718192021222324252627282930function object(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); // 创建了父类原型的浅复制 prototype.constructor = subType; // 修正原型的构造函数 subType.prototype = prototype; // 将子类的原型替换为这个原型&#125; function SuperType(name)&#123; this.name = name; this.colors = ["red", "blue", "green"];&#125; SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;; function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;// 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; alert(this.age);&#125; ES6继承写法12345678910class Person &#123; constructor(name, age) &#123;this.name=name;this.age=age&#125; sayHi() &#123;&#125;&#125;class Student extends Person &#123; constructor(name, age, weight) &#123; super(name, age); this.weight = weight; &#125; run() &#123;&#125;&#125; 在原型链继承时，为什么不直接 Student.prototype = Person.prototype ？因为对象的赋值只是引用的赋值, 上面两者都指向同一个内存地址，只要随便通过1个途径就能修改该内存地址的对象，这样子类就无法单独扩展方法，而且会影响父类。 组合继承的缺点缺点就是调用了两次父类的构造函数。第一次给子类的原型添加了父类构造函数中的属性方法；第二次又给子类的构造函数添加了父类的构造函数的属性方法，从而覆盖了子类原型中的同名参数。这种被覆盖的情况造成了性能上的浪费：1234567891011121314function SuperType() &#123; this.name = 'parent'; this.arr = [1, 2, 3];&#125; SuperType.prototype.say = function() &#123; console.log('this is parent')&#125; function SubType() &#123; SuperType.call(this) // 第二次调用SuperType&#125; SubType.prototype = new SuperType() // 第一次调用SuperType]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对this指向的判定]]></title>
    <url>%2Fposts%2F33207%2F</url>
    <content type="text"><![CDATA[对 this 的理解对于this指向的判定，时刻记住下面两点就好： 普通函数的 this 指向是在函数的执行期间绑定的，换句话说 this 总是指向函数的直接调用者 箭头函数的 this 指向是在函数创建期间就绑定好了的，指向的是创建该箭头函数所在的作用域对象 普通函数中的this这里直接引用 You-Dont-Know-JS 中对 this 的判定步骤： 函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。var bar = new foo() 函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。var bar = foo.call( obj2 ) 函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。var bar = obj1.foo() 否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。var bar = foo() 常见this指向 普通函数中this ——&gt; window 构造函数中this ——&gt; new出来的实例对象 方法中的this ——&gt; 实例对象 原型中的方法中的this ——&gt; 实例对象 定时器中的this ——&gt; window]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的遍历方法]]></title>
    <url>%2Fposts%2F64478%2F</url>
    <content type="text"><![CDATA[下面是总结的数组遍历的常见方法 for循环 标准for循环 forEach((当前值, 当前索引, 当前数组) =&gt; {…}, [, 绑定的this])` 无法中途退出循环，只能用 return 退出本次回调，进行下一次回调 它总是返回 undefined 值，即使你 return 了一个值 for…in（不推荐）会把继承链的对象属性都会遍历一遍，而且数组遍历不一定按次序 for-in 循环返回的是所有能通过对象访问的、可枚举的属性 for (variable of iterable)（ES6）可迭代Array，Map，Set，String等（迭代的是值value） 在 for..of 中如果遍历中途要退出，可以使用 break 退出循环 ES5 map (不改变原数组) 会给原数组中的每个元素都按顺序调用一次 callback 函数 reduce (不改变原数组) 数组中的前项和后项做某种计算,并累计最终值。 123456789// 语法：// arr.reduce(function(total, currentValue, currentIndex, arr), initialValue)// callback 参数// (累积器, 当前元素, 当前元素索引, 当前数组)// initialValue:指定第一次回调 的第一个参数var wallets = [4, 7.8, 3]var totalMoney = wallets.reduce(function (countedMoney, curMoney) &#123; return countedMoney + curMoney;&#125;, 0) filter (不改变原数组) 1234var arr = [2, 3, 4, 5, 6]var morearr = arr.filter(function (number) &#123; return number &gt; 3&#125;) // [4,5,6] every (不改变原数组) 测试数组的所有元素是否都通过了指定函数的测试 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测 如果所有元素都满足条件，则返回 true 1234var arr = [1,2,3,4,5]var result = arr.every(function (item, index) &#123; return item &gt; 2&#125;) // false some (不改变原数组) 测试是否至少有一个元素通过 callback 中的条件。对于放在空数组上的任何条件，此方法返回 false 如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测 如果没有满足条件的元素，则返回false 12345678// some(callback, thisArg)// callback:// (当前元素, 当前索引, 调用some的数组)var arr = [1,2,3,4,5]var result = arr.some(function (item,index) &#123; return item &gt; 3&#125;) // true ES6 find() &amp; findIndex() 根据条件找到数组成员 find 定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回 undefined findIndex 定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 123456789101112// 语法let new_array = arr.find(function(currentValue, index, arr), thisArg)let new_array = arr.findIndex(function(currentValue, index, arr), thisArg)// 这两个方法都可以识别NaN,弥补了indexOf的不足// findlet a = [1, 4, -5, 10].find((n) =&gt; n &lt; 0); // 返回元素-5let b = [1, 4, -5, 10,NaN].find((n) =&gt; Object.is(NaN, n)); // 返回元素NaN// findIndexlet a = [1, 4, -5, 10].findIndex((n) =&gt; n &lt; 0); // 返回索引2let b = [1, 4, -5, 10,NaN].findIndex((n) =&gt; Object.is(NaN, n)); // 返回索引4 keys() &amp; values() &amp; entries() 遍历键名、遍历键值、遍历键名+键值 三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值 1234567891011121314151617181920// 语法array.keys() array.values() array.entries()for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b"]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[null 和 undefined 的区别]]></title>
    <url>%2Fposts%2F63928%2F</url>
    <content type="text"><![CDATA[含义 null 表示一个对象是“没有值”的值，也就是值为“空” undefined 表示一个变量声明了没有初始化(赋值) 类型 undefined 的类型(typeof)是 undefined null 的类型(typeof)是 object 双等三等另外，在验证 null 时，一定要使用 === ，因为 == 无法分辨 null 和 undefined ：12null == undefined // true null === undefined // false 总结undefined 变量提升：只声明未定义默认值就是 undefined 严格模式下：没有明确的执行主体，this 就是 undefined 对象没有这个属性名，属性值是 undefined 函数定义形参不传值，默认就是 undefined 函数没有返回值（没有 return 或者 return; ），默认返回的就是 undefined 数组越界取值也是 undefined （arr=[1,2]; arr[10] =&gt; undefined） … null 手动设置变量的值或者对象某个属性值为null（此时不赋值，后面会赋值） 在 JS 的 DOM 元素获取中，如果没有获取到指定的元素对象，结果一般都是null Object.prototype.proto 的值也是 null 正则捕获的时候，如果没有捕获到结果，默认也是null … 其他Javascript会将未赋值的变量默认值设为undefined；Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对闭包的理解]]></title>
    <url>%2Fposts%2F29980%2F</url>
    <content type="text"><![CDATA[什么是闭包我一直认为，MDN是前端学习的在线指南。只要有不懂的语法，或者不懂的概念，查找资料的首选就应该是它。虽然早些年做iOS开发的时候就就接触过闭包，但如今已经忘得一干二净，所以在想要了解闭包的时候，第一件事就是在MDN中搜索。其中给到了一个闭包的例子： 12345678910function makeFunc() &#123; var name = "Mozilla"; // name 是一个被 init 创建的局部变量 function displayName() &#123; // displayName() 是内部函数,一个闭包 alert(name); // 使用了父函数中声明的变量 &#125; return displayName; // 返回 displayName 这个函数&#125;var myFunc = makeFunc();myFunc(); // 当执行myFunc时，其实调用了displayName，会弹窗显示"Mozilla" 在上面这个例子中，一个函数套了一个函数，且这个内部函数使用到了外部函数中的变量，这个时候就形成了闭包。有什么用呢？其中一个用处就如上面代码所示，能够让 makeFunc 函数外面也能访问 name 这个局部变量。换句话说，闭包缓存了数据，延长了作用域链。 Kyle Simpson编写的You-Dont-Know-JS中对闭包的总结我觉得很精髓： 闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。 闭包的特性 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 闭包的用途缓存数据，延长作用域链一个经典的例子，给 ul&gt;li 下面的每个 li 节点添加点击事件，让其弹出当前 li 元素的索引：1234567891011121314&lt;ul id="testUL"&gt; &lt;li&gt; index = 0&lt;/li&gt; &lt;li&gt; index = 1&lt;/li&gt; &lt;li&gt; index = 2&lt;/li&gt; &lt;li&gt; index = 3&lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var nodes = document.getElementsByTagName("li"); for (var i = 0; i &lt; nodes.length; i += 1) &#123; nodes[i].onclick = function () &#123; console.log(i); &#125; &#125;&lt;/script&gt; 运行上述代码后就会发现，每次打印的结果都显示为4，而不是真正的索引值。这是因为点击事件的匿名函数发生在for循环之后，而for循环执行完毕时 i 的值就为4，所以点谁都是同样的结果。那么这个时候就能通过立即执行函数 + 闭包的方法解决此问题：1234567891011&lt;script type="text/javascript"&gt; var nodes = document.getElementsByTagName("li"); for (var i = 0; i &lt; nodes.length; i += 1) &#123; nodes[i].onclick = (function (i) &#123; // 1. IIFE创建一个函数作用域 return function () &#123; // 4. 返回这个匿名函数，延长作用域链 // 3. 内部嵌套的匿名函数使用到了IIFE的参数i，形成闭包 console.log(i); &#125; &#125;)(i); // 2. 给IIFE传递每次for循环的i &#125;&lt;/script&gt; 这个时候触发click事件，打印的值就是li元素的索引了。 用闭包模拟私有变量和方法使用闭包定义能访问私有函数和私有变量的公有函数（也叫做模块模式） 123456789101112131415161718192021222324var counter = (function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125;; &#125;)(); // 立即执行函数console.log(counter.value()); // logs 0counter.increment();counter.increment();console.log(counter.value()); // logs 2counter.decrement();console.log(counter.value()); // logs 1 环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。它俩都无法在匿名函数外部直接访问。必须通过匿名包装器返回的对象的三个公共函数访问。 内存泄漏其实闭包并不会造成内存泄漏，现在的垃圾回收机制已经很成熟了。但早期的IE（ie4-ie6）版本里，对宿主对象（也就是document对象）采用是引用计数的垃圾回收机制，闭包导致内存泄漏的一个原因就是这个算法的一个缺陷。循环引用会导致没法回收，这个循环引用只限定于有宿主对象参与的循环引用，而js对象之间即使形成循环引用，也不会产生内存泄漏，因为对js对象的回收算法不是计数的方式：12345678910111213141516171819202122232425function closure()&#123; var oDiv = document.getElementById('oDiv');//oDiv用完之后一直驻留在内存中 oDiv.onclick = function () &#123; alert('oDiv.innerHTML');//这里用oDiv导致内存泄露 &#125;;&#125;// 以上代码创建了一个作为 div 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。// 由于匿名函数保存了一个对closure()的活动对象的引用，因此就会导致无法减少 div 的引用数。// 只要匿名函数存在，element 的引用数至少也是1，因此它所占用的内存就永远不会被回收closure();//最后应将oDiv解除引用来避免内存泄露function closure()&#123; var oDiv = document.getElementById('oDiv'); var test = oDiv.innerHTML; oDiv.onclick = function () &#123; alert(test); &#125;; oDiv = null;&#125;// 解决办法: 把 oDiv.innerHTML 的一个副本保存在一个变量中，// 从而消除闭包中该变量的循环引用,同时将 oDiv 变量设为null。]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组有哪些常用方法]]></title>
    <url>%2Fposts%2F21501%2F</url>
    <content type="text"><![CDATA[改变原数组的方法splice() 添加/删除数组元素 splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目 array.splice(index,howmany,item1,…..,itemX) index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX： 可选。向数组添加的新项目。 返回值: 如果有元素被删除,返回包含被删除项目的新数组。 删除元素1234567// 从数组下标0开始，删除3个元素let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0, 3); // [1,2,3]console.log(a); // [4,5,6,7]// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7let item = a.splice(-1, 3); // [7] 删除并添加123456789// 从数组下标0开始，删除3个元素，并添加元素'添加'let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0,3,'添加'); // [1,2,3]console.log(a); // ['添加',4,5,6,7]// 从数组最后第二个元素开始，删除3个元素，并添加两个元素'添加1'、'添加2'let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-2,3,'添加1','添加2'); // [6,7]console.log(b); // [1,2,3,4,5,'添加1','添加2'] 不删除只添加1234567let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0,0,'添加1','添加2'); // [] 没有删除元素，返回空数组console.log(a); // ['添加1','添加2',1,2,3,4,5,6,7]let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-1,0,'添加1','添加2'); // [] 没有删除元素，返回空数组console.log(b); // [1,2,3,4,5,6,'添加1','添加2',7] 在最后一个元素的前面添加两个元素 sort() 数组排序 定义: sort()方法对数组元素进行排序，并返回这个数组。 参数可选: 规定排序顺序的比较函数。 默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用toString()方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。 不传参1234567// 字符串排列 看起来很正常var a = ["Banana", "Orange", "Apple", "Mango"];a.sort(); // ["Apple","Banana","Mango","Orange"]// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的var a = [10, 1, 3, 20,25,8];console.log(a.sort()) // [1,10,20,25,3,8]; 比较函数的两个参数： sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素： 若比较函数返回值&lt;0，那么a将排到b的前面; 若比较函数返回值=0，那么a 和 b 相对位置不变； 若比较函数返回值&gt;0，那么b 排在a 将的前面； 数字升降序12345678910var array = [10, 1, 3, 4, 20, 4, 25, 8]; array.sort(function(a,b)&#123; return a-b;&#125;);console.log(array); // [1,3,4,4,8,10,20,25];array.sort(function(a,b)&#123; return b-a;&#125;);console.log(array); // [25,20,10,8,4,4,3,1]; pop() 删除一个数组中的最后的一个元素 定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。 123let a = [1,2,3];let item = a.pop(); // 3console.log(a); // [1,2] shift() 删除数组的第一个元素 定义: shift()方法删除数组的第一个元素，并返回这个元素。 123let a = [1,2,3];let item = a.shift(); // 1console.log(a); // [2,3] push() 向数组的末尾添加元素 定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 参数: item1, item2, …, itemX ,要添加到数组末尾的元素 123let a = [1,2,3];let item = a.push('末尾', '233'); // 5console.log(a); // [1,2,3,'末尾', '233'] unshift() 定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。 参数: item1, item2, …, itemX ,要添加到数组开头的元素 123let a = [1, 2, 3];let item = a.unshift('开头', '开头2'); // 5console.log(a); // [ '开头', '开头2', 1, 2, 3 ] reverse() 颠倒数组中元素的顺序 定义: reverse() 方法用于颠倒数组中元素的顺序。 123let a = [1,2,3];a.reverse(); console.log(a); // [3,2,1] 不改变原数组的方法slice() 浅拷贝数组的元素 定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。 语法：array.slice(begin, end); 12345678910111213let a= ['hello','world'];let b=a.slice(0,1); // ['hello']// 新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。// 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。a[0]='改变原数组';console.log(a,b); // ['改变原数组','world'] ['hello']let a= [&#123;name:'OBKoro1'&#125;];let b=a.slice();console.log(b,a); // [&#123;"name":"OBKoro1"&#125;] [&#123;"name":"OBKoro1"&#125;]// a[0].name='改变原数组';// console.log(b,a); // [&#123;"name":"改变原数组"&#125;] [&#123;"name":"改变原数组"&#125;] join() 数组转字符串 定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。 语法: array.join(str) 12345678910111213let a= ['hello','world'];let str=a.join(); // 'hello,world'let str2=a.join('+'); // 'hello+world'let a= [['OBKoro1','23'],'test'];let str1=a.join(); // OBKoro1,23,testlet b= [&#123;name:'OBKoro1',age:'23'&#125;,'test'];let str2 = b.join(); // [object Object],test// 对象转字符串推荐JSON.stringify(obj);// 结论：// join()/toString()方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),// 如果是对象的话，对象会被转为[object Object]字符串。 join() 数组转字符串 定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。 语法: array.join(str) 12345678910111213let a= ['hello','world'];let str=a.join(); // 'hello,world'let str2=a.join('+'); // 'hello+world'let a= [['OBKoro1','23'],'test'];let str1=a.join(); // OBKoro1,23,testlet b= [&#123;name:'OBKoro1',age:'23'&#125;,'test'];let str2 = b.join(); // [object Object],test// 对象转字符串推荐JSON.stringify(obj);// 结论：// join()/toString()方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),// 如果是对象的话，对象会被转为[object Object]字符串。 concat 定义： 方法用于合并两个或多个数组，返回一个新数组。 语法：var newArr =oldArray.concat(arrayX,arrayX,……,arrayX) 参数：arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。 1234567891011121314let a = [1, 2, 3];let b = [4, 5, 6];//连接两个数组let newVal=a.concat(b); // [1,2,3,4,5,6]// 连接三个数组let c = [7, 8, 9]let newVal2 = a.concat(b, c); // [1,2,3,4,5,6,7,8,9]// 添加元素let newVal3 = a.concat('添加元素',b, c,'再加一个'); // [1,2,3,"添加元素",4,5,6,7,8,9,"再加一个"]// 合并嵌套数组 会浅拷贝嵌套数组let d = [1,2 ];let f = [3,[4]];let newVal4 = d.concat(f); // [1,2,3,[4]] ES6扩展运算符...合并数组123let a = [2, 3, 4, 5]let b = [ 4,...a, 4, 4]console.log(a,b); // [2, 3, 4, 5] [4,2,3,4,5,4,4] indexOf() 查找数组是否存在某个元素，返回下标 定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 p.s. 字符串也有此方法，要注意当 ‘lance’.indexOf(‘’) 一个空字符串时，返回0而不是-1 语法：array.indexOf(searchElement,fromIndex) 参数： searchElement(必须):被查找的元素 fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。 严格相等的搜索: 数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等===搜索元素，即数组元素要完全匹配才能搜索成功。 注意：indexOf()不能识别NaN 1234let a=['啦啦',2,4,24,NaN]console.log(a.indexOf('啦')); // -1 console.log(a.indexOf('NaN')); // -1 console.log(a.indexOf('啦啦')); // 0 lastIndexOf() 查找指定元素在数组中的最后一个位置 定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找） 语法：arr.lastIndexOf(searchElement,fromIndex) 参数: searchElement(必须): 被查找的元素 fromIndex(可选): 逆向查找开始位置，默认值数组的 长度-1，即查找整个数组。 关于fromIndex有三个规则: 正值。如果该值大于或等于数组的长度，则整个数组会被查找。 负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找) 负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 12345let a=['OB',4,'Koro1',1,2,'Koro1',3,4,5,'Koro1']; // 数组长度为10// let b=a.lastIndexOf('Koro1',4); // 从下标4开始往前找 返回下标2// let b=a.lastIndexOf('Koro1',100); // 大于或数组的长度 查找整个数组 返回9// let b=a.lastIndexOf('Koro1',-11); // -1 数组不会被查找let b=a.lastIndexOf('Koro1',-9); // 从第二个元素4往前查找，没有找到 返回-1 ES7 includes() 查找数组是否包含某个元素 返回布尔 定义： 返回一个布尔值，表示某个数组是否包含给定的值 语法：array.includes(searchElement,fromIndex=0) 参数： searchElement(必须):被查找的元素 fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。 includes方法是为了弥补indexOf方法的缺陷而出现的: indexOf方法不能识别NaN indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观 12345let a=['OB','Koro1',1,NaN];// let b=a.includes(NaN); // true 识别NaN// let b=a.includes('Koro1',100); // false 超过数组长度 不搜索// let b=a.includes('Koro1',-3); // true 从倒数第三个元素开始搜索 // let b=a.includes('Koro1',-100); // true 负值绝对值超过数组长度，搜索整个数组]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去除图片上下左右间隙]]></title>
    <url>%2Fposts%2F31251%2F</url>
    <content type="text"><![CDATA[情景当在定宽父容器下有多张图片顺序排列时，图片的上下左右之间都有间隙： See the Pen KEBmRP by JingW (@JingW) on CodePen. 原因 左右：因为 img 是 inline-block 元素，元素代码之间有『换行（回车），空格，tab』时会产生左右间隙。 上下：行内元素默认与父容器基线对齐，而基线与父容器底部有一定间隙，所以上下图片间有间隙。 解决方案 移除上下间隙： img本身设置 display: block; 父元素设置 font-size: 0; （基线与字体大小有关，字体为零，基线间就没距离了） img本身设置 vertical-align: bottom;（让inline-block 的 img 与每行的底部对齐） 移除左右间距： 行内元素间不要有换行，连成一行写消除间隙（阅读性差，不推荐） 第一行img结尾写上 &lt;!-- ，第二行img开头跟上 --&gt; 。即利用注释消除间距 父元素 font-size: 0]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何清除浮动]]></title>
    <url>%2Fposts%2F12906%2F</url>
    <content type="text"><![CDATA[为什么要清除浮动其实浮动（e.g. float: left;）本质上是用来做文字混排的，但却被我们拿来做布局，这个时候虽然实现了某些效果，但也带来了不少副作用。 由于浮动元素不再占有原文档流的位置，所以它会对后续元素的排版带来影响（无视浮动元素，就当它不存在过）。因此我们很多时候要做的，就是消除浮动元素造成的影响。清除浮动的本质主要是为了解决父元素因为子元素浮动造成的内部高度为0的问题。 clear清除浮动的核心css属性是 clear ，基本语法如下： 123选择器: &#123; clear: 属性值;&#125; 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 清除浮动常见方案额外标记法在浮动元素后面添加一个空标签，例如： 12&lt;div style="float: left;"&gt;&lt;/div&gt;&lt;div style="clear: both;"&gt;&lt;/div&gt; 优点：通俗易懂，书写方便缺点：加入了过多的没有实际含义的额外标签，结构化差。 父元素添加overflow通过触发BFC达到清除浮动的效果。（p.s. 对bfc不了解可以看这篇文章） 123.parent &#123; overflow: hidden;&#125; 优点：代码简洁缺点：超出的内容会被隐藏 before和after双伪元素方案1234567891011.clearfix:before,.clearfix:after &#123; content:""; display: table; /* 触发BFC清除浮动 */&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 优点：代码简洁缺点：IE6-7不支持:after，需要使用 zoom: 1 触发 hasLayout 使用after伪元素（我平常使用的）1234567891011.clearfix::after &#123; content: "."; display: block; height: 0; visibility: hidden; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; /* IE6、7 专有 */ 使用方式：给浮动元素的父元素添加一个class类：clearfix优点：一次书写多处使用，并且符合闭合浮动思想，结构语义化正确缺点：IE6-7不支持:after，需要使用 zoom: 1 触发 hasLayout注意：content:&quot;.&quot; 内容尽量不为空，可以跟一个小点，否则在firefox 7.0前的版本会生成空格 :after 和 ::after 的区别:before、:after 在旧版本里是伪元素，CSS3的规范里 “:” 用来表示伪类，”::” 用来表示伪元素，但是在高版本浏览器下 :before、:after 会被自动识别为 ::before、::after ，这样做的目的是用来做兼容处理。 相同点伪类对象，用来设置对象前的内容:before 和 ::before 写法是等效的 不同点:before 是 css2 的写法，::before 是 css3 的写法:before 兼容性比 ::before要好 注意伪类元素必须要配合 content 属性一起使用，否则无效伪类元素是css渲染层加入的，不能通过js来操作]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>清除浮动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC的理解与应用]]></title>
    <url>%2Fposts%2F9722%2F</url>
    <content type="text"><![CDATA[定义先上MDN上对 BFC 的定义： 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 ———— BFC | MDN 不知道别人看完这段定义有何感受，反正我是懵逼的。不过我在这儿还是建议各位认真阅读上面给出的MDN链接至少两遍，这能让你对一个陌生的概念有一个基本的认知。 理解这里谈下我对BFC的理解：BFC其实是一个独立的，与外界隔离了的容器，容器里面的子元素不会影响到外面的元素，外面的也同样不会影响到容器内部的元素。我们可以利用这个特性，来解决一些布局上的问题。 BFC触发条件BFC的触发条件有很多，想要知道所有细节可以移步上面给出的 MDN 链接。这里我只列出一些常见触发条件： 根元素（HTML元素） 浮动元素（float不为none） 绝对定位元素（position 为 absolute 或 fixed） display 为 block, inline-block, flex, inline-flex, list-item, table overflow 值不为 visible 的块元素 BFC布局特性对于一个BFC容器来说： 内部相邻的两个元素垂直方向上的 margin 会发生重叠 不会与外界的浮动元素产生交集，而是紧贴浮动元素的边缘 元素从容器的顶端开始垂直地一个接一个地排列 每一个元素的左外边缘（margin-left）会触碰到容器的左边缘（border-left）（如果设置了容器内部的元素从右到左的格式排布，则触碰的是右边缘） 在计算它的高度时，还会检测内部浮动或者定位元素的高度 实际应用清除浮动利用BFC “在计算它的高度时，还会检测内部浮动或者定位元素的高度” 这条特性，我们可以触发父元素的BFC来清除子元素浮动带来的影响。常见的用法是给父元素设置 overflow: hidden 样式（如果考虑IE6版本，还需设置 zoom: 1，因为IE6不支持 overflow: hidden 来清除浮动）： See the Pen 利用BFC清除浮动 by JingW (@JingW) on CodePen. 解决外边距合并问题如果看上面标题不知道在说什么，请很戳这里了解详情。由于属于同一个BFC的两个相邻盒子的垂直margin会发生重叠，那么我们可以隔离开这两个元素，让它们不属于同一个BFC，这样就不会发生margin重叠了。 See the Pen 解决外边距合并问题 by JingW (@JingW) on CodePen. 两栏布局，右边宽度自适应我们常常在开发中有这样类似的需求：两栏布局，左边定宽，右边自适应。这时我们就可以利用BFC特性来实现需求：左边设置定宽+左浮动；右边给自己加上 overflow: hidden 。原理就是：给元素设置BFC后，为了和浮动元素不产生任何交集，它会顺着浮动元素的边缘形成自己的封闭上下文。直接上代码看效果： See the Pen 利用BFC实现两栏布局 by JingW (@JingW) on CodePen. 以上是我对BFC的一些理解以及实际应用，希望能够帮助大家了解BFC这个听起来摸不着头脑的东西。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三栏布局方案(圣杯+双飞翼)]]></title>
    <url>%2Fposts%2F55613%2F</url>
    <content type="text"><![CDATA[圣杯布局步骤一 - HTML框架搭建 &amp; 初始化CSS首先把基本框架搭起来（注意中间部分放最前面）： 12345&lt;div class="container"&gt; &lt;div class="center"&gt;我是中间&lt;/div&gt; &lt;div class="left"&gt;我是左边&lt;/div&gt; &lt;div class="right"&gt;我是右边&lt;/div&gt;&lt;/div&gt; 接下来是初始化样式。left, right宽度分别设置为100px和200px；然后设置container的 padding-left: 100px + padding-right: 200px 来占据两侧填充；center宽度设为100%，这样能够自适应剩下的宽度。再让所有子元素左浮动。代码如下： 12345678910111213141516171819202122232425.container &#123; padding: 0 200px 0 100px; /* 左边100， 右边200*/ background-color: #e1e1e1; height: 300px; /* 为了看效果，给个300px把高度撑起来 */&#125;.left, .center, .right &#123; float: left; height: 100%;&#125;.center &#123; width: 100%; /* 占据父元素剩下的宽度*/ background-color: lightblue;&#125;.left &#123; width: 100px; background-color: pink;&#125;.right &#123; width: 200px; background-color: yellow;&#125; 此时的页面效果： 步骤二 - 让left占据最左列为了让left能越过center，我们先给它设置一个 -100% 的左边距。这个100%是在container中的宽度，也就是center的宽度： 123456.left &#123; margin-left: -100%; width: 100px; /*为了看left和center的重叠效果，暂时bgc设为半透明*/ background-color: rgba(255,204,204,.6);&#125; 页面效果： 此时，我们已经让left从“第二行”升到了“第一行”，为了让它靠到最左侧，不与center重叠，可以给它设置相对定位，然后给个 left: -100px ，让它定位到container最左侧： 123456789.left &#123; /* 设置相对定位 */ position: relative; /* 靠到最左侧 */ left: -100px; margin-left: -100%; width: 100px; background-color: pink;&#125; 页面效果： 步骤三 - 让right占据最右列定位好了left，也是时候让right呆在最右边来填充位置了，我们继续使用负margin： 12345.right &#123; width: 200px; margin-right: -200px; background-color: yellow;&#125; 页面效果： 步骤四 - 给container设置min-width看起来已经实现了不是吗？但我们还差最后一步，给container设置一个 min-width: 100px （就是左列的宽度），否则当浏览器缩小到一定程度时，这个布局可能会被破坏。原因简单来讲就是：“由于设置了相对定位，所以当left原来的位置和right的位置产生重叠时，由于浮动的原因一行放不下就会换行”。所以布局就被打乱了。 123456.container &#123; min-width: 100px; background-color: #e1e1e1; padding: 0 200px 0 100px; height: 300px;&#125; 完整代码 + 最终效果这样，我们就实现了圣杯布局，完整代码和效果见下： See the Pen 三栏布局 - 圣杯布局 by JingW (@JingW) on CodePen. 双飞翼布局如果上面圣杯布局你已经理解并自己实践了一遍，那么这里的双飞翼布局你也应该不再话下。跟着我一起撸一遍代码吧。 步骤一 - HTML框架搭建 &amp; 初始化CSS首先搭建html，仔细观察下方代码你会发现，双飞翼布局在html上面有一点和圣杯布局有差别，那就是双飞翼在center里又套了一个div。到后面你就会知道这样设置的目的。 12345&lt;div class="container"&gt; &lt;div class="center"&gt;&lt;div&gt;我是中间&lt;/div&gt;&lt;/div&gt; &lt;div class="left"&gt;我是左边&lt;/div&gt; &lt;div class="right"&gt;我是右边&lt;/div&gt;&lt;/div&gt; 然后编写初始样式。left定宽100；right定宽200；left, right, center全部设置左浮动。其他例如设置颜色高度等等直接看下方代码： 1234567891011121314151617181920212223.container &#123; background-color: #e1e1e1; height: 300px;&#125;.center &#123; background-color: lightblue;&#125;.left &#123; width: 100px; background-color: pink;&#125;.right &#123; width: 200px; background-color: yellow;&#125;.left, .center, .right &#123; float: left; height: 100%;&#125; 效果如下： 步骤二 - 设置center为100%宽将center的宽度设为100%，这样会把left，right“挤”到第二行： 1234.center &#123; width: 100%; background-color: lightblue;&#125; 效果如下： 步骤三 - 分别让left,right回到最左边和最右边接着，给left设置 margin-left: -100% 回到最左边，给right设置 margin-left: -200px 回到最右边。此时center和left,right都有重叠区域，为了看效果，设置了半透明背景颜色。 1234567891011.left &#123; width: 100px; margin-left: -100%; background-color: pink;&#125;.right &#123; width: 200px; margin-left: -200px; background-color: yellow;&#125; 效果如下： 步骤四 - 给center的子div设置左右margin其实上面的效果图已经实现了三栏布局中间自适应。但有个问题是center左右部分区域会被遮挡，这个时候在步骤一提到的center子div的作用就体现出来了，我们可以给它设置一个左右的margin值，分别等于left的宽和right的宽，消除掉重叠的副作用。 1234.center div &#123; /* 左margin100，右margin200 */ margin: 0 200px 0 100px;&#125; 效果如下： 步骤五 - 给container设置min-width最后，给container设置一个min-width，让container最小宽度不小于left宽+right宽 12345.container &#123; min-width: 300px; background-color: #e1e1e1; height: 300px;&#125; 大功告成~ 完整代码 + 最终效果 See the Pen 三栏布局 - 双飞翼布局 by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两栏布局方案汇总]]></title>
    <url>%2Fposts%2F44541%2F</url>
    <content type="text"><![CDATA[记录下常见的两栏布局方式。 左边定宽，右边自适应模拟table父元素 display: table ，子元素左右 table-cell ，左边定宽。 See the Pen 两栏布局（左定右自适应）模拟table by JingW (@JingW) on CodePen. 左浮 + 右Margin子元素的左边浮动脱标，右边设置 margin-left: 左边元素宽度 See the Pen 两栏布局（左定右自适应）子元素绝对定位 by JingW (@JingW) on CodePen. 左浮 + 右BFC子元素左边设置浮动+定宽，右边子元素设置 overflow: hidden 触发自身BFC See the Pen 两栏布局（左定右自适应）左浮 + 右BFC by JingW (@JingW) on CodePen. 子绝父相子绝父相，左边 top, left: 0，右边 top, right: 0，left等于左边宽度。 See the Pen 两栏布局（左定右自适应）子绝父相 by JingW (@JingW) on CodePen. flex布局父元素 display: flex ，左边定宽，右边 flex: 1。 See the Pen 两栏布局（左定右自适应）flex by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垂直居中方案汇总]]></title>
    <url>%2Fposts%2F12733%2F</url>
    <content type="text"><![CDATA[这里汇总了常见的元素居中方案。 水平居中行内元素水平居中核心：给父元素添加 text-align: center See the Pen 行内元素水平居中 by JingW (@JingW) on CodePen. 块级元素水平居中核心：子元素自身 margin: 0 auto; See the Pen 块元素水平居中 by JingW (@JingW) on CodePen. 多个div水平居中传统方案核心：父元素设置 text-align: center ，子元素设置 inline-block See the Pen 多个div水平居中 - 传统方案 by JingW (@JingW) on CodePen. Flex方案核心：父元素 display: flex + justify-content: center + align-items: center See the Pen 多个div水平居中-flex by JingW (@JingW) on CodePen. 水平垂直居中table自带水平垂直居中核心：使用 table&gt;tr&gt;td 布局 See the Pen div水平垂直居中 - table by JingW (@JingW) on CodePen. 模拟table核心：父元素 display: table ，子元素 display: table-cell + vertical-align: middle See the Pen div水平垂直居中 - 模拟table by JingW (@JingW) on CodePen. 子绝父相 + 子元素 margin:auto核心：子元素相对于父元素绝对定位，top、right、bottom、left 都设为0，margi设为auto See the Pen div水平垂直居中 - 子绝父相 + Margin Auto by JingW (@JingW) on CodePen. 子绝父相 + 负margin核心：子元素相对于父元素绝对定位，top、left设为50%，margin相对自身宽/高一半 See the Pen div水平垂直居中 - 子绝父相 + 负Margin by JingW (@JingW) on CodePen. 子绝父相 + translate核心：子元素相对于父元素绝对定位，top、left设为50%，此时子元素左上角在父元素中心，然后让子元素向左上角位移自身宽度的一半 See the Pen div水平垂直居中 - 子绝父相 + translate by JingW (@JingW) on CodePen. Flex布局父元素 display: flex，justify-content 和 align-items 都设为 center 实现垂直居中 See the Pen div水平垂直居中 - flex by JingW (@JingW) on CodePen.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对HTML语义化的理解]]></title>
    <url>%2Fposts%2F2906%2F</url>
    <content type="text"><![CDATA[对HTML语义化的理解核心：用正确的标签做正确的事情 利与开发：方便代码的阅读和维护 利于SEO：方便爬虫根据 语义标签 确定 页面结构 和 关键字 的权重 常见语义化标签一图胜千言： 元素细节： &lt;main&gt; 存放每个页面独有的内容。每个页面上只能用一次 &lt;main&gt;，且直位于 &lt;body&gt;中。最好不要把它嵌套进其它元素。 &lt;article&gt; 包围的内容即一篇文章，与页面其它部分无关（比如一篇博文）。 &lt;section&gt; 与 &lt;article&gt; 类似，但 &lt;section&gt; 更适用于组织页面使其按功能（比如迷你地图、一组文章标题和摘要）分块。一般的最佳用法是：以 标题 作为开头；也可以把一篇 &lt;article&gt; 分成若干部分并分别置于不同的 &lt;section&gt; 中，也可以把一个区段 &lt;section&gt; 分成若干部分并分别置于不同的 &lt;article&gt; 中，取决于上下文。 &lt;aside&gt; 包含一些间接信息（术语条目、作者简介、相关链接，等等）。 &lt;header&gt; 是简介形式的内容。如果它是 &lt;body&gt; 的子元素，那么就是网站的全局页眉。如果它是 &lt;article&gt; 或&lt;section&gt; 的子元素，那么它是这些部分特有的页眉（此 &lt;header&gt; 非彼 标题）。 &lt;nav&gt; 包含页面主导航功能。其中不应包含二级链接等内容。 &lt;footer&gt; 包含了页面的页脚部分。 来源：文档与网站架构]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>语义化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo搭建个人博客]]></title>
    <url>%2Fposts%2F43303%2F</url>
    <content type="text"><![CDATA[介绍利用 Hexo 在 GitHub 上搭建个人博客。 准备工作你的电脑需要安装下面两个应用程序： NodeJS 如何安装 Git 如何安装 重要步骤安装Hexo安装文档 插件安装 hexo-abbrlink 介绍 &amp;&amp; 此插件诞生原因 hexo-deployer-git 将本地博客部署到GitHub 如何安装和使用 hexo-server npm install hexo-server –save 服务器模块。在启动期间，Hexo 会监视文件变动并自动更新 使用第三方主题 Next Yilia 创建分类功能运行： 1hexo new page &quot;categories&quot; p.s. 命名为categories原因是 categories 在next主题中是一个关键词对应着分类。 在主站根目录下,也就是你hexo的目录下找到 /source/categories/index.md，打开后的效果类似下方代码： 123456---title: categories #本页标题date: 2019-03-13 23:02:50 #创建日期type: "categories" #分类属于comments: false #如果有启用多说 或者 Disqus评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false--- 接着在 themes 主题文件夹下找到 next 文件夹，修改 _config.yml 文件： 123456menu: home: / || home # 地址路径 | 导航栏对应的图标 about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 然后在命令行输入添加文章命令： 1hexo new '你想要创建的文章名称' 根目录(主站目录下)/source/_posts/上一步创建的文章名称.md，双击打开： 123456---title: 文章标题date: 2019-03-13 23:13:23tags: html #属于哪个标签categories: interview #属于哪个分类--- 参考：分类和标签p.s. 如果想要实现父子分类，可以查看上方链接的评论 创建标签功能打开命令行，进入博客所在文件夹。执行命令：1hexo new page tags 成功后会有一个路径提示1INFO Created: ~/Documents/blog/source/tags/index.md 找到对应的文件打开1234---title: 标签date: 2019-03-14 00:02:05--- 添加type: “tags”到内容中，添加后是这样的：12345---title: 标签date: 2019-03-14 00:03:52type: 'tags'--- 打开你的文章页面：123456---title: jQuery对表单的操作及更多应用date: 2019-03-14 00:03:55categories: 前端 tags: jQuery #如果想要多个标签可以 tags: [jQuery, 表格, 表单验证]--- 不蒜子统计功能NexT主题集成了不蒜子统计功能，在NexT配置文件中找到关键词 busuanzi_count: ，把 enable 设置为 true p.s. 除此之外，如果设置为true后仍然无效，且打开控制台显示js报错。有可能是不蒜子链接失效的原因，需要在Next主题配置文件位置：1themes\next\layout\_third-party\analytics\busuanzi-counter.swig 修改script链接为：1&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 评论功能使用 Valine 参考： 评论系统从Disqus到Valine Valine - 一款快速、简洁且高效的无后端评论系统。 常用配置 Hexo瞎折腾系列(4) - 站点首页不显示文章全文 常用命令12345678910111213141516171819// npm全局安装Hexonpm install -g hexo-cli // 新建Hexo项目hexo init &lt;folder&gt;cd &lt;folder&gt;npm install// 新建文章hexo new '文章名'// 启动服务器hexo server -p 5000// 生成静态文件hexo generate --watch// 部署hexo clean &amp;&amp; hexo deploy 相关配置及资源 Hexo+NexT 打造一个炫酷博客 这应该是最全的hexo博客搭建以及next美化教程 给hexo添加Valine评论功能 LeanCloud Hexo搭建GitHub博客—打造炫酷的NexT主题–高级(四)]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
