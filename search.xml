<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BFC的理解与应用</title>
    <url>/posts/9722/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>先上MDN上对 BFC 的定义：</p>
<blockquote>
<p>块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>
</blockquote>
<p>———— <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">BFC | MDN</a></p>
<p>不知道别人看完这段定义有何感受，反正我是懵逼的。不过我在这儿还是建议各位认真阅读上面给出的MDN链接至少两遍，这能让你对一个陌生的概念有一个基本的认知。</p>
<a id="more"></a>

<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>这里谈下我对BFC的理解：BFC其实是一个独立的，与外界隔离了的容器，容器里面的子元素不会影响到外面的元素，外面的也同样不会影响到容器内部的元素。我们可以利用这个特性，来解决一些布局上的问题。</p>
<h2 id="BFC触发条件"><a href="#BFC触发条件" class="headerlink" title="BFC触发条件"></a>BFC触发条件</h2><p>BFC的触发条件有很多，想要知道所有细节可以移步上面给出的 MDN 链接。这里我只列出一些常见触发条件：</p>
<ul>
<li>根元素（HTML元素）</li>
<li>浮动元素（float不为none）</li>
<li>绝对定位元素（position 为 absolute 或 fixed）</li>
<li>display 为 block, inline-block, flex, inline-flex, list-item, table</li>
<li>overflow 值不为 visible 的块元素</li>
</ul>
<h2 id="BFC布局特性"><a href="#BFC布局特性" class="headerlink" title="BFC布局特性"></a>BFC布局特性</h2><p>对于一个BFC容器来说：</p>
<ul>
<li>内部相邻的两个元素垂直方向上的 margin 会发生重叠</li>
<li>不会与外界的浮动元素产生交集，而是紧贴浮动元素的边缘</li>
<li>元素从容器的顶端开始垂直地一个接一个地排列</li>
<li>每一个元素的左外边缘（margin-left）会触碰到容器的左边缘（border-left）（如果设置了容器内部的元素从右到左的格式排布，则触碰的是右边缘）</li>
<li>在计算它的高度时，还会检测内部浮动或者定位元素的高度</li>
</ul>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>利用BFC “在计算它的高度时，还会检测内部浮动或者定位元素的高度” 这条特性，我们可以触发父元素的BFC来清除子元素浮动带来的影响。常见的用法是给父元素设置 <code>overflow: hidden</code> 样式（如果考虑IE6版本，还需设置 <code>zoom: 1</code>，因为IE6不支持 <code>overflow: hidden</code> 来清除浮动）：</p>
<iframe height="265" scrolling="no" title="利用BFC清除浮动" src="https://codepen.io/JingW/embed/BbxEGP/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="解决外边距合并问题"><a href="#解决外边距合并问题" class="headerlink" title="解决外边距合并问题"></a>解决外边距合并问题</h3><p>如果看上面标题不知道在说什么，请很戳<a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp">这里</a>了解详情。由于属于同一个BFC的两个相邻盒子的垂直margin会发生重叠，那么我们可以隔离开这两个元素，让它们不属于同一个BFC，这样就不会发生margin重叠了。</p>
<iframe height="265" scrolling="no" title="解决外边距合并问题" src="https://codepen.io/JingW/embed/YgLbzY/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="两栏布局，右边宽度自适应"><a href="#两栏布局，右边宽度自适应" class="headerlink" title="两栏布局，右边宽度自适应"></a>两栏布局，右边宽度自适应</h3><p>我们常常在开发中有这样类似的需求：两栏布局，左边定宽，右边自适应。<br>这时我们就可以利用BFC特性来实现需求：左边设置定宽+左浮动；右边给自己加上 <code>overflow: hidden</code> 。<br>原理就是：给元素设置BFC后，为了和浮动元素不产生任何交集，它会顺着浮动元素的边缘形成自己的封闭上下文。直接上代码看效果：</p>
<iframe height="265" scrolling="no" title="利用BFC实现两栏布局" src="https://codepen.io/JingW/embed/MxGdEe/?height=265&amp;theme-id=0&amp;default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<p>以上是我对BFC的一些理解以及实际应用，希望能够帮助大家了解BFC这个听起来摸不着头脑的东西。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>APFS、Mac OS 扩展、ExFAT格式有何区别</title>
    <url>/posts/33677/</url>
    <content><![CDATA[<h2 id="APFS"><a href="#APFS" class="headerlink" title="APFS"></a><strong>APFS</strong></h2><p>是<strong>Apple 苹果系统特有的一种文件格式</strong>，是 Mac OS High Sierra 操作系统版本时发布的；这种文件格式只能苹果 Mac OS 操作系统使用。（必须至少是 Mac OS High Sierra 版本以及更新的 Mac OS 才行，老版本的苹果系统不支持）这种系统非常牛逼，主要是<strong>针对 PCIe 闪存和 SSD 固态硬盘进行了优化</strong>；如果你是使用固态硬盘，且<strong>不考虑硬盘上的东西在 Windows 操作系统中使用，那推荐使用 APFS 硬盘格式</strong>。</p>
<h2 id="Mac-OS-扩展格式"><a href="#Mac-OS-扩展格式" class="headerlink" title="Mac OS 扩展格式"></a><strong>Mac OS 扩展格式</strong></h2><p>Mac OS Extended 是以前苹果 Mac OS 使用的文件系统，现在基本上已经淘汰了。能用 APFS 就尽量使用 APFS，与其考虑<strong>兼容旧版的 Mac OS</strong>，不如让更新旧版的 Mac OS 系统。</p>
<h2 id="Mac-OS-日志格式"><a href="#Mac-OS-日志格式" class="headerlink" title="Mac OS 日志格式"></a><strong>Mac OS 日志格式</strong></h2><p>Mac OS 操作系统有一个自带的硬盘备份工具，叫 Time Machine（时间机器）；这种硬盘格式就是<strong>专门用于 Time Machine</strong>。如果是要<strong>把这个硬盘作为备份盘</strong>，那就格式化成这种硬盘格式。</p>
<h2 id="ExFAT"><a href="#ExFAT" class="headerlink" title="ExFAT"></a><strong>ExFAT</strong></h2><p>上面说的三种硬盘格式都是专门用于苹果的 Mac OS 操作系统的，而 ExFAT 则是不仅可用于 Mac OS 苹果操作系统，还可以用于 Windows 操作系统。<strong>如果你想该硬盘的东西在 Windows 系统可以被读取，那就选择 ExFAT 操作系统</strong>。</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3伪元素实现自定义复选框</title>
    <url>/posts/3583/</url>
    <content><![CDATA[<p>我们都知道原生的复选框控件样式极难自定义，这对于工程师实现设计稿的难度加大了一大截。css3 的出现，增加了:checked 选择器，因此我们可以利用:checked 和 label 来实现各式各样的表单选择控件，接下来让我们来看看如何实现吧！</p>
<a id="more"></a>

<p>我们来看看如何实现上述自定义的复选框：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.check-wrap</span> &#123;</span></span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.checkbox</span> &#123;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    clip: rect(0, 0, 0, 0);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.checkbox</span><span class="selector-attr">[type=<span class="string">&#x27;checkbox&#x27;</span>]</span><span class="selector-pseudo">:focus</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">box-shadow</span>: 0 0 0.6<span class="selector-tag">em</span> <span class="selector-id">#06c</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.checkbox</span><span class="selector-attr">[type=<span class="string">&#x27;checkbox&#x27;</span>]</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line">    content: &#x27;\a0&#x27;; /* 不换行空格 */</span><br><span class="line">    display: inline-block;</span><br><span class="line">    margin-right: 0.3em;</span><br><span class="line">    width: 2em;</span><br><span class="line">    height: 2em;</span><br><span class="line">    border-radius: 0.3em;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line"><span class="css">    <span class="selector-tag">line-height</span>: 2<span class="selector-tag">em</span>; <span class="comment">/* 关键 */</span></span></span><br><span class="line">    font-size: 20px;</span><br><span class="line">    text-align: center;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">    background: gray;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.checkbox</span><span class="selector-attr">[type=<span class="string">&#x27;checkbox&#x27;</span>]</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line">    content: &#x27;\2713&#x27;; /* 对勾 */</span><br><span class="line">    background: black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  label &#123;</span><br><span class="line">    margin-right: 40px;</span><br><span class="line">    font-size: 20px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;check-wrap&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;check-1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;check-1&quot;</span>&gt;</span>生男孩<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;check-2&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;check-2&quot;</span>&gt;</span>生女孩<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>这里为了隐藏原生的 checkbox 控件，我们用了 clip: rect(0,0,0,0)进行截取，然后使用 checkbox 的伪类:checked 来实现交互。</p>
<p>接下来扩展一下，我们来实现自定义开关：</p>


<p>这里原理是一样的，只不过样式做了改动，直接上代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.check-wrap</span> &#123;</span></span><br><span class="line">    margin-bottom: 20px;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.switch</span> &#123;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    clip: rect(0, 0, 0, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-class">.switch</span><span class="selector-attr">[type=<span class="string">&#x27;checkbox&#x27;</span>]</span> + <span class="selector-tag">label</span> &#123;</span></span><br><span class="line">    width: 6em;</span><br><span class="line">    height: 3em;</span><br><span class="line">    padding: 0.3em;</span><br><span class="line">    border-radius: 0.3em;</span><br><span class="line">    border: 1px solid rgba(0, 0, 0, 0.2);</span><br><span class="line">    vertical-align: middle;</span><br><span class="line"><span class="css">    <span class="selector-tag">line-height</span>: 2<span class="selector-tag">em</span>; <span class="comment">/* 关键 */</span></span></span><br><span class="line">    font-size: 20px;</span><br><span class="line">    text-align: center;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">    box-shadow: 0 1px white inset;</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-id">#ddd</span>, <span class="selector-id">#bbb</span>);</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.switch</span><span class="selector-attr">[type=<span class="string">&#x27;checkbox&#x27;</span>]</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">label</span> &#123;</span></span><br><span class="line">    box-shadow: 0.05em 0.1em 0.2em rgba(0, 0, 0, 0.6) inset;</span><br><span class="line">    border-color: rgba(0, 0, 0, 0.3);</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#bbb</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  label &#123;</span><br><span class="line">    margin-right: 40px;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-class">.switch-an</span> &#123;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    clip: rect(0, 0, 0, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-class">.switch-an</span><span class="selector-attr">[type=<span class="string">&#x27;checkbox&#x27;</span>]</span> + <span class="selector-tag">label</span> &#123;</span></span><br><span class="line">    position: relative;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: 5em;</span><br><span class="line">    height: 2em;</span><br><span class="line">    border-radius: 1em;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#06c</span>;</span></span><br><span class="line">    text-align: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-class">.switch-an</span><span class="selector-attr">[type=<span class="string">&#x27;checkbox&#x27;</span>]</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line">    content: &#x27;&#x27;;</span><br><span class="line">    width: 2em;</span><br><span class="line">    height: 2em;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    border-radius: 100%;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">    transition: left 0.3s;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.switch-an</span><span class="selector-attr">[type=<span class="string">&#x27;checkbox&#x27;</span>]</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">    content: &#x27;OFF&#x27;;</span><br><span class="line">    margin-left: 2.6em;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.switch-an</span><span class="selector-attr">[type=<span class="string">&#x27;checkbox&#x27;</span>]</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line">    transition: left 0.3s;</span><br><span class="line">    left: 3em;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.switch-an</span><span class="selector-attr">[type=<span class="string">&#x27;checkbox&#x27;</span>]</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">    content: &#x27;NO&#x27;;</span><br><span class="line">    margin-left: 0.6em;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;check-wrap&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;switch&quot;</span> <span class="attr">id</span>=<span class="string">&quot;switch-1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;switch-1&quot;</span>&gt;</span>生男孩<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;switch&quot;</span> <span class="attr">id</span>=<span class="string">&quot;switch-2&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;switch-2&quot;</span>&gt;</span>生女孩<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;check-wrap&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;switch-an&quot;</span> <span class="attr">id</span>=<span class="string">&quot;switch-an-1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;switch-an-1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中如何实现继承</title>
    <url>/posts/2751/</url>
    <content><![CDATA[<h2 id="组合继承（原型链-借用构造函数）"><a href="#组合继承（原型链-借用构造函数）" class="headerlink" title="组合继承（原型链 + 借用构造函数）"></a>组合继承（原型链 + 借用构造函数）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组合继承:原型继承+借用（调用）构造函数继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex, score</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 借用构造函数</span></span><br><span class="line">  Person.call(<span class="built_in">this</span>,name,age,sex);</span><br><span class="line">  <span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改变原型指向----继承</span></span><br><span class="line"><span class="comment">// 我们让 Student.prototype 指向一个Person的实例对象</span></span><br><span class="line"><span class="comment">// 这个对象的__proto__指向的是Person.prototype</span></span><br><span class="line"><span class="comment">// 所以我们就可以借助这个实例对象拿到sayHi方法，实现继承</span></span><br><span class="line">Student.prototype=<span class="keyword">new</span> Person();</span><br><span class="line">Student.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">&quot;Lance&quot;</span>, <span class="number">20</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;100分&quot;</span>);</span><br><span class="line">stu.sayHi();</span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> Student(<span class="string">&quot;Jerry&quot;</span>, <span class="number">19</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;101分&quot;</span>);</span><br><span class="line">stu2.eat();</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性和方法都被继承了</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="寄生组合继承（组合继承升级版）"><a href="#寄生组合继承（组合继承升级版）" class="headerlink" title="寄生组合继承（组合继承升级版）"></a>寄生组合继承（组合继承升级版）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">// 创建了父类原型的浅复制</span></span><br><span class="line">    prototype.constructor = subType;             <span class="comment">// 修正原型的构造函数</span></span><br><span class="line">    subType.prototype = prototype;               <span class="comment">// 将子类的原型替换为这个原型</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费</span></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ES6继承写法"><a href="#ES6继承写法" class="headerlink" title="ES6继承写法"></a>ES6继承写法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;<span class="built_in">this</span>.name=name;<span class="built_in">this</span>.age=age&#125;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age, weight</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age); <span class="built_in">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在原型链继承时，为什么不直接-Student-prototype-Person-prototype-？"><a href="#在原型链继承时，为什么不直接-Student-prototype-Person-prototype-？" class="headerlink" title="在原型链继承时，为什么不直接 Student.prototype = Person.prototype ？"></a>在原型链继承时，为什么不直接 <code>Student.prototype = Person.prototype</code> ？</h2><p>因为对象的赋值只是引用的赋值, 上面两者都指向同一个内存地址，只要随便通过1个途径就能修改该内存地址的对象，这样子类就无法单独扩展方法，而且会影响父类。</p>
<h2 id="组合继承的缺点"><a href="#组合继承的缺点" class="headerlink" title="组合继承的缺点"></a>组合继承的缺点</h2><p>缺点就是调用了两次父类的构造函数。<br>第一次给子类的原型添加了父类构造函数中的属性方法；第二次又给子类的构造函数添加了父类的构造函数的属性方法，从而覆盖了子类原型中的同名参数。这种被覆盖的情况造成了性能上的浪费：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SuperType.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is parent&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="built_in">this</span>) <span class="comment">// 第二次调用SuperType</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType() <span class="comment">// 第一次调用SuperType</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5的自定义属性</title>
    <url>/posts/39974/</url>
    <content><![CDATA[<blockquote>
<p>在 HTML5 中我们可以自定义属性，其格式为 <code>data-*=&quot;&quot;</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">data-my-name</span>=<span class="string">&quot;sw&quot;</span> <span class="attr">data-age</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">/*</span><br><span class="line">  Node.dataset 是以对象形式存在的，当我们为同一个 DOM 节点指定了多个自定义属性时，</span><br><span class="line">  Node.dataset 则存储了所有的自定义属性的值。</span><br><span class="line">  */</span><br><span class="line"><span class="javascript"><span class="keyword">var</span> demo = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#demo&quot;</span>);</span></span><br><span class="line"><span class="javascript"><span class="comment">//获取</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//注：当我们如下格式设置时，则需要以驼峰格式才能正确获取</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> name = demo.dataset[<span class="string">&#x27;myName&#x27;</span>];</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> age = demo.dataset[<span class="string">&#x27;age&#x27;</span>];</span></span><br><span class="line"><span class="javascript"><span class="comment">//设置</span></span></span><br><span class="line"><span class="javascript">demo.dataset[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;web developer&#x27;</span>;</span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span>/&gt;</span></span></span></span><br></pre></td></tr></table></figure>

<p><strong>资源</strong></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/data-*">mdn - data-*</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>JS数组有哪些常用方法</title>
    <url>/posts/21501/</url>
    <content><![CDATA[<h2 id="改变原数组的方法"><a href="#改变原数组的方法" class="headerlink" title="改变原数组的方法"></a>改变原数组的方法</h2><h3 id="splice-添加-删除数组元素"><a href="#splice-添加-删除数组元素" class="headerlink" title="splice() 添加/删除数组元素"></a>splice() 添加/删除数组元素</h3><blockquote>
<p>splice() 方法<strong>向/从数组中添加/删除</strong>项目，然后返回被删除的项目</p>
<p>array.splice(index,howmany,item1,…..,itemX)</p>
<ol>
<li>index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</li>
<li>howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。</li>
<li>item1, …, itemX： 可选。向数组添加的新项目。</li>
</ol>
<p>返回值: 如果有元素被删除,返回包含被删除项目的新数组。</p>
</blockquote>
<a id="more"></a>

<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组下标0开始，删除3个元素</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7</span></span><br><span class="line"><span class="keyword">let</span> item = a.splice(-<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// [7]</span></span><br></pre></td></tr></table></figure>

<h4 id="删除并添加"><a href="#删除并添加" class="headerlink" title="删除并添加"></a>删除并添加</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组下标0开始，删除3个元素，并添加元素&#x27;添加&#x27;</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;添加&#x27;</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [&#x27;添加&#x27;,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组最后第二个元素开始，删除3个元素，并添加两个元素&#x27;添加1&#x27;、&#x27;添加2&#x27;</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = b.splice(-<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;添加1&#x27;</span>,<span class="string">&#x27;添加2&#x27;</span>); <span class="comment">// [6,7]</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [1,2,3,4,5,&#x27;添加1&#x27;,&#x27;添加2&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="不删除只添加"><a href="#不删除只添加" class="headerlink" title="不删除只添加"></a>不删除只添加</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;添加1&#x27;</span>,<span class="string">&#x27;添加2&#x27;</span>); <span class="comment">// [] 没有删除元素，返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [&#x27;添加1&#x27;,&#x27;添加2&#x27;,1,2,3,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = b.splice(-<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;添加1&#x27;</span>,<span class="string">&#x27;添加2&#x27;</span>); <span class="comment">// [] 没有删除元素，返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [1,2,3,4,5,6,&#x27;添加1&#x27;,&#x27;添加2&#x27;,7] 在最后一个元素的前面添加两个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="sort-数组排序"><a href="#sort-数组排序" class="headerlink" title="sort() 数组排序"></a>sort() 数组排序</h3><blockquote>
<p>定义: sort()方法对数组元素进行排序，并返回这个数组。</p>
<p>参数可选: 规定排序顺序的比较函数。</p>
<p>默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用<code>toString()</code>方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。</p>
</blockquote>
<h4 id="不传参"><a href="#不传参" class="headerlink" title="不传参"></a>不传参</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串排列 看起来很正常</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>];</span><br><span class="line">a.sort(); <span class="comment">// [&quot;Apple&quot;,&quot;Banana&quot;,&quot;Mango&quot;,&quot;Orange&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>,<span class="number">25</span>,<span class="number">8</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a.sort()) <span class="comment">// [1,10,20,25,3,8];</span></span><br></pre></td></tr></table></figure>

<p><strong>比较函数的两个参数：</strong></p>
<p>sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：</p>
<ul>
<li>若比较函数返回值&lt;0，那么a将排到b的前面;</li>
<li>若比较函数返回值=0，那么a 和 b 相对位置不变；</li>
<li>若比较函数返回值&gt;0，那么b 排在a 将的前面；</li>
</ul>
<h4 id="数字升降序"><a href="#数字升降序" class="headerlink" title="数字升降序"></a>数字升降序</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array =  [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">4</span>, <span class="number">25</span>, <span class="number">8</span>];  </span><br><span class="line">array.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [1,3,4,4,8,10,20,25];</span></span><br><span class="line"></span><br><span class="line">array.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b-a;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [25,20,10,8,4,4,3,1];</span></span><br></pre></td></tr></table></figure>

<h3 id="pop-删除一个数组中的最后的一个元素"><a href="#pop-删除一个数组中的最后的一个元素" class="headerlink" title="pop() 删除一个数组中的最后的一个元素"></a>pop() 删除一个数组中的最后的一个元素</h3><blockquote>
<p>定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.pop();  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure>

<h3 id="shift-删除数组的第一个元素"><a href="#shift-删除数组的第一个元素" class="headerlink" title="shift() 删除数组的第一个元素"></a>shift() 删除数组的第一个元素</h3><blockquote>
<p>定义: shift()方法删除数组的第一个元素，并返回这个元素。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.shift();  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [2,3]</span></span><br></pre></td></tr></table></figure>

<h3 id="push-向数组的末尾添加元素"><a href="#push-向数组的末尾添加元素" class="headerlink" title="push() 向数组的末尾添加元素"></a>push() 向数组的末尾添加元素</h3><blockquote>
<p>定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p>
<p>参数: item1, item2, …, itemX ,要添加到数组末尾的元素</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.push(<span class="string">&#x27;末尾&#x27;</span>, <span class="string">&#x27;233&#x27;</span>);  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [1,2,3,&#x27;末尾&#x27;, &#x27;233&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><blockquote>
<p>定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</p>
<p>参数: item1, item2, …, itemX ,要添加到数组开头的元素</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.unshift(<span class="string">&#x27;开头&#x27;</span>, <span class="string">&#x27;开头2&#x27;</span>);  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [ &#x27;开头&#x27;, &#x27;开头2&#x27;, 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="reverse-颠倒数组中元素的顺序"><a href="#reverse-颠倒数组中元素的顺序" class="headerlink" title="reverse() 颠倒数组中元素的顺序"></a>reverse() 颠倒数组中元素的顺序</h3><blockquote>
<p>定义: reverse() 方法用于颠倒数组中元素的顺序。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.reverse();  </span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [3,2,1]</span></span><br></pre></td></tr></table></figure>

<h2 id="不改变原数组的方法"><a href="#不改变原数组的方法" class="headerlink" title="不改变原数组的方法"></a>不改变原数组的方法</h2><h3 id="slice-浅拷贝数组的元素"><a href="#slice-浅拷贝数组的元素" class="headerlink" title="slice() 浅拷贝数组的元素"></a>slice() 浅拷贝数组的元素</h3><blockquote>
<p>定义： 方法返回一个从开始到结束（<strong>不包括结束</strong>）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。</p>
<p>语法：array.slice(begin, end);</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a= [<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> b=a.slice(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// [&#x27;hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。</span></span><br><span class="line"><span class="comment">// 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="string">&#x27;改变原数组&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b); <span class="comment">// [&#x27;改变原数组&#x27;,&#x27;world&#x27;] [&#x27;hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a= [&#123;<span class="attr">name</span>:<span class="string">&#x27;OBKoro1&#x27;</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> b=a.slice();</span><br><span class="line"><span class="built_in">console</span>.log(b,a); <span class="comment">// [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;]  [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;]</span></span><br><span class="line"><span class="comment">// a[0].name=&#x27;改变原数组&#x27;;</span></span><br><span class="line"><span class="comment">// console.log(b,a); // [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;] [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;]</span></span><br></pre></td></tr></table></figure>

<h3 id="join-数组转字符串"><a href="#join-数组转字符串" class="headerlink" title="join() 数组转字符串"></a>join() 数组转字符串</h3><blockquote>
<p>定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。</p>
<p>语法: array.join(str)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a= [<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str=a.join(); <span class="comment">// &#x27;hello,world&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2=a.join(<span class="string">&#x27;+&#x27;</span>); <span class="comment">// &#x27;hello+world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a= [[<span class="string">&#x27;OBKoro1&#x27;</span>,<span class="string">&#x27;23&#x27;</span>],<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str1=a.join(); <span class="comment">// OBKoro1,23,test</span></span><br><span class="line"><span class="keyword">let</span> b= [&#123;<span class="attr">name</span>:<span class="string">&#x27;OBKoro1&#x27;</span>,<span class="attr">age</span>:<span class="string">&#x27;23&#x27;</span>&#125;,<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str2 = b.join(); <span class="comment">// [object Object],test</span></span><br><span class="line"><span class="comment">// 对象转字符串推荐JSON.stringify(obj);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结论：</span></span><br><span class="line"><span class="comment">// join()/toString()方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),</span></span><br><span class="line"><span class="comment">// 如果是对象的话，对象会被转为[object Object]字符串。</span></span><br></pre></td></tr></table></figure>

<h3 id="join-数组转字符串-1"><a href="#join-数组转字符串-1" class="headerlink" title="join() 数组转字符串"></a>join() 数组转字符串</h3><blockquote>
<p>定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。</p>
<p>语法: array.join(str)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a= [<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str=a.join(); <span class="comment">// &#x27;hello,world&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2=a.join(<span class="string">&#x27;+&#x27;</span>); <span class="comment">// &#x27;hello+world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a= [[<span class="string">&#x27;OBKoro1&#x27;</span>,<span class="string">&#x27;23&#x27;</span>],<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str1=a.join(); <span class="comment">// OBKoro1,23,test</span></span><br><span class="line"><span class="keyword">let</span> b= [&#123;<span class="attr">name</span>:<span class="string">&#x27;OBKoro1&#x27;</span>,<span class="attr">age</span>:<span class="string">&#x27;23&#x27;</span>&#125;,<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str2 = b.join(); <span class="comment">// [object Object],test</span></span><br><span class="line"><span class="comment">// 对象转字符串推荐JSON.stringify(obj);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结论：</span></span><br><span class="line"><span class="comment">// join()/toString()方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),</span></span><br><span class="line"><span class="comment">// 如果是对象的话，对象会被转为[object Object]字符串。</span></span><br></pre></td></tr></table></figure>

<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><blockquote>
<p>定义： 方法用于合并两个或多个数组，返回一个新数组。</p>
<p>语法：var newArr =oldArray.concat(arrayX,arrayX,……,arrayX)</p>
<p>参数：arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">//连接两个数组</span></span><br><span class="line"><span class="keyword">let</span> newVal=a.concat(b); <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment">// 连接三个数组</span></span><br><span class="line"><span class="keyword">let</span> c = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> newVal2 = a.concat(b, c); <span class="comment">// [1,2,3,4,5,6,7,8,9]</span></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="keyword">let</span> newVal3 = a.concat(<span class="string">&#x27;添加元素&#x27;</span>,b, c,<span class="string">&#x27;再加一个&#x27;</span>); </span><br><span class="line"><span class="comment">// [1,2,3,&quot;添加元素&quot;,4,5,6,7,8,9,&quot;再加一个&quot;]</span></span><br><span class="line"><span class="comment">// 合并嵌套数组  会浅拷贝嵌套数组</span></span><br><span class="line"><span class="keyword">let</span> d = [<span class="number">1</span>,<span class="number">2</span> ];</span><br><span class="line"><span class="keyword">let</span> f = [<span class="number">3</span>,[<span class="number">4</span>]];</span><br><span class="line"><span class="keyword">let</span> newVal4 = d.concat(f); <span class="comment">// [1,2,3,[4]]</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6扩展运算符-合并数组"><a href="#ES6扩展运算符-合并数组" class="headerlink" title="ES6扩展运算符...合并数组"></a>ES6扩展运算符<code>...</code>合并数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> b = [ <span class="number">4</span>,...a, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a,b); <span class="comment">//  [2, 3, 4, 5] [4,2,3,4,5,4,4]</span></span><br></pre></td></tr></table></figure>

<h3 id="indexOf-查找数组是否存在某个元素，返回下标"><a href="#indexOf-查找数组是否存在某个元素，返回下标" class="headerlink" title="indexOf() 查找数组是否存在某个元素，返回下标"></a>indexOf() 查找数组是否存在某个元素，返回下标</h3><blockquote>
<p>定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p>
<p>p.s. 字符串也有此方法，要注意当 ‘lance’.indexOf(‘’) 一个空字符串时，返回0而不是-1</p>
<p>语法：array.indexOf(searchElement,fromIndex)</p>
<p>参数：</p>
<p>searchElement(必须):被查找的元素</p>
<p>fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。</p>
<p>严格相等的搜索:</p>
<p>数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等<code>===</code>搜索元素，即<strong>数组元素要完全匹配</strong>才能搜索成功。</p>
<p><strong>注意</strong>：indexOf()不能识别<code>NaN</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="string">&#x27;啦啦&#x27;</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">24</span>,<span class="literal">NaN</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">&#x27;啦&#x27;</span>));  <span class="comment">// -1 </span></span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">&#x27;NaN&#x27;</span>));  <span class="comment">// -1 </span></span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">&#x27;啦啦&#x27;</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="lastIndexOf-查找指定元素在数组中的最后一个位置"><a href="#lastIndexOf-查找指定元素在数组中的最后一个位置" class="headerlink" title="lastIndexOf() 查找指定元素在数组中的最后一个位置"></a>lastIndexOf() 查找指定元素在数组中的最后一个位置</h3><blockquote>
<p>定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）</p>
<p>语法：arr.lastIndexOf(searchElement,fromIndex)</p>
<p>参数:</p>
<p>searchElement(必须): 被查找的元素</p>
<p>fromIndex(可选): 逆向查找开始位置，默认值数组的 <code>长度-1</code>，即查找整个数组。</p>
<p>关于fromIndex有三个规则:</p>
<ol>
<li>正值。如果该值大于或等于数组的长度，则整个数组会被查找。</li>
<li>负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)</li>
<li>负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="string">&#x27;OB&#x27;</span>,<span class="number">4</span>,<span class="string">&#x27;Koro1&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;Koro1&#x27;</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;Koro1&#x27;</span>]; <span class="comment">// 数组长度为10</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,4); // 从下标4开始往前找 返回下标2</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,100); //  大于或数组的长度 查找整个数组 返回9</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,-11); // -1 数组不会被查找</span></span><br><span class="line"><span class="keyword">let</span> b=a.lastIndexOf(<span class="string">&#x27;Koro1&#x27;</span>,-<span class="number">9</span>); <span class="comment">// 从第二个元素4往前查找，没有找到 返回-1</span></span><br></pre></td></tr></table></figure>

<h3 id="ES7-includes-查找数组是否包含某个元素-返回布尔"><a href="#ES7-includes-查找数组是否包含某个元素-返回布尔" class="headerlink" title="ES7 includes() 查找数组是否包含某个元素 返回布尔"></a>ES7 includes() 查找数组是否包含某个元素 返回布尔</h3><blockquote>
<p>定义： 返回一个布尔值，表示某个数组是否包含给定的值</p>
<p>语法：array.includes(searchElement,fromIndex=0)</p>
<p>参数：</p>
<p>searchElement(必须):被查找的元素</p>
<p>fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。</p>
<p><strong>includes方法是为了弥补indexOf方法的缺陷而出现的:</strong></p>
<ol>
<li>indexOf方法不能识别<code>NaN</code></li>
<li>indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于<code>-1</code>，表达不够直观</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="string">&#x27;OB&#x27;</span>,<span class="string">&#x27;Koro1&#x27;</span>,<span class="number">1</span>,<span class="literal">NaN</span>];</span><br><span class="line"><span class="comment">// let b=a.includes(NaN); // true 识别NaN</span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,100); // false 超过数组长度 不搜索</span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,-3);  // true 从倒数第三个元素开始搜索 </span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,-100);  // true 负值绝对值超过数组长度，搜索整个数组</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>【翻译】Minification 压缩与 Gzip 压缩的区别</title>
    <url>/posts/8214/</url>
    <content><![CDATA[<blockquote>
<p>原链接：<a href="https://css-tricks.com/the-difference-between-minification-and-gzipping/">https://css-tricks.com/the-difference-between-minification-and-gzipping/</a><br>作者：Chris Coyier</p>
</blockquote>
<p>这两种方法都针对你网站上的资源（比如 .css 文件和 .js 文件）所使用。它们都用来压缩文件大小，使服务器和浏览器之间的网络更加通畅，提高网页性能。网络是网页的速度瓶颈所在，而压缩文件大小能够改善这一点。</p>
<p>但这两者也截然不同。如果之前你并不知道这一点，那么你应当花时间来了解它。</p>
<a id="more"></a>

<h1 id="Minification-能够删除空格符（whitespace）、注释符（comments）、无用的分号（semicolons）或是减少-hex-代码的长度…"><a href="#Minification-能够删除空格符（whitespace）、注释符（comments）、无用的分号（semicolons）或是减少-hex-代码的长度…" class="headerlink" title="Minification 能够删除空格符（whitespace）、注释符（comments）、无用的分号（semicolons）或是减少 hex 代码的长度…"></a>Minification 能够删除空格符（whitespace）、注释符（comments）、无用的分号（semicolons）或是减少 hex 代码的长度…</h1><p>……诸如此类。剩下的文件依然是有效代码。你不必尝试读取它或是使用它，它并没有违反任何规则。就像对原始文件那样，浏览器可以读取它和使用它。</p>
<p>Minification 能够创建你最终使用的新文件。比如当你创建了一个名为 <code>style.css</code> 的文件之后，你可以把它压缩为 <code>style.min.css</code>。</p>
<h1 id="Gizpping-能识别所有重复的字符串，并使用指代该字符串第一个实例的指针来代替。"><a href="#Gizpping-能识别所有重复的字符串，并使用指代该字符串第一个实例的指针来代替。" class="headerlink" title="Gizpping 能识别所有重复的字符串，并使用指代该字符串第一个实例的指针来代替。"></a>Gizpping 能识别所有重复的字符串，并使用指代该字符串第一个实例的指针来代替。</h1><p>Julia Evans 曾想出一个绝佳的方法来解释这一点（点击<a href="https://jvns.ca/blog/2013/10/24/day-16-gzip-plus-poetry-equals-awesome/">这里</a>查阅她发布的内容和视频）。下面是一首诗的第一段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Once upon a midnight dreary, <span class="keyword">while</span> I &#123;pon&#125;dered weak an&#123;d wea&#125;&#123;ry,&#125;</span><br><span class="line">Over many&#123; a &#125;quaint&#123; and &#125;curious volume <span class="keyword">of</span> forgotten lore,</span><br><span class="line">W&#123;hile I &#125;nodded, n&#123;ear&#125;ly napping, su&#123;dde&#125;n&#123;ly &#125;th&#123;ere&#125; ca&#123;me &#125;a t&#123;apping,&#125;</span><br><span class="line">As&#123; <span class="keyword">of</span> &#125;so&#123;me o&#125;ne gent&#123;ly &#125;r&#123;apping, &#125;&#123;rapping&#125; at my chamb&#123;er &#125;door.</span><br><span class="line"><span class="string">`&#x27;Tis&#123; some &#125;visitor,&#x27;&#123; I &#125;mu&#123;tte&#125;r&#123;ed, &#125;`</span>t&#123;apping at my chamber door&#125; -</span><br><span class="line">O&#123;nly th&#125;is,&#123; and &#125;no&#123;thi&#125;&#123;ng &#125;m&#123;ore&#125;.</span><br></pre></td></tr></table></figure>

<p>Gzip 识别出括弧里的文字都是重复的，因此将会使用指针来代替它们，这样这些文字占用的空间将会比原来更小。</p>
<p>对于减少文件大小、尤其是代码而言，这种方法十分高效，因为代码中有大量重复的内容。设想一下一个 HTML 文件里有多少个 <code>&lt;div</code>，一个 CSS 文件里又有多少 <code>&#123;</code>。</p>
<p>你也可以创建某个文件的 Gzip 压缩版本，比如 style.css.zip。但你一般不会这样做，浏览器也不知道应该如何使用这个文件。</p>
<p>在网页中，Gzip 压缩直接通过服务器完成。因此你要做的是配置服务器。一旦完成配置，Gzip 压缩将会自动进行，你无需再做任何工作。服务器会压缩文件，并通过网络传送文件。浏览器则接受文件，并在使用之前进行解压。我从未听谁提到过压缩和解压的成本，因此在这里我假设这些成本可以忽略不计，并且我们获得的受益远大于成本。</p>
<p>点击<a href="https://css-tricks.com/snippets/htaccess/active-gzip-compression/">这里</a>查看如何在 Apache 服务器中进行配置，这里使用了 <code>mod_deflate</code> 模块。H5BP 也为所有常见的服务器<a href="https://github.com/h5bp/server-configs">提供了服务器配置</a>，包括 Gzipping。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>我们将用到 <a href="https://getbootstrap.com/">Bootstrap</a> 中常见的 CSS 文件。</p>
<img src="/posts/8214/3e99e9b284d401c365c5044bc715ba44c9246f83.jpg" class="" title="3e99e9b284d401c365c5044bc715ba44c9246f83">

<p>通过 Minification 来压缩这个 CSS 文件，你将节省 17% 的空间，而使用 Gzipping 能够节省 85%，将两种方法结合使用节省的空间是 86%。</p>
<p>下面是使用 DevTools 检查工作状况时的理想情况：</p>
<img src="/posts/8214/997aee7f7378ac61ca5b36877a65f44c3ed70bc5.jpg" class="" title="997aee7f7378ac61ca5b36877a65f44c3ed70bc5">

<h1 id="Gzip压缩-要高效得多，而将两种方法结合起来更为理想。"><a href="#Gzip压缩-要高效得多，而将两种方法结合起来更为理想。" class="headerlink" title="Gzip压缩 要高效得多，而将两种方法结合起来更为理想。"></a>Gzip压缩 要高效得多，而将两种方法结合起来更为理想。</h1><p>Gzip 压缩节省的空间大概是 Minification 压缩的五倍。然而，通过 Minification 压缩，你也可以获得一些帮助，不过在构建步骤时你需要耗费一些额外的力气。</p>
<p>同样<a href="http://carlos.bueno.org/2010/02/measuring-javascript-parse-and-load.html#minifi">有证据</a>证明浏览器在读取和解析 Minification 压缩的文件时速度更快：</p>
<blockquote>
<p>正如预期的那样，除了缩短网络传输时间以外，Minification 压缩还有助于解析和加载。这也许是因为缺少注释符和额外的空白符。</p>
</blockquote>
<p>微软也开始为此优化它们的语法分析器：</p>
<blockquote>
<p>因此，在 Window 10 和 Microsoft Edge 中，我们新添加了快速路径，改善了在 Chakra 的 JIT 编译器中嵌入和优化部分探视程序的体验，以保证压缩代码的运行速度不低于原始版本。通过这些改变，通过 UglifyJS 压缩过的个体代码模式的性能提高了 20% 到 50%。</p>
</blockquote>
<p>缓存资源同样与这段对话相关，没有什么比一个不需要请求任何资源的浏览器速度更快了！关于这一点，网上或者<a href="https://www.amazon.com/Designing-Performance-Weighing-Aesthetics-Speed/dp/1491902515/ref=as_li_ss_tl?ie=UTF8&linkCode=sl1&tag=css-tricks-20&linkId=d4d794b5604a084164c8ba33d2540283">书</a>中还有许多相关知识，不过很快我们也许会发布一些有关使用技巧的内容。</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise用法</title>
    <url>/posts/7878/</url>
    <content><![CDATA[<h2 id="Promise是什么"><a href="#Promise是什么" class="headerlink" title="Promise是什么"></a>Promise是什么</h2><p>Promise 是一种异步编程的解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。</p>
<h2 id="诞生的原因"><a href="#诞生的原因" class="headerlink" title="诞生的原因"></a>诞生的原因</h2><p>异步网络请求的<strong>回调地狱</strong>，而且我们还得对每次请求的结果进行一些处理，代码会更加臃肿。一张图完美诠释：</p>
<img src="/posts/7878/call-back-hello.jpg" class="" title="回调地狱">

<p>不够？再加一张：</p>
<img src="/posts/7878/8144ca8cgw1f2wc9ed35zj218g0p0tey.jpg" class="" title="行为艺术">

<a id="more"></a>

<h2 id="Promise的三种状态"><a href="#Promise的三种状态" class="headerlink" title="Promise的三种状态"></a>Promise的三种状态</h2><ul>
<li>pedding 等待（默认状态。异步代码执行完毕后会转换为以下两种状态）</li>
<li>resolve 成功</li>
<li>reject 失败</li>
</ul>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li>Promise:<ul>
<li>构造函数</li>
<li>接受一个参数：callback，我们把要执行的异步任务放置在这个callback中</li>
</ul>
</li>
<li>then:<ul>
<li>Promise对象下的一个方法：该方法在Promise对象的状态发生改变的时候触发then的回调</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//defined Promise async function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolve(<span class="comment">/*resolve parameter*/</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="comment">/*Error*/</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//use Promise&amp;then</span></span><br><span class="line">asyncFun().then(<span class="comment">/*function*/</span>).then(<span class="comment">/*function*/</span>)...</span><br></pre></td></tr></table></figure>

<h2 id="Promise特性"><a href="#Promise特性" class="headerlink" title="Promise特性"></a>Promise特性</h2><h3 id="立即执行"><a href="#立即执行" class="headerlink" title="立即执行"></a>立即执行</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当Promise被实例化的时候，callback的异步任务就会被执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;一个Promise对象被创建出来&quot;</span>);</span><br><span class="line">    resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 一个Promise对象被创建出来</span></span><br><span class="line"><span class="comment">// flag</span></span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure>

<h3 id="状态不可逆"><a href="#状态不可逆" class="headerlink" title="状态不可逆"></a>状态不可逆</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    reject(<span class="string">&quot;reject&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure>

<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过传入的resolve, reject，去改变当前Promise任务的状态</span></span><br><span class="line">    <span class="comment">// resolve, reject 是两个函数，调用 resolve ，会把状态改成 resolved ，调用 reject 函数会把状态改成 rejected</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        reject();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// then接受两个参数：这两个参数都是回调，当对应的 promise 对象的状态变成了resolved，那么 then 的第一个 callback 就会被执行，如果状态变成了 rejected ，那么 then 的第二个 callback 就会被执行</span></span><br><span class="line">p.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 失败</span></span><br></pre></td></tr></table></figure>

<h3 id="then的回调异步性"><a href="#then的回调异步性" class="headerlink" title="then的回调异步性"></a>then的回调异步性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是Promise的callback中的代码&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;我1s后才会被执行&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;我是主线程中的同步代码&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 我是Promise的callback中的代码</span></span><br><span class="line"><span class="comment">// 我是主线程中的同步代码</span></span><br><span class="line"><span class="comment">// 我1s后才会被执行</span></span><br></pre></td></tr></table></figure>

<p>解释：Promise 的 callback 回调函数中的代码是立即执行的（setTimeout 这个定时器也是立即执行的，只是函数内的 resolve 被延迟1s执行，跟 Promise 本身的立即执行没关系），但 then 方法中的回调函数执行则是异步的，因此，<code>&quot;我1s后才会被执行&quot;</code> 会在最后输出。</p>
<h3 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h3><p>Promise的异常有两种方法可以捕获，一种是 then 的第二个回调；一种 <code>.catch()</code> 来捕获前一个 Promise 抛出的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;catch:&quot;</span> + error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// catch:error</span></span><br></pre></td></tr></table></figure>

<h2 id="Promise-all-和-Promise-race"><a href="#Promise-all-和-Promise-race" class="headerlink" title="Promise.all 和 Promise.race"></a>Promise.all 和 Promise.race</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all 接收一个参数，它必须是可以迭代的，例如数组。<br>它通常用来处理一些并发的异步操作，即它们的结果互不干扰，但是又需要异步执行。当所有 Promise 都成功的时候，整个 Promise.all 才成功。成功调用后返回一个数组，数组的值是有序的，顺序就是传入参数的数组顺序：</p>
<blockquote>
<p>成功的情况</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> tasks = arr.map(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(num * <span class="number">5</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 有序输出</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// [5, 10, 15]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>失败的情况</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> tasks = arr.map(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num === <span class="number">3</span>) &#123;</span><br><span class="line">            reject(<span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(num * <span class="number">5</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里不会执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// rejected</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race 和 Promise.all 类似，都接收一个可以迭代的参数，但是不同之处是 Promise.race 的状态变化不是全部受参数内的状态影响，一旦参数内有一个值的状态发生的改变，那么该 Promise 的状态就是改变的状态。就跟 race 单词的字面意思一样，谁跑的快谁赢。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">300</span>, <span class="string">&#x27;p1 doned&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">50</span>, <span class="string">&#x27;p2 doned&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(reject, <span class="number">100</span>, <span class="string">&#x27;p3 rejected&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2, p3]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 显然p2更快，所以状态变成了fulfilled</span></span><br><span class="line">    <span class="comment">// 如果p3更快，那么状态就会变成rejected</span></span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// p2 doned</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 不执行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Sequelize框架进阶</title>
    <url>/posts/3278/</url>
    <content><![CDATA[<h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><ul>
<li><a href="https://evestorm.github.io/posts/1183/">Sequelize框架入门</a></li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇入门讲到了 <code>Sequelize框架</code> 的基本用法，比如实现简单的增删查改。原本打算一篇文章写到底的，但感觉内容太多，对读者不太友好，就另开了这篇文章。</p>
<p>虽然标题写着“进阶”，但其实有标题党的以为。这篇文章仍然着手于框架的使用，不涉及源码。大纲见侧边栏的目录，我们直接开始吧~</p>
<a id="more"></a>

<h2 id="连表查询"><a href="#连表查询" class="headerlink" title="连表查询"></a>连表查询</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>既然是连表查询，至少得有两个表吧。所以我们还需要另外新建一张表，这里起名为 <code>message</code> 表，表结构如下：</p>
<img src="/posts/3278/message-table.png" class="" title="message-table">

<p>其中 uid 对应用户的 id 。下面是两表的数据：</p>
<img src="/posts/3278/user-message-data.png" class="" title="user-message-data">

<p>接着我们新建一个 <code>app2.js</code> 文件，引入之前 <code>app.js</code> 中的部分代码（连接数据库+UserModel）以及创建一个 <code>MessageModel</code> 模型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Sequelize = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(<span class="string">&quot;miaov&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>, &#123;</span><br><span class="line">    host: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    port: <span class="number">8889</span>,</span><br><span class="line">    dialect: <span class="string">&quot;mysql&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sequelize.authenticate();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据库连接成功!&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;连接失败&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UserModel = sequelize.define(<span class="string">&#x27;User&#x27;</span>, &#123;</span><br><span class="line">    id: &#123;</span><br><span class="line">        type: Sequelize.INTEGER(<span class="number">11</span>),</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">        autoIncrement: <span class="literal">true</span>,</span><br><span class="line">        primaryKey: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    username: &#123;</span><br><span class="line">        type: Sequelize.STRING(<span class="number">50</span>),</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">        defaultValue: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        type: Sequelize.TINYINT(<span class="number">3</span>),</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    gender: &#123;</span><br><span class="line">        type: Sequelize.ENUM([<span class="string">&#x27;men&#x27;</span>, <span class="string">&#x27;women&#x27;</span>, <span class="string">&#x27;other&#x27;</span>]),</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">        defaultValue: <span class="string">&#x27;men&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    timestamps: <span class="literal">false</span>,</span><br><span class="line">    tableName: <span class="string">&#x27;users&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MessageModel = sequelize.define(<span class="string">&#x27;Message&#x27;</span>, &#123;</span><br><span class="line">    id: &#123;</span><br><span class="line">        type: Sequelize.INTEGER(<span class="number">11</span>),</span><br><span class="line">        primaryKey: <span class="literal">true</span>,</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">        autoIncrement: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    uid: &#123;</span><br><span class="line">        type: Sequelize.INTEGER(<span class="number">11</span>),</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">        defaultValue: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    content: &#123;</span><br><span class="line">        type: Sequelize.STRING(<span class="number">255</span>),</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">        defaultValue: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    timestamps: <span class="literal">false</span>,</span><br><span class="line">    freezeTableName: <span class="literal">true</span>, <span class="comment">// 默认 false 将自动修改表名为复数，true 表示不修改表名，与数据库表名同步</span></span><br><span class="line">    tableName: <span class="string">&#x27;message&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="需求-普通做法"><a href="#需求-普通做法" class="headerlink" title="需求+普通做法"></a>需求+普通做法</h3><p>我们这次的需求是获取某条留言的所有数据，其中包含 <code>留言本身的数据</code> + <code>该留言的用户数据</code> ，先来看最“耿直”的做法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> data = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 根据 id 查找 message</span></span><br><span class="line">    <span class="keyword">let</span> message = <span class="keyword">await</span> MessageModel.findByPk(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 根据 message 的 uid 反查出发布这条 message 的 user</span></span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> UserModel.findByPk(message.get(<span class="string">&#x27;uid&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.assign(data, &#123;</span><br><span class="line">        id: message.id,</span><br><span class="line">        uid: message.uid,</span><br><span class="line">        content: message.content,</span><br><span class="line">        username: user.username,</span><br><span class="line">        age: user.age,</span><br><span class="line">        gender: user.gender,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="BelongsTo"><a href="#BelongsTo" class="headerlink" title="BelongsTo"></a>BelongsTo</h3><p>除了上面这种做法外，我们还可以使用 <code>sequelize</code> 提供的 <code>BelongsTo</code> 来关联两个模型进行查询。</p>
<p>思考一下我们的 <code>users</code> 和 <code>message</code> 表，从 <code>message</code> 的角度来讲，一条留言属于一个用户发布的，是一对一的关系。而 <code>BelongsTo</code> 关联的含义就是 A 属于 B。那我们应该怎么写代码呢？步骤如下：</p>
<ol>
<li><p>首先在模型中给关联的字段定义外键关系</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">references: &#123;</span><br><span class="line">   model: 关联的外键表模型, e.g. UserModel</span><br><span class="line">   key: 关联的外键表的字段, e.g. id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在调用 <code>belongsTo</code> 或 <code>hasMany</code> 等方法的时候，通过第二个参数设置对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">   foreignKey: 当前关联表的字段, e.g. uid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>没有完全理解上面的步骤也没关系，直接上代码更加清晰：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MessageModel = sequelize.define(<span class="string">&#x27;Message&#x27;</span>, &#123;</span><br><span class="line">    ...,</span><br><span class="line">    uid: &#123; <span class="comment">// 第一步：在模型中给关联的字段定义外键关系</span></span><br><span class="line">        ...</span><br><span class="line">        references: &#123;</span><br><span class="line">            model: UserModel, <span class="comment">// 关联的外键表模型</span></span><br><span class="line">            key: <span class="string">&#x27;id&#x27;</span>,        <span class="comment">// 关联的外键表的字段</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;, ...);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 第二步：声明两表关系及外键</span></span><br><span class="line">    <span class="comment">// 下面方法翻译过来：留言属于用户</span></span><br><span class="line">    MessageModel.belongsTo(UserModel, &#123;</span><br><span class="line">        foreignKey: <span class="string">&#x27;uid&#x27;</span> <span class="comment">// 声明自己（message）的外键是 uid</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> MessageModel.findByPk(<span class="number">1</span>, &#123;</span><br><span class="line">        include: [UserModel] <span class="comment">// 表述查出的 message 记录中包含有对应的 user</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`</span></span><br><span class="line"><span class="string">        留言id：<span class="subst">$&#123;data.id&#125;</span></span></span><br><span class="line"><span class="string">        留言人名称：<span class="subst">$&#123;data.User.username&#125;</span></span></span><br><span class="line"><span class="string">        留言内容：<span class="subst">$&#123;data.content&#125;</span></span></span><br><span class="line"><span class="string">    `</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<h3 id="HasMany"><a href="#HasMany" class="headerlink" title="HasMany"></a>HasMany</h3><p>这次我们换个角度，来通过某个用户查找他/她所有的留言。稍微想一下，一个用户是可以发布多条留言的，所以从 <code>users</code> 角度来讲，跟 <code>message</code> 是一对多的关系。而 <code>sequelize</code> 也提供了处理这种关系的方法，那就是 <code>HasMany</code>。直接上代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// users 拥有</span></span><br><span class="line">    UserModel.hasMany(MessageModel, &#123;</span><br><span class="line">        foreignKey: <span class="string">&#x27;uid&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> UserModel.findByPk(<span class="number">3</span>, &#123;</span><br><span class="line">        include: [MessageModel]</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`</span></span><br><span class="line"><span class="string">        id为 <span class="subst">$&#123;data.id&#125;</span> 的留言人 <span class="subst">$&#123;data.username&#125;</span> 的留言内容：</span></span><br><span class="line"><span class="string">    `</span>);</span><br><span class="line">    data.Messages.forEach(<span class="function"><span class="params">m</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;m.content&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>安装的 sequelize 和 mysql2 的版本为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;mysql2&quot;</span>: <span class="string">&quot;^1.6.5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sequelize&quot;</span>: <span class="string">&quot;^5.3.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Sequelize</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex的基本使用</title>
    <url>/posts/36068/</url>
    <content><![CDATA[<h2 id="什么是-Vuex"><a href="#什么是-Vuex" class="headerlink" title="什么是 Vuex"></a>什么是 Vuex</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理工具。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先使用 vue-cli 脚手架工具新建一个项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue create vuex-demo</span><br></pre></td></tr></table></figure>

<p>src文件夹下的目录结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">├── App.vue</span><br><span class="line">├── assets</span><br><span class="line">│   └── logo.png</span><br><span class="line">├── components</span><br><span class="line">│   └── HelloWorld.vue</span><br><span class="line">└── main.js # 入口文件</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="安装-vuex"><a href="#安装-vuex" class="headerlink" title="安装 vuex"></a>安装 vuex</h2><p>命令行下执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i vuex</span><br></pre></td></tr></table></figure>

<p>然后在入口文件引入 vuex ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>

<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>为了了解 vuex 到底做了什么事情、解决了哪些问题。我们先来实现一个简单的 demo ，有一个标签显示数字，两个按钮分别做数字的 +1 和 -1 操作。</p>
<p>我们先在 <code>src/components/</code> 下的 Normal.vue 组件中使用纯 Vue 版本编写代码：</p>
<blockquote>
<p>Normal.vue</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;normal&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;count&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;inc&quot;</span>&gt;</span> + <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;dec&quot;</span>&gt;</span> - <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">inc</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.count++</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">dec</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.count--</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在 <code>src/App.vue</code> 中引入并使用该组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Normal</span>&gt;</span><span class="tag">&lt;/<span class="name">Normal</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Normal <span class="keyword">from</span> <span class="string">&#x27;@/components/Normal&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    Normal,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>命令行执行 <code>npm run serve</code> 就能运行 App 了。</p>
<p>如上的代码的含义是：两个 button 标签绑定函数，当点击的时候分别调用 inc 和 dec 方法，接着会调用 vue 中的 methods 的对应的方法<br>。然后会让 data 中的 count 属性值发生改变，改变后会把最新值渲染到视图中。</p>
<p>现在我们来看看使用 vuex 的方式来实现如上 demo ：</p>
<blockquote>
<p>src下新建 <code>vuex/store.js</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意是new【Vuex.Store】实例而不是【Vuex】</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        inc: <span class="function"><span class="params">state</span> =&gt;</span> state.count++,</span><br><span class="line">        dec: <span class="function"><span class="params">state</span> =&gt;</span> state.count--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>main.js 中引入</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/vuex/store&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  store</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>src/components/</code> 下新建 SWVuex.vue 组件</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;vuex&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;count&#125;&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;inc&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;dec&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        computed: &#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">count</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.count</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">inc</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;inc&#x27;</span>)</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">dec</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;dec&#x27;</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 App.vue 中使用 SWVuex 组件</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">SWVuex</span>&gt;</span><span class="tag">&lt;/<span class="name">SWVuex</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> SWVuex <span class="keyword">from</span> <span class="string">&#x27;@/components/SWVuex&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    SWVuex</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h3><ol>
<li>需要引用 vuex 。</li>
<li>methods 的方法不变，但是方法内的逻辑不在函数内进行，而是让 store 对象去处理。</li>
<li>count 数据不再是一个 data 函数返回的对象的属性了。而是通过 store 方法内的计算字段返回的。</li>
</ol>
<p>回到 store 对象上来，store 对象是 Vuex.Store 的实例。在 store 内分为 state 对象和 mutations 对象，其中 state 存放的是状态，<br>比如 count 属性就是它的状态值，而 mutations 则是一个会引发状态改变的所有方法。</p>
<h2 id="什么是状态管理模式"><a href="#什么是状态管理模式" class="headerlink" title="什么是状态管理模式"></a>什么是状态管理模式</h2><p>简单的理解就是<strong>统一管理和维护各个 vue 组件的可变化状态</strong>。</p>
<p>我们明白 vue 是单向数据流的，那么它的状态管理一般包含如下几部分：</p>
<ol>
<li>state：驱动应用的数据（一般指 data 中返回的数据）</li>
<li>view：一般指模板，以声明的方式将 state 的数据映射到视图</li>
<li>actions：响应在 view 上的用户输入导致的状态变化</li>
</ol>
<p>但是当我们的应用遇到多个组件共享状态时候，那么单向数据流可能不太满足我们的需求，比如：</p>
<ol>
<li>组件的多层嵌套</li>
<li>多个视图依赖同一个状态</li>
</ol>
<p>上面这些情况确实能在不使用 vuex 的情况下实现，但往往会导致写出无法维护的代码。因此我们可以把组件的共享状态<strong>提取出来、全局管理</strong>，因此 vuex 产生了。</p>
<h2 id="Vuex-的优点"><a href="#Vuex-的优点" class="headerlink" title="Vuex 的优点"></a>Vuex 的优点</h2><p>最主要解决了组件之间共享同一状态的问题。可以把组件的共享状态提取出来，作为全局来管理。</p>
<h2 id="什么情况下才推荐使用-Vuex"><a href="#什么情况下才推荐使用-Vuex" class="headerlink" title="什么情况下才推荐使用 Vuex"></a>什么情况下才推荐使用 Vuex</h2><p>大型单页应用！！！如果你的项目不够大，足够简单，最好不要使用 Vuex ，一个简单的 global event bus 就足够所需了。</p>
<h2 id="State-对象状态的访问"><a href="#State-对象状态的访问" class="headerlink" title="State 对象状态的访问"></a>State 对象状态的访问</h2><h3 id="通过-computed-计算属性直接赋值"><a href="#通过-computed-计算属性直接赋值" class="headerlink" title="通过 computed 计算属性直接赋值"></a>通过 computed 计算属性直接赋值</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;vuex&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>通过 $store.state 方式获取：&#123;&#123;$store.state.count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>通过 computed 计算属性赋值：&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;inc&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;dec&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        computed: &#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">count</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.count</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">inc</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;inc&#x27;</span>)</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">dec</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;dec&#x27;</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="借助-mapState-辅助函数"><a href="#借助-mapState-辅助函数" class="headerlink" title="借助 mapState 辅助函数"></a>借助 mapState 辅助函数</h3><h4 id="对象形式"><a href="#对象形式" class="headerlink" title="对象形式"></a>对象形式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;vuex&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>通过 $store.state 方式获取：&#123;&#123;$store.state.count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>通过 computed 计算属性赋值：&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;inc&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;dec&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        computed: mapState(&#123;</span><br><span class="line"><span class="javascript">            count: <span class="function"><span class="params">state</span> =&gt;</span> state.count</span></span><br><span class="line">        &#125;),</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">inc</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;inc&#x27;</span>)</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">dec</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;dec&#x27;</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="数组形式"><a href="#数组形式" class="headerlink" title="数组形式"></a>数组形式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组中的 count 必须和 store.js 中定义的常量 count 同名，因为这是直接访问 state 的 count</span></span><br><span class="line">computed: mapState([<span class="string">&#x27;count&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h2 id="Getters-计算过滤操作"><a href="#Getters-计算过滤操作" class="headerlink" title="Getters 计算过滤操作"></a>Getters 计算过滤操作</h2><p>有时候我们需要从 store 的 state 中派生出一些状态，比如在使用 store 中的 state 之前，我们会对 state 中的某些字段进行过滤——让 count 字段都进行加 10 这样的数据操作；但是如果有多个组件需要用到这个操作的话，那么我们就需要复制这个函数，或者抽取到一个共享函数内，<br>然后多处导入这个函数，但是这上面两种方式都不是太好，因为我们现在有更好的方式来解决它。</p>
<p>Vuex 允许我们在 store 中定义 getters，getters 的返回值会根据它的依赖被缓存起来，且只有当他的依赖值发生改变了才会重新计算。</p>
<p>现在我们对 store.js 文件中的 count 进行一个计算属性的操作，在它每次输出之前，加上20。</p>
<p>如下代码有两个按钮，一个加5，一个减5，那么在加5或者减5之前，先加20，然后再进行加5或者5操作。代码如下：</p>
<blockquote>
<p>store.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        inc: <span class="function">(<span class="params">state, num</span>) =&gt;</span> state.count += num,</span><br><span class="line">        dec: <span class="function">(<span class="params">state, num</span>) =&gt;</span> state.count -= num</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        <span class="function"><span class="title">myCount</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> state.count + <span class="number">20</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SWVuex.vue</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;vuex&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>通过 $store.state 方式获取：&#123;&#123;$store.state.count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>通过 computed 计算属性赋值：&#123;&#123;myCount&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用 $store.commit(&#x27;inc&#x27;, 5) 方式调用<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- $store.commit(&#x27;inc&#x27;, 5) 第一个参数是方法名，第二个是参数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.commit(&#x27;inc&#x27;, 5)&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.commit(&#x27;dec&#x27;, 5)&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用mapMutations修改状态：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;inc(10)&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;dec(10)&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123;mapState, mapGetters, mapMutations&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        computed: &#123;</span><br><span class="line"><span class="javascript">            <span class="comment">// mapState([&#x27;count&#x27;]) 此处的 count 必须和 store.js</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// state 中的 count 同名，因为这是直接访问 state 的 count</span></span></span><br><span class="line"><span class="javascript">            ...mapState([<span class="string">&#x27;count&#x27;</span>]),</span></span><br><span class="line"><span class="javascript">            <span class="comment">// mapGetters 辅助函数，</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 可以将 store 中的 getter 映射到局部计算属性 myCount</span></span></span><br><span class="line"><span class="javascript">            ...mapGetters([<span class="string">&#x27;myCount&#x27;</span>])</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            ...mapMutations([<span class="string">&#x27;inc&#x27;</span>, <span class="string">&#x27;dec&#x27;</span>])</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Mutations-修改状态"><a href="#Mutations-修改状态" class="headerlink" title="Mutations 修改状态"></a>Mutations 修改状态</h2><p>Mutations 是修改 vuex 中的 store 的唯一方法。每个 mutations 都有一个字符串的事件类型(type)和一个回调函数(handler)。这个回调函数就是我们进行更改的地方。它也会接受 state 作为第一个参数。</p>
<p>回顾上面的 <code>store.js</code> 中有关 mutations 的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">    inc: <span class="function">(<span class="params">state, num</span>) =&gt;</span> state.count += num,</span><br><span class="line">    dec: <span class="function">(<span class="params">state, num</span>) =&gt;</span> state.count -= num</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>当我们点击页面上的按钮后会触发事件并执行方法，方法中又会调用 <code>$store.commit(type, args)</code> 来传入参数改变 state 数据。</p>
<h2 id="Actions-异步修改状态"><a href="#Actions-异步修改状态" class="headerlink" title="Actions 异步修改状态"></a>Actions 异步修改状态</h2><p>Actions 和 Mutations 类似，但它用来异步修改 state 的状态。而 Mutations 则是同步修改 state 的状态。</p>
<p>我们在 store.js 中声明 actions，actions 可以调用 mutations 的方法的。代码如下：</p>
<blockquote>
<p>store.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加两个 actions 方法</span></span><br><span class="line">actions: &#123;</span><br><span class="line">    <span class="function"><span class="title">incAction</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(context)</span><br><span class="line">        <span class="comment">// 调用 mutations 中的 inc 方法，并传参数5</span></span><br><span class="line">        context.commit(<span class="string">&#x27;inc&#x27;</span>, <span class="number">5</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decAction</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;dec&#x27;</span>, <span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上方代码中的参数 context 指上下文，即 store 本身。</p>
<p>然后在 SWVuex.vue 中通过 <code>this.$store.dispatch(action方法名, 参数)</code> 的方式调用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;vuex&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>通过 $store.state 方式获取：&#123;&#123;$store.state.count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>通过 computed 计算属性赋值：&#123;&#123;myCount&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用 $store.commit(&#x27;inc&#x27;, 5) 方式调用<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- $store.commit(&#x27;inc&#x27;, 5) 第一个参数是方法名，第二个是参数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.commit(&#x27;inc&#x27;, 5)&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.commit(&#x27;dec&#x27;, 5)&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用mapMutations修改状态：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;inc(10)&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;dec(10)&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>actions的异步操作<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;incAction&quot;</span>&gt;</span> + <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decAction&quot;</span>&gt;</span> - <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123;mapState, mapGetters, mapMutations&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        computed: &#123;</span><br><span class="line"><span class="javascript">            <span class="comment">// mapState([&#x27;count&#x27;]) 此处的 count 必须和 store.js</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// state 中的 count 同名，因为这是直接访问 state 的 count</span></span></span><br><span class="line"><span class="javascript">            ...mapState([<span class="string">&#x27;count&#x27;</span>]),</span></span><br><span class="line"><span class="javascript">            <span class="comment">// mapGetters 辅助函数，</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 可以将 store 中的 getter 映射到局部计算属性 myCount</span></span></span><br><span class="line"><span class="javascript">            ...mapGetters([<span class="string">&#x27;myCount&#x27;</span>])</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            ...mapMutations([<span class="string">&#x27;inc&#x27;</span>, <span class="string">&#x27;dec&#x27;</span>]),</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">incAction</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;incAction&#x27;</span>)</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">decAction</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;decAction&#x27;</span>)</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，除了使用 <code>this.$store.dispatch()</code> 的方式以外，还可以借助 <code>mapActions</code> 来简化代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新加 mapActions</span></span><br><span class="line"><span class="keyword">import</span> &#123;mapState, mapGetters, mapMutations, mapActions&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">...</span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapMutations([<span class="string">&#x27;inc&#x27;</span>, <span class="string">&#x27;dec&#x27;</span>]),</span><br><span class="line">    ...mapActions([<span class="string">&#x27;incAction&#x27;</span>, <span class="string">&#x27;decAction&#x27;</span>]) <span class="comment">// +</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode+Vue项目Ctrl加V自动格式化代码</title>
    <url>/posts/22469/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>期望多人开发 Vue 项目时，大家的代码风格保持一致。并且在 VSCode 中，Ctrl+V 保存代码时自动按照 eslint 规范格式化代码。</p>
<h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">ESLint</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=octref.vetur">Vetur</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">Prettier - Code formatter</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense">Path Intellisense</a></li>
</ul>
<a id="more"></a>

<h2 id="配置-VSCode-用户-Settings-json"><a href="#配置-VSCode-用户-Settings-json" class="headerlink" title="配置 VSCode 用户 Settings.json"></a>配置 VSCode 用户 Settings.json</h2><h3 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h3><ol>
<li>文件——&gt;首选项——&gt;设置</li>
<li>Ctrl+P 搜索 settings.json</li>
</ol>
<h3 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h3><blockquote>
<p>有注释的才需要添加，其他没注释的可以不用管</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;editor.fontSize&quot;</span>: <span class="number">14</span>,</span><br><span class="line">  <span class="attr">&quot;bracket-pair-colorizer-2.showBracketsInGutter&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;workbench.iconTheme&quot;</span>: <span class="string">&quot;material-icon-theme&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;sync.gist&quot;</span>: <span class="string">&quot;e9262ee54aa0988ee98c24e6be1dada1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;workbench.colorTheme&quot;</span>: <span class="string">&quot;Atom One Dark&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;editor.fontFamily&quot;</span>: <span class="string">&quot;&#x27;Fira Code&#x27;, Menlo, Monaco, &#x27;Courier New&#x27;, monospace&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增配置</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;editor.formatOnSave&quot;</span>: <span class="literal">true</span>, <span class="comment">// #每次保存的时候自动格式化</span></span><br><span class="line">  <span class="attr">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;source.fixAll.eslint&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;, <span class="comment">// 每次保存的时候将代码按eslint格式进行修复</span></span><br><span class="line">  <span class="attr">&quot;editor.tabSize&quot;</span>: <span class="number">2</span>, <span class="comment">// 重新设定tabSize</span></span><br><span class="line">  <span class="attr">&quot;prettier.semi&quot;</span>: <span class="literal">true</span>, <span class="comment">// 添加代码结尾的分号</span></span><br><span class="line">  <span class="attr">&quot;prettier.singleQuote&quot;</span>: <span class="literal">true</span>, <span class="comment">// 使用单引号替代双引号</span></span><br><span class="line">  <span class="attr">&quot;prettier.arrowParens&quot;</span>: <span class="string">&quot;avoid&quot;</span>, <span class="comment">// 箭头函数参数只有一个时是否要有小括号。</span></span><br><span class="line">  <span class="comment">// avoid - 省略括号</span></span><br><span class="line">  <span class="comment">// always - 总是不省略</span></span><br><span class="line">  <span class="attr">&quot;prettier.htmlWhitespaceSensitivity&quot;</span>: <span class="string">&quot;ignore&quot;</span>, <span class="comment">// 指定 HTML 文件的全局空白区域敏感度</span></span><br><span class="line">  <span class="comment">// &quot;css&quot;- 遵守 CSS display属性的默认值。</span></span><br><span class="line">  <span class="comment">// &quot;strict&quot; - 空格被认为是敏感的。</span></span><br><span class="line">  <span class="comment">// &quot;ignore&quot; - 空格被认为是不敏感的。</span></span><br><span class="line">  <span class="comment">// html 中空格也会占位，影响布局，prettier 格式化的时候可能会将文本换行，造成布局错乱</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// --------------- html -----------------</span></span><br><span class="line">  <span class="comment">//  &lt;a href=&quot;https://prettier.io/&quot;&gt;Prettier is an opinionated code formatter.&lt;/a&gt;</span></span><br><span class="line">  <span class="comment">//  &lt;!-- 变成 --&gt;</span></span><br><span class="line">  <span class="comment">//  &lt;!-- &quot;Prettier is an opinionated code formatter. &quot; 另起一行，在页面的布局上就会多一个节点文本出来 --&gt;</span></span><br><span class="line">  <span class="comment">//  &lt;a href=&quot;https://prettier.io/&quot;&gt;</span></span><br><span class="line">  <span class="comment">//    Prettier is an opinionated code formatter.</span></span><br><span class="line">  <span class="comment">//  &lt;/a&gt;</span></span><br><span class="line">  <span class="comment">// --------------- html -----------------</span></span><br><span class="line">  <span class="attr">&quot;prettier.jsxBracketSameLine&quot;</span>: <span class="literal">true</span>, <span class="comment">// 将 &gt; 多行 JSX 元素放在最后一行的末尾，而不是单独放在下一行（不适用于自闭元素）。</span></span><br><span class="line">  <span class="comment">// true - 放最后一行末尾</span></span><br><span class="line">  <span class="comment">// false - 单独放在末尾的下一行</span></span><br><span class="line">  <span class="attr">&quot;prettier.bracketSpacing&quot;</span>: <span class="literal">true</span>, <span class="comment">// 在对象，数组括号与文字之间加空格 &quot;&#123; foo: bar &#125;&quot;</span></span><br><span class="line">  <span class="attr">&quot;prettier.trailingComma&quot;</span>: <span class="string">&quot;none&quot;</span>, <span class="comment">// 在对象或数组最后一个元素后面是否加逗号（在ES5中加尾逗号）</span></span><br><span class="line">  <span class="attr">&quot;javascript.preferences.quoteStyle&quot;</span>: <span class="string">&quot;single&quot;</span>, <span class="comment">// JS格式化设置单引号</span></span><br><span class="line">  <span class="attr">&quot;typescript.preferences.quoteStyle&quot;</span>: <span class="string">&quot;single&quot;</span>, <span class="comment">// TS格式化设置单引号</span></span><br><span class="line">  <span class="attr">&quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;</span>: <span class="literal">false</span>, <span class="comment">// 让函数(名)和后面的括号之间加个空格</span></span><br><span class="line">  <span class="comment">// 配置 ESLint 检查的文件类型</span></span><br><span class="line">  <span class="attr">&quot;eslint.validate&quot;</span>: [<span class="string">&quot;javascript&quot;</span>, <span class="string">&quot;vue&quot;</span>, <span class="string">&quot;html&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;eslint.options&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 指定vscode的eslint所处理的文件的后缀</span></span><br><span class="line">    <span class="attr">&quot;extensions&quot;</span>: [<span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.vue&quot;</span>, <span class="string">&quot;.ts&quot;</span>, <span class="string">&quot;.tsx&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//一定要在vutur.defaultFormatterOptions参数中设置，单独修改prettier扩展的设置是无法解决这个问题的，因为perttier默认忽略了vue文件（事实上从忽略列表移除vue也不能解决这个问题）</span></span><br><span class="line">  <span class="attr">&quot;vetur.format.defaultFormatterOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;prettier&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;semi&quot;</span>: <span class="literal">true</span>, <span class="comment">// 格式化末尾加分号</span></span><br><span class="line">      <span class="attr">&quot;singleQuote&quot;</span>: <span class="literal">true</span>, <span class="comment">// 格式化以单引号为主</span></span><br><span class="line">      <span class="attr">&quot;trailingComma&quot;</span>: <span class="string">&quot;none&quot;</span> <span class="comment">// 是否末尾自动添加逗号（数组，json，对象）</span></span><br><span class="line">      <span class="comment">// &quot;es5&quot; - 在ES5中的对象、数组等最后一个元素后面加逗号</span></span><br><span class="line">      <span class="comment">// &quot;none&quot; - 不加逗号</span></span><br><span class="line">      <span class="comment">// &quot;all&quot; - 尽可能都加逗号 (包括函数function的参数).</span></span><br><span class="line">    &#125;, <span class="comment">// 配置文档：https://prettier.io/docs/en/options.html</span></span><br><span class="line">    <span class="attr">&quot;js-beautify-html&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">// force-aligned | force-expand-multiline vue html代码格式化</span></span><br><span class="line">      <span class="attr">&quot;wrap_attributes&quot;</span>: <span class="string">&quot;force-aligned&quot;</span>, <span class="comment">// 对除第一个属性外的其他每个属性进行换行，并保持对齐</span></span><br><span class="line">      <span class="comment">// - auto: 仅在超出行长度时才对属性进行换行。</span></span><br><span class="line">      <span class="comment">// - force: 对除第一个属性外的其他每个属性进行换行。</span></span><br><span class="line">      <span class="comment">// - force-aligned: 对除第一个属性外的其他每个属性进行换行，并保持对齐。</span></span><br><span class="line">      <span class="comment">// - force-expand-multiline: 对每个属性进行换行。</span></span><br><span class="line">      <span class="comment">// - aligned-multiple: 当超出折行长度时，将属性进行垂直对齐。</span></span><br><span class="line">      <span class="attr">&quot;wrap_line_length&quot;</span>: <span class="number">200</span>, <span class="comment">// 换行长度</span></span><br><span class="line">      <span class="attr">&quot;wrap_width_line&quot;</span>: <span class="literal">false</span>, <span class="comment">// 根据行宽换行</span></span><br><span class="line">      <span class="attr">&quot;semi&quot;</span>: <span class="literal">false</span>, <span class="comment">// 格式化不加分号</span></span><br><span class="line">      <span class="attr">&quot;singleQuote&quot;</span>: <span class="literal">true</span> <span class="comment">// 格式化使用单引号</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;prettyhtml&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;printWidth&quot;</span>: <span class="number">200</span>, <span class="comment">// 每行最多多少字符换行</span></span><br><span class="line">      <span class="attr">&quot;singleQuote&quot;</span>: <span class="literal">false</span>, <span class="comment">// 格式化使用单引号</span></span><br><span class="line">      <span class="attr">&quot;wrapAttributes&quot;</span>: <span class="literal">false</span>, <span class="comment">// 强制属性换行</span></span><br><span class="line">      <span class="attr">&quot;sortAttributes&quot;</span>: <span class="literal">true</span> <span class="comment">// 按字母顺序排序属性</span></span><br><span class="line">    &#125; <span class="comment">// 配置文档：https://github.com/Prettyhtml/prettyhtml</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;vetur.format.defaultFormatter.html&quot;</span>: <span class="string">&quot;js-beautify-html&quot;</span>, <span class="comment">// 使用 js-beautify-html 格式化 html</span></span><br><span class="line">  <span class="attr">&quot;vetur.format.defaultFormatter.js&quot;</span>: <span class="string">&quot;prettier&quot;</span>, <span class="comment">// 使用 prettier 格式化 js</span></span><br><span class="line">  <span class="attr">&quot;[vue]&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;octref.vetur&quot;</span> <span class="comment">// 使用 vetur 格式化 vue</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;editor.fontFamily&quot;</span>: <span class="string">&quot;&#x27;Fira Code&#x27;, Menlo, Monaco, &#x27;Courier New&#x27;, monospace&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;path-intellisense.mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;/src&quot;</span></span><br><span class="line">  &#125; <span class="comment">// Vue路径提示配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置-eslintrc-js"><a href="#配置-eslintrc-js" class="headerlink" title="配置 .eslintrc.js"></a>配置 .eslintrc.js</h2><p>Vue 项目的根目录下创建 .eslintrc.js ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  root: <span class="literal">true</span>,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    parser: <span class="string">&#x27;babel-eslint&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">    node: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">extends</span>: [<span class="string">&#x27;plugin:vue/essential&#x27;</span>, <span class="string">&#x27;eslint:recommended&#x27;</span>, <span class="string">&#x27;airbnb-base/legacy&#x27;</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="comment">// 文档：https://cn.eslint.org/docs/rules/</span></span><br><span class="line">    <span class="string">&#x27;generator-star-spacing&#x27;</span>: <span class="string">&#x27;off&#x27;</span>, <span class="comment">// 强制 generator 函数中 * 号周围使用一致的空格</span></span><br><span class="line">    <span class="comment">// 开发模式允许使用console</span></span><br><span class="line">    <span class="string">&#x27;no-console&#x27;</span>: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;error&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="comment">// 开发环境允许使用调试 (生产模式禁用)</span></span><br><span class="line">    <span class="string">&#x27;no-debugger&#x27;</span>: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;error&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="comment">// 禁止使用 var</span></span><br><span class="line">    <span class="string">&#x27;no-var&#x27;</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;padded-blocks&#x27;</span>: <span class="string">&#x27;off&#x27;</span>, <span class="comment">// 代码块中避免多余留白</span></span><br><span class="line">    <span class="string">&#x27;comma-dangle&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;never&#x27;</span>], <span class="comment">// 是否允许对象中出现结尾逗号</span></span><br><span class="line">    <span class="string">&#x27;no-undef&#x27;</span>: <span class="number">0</span>, <span class="comment">// 禁用未声明的变量，除非它们在 /*global */ 注释中被提到</span></span><br><span class="line">    quotes: <span class="number">0</span>, <span class="comment">// 强制使用一致的反勾号、双引号或单引号 (0: double, 1: single, 2: backtick)</span></span><br><span class="line">    eqeqeq: <span class="string">&#x27;off&#x27;</span>, <span class="comment">//  关闭 (要求使用 === 和 !==) 的校验</span></span><br><span class="line">    <span class="string">&#x27;eol-last&#x27;</span>: <span class="string">&#x27;off&#x27;</span>, <span class="comment">// 要求或禁止文件末尾存在空行</span></span><br><span class="line">    indent: <span class="number">0</span>, <span class="comment">// 忽略强制使用一致的缩进</span></span><br><span class="line">    <span class="string">&#x27;no-tabs&#x27;</span>: <span class="number">0</span>, <span class="comment">// 忽略tab检查</span></span><br><span class="line">    <span class="string">&#x27;no-mixed-spaces-and-tabs&#x27;</span>: <span class="number">0</span> <span class="comment">// 忽略检查当空格用于对齐时，允许混合制表符和空格。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>npm 安装 <code>eslint-config-airbnb-base</code> ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm info &quot;eslint-config-airbnb-base@latest&quot; peerDependencies</span><br></pre></td></tr></table></figure>

<p>在 <code>.eslintrc.js</code> 中添加（上面配置已添加）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;extends&quot;</span>: <span class="string">&quot;airbnb-base/legacy&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的生命周期函数</title>
    <url>/posts/33186/</url>
    <content><![CDATA[<h2 id="创建期间的生命周期函数"><a href="#创建期间的生命周期函数" class="headerlink" title="创建期间的生命周期函数"></a>创建期间的生命周期函数</h2><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><p>实例刚在内存中被创建出来，此时还没有初始化好 data 和 methods 属性。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>执行 loading 动画。</p>
<h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><p>实例已经在内存中创建完毕，data 和 methods 等属性也已经创建完成。但此刻<strong>还没有开始编译模板</strong>。</p>
<a id="more"></a>

<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul>
<li>结束掉 loading 动画</li>
<li>做一些初始化工作，比如函数自执行，发起异步请求获取数据</li>
</ul>
<h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><p>此刻<strong>已经完成了模板的编译</strong>，但<strong>还没有挂载到页面上</strong>。换句话说，此时页面中类似 的语法还没有被替换成真正的数据。</p>
<h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>此刻已经将编译好的模板挂载到了页面中指定的容器中显示。用户已经可以看到渲染好的页面了。</p>
<h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><ul>
<li>由于此刻已经把模板挂载到了页面，所以能够在此钩子函数中获取 DOM 节点。</li>
<li>此函数中也能发起异步请求</li>
</ul>
<h2 id="运行期间的生命周期函数"><a href="#运行期间的生命周期函数" class="headerlink" title="运行期间的生命周期函数"></a>运行期间的生命周期函数</h2><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><p>状态更新之前执行此函数，此刻 data 中的状态值是最新的，但是<strong>界面上显示的数据还是旧的</strong>。因此此时还没有开始重新渲染 DOM 节点。</p>
<h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><p>实例更新完毕后调用此函数，此刻 data 中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了。</p>
<h2 id="销毁期间的生命周期函数"><a href="#销毁期间的生命周期函数" class="headerlink" title="销毁期间的生命周期函数"></a>销毁期间的生命周期函数</h2><h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h3><p>实例销毁之前调用。此刻实例仍然完全可用。</p>
<h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><p>一切你想要在组件销毁之前做事，例如弹出确认窗：“你确认删除XXX吗？”</p>
<h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h3><p>实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack4 如何优雅打包缓存文件（转载）</title>
    <url>/posts/64694/</url>
    <content><![CDATA[<p>一般来说，对于静态资源，我们都希望浏览器能够进行缓存，那样以后进入页面就可以直接使用缓存资源，页面直接直逼火箭速度打开，既提高了用户的体验也节省了宽带资源。</p>
<p>当然浏览器缓存方法有很多种，这里只简单讨论下 webpack 利用 hash 方式修改文件名，以达到缓存目的。</p>
<h2 id="webpack-hash"><a href="#webpack-hash" class="headerlink" title="webpack hash"></a>webpack hash</h2><p>webpack 内置了多种可使用 hash，官网解释分别如下：</p>
<ul>
<li><code>hash</code>：the hash of the module identifier</li>
<li><code>chunkHash</code>：the hash of the chunk content</li>
<li><code>contentHash</code>：the hash of extracted content</li>
</ul>
<p>注：hash 的默认长度为 20 个字符，可通过 <code>output.hashDigestLength</code> 全局配置，或使用 <code>[hash:16]</code> 方式配置，还可以通过 <code>output.hashDigest</code> 配置何时生成 hash。</p>
<p>那么问题来了，这么多种 hash 该如何选择呢？</p>
<a id="more"></a>

<h2 id="实战-hash"><a href="#实战-hash" class="headerlink" title="实战 hash"></a>实战 hash</h2><p>基础的配置文件如下（基于webpack 4，入口文件分别为 index 和 detail，其中每个文件中引入了一个图片）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">&#x27;none&#x27;</span>, <span class="comment">// 设置为 none，避免 development 或 production 默认设置的一些影响</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">&#x27;./src/index.js&#x27;</span>, </span><br><span class="line">    detail: <span class="string">&#x27;./src/detail.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;[name].[hash].js&#x27;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hash（the-hash-of-the-module-identifier）"><a href="#hash（the-hash-of-the-module-identifier）" class="headerlink" title="hash（the hash of the module identifier）"></a>hash（the hash of the module identifier）</h3><p>首先，我们来解释下 the module identifier。webpack 默认为给各个模块分配一个 id 以作标识，用来处理模块之间的依赖关系。而默认的 id 命名规则是根据模块引入的顺序，赋予一个整数(1、2、3……)。如下图就是使用 hash 的打包，index 和 detail 作为 entry 的两个入口，可以看到其 hash 值是一样的，而另外两个图片的 hash 值是不同的。</p>


<p>由于该 hash 是基于整个 module identifier 序列计算得到的，所以 JS 或 CSS 文件如果使用该 hash，则所有值都一样，而任意增添或删减一个模块的依赖，都会对整个 id 序列造成影响，从而改变 hash 值。这样的话 JS 或 CSS 文件是不适合使用该 hash 值的。</p>
<p>当然对于图片、字体、PDF 等资源该 hash 还是可以生成一个唯一值的。</p>
<h4 id="runtime-amp-manifest"><a href="#runtime-amp-manifest" class="headerlink" title="runtime &amp; manifest"></a>runtime &amp; manifest</h4><p>假如我们什么都不改动，只是重新跑一次构建，会惊奇的发现 index 和 detail 的 hash 值居然变了（图片的 hash 是不变的），如下图：</p>


<p>这究竟是怎么回事呢？webpack 官方解释为：</p>
<blockquote>
<p>This is because webpack includes certain boilerplate, specifically the <a href="https://webpack.js.org/concepts/manifest/">runtime and manifest</a>, in the entry chunk.</p>
</blockquote>
<p>为了解决这个不稳定的因素，webpack 4 提供了一个配置可以直接把 boilerplate 给单独抽离出来，配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    runtimeChunk: <span class="string">&#x27;single&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就能得到一个 runtime 的 js 文件，如下图：</p>


<h3 id="chunkhash（the-hash-of-the-chunk-content）"><a href="#chunkhash（the-hash-of-the-chunk-content）" class="headerlink" title="chunkhash（the hash of the chunk content）"></a>chunkhash（the hash of the chunk content）</h3><p>现在我们把 hash 改成 chunkhash ，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">&#x27;[name].[chunkhash].js&#x27;</span>,</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新跑下构建，会发现打包出来的三个 JS 文件的 chunkhash 值是不一样的了，如下：</p>


<p>现在我们在 index 文件中再引入一个 JS 模块，重新打包如下：</p>


<p>我们会发现 index 和 detail 文件的 chunkhash 都变了，这就奇怪了，按理来说 detail 文件我们根本没有改变啊，为什么它的 chunkhash 值变了呢？</p>
<p>其实根本原因还是 module identifier，因为 index 新引入的模块改变了以后所有模块的 id 值，所以 detail 文件中引入的模块 id 值发生了改变，于是 detail 的 chunkhash 也随着发生改变。</p>
<p>解决方案是将默认的数字 id 命名规则换成路径的方式。webpack 4 中当 mode 为 development 会默认启动</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    namedModules: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然如果是生产环境的话，全路径是有点太长，所以我们可以换成使用<a href="https://webpack.js.org/plugins/hashed-module-ids-plugin/">HashedModuleIdsPlugin</a> 插件来根据路径生成的 hash 作为 module identifier。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HashedModuleIdsPlugin(),</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>这样最后 chunkhash 改变的就只有修改的文件了，也达到了我们想要的效果。</p>
<h3 id="contenthash（the-hash-of-extracted-content）"><a href="#contenthash（the-hash-of-extracted-content）" class="headerlink" title="contenthash（the hash of extracted content）"></a>contenthash（the hash of extracted content）</h3><p>现在我们将 CSS 样式单独抽离生成文件（使用了 <a href="https://webpack.js.org/plugins/mini-css-extract-plugin/">MiniCssExtractPlugin</a> 插件），会发现其 chunkhash 值跟该 entry 的 js 文件的 chunkhash 是一样的，如下图：</p>


<p>现在如果只改变 CSS 文件，会发现对应的 entry JS 和 CSS 文件的 chunkhash 都会改变。（注意：可能以前 <a href="https://webpack.js.org/plugins/extract-text-webpack-plugin/">ExtractTextWebpackPlugin</a> 不会改变，所以只能对抽离的 CSS 文件使用 contenthash）。</p>
<p>反正不管同时变或不变，可能都不是我们想要的效果，我们需要应该是改变了什么就反应到什么文件上。而不是 CSS 和 JS 文件的 chunkhash 同时改变或不变，无法区分 CSS 和 JS 的更新。</p>
<p>所以这里抽离出来的 CSS 文件将使用 contenthash，以区分 CSS 文件和 JS 文件的更新。</p>
<h3 id="Chunks-ID"><a href="#Chunks-ID" class="headerlink" title="Chunks ID"></a>Chunks ID</h3><p>然而这还没有结束，还有个问题，那就是目前我们的 chunks ID 还是以自增的数字命名的，这当我们的 entry 文件发生改变（新增或删除）的时候，原先的 chunks ID 就有可能发生变化。于是我们也需要把数字改掉就好，webpack 4 在 <code>optimization</code> 新增了一个 <code>namedChunks</code> 配置，该配置开发环境为 <code>true</code>，生产环境为 <code>false</code>，所以在生产环境的时候我们为了构建稳定的 hash 时，还是需要把该选项设置为 <code>true</code>，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    namedChunks: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了一份理想的缓存文件，我们需要做这些事情：</p>
<ul>
<li>抽离 boilerplate（[runtime &amp; manifest）</li>
<li>将 module identifier 默认的数字标识方式转成使用路径标识</li>
<li>JS 文件使用 chunkhash</li>
<li>抽离的 CSS 样式文件使用 contenthash</li>
<li>gif|png|jpe?g|eot|woff|ttf|svg|pdf 等使用 hash</li>
<li>设置 <code>namedChunks</code> 为 true</li>
</ul>
<h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p><a href="https://imweb.io/topic/5b6f224a3cb5a02f33c013ba">Webpack4 如何优雅打包缓存文件</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>animation动画（一）</title>
    <url>/posts/57136/</url>
    <content><![CDATA[<h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><ul>
<li><a href="https://evestorm.github.io/posts/31280/">animation动画（一）</a></li>
<li><a href="https://evestorm.github.io/posts/20298/">animation动画（二）</a></li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>CSS Animations 是CSS的一个模块，它定义了如何用关键帧来随时间推移对CSS属性的值进行动画处理。关键帧动画的行为可以通过指定它们的持续时间，它们的重复次数以及它们如何重复来控制。</p>
</blockquote>
<p>———— 出自 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations">CSS Animations | MDN</a></p>
<a id="more"></a>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 简写 */</span></span><br><span class="line"><span class="selector-tag">animation</span>: 动画名称，一个周期所花费的时间，运动曲线（默认<span class="selector-tag">ease</span>），</span><br><span class="line">           动画延迟（默认0），播放次数（默认1），</span><br><span class="line">           是否反向播放动画（默认<span class="selector-tag">normal</span>），是否暂停动画（默认<span class="selector-tag">running</span>）</span><br></pre></td></tr></table></figure>

<p>就像在介绍中写到的那样，整个 animations 是个模块，包含很多属性来定义动画，比方说 <code>animation-name</code> 、<code>animation-duration</code> 和 <code>animation-delay</code> 等等。但本着快速上手的目的，第一篇文章主要围绕 <code>animation</code> 这个简写属性来讲，因为用它最直观，而且就经验来讲，日常使用最多的也是这个属性。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>一个CSS3动画由两个基本项组成：</p>
<ol>
<li>关键帧（Keyforames） - 用来定义动画的阶段和样式。</li>
<li>动画属性 - 分配关键帧（@keyframes）到一个特定的css元素，来定义它的动画方式。</li>
</ol>
<p>我们围绕这两项讨论，并在这个过程中实现一个按钮不断放大缩小的动画效果：</p>
<img src="/posts/57136/shrink.gif" class="" title="shrink">

<h3 id="keyframes"><a href="#keyframes" class="headerlink" title="keyframes"></a>keyframes</h3><p>关键帧 keyframes 定义了动画在每个阶段的动画效果。它包括：</p>
<ul>
<li>动画名称：定义动画的名称</li>
<li>动画阶段：整个动画阶段用百分比来表示。0% 表示动画的开始状态。100% 表示动画的结束状态。可以在其间添加多个中间状态，比如 20%，60%…</li>
<li>动画属性：给动画每个阶段定义的CSS属性</li>
</ul>
<p>现在我们来编写一段 @keyframes 。动画名称命名为 <code>shrink</code> 。它只有简单的两个阶段：</p>
<ul>
<li>第一阶段（0%）：元素的缩放比例为 1:1</li>
<li>第二阶段（100%）：元素的缩放比例为 1:0.8</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> shrink &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(<span class="number">0.8</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.8</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动画属性"><a href="#动画属性" class="headerlink" title="动画属性"></a>动画属性</h3><p>接着，我们给要设置动画的元素添加上动画属性。要使动画生效，我们至少要添加以下两个动画属性：</p>
<ul>
<li>animation-name: 动画的名称，在 @keyframes 中定义。</li>
<li>animation-duration: 动画的持续时间，以秒为单位（例如 5s）或毫秒（例如 200ms）。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="comment">/*  其他样式  */</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/*  动画名称: shrink  */</span></span><br><span class="line">  <span class="selector-tag">animation-name</span>: <span class="selector-tag">shrink</span>;</span><br><span class="line">  <span class="comment">/*  动画持续时间: 0.5秒 */</span></span><br><span class="line">  <span class="selector-tag">animation-duration</span>: .5<span class="selector-tag">s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就实现页面加载后，一个按钮从开始的原始大小，经过0.5s后变成了原始大小的0.8的动画效果。然而我们希望最终的效果是一个按钮的不断放大和缩小，交替进行。这就得添加 <code>animation-iteration-count</code> 和 <code>animation-direction</code> 两个动画属性了，它们一个用来定义元素动画的循环次数，一个用来定义动画在循环过程中是否反向运动：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/*  动画的循环次数: 无限次  */</span></span><br><span class="line">  <span class="selector-tag">animation-iteration-count</span>: <span class="selector-tag">infinite</span>;</span><br><span class="line">  <span class="comment">/*  循环是否反向：先正向后反向  */</span></span><br><span class="line">  <span class="selector-tag">animation-direction</span>: <span class="selector-tag">alternate</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的简写形式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="selector-tag">animation</span>: <span class="selector-tag">shrink</span> .5<span class="selector-tag">s</span> <span class="selector-tag">linear</span> <span class="selector-tag">alternate</span> <span class="selector-tag">infinite</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整效果：</p>
<iframe height="265" scrolling="no" title="animation-shrink" src="https://codepen.io/JingW/embed/MRaJrz/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h2 id="资源-📚"><a href="#资源-📚" class="headerlink" title="资源 📚"></a>资源 📚</h2><ul>
<li><p>animation | 一个CSS3动画库</p>
<p>【推荐】</p>
<ul>
<li><a href="https://daneden.github.io/animate.css/">点我查看效果</a></li>
</ul>
</li>
<li><p>magic | 另一个CSS3动画库</p>
<ul>
<li><a href="https://www.minimamente.com/example/magic_animations/">点我查看效果</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>animation动画（二）</title>
    <url>/posts/20298/</url>
    <content><![CDATA[<h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><ul>
<li><a href="https://evestorm.github.io/posts/31280/">animation动画（一）</a></li>
<li><a href="https://evestorm.github.io/posts/20298/">animation动画（二）</a></li>
</ul>
<p>老规矩，二系列来谈谈具体每个动画属性的含义和用法，算是一个对知识点的总结吧。</p>
<h2 id="animation-name-动画名称"><a href="#animation-name-动画名称" class="headerlink" title="animation-name 动画名称"></a>animation-name 动画名称</h2><p>CSS语法：<code>animation-name: shrink</code></p>
<p>用来设置元素的动画名称。</p>
<a id="more"></a>

<h2 id="animation-duration-持续时间"><a href="#animation-duration-持续时间" class="headerlink" title="animation-duration 持续时间"></a>animation-duration 持续时间</h2><p>CSS语法：<code>animation-duration: 1s</code></p>
<p>用来指定动画在一个周期内所花费的时间。</p>
<h2 id="animation-timing-function-运动曲线"><a href="#animation-timing-function-运动曲线" class="headerlink" title="animation-timing-function 运动曲线"></a>animation-timing-function 运动曲线</h2><p>CSS语法：<code>animation-timing-function: ease-in-out</code></p>
<p>用来设置元素的动画速度曲线，它的用法和 <a href="https://evestorm.github.io/posts/13167/#transition-timing-function-%E6%95%88%E6%9E%9C%E6%9B%B2%E7%BA%BF">transition-timing-function</a> 类似，想要了解详情的直接点这个链接吧。</p>
<blockquote>
<p>DEMO</p>
</blockquote>
<iframe height="521" scrolling="no" title="animation-timing-function" src="https://codepen.io/JingW/embed/qwbVgB/?height=521&amp;theme-id=0&amp;default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h2 id="animation-delay-动画延迟"><a href="#animation-delay-动画延迟" class="headerlink" title="animation-delay 动画延迟"></a>animation-delay 动画延迟</h2><p>CSS语法：<code>animation-delay: 1s</code></p>
<p>用来设置动画延迟多少秒/毫秒后才开始执行。正值（例如2s）将在2s后启动动画；负值（例如-2s）将立即执行动画，但是动画会从它的动画序列中的第2s位置处立即开始。</p>
<h2 id="animation-iteration-count-循环次数"><a href="#animation-iteration-count-循环次数" class="headerlink" title="animation-iteration-count 循环次数"></a>animation-iteration-count 循环次数</h2><p>CSS语法：<code>animation-iteration-count: 1s</code></p>
<p>用来设置动画循环的次数，默认值是1，表示动画只播放一次。除了使用正整数来设置次数外，还可以将值设置为 <code>infinite</code> ，表示无限循环。</p>
<h2 id="animation-direction-是否反向"><a href="#animation-direction-是否反向" class="headerlink" title="animation-direction 是否反向"></a>animation-direction 是否反向</h2><p>CSS语法：<code>animation-direction: normal | reverse | alternate | alternate-reverse</code></p>
<p>用来设置动画在循环过程中是否反向运动，默认值为 <code>normal</code> ，即正常模式，动画会从第一帧播放到最后一帧；<code>reverse</code> 表示反向模式，动画会从最后一帧倒着播放到第一帧；<code>alternate</code> 设置动画先正向播放，第二次再从反向播放，交替进行，例如 animation 系列一中的案例；<code>alternate-reverse</code> 则是先让动画反向播放，第二次再正向播放，交替进行。</p>
<h2 id="animation-fill-mode-动画填充模式"><a href="#animation-fill-mode-动画填充模式" class="headerlink" title="animation-fill-mode 动画填充模式"></a>animation-fill-mode 动画填充模式</h2><p>CSS语法：<code>animation-fill-mode: none | forwards | backwards | both</code></p>
<p>用来指定在动画执行之前和之后如何给动画的目标应用样式。这个属性在我第一次接触时没太理解，直到我看了 <a href="https://segmentfault.com/">segmentfault</a> 上的 <a href="https://segmentfault.com/q/1010000003867335">这篇文章</a> 。</p>
<p>在理解它之前，我们需要在脑海里有个概念，那就是一个动画是分为初始状态、等待期、动画执行期、完成期四个阶段的。而上面 animation-fill-mode 接收的四个值则分别对应：</p>
<ul>
<li>none 表示 等待期和完成期，元素样式都为初始状态样式，不受动画定义（@keyframes）的影响</li>
<li>forwards 表示等待期保持初始样式，完成期间保持最后一帧样式</li>
<li>backwards 表示等待期为第一帧样式，完成期跳转为初始样式</li>
<li>both 表示 等待期样式为第一帧样式，完成期保持最后一帧样式</li>
</ul>
<p>单纯的文字不直观？相信下面的这个demo能让你豁然开朗：</p>
<iframe height="435" scrolling="no" title="animation-fill-mode" src="https://codepen.io/JingW/embed/qwNLJE/?height=435&amp;theme-id=0&amp;default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h2 id="animation-play-state-动画播放状态"><a href="#animation-play-state-动画播放状态" class="headerlink" title="animation-play-state 动画播放状态"></a>animation-play-state 动画播放状态</h2><p>CSS语法：<code>animation-play-state: running | paused</code></p>
<p>用来设置动画的播放或者暂停。比如希望在鼠标经过的时候，让动画先停止下来，鼠标移开之后再继续播放，就可以通过设置 <code>.element:hover &#123; animation-play-state: paused; &#125;</code> 来实现。下面是一个案例，在鼠标移入时钟后指针暂停旋转；移出后时钟继续旋转。</p>
<iframe height="339" scrolling="no" title="animation-play-state闹钟示例" src="https://codepen.io/JingW/embed/rbMWjB/?height=339&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie与session区别</title>
    <url>/posts/63891/</url>
    <content><![CDATA[<h2 id="保存状态"><a href="#保存状态" class="headerlink" title="保存状态"></a>保存状态</h2><p>cookie 是通过在客户端记录信息确定用户身份的，而 session 则通过在服务器端记录信息来确定用户身份。下面是网上找到的两张图，能够对 cookie 以及 session 在客户端与服务端传递的过程有个较清晰的认识：</p>
<img src="/posts/63891/1550245038963-b61378bb-65db-411e-9069-cf7d2b7a2908-20201119143043224.png" class="" title="cookie">

<img src="/posts/63891/1550245194054-9e6b0a42-c09e-4a8b-8e7e-93ba715e6e5a-20201119143043424.png" class="" title="session">

<a id="more"></a>

<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>cookie机制：</p>
<ul>
<li>默认情况下，cookie 保存在内存中，<strong>浏览器关闭</strong>就没了；设置过期时间后，cookie 保存在硬盘上，关闭浏览器仍然存在，直到过期时间结束才消失。</li>
<li>cookie 以<strong>文本形式</strong>保存在客户端，每次请求时都带上它。</li>
</ul>
<p>session机制：</p>
<ul>
<li>每次请求，服务器会检查是否有 sessionid<ul>
<li>有，服务器根据 id 返回对应 session 对象</li>
<li>无，服务器创建新的 session 对象，并把 sessionid 在本次响应中返回给客户端。</li>
</ul>
</li>
<li>通常使用 cookie 方式存储 sessionid 到客户端<ul>
<li>用户禁用 cookie 时，则服务端可以使用URL重写，可以通过 response.encodeURL(url) 进行实现</li>
</ul>
</li>
</ul>
<h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><ul>
<li>cookie 只能保存字符串类型，以文本的方式</li>
<li>session 能支持任何类型的对象</li>
</ul>
<h2 id="存储大小"><a href="#存储大小" class="headerlink" title="存储大小"></a>存储大小</h2><ul>
<li>cookie单个不超过4kb</li>
<li>session没限制</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>flex布局中，保持内容不超出容器的解决办法</title>
    <url>/posts/3930/</url>
    <content><![CDATA[<p>在移动端，flex 布局很好用，它能够根据设备宽度来自动调整容器的宽度，用起来很方便，已经越来越离不开它，但是最近在做项目的时候发现一个问题。</p>
<p>就是在一个设置了 flex:1 的容器中，如果文字很长，这时候文字就会超出容器，而不是呆在设置好的动态剩余的空间中。由于实际项目的比较复杂，不好拿出来说，这里就把问题简化描述如下：</p>
<p>大致是有一个 main 容器是 flex 布局，左边一个 logo 固定宽高，右边 content 动态宽度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span> <span class="attr">src</span>=<span class="string">&quot;pic.jpg&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span>a name<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;info&quot;</span>&gt;</span>a info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;notice&quot;</span>&gt;</span>This is notice content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.main &#123; display: flex; &#125; .logo &#123; width: 100px; height: 100px; margin: 10px; &#125;</span><br><span class="line">.content &#123; flex: 1; &#125; .content &gt; * &#123; white-space: nowrap; overflow: hidden;</span><br><span class="line">text-overflow: ellipsis; &#125;12345678910111213141516</span><br></pre></td></tr></table></figure>

<p>.notice 可能会非常长，一些设备下需要隐藏显示，即不换行，并留下省略符…作标记。<br>这里会发现 text-overflow: ellipsis 不生效，省略符根本没有出现。而且因为设置了 nowrap 会发现文字会将 content 撑开，导致内容超出了屏幕。所以必须要解决这个问题。</p>
<blockquote>
<p>尝试取消父元素.content 的 flex: 1，无效。<br>尝试取消.main 容器的 display: flex，省略号出现。</p>
</blockquote>
<p>因此猜测是 flex 布局的问题，进一步猜测省略符需要对父元素限定宽度。<br>尝试对父元素.content 设置 width: 100%无效，但是设置 width: 0 可行。即：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不设置宽度，.content 可以被子节点无限撑开；因此.notice 总有足够的宽度在一行内显示所有文本，也就不能触发截断省略的效果。测试还有一种方法可以达到效果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden；;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的二种方法都可以达到我们需要的效果，即给 content 设置了 flex 为 1 的时候，它会动态的获得父容器的剩余宽度，且不会被自己的子元素把内容撑开。</p>
<p>经过测试，以下的方法是无效的：</p>
<blockquote>
<p>给 html, body 设置 max-width，元素似乎能强行撑开页宽；<br>给 body 设置 overflow，页宽不能被撑开了，但元素宽度还在，即元素本身还是溢出；<br>给 html, body 同时设置 max-width 和 overflow，页宽限定在 max-width 内，元素本身还是溢出；<br>给.main 容器设置 overflow: hidden，同理.main 是不溢出了，.notice 本身还是溢出；<br>给.notice 元素设置 width 或 max-width，虽然宽度受限，但在特定宽度下省略符…显示不全，有时只显示两个点..</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>Flex</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title>npm-run-build遇到Node Sass could not find a binding for your current environment: OS X 64-bit with Node.js 14.x</title>
    <url>/posts/7710/</url>
    <content><![CDATA[<p>今天 <code>npm run build-prod</code> 打包项目的时候遇到如下报错信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Node Sass could not find a binding for your current environment: OS X 64-bit with Node.js</span><br></pre></td></tr></table></figure>

<p>百度了一些解决方案都没法解决问题，后来在 Stack Overflow 上看到了一种解决方案，地址：<a href="https://stackoverflow.com/questions/64612707/node-sass-does-not-yet-support-your-current-environment-windows-64-bit-with-uns">https://stackoverflow.com/questions/64612707/node-sass-does-not-yet-support-your-current-environment-windows-64-bit-with-uns</a></p>
<ol>
<li>install / downgrade node.js to a stable version (LTS) like <a href="https://nodejs.org/en/download/">14.15.0</a></li>
<li>install the compatible node-sass version via <code>npm install node-sass@4.14.0</code>; you can find the list <a href="https://www.npmjs.com/package/node-sass">here</a>, or even install <code>gulp-sass</code>with <code>npm i gulp-sass --save-dev</code>.</li>
</ol>
]]></content>
      <categories>
        <category>解决方案</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>解决方案</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>null 和 undefined 的区别</title>
    <url>/posts/63928/</url>
    <content><![CDATA[<h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><ul>
<li>null 表示一个对象是“没有值”的值，也就是值为“空”</li>
<li>undefined 表示一个变量声明了没有初始化(赋值)</li>
</ul>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul>
<li>undefined 的类型(typeof)是 undefined</li>
<li>null 的类型(typeof)是 object</li>
</ul>
<a id="more"></a>

<h2 id="双等三等"><a href="#双等三等" class="headerlink" title="双等三等"></a>双等三等</h2><p>另外，在验证 null 时，一定要使用 <code>===</code> ，因为 <code>==</code> 无法分辨 null 和 undefined ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copynull &#x3D;&#x3D; undefined &#x2F;&#x2F; true </span><br><span class="line">null &#x3D;&#x3D;&#x3D; undefined &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><ol>
<li>变量提升：只声明未定义默认值就是 undefined</li>
<li>严格模式下：没有明确的执行主体，this 就是 undefined</li>
<li>对象没有这个属性名，属性值是 undefined</li>
<li>函数定义形参不传值，默认就是 undefined</li>
<li>函数没有返回值（没有 return 或者 return; ），默认返回的就是 undefined</li>
<li>数组越界取值也是 undefined （arr=[1,2]; arr[10] =&gt; undefined）</li>
<li>…</li>
</ol>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><ol>
<li>手动设置变量的值或者对象某个属性值为null（此时不赋值，后面会赋值）</li>
<li>在 JS 的 DOM 元素获取中，如果没有获取到指定的元素对象，结果一般都是null</li>
<li>Object.prototype.<strong>proto</strong> 的值也是 null</li>
<li>正则捕获的时候，如果没有捕获到结果，默认也是null</li>
<li>…</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Javascript会将未赋值的变量默认值设为undefined；Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>let和const和var的区别</title>
    <url>/posts/37021/</url>
    <content><![CDATA[<h2 id="const-和-let-异同"><a href="#const-和-let-异同" class="headerlink" title="const 和 let 异同"></a>const 和 let 异同</h2><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul>
<li>let 定义变量可以只声明不赋值</li>
<li>const 定义常量声明时必须赋值，一旦定义不可轻易改变</li>
</ul>
<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>解决 var 没有块作用域,、变量提升、可以重复声明的问题。 let 和 const 有自己的块作用域, 不存在变量提升问题, 同一块作用域中不可重复声明（会报错）。</p>
<h2 id="let-const-和-var-区别"><a href="#let-const-和-var-区别" class="headerlink" title="let/const 和 var 区别"></a>let/const 和 var 区别</h2><ul>
<li>var 有变量提升，let/const 没有</li>
<li>let/const 的作用域是块，而 var 的作用域是函数</li>
<li>let/const 有暂时性死区，只要 let/const 声明的变量，在未声明之前使用或者赋值都会报错（ReferenceError）</li>
<li>let/const 不能被重复定义</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>transition过渡（一）</title>
    <url>/posts/41749/</url>
    <content><![CDATA[<h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><ul>
<li><a href="https://evestorm.github.io/posts/24967/">transition过渡（一）</a></li>
<li><a href="https://evestorm.github.io/posts/13167/">transition过渡（二）</a></li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。<br>要实现这一点，必须规定两项内容：</p>
<ul>
<li>指定要添加效果的CSS属性</li>
<li>指定效果的持续时间。</li>
</ul>
</blockquote>
<p>———— 出自 <a href="http://www.runoob.com/css3/css3-transitions.html">菜鸟教程</a></p>
<a id="more"></a>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 分开写：*/</span></span><br><span class="line"><span class="selector-tag">transition-property</span>: <span class="selector-tag">css</span>属性名称;</span><br><span class="line"><span class="selector-tag">transition-duration</span>: 过渡所花时间(默认0);</span><br><span class="line"><span class="selector-tag">transition-timing-function</span>: 过渡的时间曲线(默认<span class="selector-tag">ease</span>);</span><br><span class="line"><span class="selector-tag">transition-delay</span>: 延迟时间(默认0);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 简写形式： */</span></span><br><span class="line"><span class="selector-tag">transition</span>： <span class="selector-tag">CSS</span>属性，花费时间，效果曲线(默认<span class="selector-tag">ease</span>)，延迟时间(默认0)</span><br></pre></td></tr></table></figure>

<h2 id="栗子-🌰"><a href="#栗子-🌰" class="headerlink" title="栗子 🌰"></a>栗子 🌰</h2><h3 id="单个属性的变化-—-gt-按钮-hover-效果"><a href="#单个属性的变化-—-gt-按钮-hover-效果" class="headerlink" title="单个属性的变化 —&gt; 按钮 :hover 效果"></a>单个属性的变化 —&gt; 按钮 :hover 效果</h3><p>下面的两个按钮，在鼠标移入时都被设置了 <code>background: yellow;</code> 样式。但只给第一个加上了 <code>transition: background 2s;</code> 属性，意思是如果背景发生变化，则给2s的过渡效果。</p>
<iframe height="265" scrolling="no" title="XGvqMB" src="https://codepen.io/JingW/embed/XGvqMB/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="多个属性的变化-—-gt-单独设置"><a href="#多个属性的变化-—-gt-单独设置" class="headerlink" title="多个属性的变化 —&gt; 单独设置"></a>多个属性的变化 —&gt; 单独设置</h3><p>针对多个属性设置过渡效果，用逗号隔开就好。下面案例鼠标移入后，使正方形过渡到圆形，且颜色逐渐变浅，核心代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">background</span> .5<span class="selector-tag">s</span> <span class="selector-tag">ease-out</span>, <span class="selector-tag">border-radius</span> .5<span class="selector-tag">s</span> <span class="selector-tag">ease-in</span>;</span><br></pre></td></tr></table></figure>



<iframe height="265" scrolling="no" title="transition-多属性" src="https://codepen.io/JingW/embed/dLyWKM/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="多个属性的变化-gt-all"><a href="#多个属性的变化-gt-all" class="headerlink" title="多个属性的变化 -&gt; all"></a>多个属性的变化 -&gt; all</h3><p>如果要过渡的css属性较多，可以尝试使用 all 一步搞定。下面案例中将鼠标移入正方形盒子，会使其慢慢缩小为一个圆形，且颜色逐渐变深，核心代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">all</span> .5<span class="selector-tag">s</span> <span class="selector-tag">ease-out</span>;</span><br></pre></td></tr></table></figure>



<iframe height="265" scrolling="no" title="transition-多属性-all" src="https://codepen.io/JingW/embed/GLRmXm/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h2 id="实用-demo"><a href="#实用-demo" class="headerlink" title="实用 demo"></a>实用 demo</h2><h3 id="下拉导航菜单"><a href="#下拉导航菜单" class="headerlink" title="下拉导航菜单"></a>下拉导航菜单</h3><iframe height="265" scrolling="no" title="transition-下拉导航" src="https://codepen.io/JingW/embed/MxNXex/?height=265&amp;theme-id=0&amp;default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>transition过渡（二）</title>
    <url>/posts/13167/</url>
    <content><![CDATA[<h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><ul>
<li><a href="https://evestorm.github.io/posts/24967/">transition过渡（一）</a></li>
<li><a href="https://evestorm.github.io/posts/13167/">transition过渡（二）</a></li>
</ul>
<p>上篇文章是对 transition过渡 的一个简单介绍和使用。这篇文章就来聊聊具体属性的含义和用法。</p>
<a id="more"></a>

<h2 id="transition-property-过渡属性"><a href="#transition-property-过渡属性" class="headerlink" title="transition-property 过渡属性"></a>transition-property 过渡属性</h2><p>从上一篇文章能够知道 transition-property 是拿来设置元素中参与过渡的属性的。它的可选值为：</p>
<ul>
<li>none 指所有属性都不参与过渡</li>
<li>all 指所有属性都参与过渡</li>
<li>[IDENT] 指定个别属性参与过渡</li>
</ul>
<p>下面来看一个案例：</p>
<p>👇温馨提示：为了方便看效果，可点击 <code>CSS</code> 按钮折叠代码部分，仅显示页面 👇</p>
<iframe height="265" scrolling="no" title="transition-property-demo1" src="https://codepen.io/JingW/embed/oONwww/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<p>当你依次将鼠标移入上方演示demo中的三个按钮就会发现，都在各自下方显示出了一段文本。我们想要实现的，就是这段文本的显示需要有一个过渡效果，不要太生硬。最简单的一种实现方案就是鼠标移入按钮前，文本容器的 <code>height: 0</code> ，鼠标移入后固定容器高度 <code>height: 150px</code> （第一个按钮效果就用的此方案）。但在实际情况中，往往文本是自适应的，高度无法确定，所以很自然的，我们会想到将 <code>height: 150px</code> 设置为 <code>height: auto</code> ，这样不就能够实现自适应高度的容器过渡了嘛，这就是第二个按钮的一套实现方案。但结果大家都知道了，文本容器不再拥有过渡的动画，而是直接从 <code>0px</code> 瞬间变化到 <code>auto</code>，这是为什么呢？</p>
<p><strong>答案</strong>：并不是所有的属性和属性值都能存在过渡动画。</p>
<p>这里特别需要注意的是，如果想要指定某个属性有过渡状态，就需要保证我们能够计算出过渡过程中每个时间点的属性值。<br>比如，从 <code>height: 0;</code> 过渡到 <code>height: 150px;</code> ，过渡时间是 <code>t</code> ，那我们可以算出在 <code>x</code> 时刻的属性状态是 <code>height: (150px-0)*x/t;</code> 。（注：这里公式成立的前提是假设 <code>transition-timing-function: linear;</code> ，如果<code>transition-timing-function</code> 为其他值，一样可以计算，只不过算法不同）<br>然而刚才第二种方案设置了 <code>height: auto;</code>，则在 <code>x</code> 时刻的属性状态为 <code>height: (auto-0px)*x/t;</code> ，显然，这种状态是不存在的、无法被计算的，因此在设置高度变成 <code>auto</code> 之后，也自然不会再有过渡动画了。</p>
<p><strong>解决方案</strong></p>
<p>第三个按钮的效果就是我们的一种解决方案，在默认状态下，我们不设置文本容器的 <code>height: 0</code> ，而是用 <code>transform: scale(1, 0);</code> 来代替它，意思是在初始状态下，我们的文本容器比例为宽1:1，高1:0，换句话说，宽为我们设置的宽，但高度为0。在鼠标移入按钮后，用 <code>transform: scale(1, 1);</code> 来代替方案二中的 <code>height: auto</code> ，设置文本容器的宽高为1，这样就又能出现过渡动画了。</p>
<p><strong>延伸</strong></p>
<p>由此进行延伸，再比如日常中最常使用的控制元素显示隐藏的代码是 <code>display: block;</code> 和 <code>display: none;</code> ，这也是不存在过渡动画的，因此，可以调整改为使用 <code>opacity: 1;</code> 和 <code>opacity: 0;</code> 来替换。</p>
<h2 id="transition-duration-过渡花费的时间"><a href="#transition-duration-过渡花费的时间" class="headerlink" title="transition-duration 过渡花费的时间"></a>transition-duration 过渡花费的时间</h2><p>这个属性没什么可讲的，用它来设置元素过渡的持续时间</p>
<h2 id="transition-timing-function-效果曲线"><a href="#transition-timing-function-效果曲线" class="headerlink" title="transition-timing-function 效果曲线"></a>transition-timing-function 效果曲线</h2><p>这个属性是设置过渡的动画类型的，换句话说，就是设置在过渡过程中元素值的变化速度。它的可选值包含这样几组：</p>
<ul>
<li>ease | linear | ease-in | ease-out | ease-in-out</li>
<li>step-start | step-end | steps([, [ start | end ] ]?)</li>
<li>cubic-bezier(, , , )</li>
</ul>
<h3 id="预设的五个时间曲线"><a href="#预设的五个时间曲线" class="headerlink" title="预设的五个时间曲线"></a>预设的五个时间曲线</h3><iframe height="519" scrolling="no" title="transition-timing-function-五个预设时间曲线" src="https://codepen.io/JingW/embed/dLyjoN/?height=519&amp;theme-id=0&amp;default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="阶跃函数-step"><a href="#阶跃函数-step" class="headerlink" title="阶跃函数 step"></a>阶跃函数 step</h3><p>直接上案例吧，看完效果再来讲阶跃函数几个参数的具体含义：</p>
<iframe height="413" scrolling="no" title="transition-timing-function-阶跃函数" src="https://codepen.io/JingW/embed/PgwWXd/?height=413&amp;theme-id=0&amp;default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<p>实际体验了阶跃函数带来的效果后应该对其有个大概认知了吧。阶跃函数接收两个参数，第一个参数为<strong>正整数</strong>，指定阶跃函数的间隔数，你可以理解为把整个过渡过程拆成若干份儿；第二个参数可选，值为<code>[ start | end ]</code>，叫做跃点，指定是在每个间隔的起点还是终点发生阶跃变化，默认值为<code>end</code>。<br>查看上面案例的css代码，你会发现两种 <code>steps</code> 的简写形式：<code>step-start</code> 和 <code>step-end</code> ，它们分别等同于：<code>step-start = steps(1, start)</code> 和 <code>step-end = steps(1, end)</code> 。</p>
<h3 id="cubic-bezier-贝塞尔曲线函数"><a href="#cubic-bezier-贝塞尔曲线函数" class="headerlink" title="cubic-bezier 贝塞尔曲线函数"></a>cubic-bezier 贝塞尔曲线函数</h3><p>贝塞尔曲线函数接收四个参数，取值范围是 0 到 1 之间的数值（包括0和1）。</p>
<p>贝塞尔曲线函数，其实定义的是 <strong>属性状态</strong> 与 <strong>时间</strong> 的一个关系函数。如下坐标轴所示：</p>
<img src="/posts/13167/cubic05000510.png" class="" title="cubic-bezier">

<p>上图坐标轴中横坐标是时间，纵坐标是属性状态，右上角的坐标是(1,1)。在时间曲线中的每一个点，表示的就是对应时刻下属性的取值，每个点的斜率表示的就是在这个时刻属性的变化速度，因此在时间曲线中<strong>斜率越小</strong>，也就是<strong>越平缓</strong>的地方，表示<strong>属性变化速度越慢</strong>；<strong>斜率越大</strong>，也就是<strong>越陡峭</strong>的地方，表示<strong>属性变化速度越快</strong>。如上图中开始跟结束的时候，斜率都比较小，而中间的阶段，斜率比较大，因此这个曲线表示的就是在变化过程中由慢到快再到慢的一个过程。</p>
<p>回到贝塞尔曲线函数接收的四个参数上，前两个是上图中红色点的坐标(x1,y1)，后两个是图中蓝色点的坐标(x2,y2)，也就是 <code>cubic-bezier(x1, y1, x2, y2)</code> 这样的形式。我们可以在 <a href="http://cubic-bezier.com/">http://cubic-bezier.com/</a> 这个工具上来调整我们独特的贝塞尔曲线，通过拖拽红色跟蓝色点，可以形成不一样的贝塞尔曲线。我们发现，其实规定取值范围在[0,1]之间，针对的是<strong>x坐标</strong>，也就是<strong>时间</strong>，因为时间如果超过了这个范围，就会出现在同一个时刻对应了两个不同的属性状态，这个是没有意义的；而y坐标是可以超过这个范围的，如下我们通过拖拽两个点形成了这样一个曲线：</p>
<img src="/posts/13167/cubic55465149.png" class="" title="cubic-bezier">

<p>它表示的是在过渡过程中属性值会超过终止状态的设定值然后再回到终点位置，表现为回弹的效果。大家可以在 <a href="http://cubic-bezier.com/">http://cubic-bezier.com/</a> 上自己拖动两个点尝试一下，最后点击 go 按钮查看效果。</p>
<p>上面两个图的demo效果：</p>
<iframe height="265" scrolling="no" title="transition-timing-function-贝塞尔曲线" src="https://codepen.io/JingW/embed/KYwqgb/?height=265&amp;theme-id=0&amp;default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h2 id="transition-delay-延迟"><a href="#transition-delay-延迟" class="headerlink" title="transition-delay 延迟"></a>transition-delay 延迟</h2><p>这个属性同样没啥讲的，用它来设置元素延迟过渡的时间。</p>
<h2 id="transition-的不足"><a href="#transition-的不足" class="headerlink" title="transition 的不足"></a>transition 的不足</h2><ul>
<li>无法在页面加载的时候自动触发，因为只有当属性值发生改变的时候才会触发过渡动画。</li>
<li>无法重复播放过渡动画，除非再次触发过渡事件。</li>
<li>无法设置多种状态（keyframes 只有 from，to），只能从初始状态过渡到终止状态，无法再设置其他的状态。</li>
<li>transition 规则作用的是单个属性的过渡状态，不能涉及多个属性，即使定义了 <code>transition: all 1s ease 0s;</code> 这样的规则，其对应的每个属性过渡动画也都是相互独立，相当于是定义了很多个 transition 规则，而每个 transition 只作用于一个属性。</li>
</ul>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><a href="https://easings.net/en#">Easing Functions Cheat Sheet</a></li>
<li><a href="http://cubic-bezier.com/">cubic-bezier</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】20个ChromeDevTools调试技巧</title>
    <url>/posts/709/</url>
    <content><![CDATA[<p><strong>译者按：</strong> Chrome DevTools 很强大，甚至可以替代 IDE 了！</p>
<ul>
<li>原文: <a href="https://medium.com/frontmen/art-of-debugging-with-chrome-devtools-ab7b5fd8e0b4">Art of debugging with Chrome DevTools</a></li>
<li>译者: <a href="https://www.fundebug.com/">Fundebug</a></li>
</ul>
<p><strong>为了保证可读性，本文采用意译而非直译。另外，本文版权归原作者所有，翻译仅用于学习。</strong></p>
<p><strong>小编推荐：<a href="https://www.fundebug.com/">Fundebug</a>专注于 JavaScript、微信小程序、微信小游戏，Node.js 和 Java 线上 bug 实时监控。真的是一个很好用的 bug 监控服务，众多大佬公司都在使用。</strong></p>
<p>谷歌开发者工具提供了一系列的功能来帮助开发者高效 Debug 网页应用，让他们可以更快地查找和修复 bug。在谷歌的开发者工具中，有非常多有用的小工具，但是很多开发者并不知道。通过这篇文章，我把我常用的那些高效 Debug 的 Chrome 开发者工具的功能分享给大家。</p>
<p>_简洁起见，接下来我会使用<code>开发者工具</code>来指代<code>谷歌开发者工具</code>_。</p>
<p>在我们开始之前，你需要做一些准备工作。</p>
<a id="more"></a>

<h3 id="使用金丝雀版"><a href="#使用金丝雀版" class="headerlink" title="使用金丝雀版"></a><strong>使用金丝雀版</strong></h3><p>如果你想使用谷歌最新的版本和开发者工具，你可以下载<a href="https://www.google.com/chrome/canary/">金丝雀版本</a>，甚至把它设置为开发默认打开的浏览器。金丝雀版本旨在为早期接受者提供最新的更新。它可能不稳定，但是大多数时候是没问题的。你要习惯去使用最新最强的谷歌浏览器。</p>
<p><strong>1. 开启开发者工具的实验性功能</strong></p>
<p>你可以到<code>chrome://flags</code>页面，然后开启<code>Developer Tools experiments</code>选项。</p>
<p>当开启后，在开发者工具的设置页面，可以发现多了一个<code>Experiments</code>选项。如果我使用的一些功能你没有看到，那么请到<code>Experiments</code>窗口打开。</p>
<p><strong>2.超级实验性功能</strong></p>
<p>如果我使用到的功能在<code>Experiments</code>列表没有，那么它可能是一个 WIP 功能(WIP 指 working in progress)。你可以这样开启：页面处在<code>Experiments</code>界面，连续敲击<code>shift</code>键 6 次来开启 WIP 功能。</p>
<img src="/posts/709/Experiments.gif" class="" title="Experiments">

<h3 id="Console"><a href="#Console" class="headerlink" title="Console"></a><strong>Console</strong></h3><p>当 Debug 的时候，我们绝大部分时间是在和 Console 打交道。我们往往在代码中插入很多 Console logs，通过打印变量值来 debug。鉴于 Console 对于我们这么重要，很有必要了解所有开发者工具提供的相关的 APIs 和快捷键。</p>
<p><strong>3. 总是打印对象</strong></p>
<p>我的第一个建议其实和开发者工具没有关系，而是我一直使用的一个技巧。在使用<code>console.log();</code>的时候，不仅仅打印变量，而是要打印对象，用大括号(<code>&#123;&#125;</code>)将变量包围起来。这样的优点是不仅会把变量的值打印，同时还会将变量名打印出来。</p>
<img src="/posts/709/log.png" class="" title="log">
<img src="/posts/709/superlog.png" class="" title="superlog">

<p><strong>4. 使用 console.table 来打印多条目数据</strong></p>
<p>如果你要打印的变量是一个数组，每一个元素都是一个对象。我建议你使用<code>console.table</code>来打印，其表格化的呈现更加美观易读。</p>
<img src="/posts/709/logtable.png" class="" title="logtable">

<p><strong>5. 给 log 加点颜色</strong></p>
<p>log 有时候变得非常多，包含你自己的、一些第三方扩展或者浏览器的 logs。除了使用过滤器(filter)以外，你还可以使用颜色来更好地区分。</p>
<img src="/posts/709/logcolor.png" class="" title="logcolor">

<p><strong>6. $ 和 $$</strong></p>
<p>如果你在 console 下没有任何库使用<code>$</code>和<code>$$</code>，那么你可以使用它们分别作为<code>document.querySelector()</code> 和 <code>document.querySelectorAll()</code>的快捷键。</p>
<p>除了提供了一个更加快捷的方式外，还有一个好处，<code>$$</code>返回一个数组，而不是<a href="http://2ality.com/2013/05/quirk-array-like-objects.html">array-like</a>的<a href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList">NodeList</a>. 所以你可以直接使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">reduce</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">filter</a> 函数。</p>
<p>你可以使用<code>$$</code>检查页面中的无效链接：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(</span><br><span class="line">  $$(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">link</span> =&gt;</span> link.href)</span><br><span class="line">    .map(<span class="function"><span class="params">href</span> =&gt;</span> fetch(href))</span><br><span class="line">)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;All links working&#x27;</span>))</span><br><span class="line">  .catch(<span class="function">() =&gt;</span> <span class="built_in">console</span>.error(<span class="string">&#x27;Some links are broken&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>7. $0</strong></p>
<p>如果你想引用某个 DOM 元素，使用<code>$0</code>。<code>$0</code>指向你当前在 Element 中选中的元素。如果指定了<code>$0</code>，<code>$1</code>指向之前选中的元素。以此类推，直到<code>$4</code>都可以使用。</p>
<p><strong>8. $_</strong></p>
<p><code>$_</code>记录了最后一次在 Console 计算的表达式。</p>
<p><strong>9. getEventListeners()</strong></p>
<p><code>getEventListeners(domElement)</code> 返回在 DOM 元素上注册的所有的事件。请看下面的例子：</p>
<img src="/posts/709/getEventListeners.gif" class="" title="getEventListeners">

<p>你也许注意到了，当我在 console 里输入表达式的时候，其结果立即被计算出来了。你可以看到我并没有敲击 Enter 键，而结果已经显示出来。这个是金丝雀版本的一个新功能，叫做”Eager Evaluation”。</p>
<img src="/posts/709/EagerEvaluation.png" class="" title="EagerEvaluation">

<p><strong>10. debug(fn)</strong></p>
<p>在上面的例子中，如果你想在点击按钮后的执行过程中暂停，你可以使用<code>debug</code>函数。<code>debug(fn)</code>接收一个函数作为参数，当每次该函数被调用时，Debugger 就会在该函数的第一行中断执行。</p>
<p>想象一下你要 debug 一个按钮的问题，但是你不知道这个按钮对应的事件函数在代码中什么位置。除了去大量的源代码中慢慢寻找之外，还有一个巧妙的方法。使用<code>getEventListeners</code>函数，然后将<code>debug</code>方法注入进去。这样，当你点击按钮的时候，就会在该函数的第一行停下来。</p>
<p><strong>11. copy(obj)</strong></p>
<p><code>copy(anything)</code> 是一个很有用的工具函数方便你将任何东西拷贝到系统的粘贴板暂存。</p>
<p>给<code>copy</code>函数传入一个没有格式的 JSON，会返回格式化的结果：</p>
<img src="/posts/709/copy.gif" class="" title="copy">

<p><strong>12. Top-level await</strong></p>
<p><code>async/await</code> 使得异步操作变得更加容易和可读。唯一的问题在于<code>await</code>需要在 async 函数中使用。如果我们要在 DevTools 的控制台使用，需要一些特殊的处理，使用<strong>I</strong>mmediately <strong>I</strong>nvoked <strong>A</strong>sync <strong>F</strong>unction <strong>E</strong>xpression (IIAFE). 一点都不方便。好在 DevTools 已经支持直接使用 await 了。</p>
<img src="/posts/709/await.png" class="" title="await">

<h3 id="Debugging-in-the-Sources-panel"><a href="#Debugging-in-the-Sources-panel" class="headerlink" title="Debugging in the Sources panel"></a>Debugging in the Sources panel</h3><p>在 source 面板，使用 breakpoints，stepping-into, stepping-over 等方式，你可以很好地掌控程序的执行状态，来发现代码问题。接下里我不会介绍大家都知道的基础内容，而是一些我经常使用的建议和技巧。</p>
<p><strong>13. 开启 auto-pretty print</strong></p>
<p>在金丝雀版本的实验模式下，你可以开启自动美化代码模式。</p>
<img src="/posts/709/autopre.png" class="" title="autopre">

<p><strong>14. 使用条件断点在生产环境中注入 console logs</strong></p>
<p>断点是一个很棒的功能。但还有一个更棒的：条件断点。只有当设定的条件满足的时候，中断才会执行。也就是说 DevTools 并不会每次都中断程序的执行，而只是在你想要它中断的时候才中断。想了解更多：查看<a href="https://developers.google.com/web/updates/2015/07/set-a-breakpoint-based-on-a-certain-condition">这里</a>.</p>
<p>在生产环境下，因为不能修改源代码，我喜欢使用条件断点来注入 console.log。如果我的断点仅仅是一个 console.log，DevTools 不会中断，因为 console.log 返回 undefined,，是一个 false 的值。但是它会执行我注入的表达式，可以看到输出结果。</p>
<p><a href="https://gitee.com/evestorm/various_resources/raw/master/tools/insertlog.gif"><img src="%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%9120%E4%B8%AAChromeDevTools%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/insertlog.gif" alt="img"></a></p>
<img src="/posts/709/insertlog.gif" class="" title="insertlog">

<p>为什么不直接使用普通的断点，并且查看变量呢？有时候我并不想这样做。比如，当我在分析那些频繁执行的操作，例如触摸或则滑动。我并不想每一次都导致 Debugger 触发程序中断，但是我想看到程序输出的结果。</p>
<p><strong>15. 暂停 UI 在 Hover 状态下的展示结果</strong></p>
<p>我们很难去检查一个只有在 Hover 状态下展示的元素。比如，如何去检查一个 tooltip？如果你右键并选择检查，元素已经消失了。那么有办法吗？</p>
<p>我是这么操作的：</p>
<ol>
<li>打开 sources 面板</li>
<li>显示 tooltip</li>
<li>使用快捷键来暂停脚本执行(将鼠标停留在暂停的图标上查看快捷键)</li>
<li>回到 Elements 面板，然后像通常一样去检查元素</li>
</ol>
<p><a href="https://gitee.com/evestorm/various_resources/raw/master/tools/tooltips.gif"><img src="%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%9120%E4%B8%AAChromeDevTools%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/tooltips.gif" alt="img"></a></p>
<img src="/posts/709/tooltips.gif" class="" title="tooltips">

<p><strong>16. XHR breakpoints</strong></p>
<p>如果想要理解一个请求是如何执行的，可以使用 sources 面板的 XHR breakpoints。</p>
<p><strong>17. 使用 DevTools 作为 IDE</strong></p>
<p>DevTools 的 source 面板可以说相当强大。你可以快速查找，跳转到某一行，某个函数，执行一段代码，使用多行光标等等。这些功能在<a href="https://medium.com/google-developers/devtools-tips-for-sublime-text-users-cdd559ee80f8">这篇 medium 文章中有详细描述</a>。</p>
<p>既然如此，为啥不把整个开发都搬到这里呢。这样就不需要浪费时间切换 IDE 和浏览器了。</p>
<p>如果你有一个使用<a href="https://github.com/facebook/create-react-app">create-react-app</a>或则<a href="https://github.com/vuejs/vue-cli">vue-cli</a>构建的项目，你可以直接把整个文件夹拖到 Sources 面板下。DevTools 会自动对所有文件做映射。所以，你可以在 DevTools 下修改文件并立即查看。这样，整个开发效率，特别是 Debugging 效率绝对提高了。</p>
<img src="/posts/709/ide.gif" class="" title="ide">

<p><strong>18. 使用 network overrides 来简单调试生产代码</strong></p>
<p>如果你正在 Debugging 一个生产环境下面的 bug，你可以使用<code>network overrides</code>来调试，而不用在本地搭建整个配置。</p>
<p>你可以很容易将任何远程的资源下载一份本地的版本，然后可以在 DevTools 下编辑，并且 DevTools 会更新展示你编辑后的文件。</p>
<img src="/posts/709/networkoverrides.gif" class="" title="networkoverrides">

<p>在生产环境下，也可以很容易 Debugging，并且做一些性能上的测试也变得容易。</p>
<h3 id="19-Nodejs-debugging"><a href="#19-Nodejs-debugging" class="headerlink" title="19. Nodejs debugging"></a><strong>19. Nodejs debugging</strong></h3><p>如果你想使用 DevTools 的 Debugger 来 debug Node.js 应用，你可以使用<code>--inspect-brk</code> flag 来开启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node --inspect-brk script.js</span><br></pre></td></tr></table></figure>

<p>跳转到<code>chrome://inspect</code>页面，在<code>Remote Target</code>选项，可以看到 Node 程序。</p>
<p>并且，在 DevTools 中你会看到一个绿色的 Node 图标，点击图标会打开针对 Node 的 Chrome Debugger。</p>
<p><a href="https://gitee.com/evestorm/various_resources/raw/master/tools/node-debuger.gif"><img src="%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%9120%E4%B8%AAChromeDevTools%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/node-debuger.gif" alt="img"></a></p>
<img src="/posts/709/node-debuger.gif" class="" title="node-debuger">

<p>如果你想要用 DevTools Debugger 来 debug 你的单元测试，你需要这样调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copynode --inspect-brk .&#x2F;node_modules&#x2F;.bin&#x2F;jest</span><br></pre></td></tr></table></figure>

<p>不过这样做其实很麻烦，我们需要自己找到相应的路径。 GoogleChromeLabs 最近发布了一个新的工具非常好用，叫做：<a href="https://github.com/GoogleChromeLabs/ndb">ndb</a>。使用 ndb，你只需要：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ndb npx jest</span><br></pre></td></tr></table></figure>

<p>如果你有一个自定义的脚本，你可以这样调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ndb npm run unit</span><br></pre></td></tr></table></figure>

<p>更妙的是，如果你在一个有配置<code>package.json</code>的项目下调用<code>ndb</code>，他甚至会自动分析 package.json 中的脚本，方便你直接使用 DevTools。</p>
<p><strong>20. 使用 Snippets 来辅助 Debugging</strong></p>
<p>DevTools 提供了一个可以创建和保存小段代码的工具，我很喜欢用它们来加速我的工作。比如 lodashify —  可以快速给任何应用添加 lodash。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  element.src =</span><br><span class="line">    <span class="string">&#x27;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.15.0/lodash.min.js&#x27;</span>;</span><br><span class="line">  element.type = <span class="string">&#x27;text/javascript&#x27;</span>;</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(element);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>另一个小的工具函数式用来增强对象的属性，每次被访问或则修改，它都会提供给我充分的信息，比如谁访问了，谁更改了它。在 Debugging 的时候，非常有用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> traceProperty = <span class="function">(<span class="params">object, property</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> value = object[property];</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(object, property, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.trace(<span class="string">`<span class="subst">$&#123;property&#125;</span> requested`</span>);</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.trace(<span class="string">`setting <span class="subst">$&#123;property&#125;</span> to `</span>, newValue);</span><br><span class="line">      value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://gitee.com/evestorm/various_resources/raw/master/tools/methodtools.gif"><img src="%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%9120%E4%B8%AAChromeDevTools%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/methodtools.gif" alt="img"></a></p>
<img src="/posts/709/methodtools.gif" class="" title="methodtools">

<p>还有很多非常有用的<a href="http://bgrins.github.io/devtools-snippets/">devtools 代码片段</a>，你可以直接拿去使用。</p>
<h3 id="关于-Fundebug"><a href="#关于-Fundebug" class="headerlink" title="关于 Fundebug"></a>关于 Fundebug</h3><p><a href="https://www.fundebug.com/">Fundebug</a>专注于 JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js 和 Java 实时 BUG 监控。 自从 2016 年双十一正式上线，Fundebug 累计处理了 6 亿+错误事件，得到了 Google、360、金山软件等众多知名用户的认可。欢迎免费试用！</p>
<p>版权声明:<br>转载时请注明作者 Fundebug 以及本文地址：<br><a href="https://blog.fundebug.com/2018/08/22/art-of-debugging-with-chrome-devtools/">https://blog.fundebug.com/2018/08/22/art-of-debugging-with-chrome-devtools/</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】git配置ssh服务</title>
    <url>/posts/1071/</url>
    <content><![CDATA[<p>原文：<a href="https://juejin.cn/post/6844904066032599054">https://juejin.cn/post/6844904066032599054</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在管理 Git 项目上，很多时候都是直接使用<code>https url</code>克隆到本地，当然也有有些人使用<code>SSH url</code>克隆到本地。</p>
<p>这两种方式的主要区别在于：</p>
<ul>
<li>使用<code>https url</code>克隆对初学者来说会比较方便，复制<code>https url</code>然后到 git Bash 里面直接用 clone 命令克隆到本地就好了，但是每次 fetch 和 push 代码都需要输入账号和密码，这也是 https 方式的麻烦之处。</li>
<li>而使用<code>SSH url</code>克隆却需要在克隆之前先配置和添加好<code>SSH key</code>，因此，如果你想要使用<code>SSH url</code>克隆的话，你必须是这个项目的拥有者。否则你是无法添加<code>SSH key</code>的，另外 ssh 默认是每次 fetch 和 push 代码都不需要输入账号和密码，如果你想要每次都输入账号密码才能进行 fetch 和 push 也可以另外进行设置。</li>
</ul>
<p>下面主要是讲述如何配置使用 ssh 方式来提交和克隆代码。</p>
<a id="more"></a>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="配置本机-ssh"><a href="#配置本机-ssh" class="headerlink" title="配置本机 ssh"></a>配置本机 ssh</h2><h3 id="一、确定的是你的电脑上是安装过-Git"><a href="#一、确定的是你的电脑上是安装过-Git" class="headerlink" title="一、确定的是你的电脑上是安装过 Git"></a>一、确定的是你的电脑上是安装过 Git</h3><p>打开<code>cmd</code>，查看 git 版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入：git --version</span><br><span class="line">显示：git version 2.20.1.windows.1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果显示类似<code>git version 2.20.1.windows.1</code>的 Git 版本，说明你的电脑是安装过 Git 的；否则请左转<a href="https://juejin.im/post/6844903749631098893#heading-4">打开 Git 的正确姿势</a>，把 Git 安装完了再来，不送。</p>
<h3 id="二、查看是否配置了-git-用户名和邮箱"><a href="#二、查看是否配置了-git-用户名和邮箱" class="headerlink" title="二、查看是否配置了 git 用户名和邮箱"></a>二、查看是否配置了 git 用户名和邮箱</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入：git config user.name</span><br><span class="line">显示：用户名</span><br><span class="line">输入：git config user.email</span><br><span class="line">显示用户邮箱</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果没有配置，那么需要配置用户名和邮箱：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入：git config --global user.name &quot;xxx&quot;</span><br><span class="line"></span><br><span class="line">输入：git config --global user.email &quot;xxx&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="三、查看是否配置过-SSH-Key-密钥"><a href="#三、查看是否配置过-SSH-Key-密钥" class="headerlink" title="三、查看是否配置过 SSH Key(密钥)"></a>三、查看是否配置过 SSH Key(密钥)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入：cd ~/.ssh</span><br><span class="line">输入：ls，</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>查看该文件下的文件，看是否存在 <code>id_isa</code> 和 <code>id_isa.pub</code> 文件（也可以是别的文件名，只要 <code>yourName</code> 和 <code>yourName.pub</code> 成对存在就可以），如果存在的话，证明已经存在 ssh key 了，可以直接跳过<code>4、生成SSH Key</code>这一步骤，</p>
<h3 id="四、生成-SSH-Key-密钥"><a href="#四、生成-SSH-Key-密钥" class="headerlink" title="四、生成 SSH Key(密钥)"></a>四、生成 SSH Key(密钥)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入: ssh-keygen -t rsa -C &quot;你的邮箱&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>此处会提示<code>Enter file in which to save the key (/Users/shutong/.ssh/id_rsa):</code>这样一段内容,让我们输入文件名，如果第 3 步的文件存在的话最好在这里修改一下文件名以防覆盖之前的内容；如果第 3 步的文件不存在的话则直接按<code>enter</code>键就好了。</p>
<p>之后会有提示你是否需要设置密码，如果设置了每次使用 Git 都会用到密码，一般都是直接不写为空，直接<code>enter</code>就好了。</p>
<p>上述操作执行完毕后，在<code>~/.ssh/</code>目录会生成<code>XXX-rsa</code>(私钥)和<code>XXX-rsa.pub</code>(公钥)，它们默认的存储路径是：</p>
<blockquote>
<p>C:\Users\Administrator.ssh</p>
</blockquote>
<p><strong>注意</strong></p>
<blockquote>
<p>个人建议生成的 rsa 最好单独命名不要使用默认名称，因为有可能 sshkey 可能会用在多个地方，一不小心就可能被覆盖然后导致 git 功能异常</p>
</blockquote>
<h3 id="五、添加公钥到你的远程仓库（github）"><a href="#五、添加公钥到你的远程仓库（github）" class="headerlink" title="五、添加公钥到你的远程仓库（github）"></a>五、添加公钥到你的远程仓库（github）</h3><h4 id="1-、查看你生成的公钥："><a href="#1-、查看你生成的公钥：" class="headerlink" title="1 、查看你生成的公钥："></a>1 、查看你生成的公钥：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入：cat ~/.ssh/id_rsa.pub</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里会把公钥显示出来，我们把这段内容复制出来。</p>
<h4 id="2、添加公钥到远程仓库"><a href="#2、添加公钥到远程仓库" class="headerlink" title="2、添加公钥到远程仓库:"></a>2、添加公钥到远程仓库:</h4><p>登陆你的 github 帐户 -&gt; 点击你的头像，然后点击 <code>Settings</code> -&gt; 左栏点击 <code>SSH and GPG keys</code> -&gt; 点击 <code>New SSH key</code></p>
<p>然后将复制的公钥内容，粘贴进<code>Key</code>文本域内。 <code>title</code>域，自己随便起个名字。</p>
<p>点击 <code>Add SSH key</code>。</p>
<h4 id="2、查看-ssh-文件是否配置成功"><a href="#2、查看-ssh-文件是否配置成功" class="headerlink" title="2、查看 ssh 文件是否配置成功"></a>2、查看 ssh 文件是否配置成功</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入： ssh -T git@github.com</span><br><span class="line">输出： Hi danygitgit! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>恭喜你，你的设置已经成功了。</p>
<h3 id="六、修改-git-的-remote-url"><a href="#六、修改-git-的-remote-url" class="headerlink" title="六、修改 git 的 remote url"></a>六、修改 git 的 remote url</h3><p>如果之前添加的是<code>HTTPS</code>协议的 github 仓库地址，那么每次 push 或者 pull 仍然需要密码，所以，我们需要将其修改为<code>ssh</code>协议的，这样，就不需要这么麻烦了。</p>
<p>那么我们应该怎么办呢？</p>
<h4 id="1、查看当前的-remote-url"><a href="#1、查看当前的-remote-url" class="headerlink" title="1、查看当前的 remote url"></a>1、查看当前的 remote url</h4><p>首先进入本地仓库，右键 -&gt; <code>Git Bash Here</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入： git remote -v</span><br><span class="line">输出： origin https://github.com/danygitgit/document-library.git (fetch)</span><br><span class="line">输出： origin https://github.com/danygitgit/document-library.git (push)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果是以上的结果那么说明此项目是使用<code>https</code>协议进行访问的（如果地址是 git 开头则表示是<code>git</code>协议）</p>
<h4 id="2、复制远程仓库的-ssh-链接"><a href="#2、复制远程仓库的-ssh-链接" class="headerlink" title="2、复制远程仓库的 ssh 链接"></a>2、复制远程仓库的 ssh 链接</h4><p>登陆你的远程仓库，在上面可以看到你的 ssh 协议相应的 url，类似：</p>
<blockquote>
<p><a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#x69;&#116;&#104;&#117;&#x62;&#46;&#99;&#x6f;&#x6d;">&#x67;&#105;&#116;&#64;&#103;&#x69;&#116;&#104;&#117;&#x62;&#46;&#99;&#x6f;&#x6d;</a>:danygitgit/document-library.git</p>
</blockquote>
<p>复制此 ssh 链接。</p>
<h4 id="2、修改-git-的-remote-url"><a href="#2、修改-git-的-remote-url" class="headerlink" title="2、修改 git 的 remote url"></a>2、修改 git 的 remote url</h4><p>方法有三种：</p>
<ol>
<li>修改命令</li>
</ol>
<blockquote>
<p>git remote origin set-url [url]</p>
</blockquote>
<ol>
<li>先删后加</li>
</ol>
<blockquote>
<p>git remote rm origin git remote add origin [url]</p>
</blockquote>
<ol>
<li>直接修改<code>config</code>文件</li>
</ol>
<p>找到仓库下 <code>.git</code> 文件夹下的<code>config</code>文件，打开，可以看到以下内容</p>
<blockquote>
<p>[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote “origin”] url =<a href="https://github.com/danygitgit/document-library.git">https://github.com/danygitgit/document-library.git</a> fetch = +refs/heads/<em>:refs/remotes/origin/</em>[branch “master”] remote = origin merge = refs/heads/master</p>
</blockquote>
<p>将文件中的 <code>url =https://github.com/danygitgit/document-library.git</code>更改为 <code>url = git@github.com:danygitgit/document-library.git</code> 即可。</p>
<p>修改后的文件如下</p>
<blockquote>
<p>[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote “origin”] url = <a href="mailto:&#x67;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#111;&#109;">&#x67;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#111;&#109;</a>:danygitgit/document-library.git fetch = +refs/heads/<em>:refs/remotes/origin/</em>[branch “master”] remote = origin merge = refs/heads/master</p>
</blockquote>
<p>以后，不管是 push 还是 pull，你都不需要再提交密码了。</p>
<h3 id="七、Sourcetree-配置-ssh-密钥"><a href="#七、Sourcetree-配置-ssh-密钥" class="headerlink" title="七、Sourcetree 配置 ssh 密钥"></a>七、Sourcetree 配置 ssh 密钥</h3><p><code>SourceTree</code>是一款 git 管理可视化工具，就不需要繁琐的敲打命令行了。个人比较推荐，无论在 windows 环境还是 mac 的 os 环境。<a href="https://www.sourcetreeapp.com/">官网链接</a></p>
<p>关于<code>SourceTree</code>的安装及配置就不赘述了，具体请参考</p>
<ul>
<li><a href="https://blog.csdn.net/wangjiangrong/article/details/80287041">Git SourceTree 免登陆安装及配置 生成 ssh</a></li>
<li><a href="https://www.cnblogs.com/liuxin-673855200/p/11151835.html">SOURCETREE 3.1.3 版本跳过 BITBUCKET 注册方法（亲测好用） | 淡忘&amp;天涯</a></li>
<li><a href="https://jingyan.baidu.com/article/9faa7231cdec65473d28cb11.html">Sourcetree 配置 ssh 密钥</a></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>磨刀不误砍柴工。勇于尝试，善于总结。开启你的 Git 踩坑之旅吧！</p>
<p>路漫漫其修远兮，希望 Git 可以帮我们记录每一个脚印，每一步成长。与诸君共勉。</p>
<p>祝大家 2020 更上一层楼！</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】彻底理解cookie-session-token</title>
    <url>/posts/44111/</url>
    <content><![CDATA[<h2 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h2><p>1、很久很久以前，Web 基本上就是文档的浏览而已， 既然是浏览，作为服务器， 不需要记录谁在某一段时间里都浏览了什么文档，每次请求都是一个新的HTTP协议， 就是请求加响应， 尤其是我不用记住是谁刚刚发了HTTP请求， 每个请求对我来说都是全新的。这段时间很嗨皮</p>
<p>2、但是随着交互式Web应用的兴起，像在线购物网站，需要登录的网站等等，马上就面临一个问题，那就是要管理会话，必须记住哪些人登录系统， 哪些人往自己的购物车中放商品， 也就是说我必须把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，所以想出的办法就是给大家发一个会话标识(session id), 说白了就是一个随机的字串，每个人收到的都不一样， 每次大家向我发起HTTP请求的时候，把这个字符串给一并捎过来， 这样我就能区分开谁是谁了</p>
<p>3、这样大家很嗨皮了，可是服务器就不嗨皮了，每个人只需要保存自己的session id，而服务器要保存所有人的session id ！ 如果访问服务器多了， 就得由成千上万，甚至几十万个。</p>
<p>这对服务器说是一个巨大的开销 ， 严重的限制了服务器扩展能力， 比如说我用两个机器组成了一个集群， 小F通过机器A登录了系统， 那session id会保存在机器A上， 假设小F的下一次请求被转发到机器B怎么办？ 机器B可没有小F的 session id啊。</p>
<p>有时候会采用一点小伎俩： session sticky ， 就是让小F的请求一直粘连在机器A上， 但是这也不管用， 要是机器A挂掉了， 还得转到机器B去。</p>
<p>那只好做session 的复制了， 把session id 在两个机器之间搬来搬去， 快累死了。</p>
<a id="more"></a>

<img src="/posts/44111/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A11.png" class="" title="负载均衡1">

<p>后来有个叫Memcached的支了招： 把session id 集中存储到一个地方， 所有的机器都来访问这个地方的数据， 这样一来，就不用复制了， 但是增加了单点失败的可能性， 要是那个负责session 的机器挂了， 所有人都得重新登录一遍， 估计得被人骂死。</p>
<img src="/posts/44111/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A12.png" class="" title="负载均衡2">

<p>也尝试把这个单点的机器也搞出集群，增加可靠性， 但不管如何， 这小小的session 对我来说是一个沉重的负担</p>
<p>4、于是有人就一直在思考， 我为什么要保存这可恶的session呢， 只让每个客户端去保存该多好？</p>
<p>可是如果不保存这些session id , 怎么验证客户端发给我的session id 的确是我生成的呢？ 如果不去验证，我们都不知道他们是不是合法登录的用户， 那些不怀好意的家伙们就可以伪造session id , 为所欲为了。</p>
<p>嗯，对了，关键点就是验证 ！</p>
<p>比如说， 小F已经登录了系统， 我给他发一个令牌(token)， 里边包含了小F的 user id， 下一次小F 再次通过Http 请求访问我的时候， 把这个token 通过Http header 带过来不就可以了。</p>
<p>不过这和session id没有本质区别啊， 任何人都可以可以伪造， 所以我得想点儿办法， 让别人伪造不了。</p>
<p>那就对数据做一个签名吧， 比如说我用HMAC-SHA256 算法，加上一个只有我才知道的密钥， 对数据做一个签名， 把这个签名和数据一起作为token ， 由于密钥别人不知道， 就无法伪造token了。</p>
<img src="/posts/44111/token%E7%AE%97%E6%B3%95.png" class="" title="token算法">

<p>这个token 我不保存， 当小F把这个token 给我发过来的时候，我再用同样的HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名， 和token 中的签名做个比较， 如果相同， 我就知道小F已经登录过了，并且可以直接取到小F的user id , 如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者： 对不起，没有认证。</p>
<img src="/posts/44111/token%E9%AA%8C%E8%AF%81.png" class="" title="token验证">

<p>Token 中的数据是明文保存的（虽然我会用Base64做下编码， 但那不是加密）， 还是可以被别人看到的， 所以我不能在其中保存像密码这样的敏感信息。</p>
<p>当然， 如果一个人的token 被别人偷走了， 那我也没办法， 我也会认为小偷就是合法用户， 这其实和一个人的session id 被别人偷走是一样的。</p>
<p>这样一来， 我就不保存session id 了， 我只是生成token , 然后验证token ， 我用我的CPU计算时间获取了我的session 存储空间 ！</p>
<p>解除了session id这个负担， 可以说是无事一身轻， 我的机器集群现在可以轻松地做水平扩展， 用户访问量增大， 直接加机器就行。 这种无状态的感觉实在是太好了！</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。</p>
<p>cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。</p>
<p>session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。</p>
<p>服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。</p>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。</p>
<p>以下几点特性会让你在程序中使用基于Token的身份验证</p>
<ol>
<li>无状态、可扩展</li>
<li>支持移动设备</li>
<li>跨程序调用</li>
<li>安全</li>
</ol>
<p>那些使用基于Token的身份验证的大佬们</p>
<p>大部分你见到过的API和Web应用都使用tokens。例如Facebook, Twitter, Google+, GitHub等。</p>
<h3 id="Token的起源"><a href="#Token的起源" class="headerlink" title="Token的起源"></a>Token的起源</h3><p>在介绍基于Token的身份验证的原理与优势之前，不妨先看看之前的认证都是怎么做的。</p>
<h4 id="基于服务器的验证"><a href="#基于服务器的验证" class="headerlink" title="基于服务器的验证"></a>基于服务器的验证</h4><p>我们都是知道HTTP协议是无状态的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。</p>
<p>在这之前，程序都是通过在服务端存储的登录信息来辨别请求的。这种方式一般都是通过存储Session来完成。</p>
<p>下图展示了基于服务器验证的原理</p>
<img src="/posts/44111/session.png" class="" title="session">

<p>随着Web，应用程序，已经移动端的兴起，这种验证的方式逐渐暴露出了问题。尤其是在可扩展性方面。</p>
<h4 id="基于服务器验证方式暴露的一些问题"><a href="#基于服务器验证方式暴露的一些问题" class="headerlink" title="基于服务器验证方式暴露的一些问题"></a>基于服务器验证方式暴露的一些问题</h4><ol>
<li>Session：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。</li>
<li>可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。</li>
<li>CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。</li>
<li>CSRF(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。</li>
</ol>
<p>在这些问题中，可扩展行是最突出的。因此我们有必要去寻求一种更有行之有效的方法。</p>
<h4 id="基于Token的验证原理"><a href="#基于Token的验证原理" class="headerlink" title="基于Token的验证原理"></a>基于Token的验证原理</h4><p>基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。</p>
<p>这种概念解决了在服务端存储信息时的许多问题</p>
<p>NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。</p>
<p>基于Token的身份验证的过程如下:</p>
<ol>
<li>用户通过用户名和密码发送请求。</li>
<li>程序验证。</li>
<li>程序返回一个签名的token 给客户端。</li>
<li>客户端储存token,并且每次用于每次发送请求。</li>
<li>服务端验证token并返回数据。</li>
</ol>
<p>每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control-Allow-Origin: *，让服务器能接受到来自所有域的请求。需要主要的是，在ACAO头部标明(designating)*时，不得带有像HTTP认证，客户端SSL证书和cookies的证书。</p>
<p>实现思路：</p>
<img src="/posts/44111/token%E6%B5%81%E7%A8%8B.png" class="" title="token流程">

<ol>
<li>用户登录校验，校验成功后就返回Token给客户端。</li>
<li>客户端收到数据后保存在客户端</li>
<li>客户端每次访问API是携带Token到服务器端。</li>
<li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li>
</ol>
<p>当我们在程序中认证了信息并取得token之后，我们便能通过这个Token做许多的事情。</p>
<p>我们甚至能基于创建一个基于权限的token传给第三方应用程序，这些第三方程序能够获取到我们的数据（当然只有在我们允许的特定的token）</p>
<h4 id="Tokens的优势"><a href="#Tokens的优势" class="headerlink" title="Tokens的优势"></a>Tokens的优势</h4><p><strong>无状态、可扩展</strong></p>
<p>在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。</p>
<p>如果我们将已验证的用户的信息保存在Session中，则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。用户量大时，可能会造成一些拥堵。</p>
<p>但是不要着急。使用tokens之后这些问题都迎刃而解，因为tokens自己hold住了用户的验证信息。</p>
<p><strong>安全性</strong></p>
<p>请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。</p>
<p>token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。</p>
<p><strong>可扩展性</strong></p>
<p>Tokens能够创建与其它程序共享权限的程序。例如，能将一个随便的社交帐号和自己的大号(Fackbook或是Twitter)联系起来。当通过服务登录Twitter(我们将这个过程Buffer)时，我们可以将这些Buffer附到Twitter的数据流上(we are allowing Buffer to post to our Twitter stream)。</p>
<p>使用tokens时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问它们的数据，我们可以通过建立自己的API，得出特殊权限的tokens。</p>
<p><strong>多平台跨域</strong></p>
<p>我们提前先来谈论一下CORS(跨域资源共享)，对应用程序和服务进行扩展的时候，需要介入各种各种的设备和应用程序。</p>
<p>Having our API just serve data, we can also make the design choice to serve assets from a CDN. This eliminates the issues that CORS brings up after we set a quick header configuration for our application.</p>
<p>只要用户有一个通过了验证的token，数据和资源就能够在任何域上被请求到。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>

<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://zhuanlan.zhihu.com/p/63061864">https://zhuanlan.zhihu.com/p/63061864</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】使用Object键值替换Switch</title>
    <url>/posts/10849/</url>
    <content><![CDATA[<p>转载地址：<a href="https://www.cnblogs.com/ZerlinM/p/13595810.html">https://www.cnblogs.com/ZerlinM/p/13595810.html</a><br>原文地址：<a href="https://ultimatecourses.com/blog/deprecating-the-switch-statement-for-object-literals">https://ultimatecourses.com/blog/deprecating-the-switch-statement-for-object-literals</a></p>
<p>在许多编程语言中，switch 语句存在 - 但是它应该更长吗？如果你是一个 JavaScript 程序员，你经常跳进和跳出对象，创建，实例化和操作它们。对象非常灵活，它们是 JavaScript 中几乎所有内容的核心，使用它们代替 switch 语句是我最近一直在做的事情。</p>
<a id="more"></a>

<h2 id="什么是-switch-语句"><a href="#什么是-switch-语句" class="headerlink" title="什么是 switch 语句?"></a>什么是 switch 语句?</h2><p>如果您以前没有使用 switch 过或者有点不确定它是做什么的，那么让我们来看看吧。什么 switch 是输入并提供输出，例如正在运行的代码。<br>让我们来看一个通常的 switch 陈述：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="string">&#x27;coke&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> drink;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;coke&#x27;</span>:</span><br><span class="line">    drink = <span class="string">&#x27;Coke&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;pepsi&#x27;</span>:</span><br><span class="line">    drink = <span class="string">&#x27;Pepsi&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    drink = <span class="string">&#x27;Unknown drink!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(drink); <span class="comment">// &#x27;Coke&#x27;</span></span><br></pre></td></tr></table></figure>

<p>它类似于 if 和 else 语句，但它应该评估单个值 - 在 switch 我们使用 a case 来评估每个值。<br>当你开始看到很多 else if 陈述时，某些东西可能是错误的，通常你会使用类似于 switch 它更适合目的和意图的东西。这是一些 else if 滥用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDrink</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;coke&#x27;</span>) &#123;</span><br><span class="line">    type = <span class="string">&#x27;Coke&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;pepsi&#x27;</span>) &#123;</span><br><span class="line">    type = <span class="string">&#x27;Pepsi&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;mountain dew&#x27;</span>) &#123;</span><br><span class="line">    type = <span class="string">&#x27;Mountain Dew&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;lemonade&#x27;</span>) &#123;</span><br><span class="line">    type = <span class="string">&#x27;Lemonade&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;fanta&#x27;</span>) &#123;</span><br><span class="line">    type = <span class="string">&#x27;Fanta&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// acts as our &quot;default&quot;</span></span><br><span class="line">    type = <span class="string">&#x27;Unknown drink!&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;You&#x27;ve picked a &quot;</span> + type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现太松散了，有错误的余地，加上它是一个非常冗长的语法，可以不断重复自己。还有一个黑客攻击的空间，因为你可以评估每个内部的多个表达式 else if，例如 else if (type === ‘coke’ &amp;&amp; somethingElse ！== ‘apples’)。这 switch 是该工作的最佳工具，尽管您需要不断添加 break;语句以防止案件失败，这是其众多问题之一。</p>
<h2 id="开关问题"><a href="#开关问题" class="headerlink" title="开关问题"></a>开关问题</h2><p>switch 从程序控制流程到其处理代码块的非标准方式存在多个问题，其余的 JavaScript 使用花括号而交换机则不然。从语法上讲，它不是 JavaScript 的最佳选择，也不是它的设计。我们被迫 break;在每个语句中手动添加语句 case，这可能导致难以调试和嵌套错误，如果我们忘记了！道格拉斯·克罗克福德（Douglas Crockford）曾多次撰写和谈论过这个问题，他的建议是谨慎对待。</p>
<p>我们经常在 JavaScript 中使用 Object 查找，通常用于我们永远不会考虑使用的东西 switch- 那么为什么不使用 Object 键值替换 switch？对象更灵活，具有更好的可读性和可维护性，我们不需要手动 break;每个“案例”。他们对新的 JavaScript 开发人员也很友好，因为他们是标准对象。</p>
<p>随着“案例”数量的增加，对象（哈希表）的性能优于交换机的平均成本（案例的顺序很重要）。对象方法是哈希表查找，并且交换机必须评估每个案例，直到它遇到匹配和中断。</p>
<h2 id="对象文本查找"><a href="#对象文本查找" class="headerlink" title="对象文本查找"></a>对象文本查找</h2><p>我们一直使用对象，无论是构造函数还是文字。通常，我们将它们用于对象查找目的，以从 Object 属性中获取值。<br>让我们设置一个 String 仅返回值的简单 Object 键值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDrink</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> drinks = &#123;</span><br><span class="line">    coke: <span class="string">&#x27;Coke&#x27;</span>,</span><br><span class="line">    pepsi: <span class="string">&#x27;Pepsi&#x27;</span>,</span><br><span class="line">    lemonade: <span class="string">&#x27;Lemonade&#x27;</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">&#x27;Default item&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;The drink I chose was &#x27;</span> + (drinks[type] || drinks[<span class="string">&#x27;default&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> drink = getDrink(<span class="string">&#x27;coke&#x27;</span>);</span><br><span class="line"><span class="comment">// The drink I chose was Coke</span></span><br><span class="line"><span class="built_in">console</span>.log(drink);</span><br></pre></td></tr></table></figure>

<p>我们从交换机中保存了几行代码，对我而言，数据在演示中更加清晰。我们甚至可以进一步简化它，没有默认情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDrink</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="string">&#x27;The drink I chose was &#x27;</span> +</span><br><span class="line">    &#123;</span><br><span class="line">      coke: <span class="string">&#x27;Coke&#x27;</span>,</span><br><span class="line">      pepsi: <span class="string">&#x27;Pepsi&#x27;</span>,</span><br><span class="line">      lemonade: <span class="string">&#x27;Lemonade&#x27;</span></span><br><span class="line">    &#125;[type]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，我们可能需要比 a 更复杂的代码 String，这可能会挂在函数内部。为了简洁和易于理解的示例，我将从新创建的函数返回上述字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="string">&#x27;coke&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> drinks = &#123;</span><br><span class="line">  coke: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Coke&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  pepsi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Pepsi&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  lemonade: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Lemonade&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>区别在于我们需要调用 Object 文字的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">drinks[type]();</span><br></pre></td></tr></table></figure>

<p>更具可维护性和可读性。我们也不必担心 break;陈述和案例会失败-这只是一个普通的对象。<br>通常，我们会 switch 在函数内部放入一个 return 值，因此在这里做同样的事情，然后将对象文字查找转换为可用的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDrink</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> drinks = &#123;</span><br><span class="line">    coke: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Coke&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    pepsi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Pepsi&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    lemonade: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Lemonade&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> drinks[type]();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let&#x27;s call it</span></span><br><span class="line"><span class="keyword">var</span> drink = getDrink(<span class="string">&#x27;coke&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(drink); <span class="comment">// &#x27;Coke&#x27;</span></span><br></pre></td></tr></table></figure>

<p>不错，很容易，但这并不能满足“ default”的要求 case，因此我们可以轻松创建它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDrink</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn;</span><br><span class="line">  <span class="keyword">var</span> drinks = &#123;</span><br><span class="line">    coke: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Coke&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    pepsi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Pepsi&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    lemonade: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Lemonade&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Default item&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// if the drinks Object contains the type</span></span><br><span class="line">  <span class="comment">// passed in, let&#x27;s use it</span></span><br><span class="line">  <span class="keyword">if</span> (drinks[type]) &#123;</span><br><span class="line">    fn = drinks[type];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// otherwise we&#x27;ll assign the default</span></span><br><span class="line">    <span class="comment">// also the same as drinks.default</span></span><br><span class="line">    <span class="comment">// it&#x27;s just a little more consistent using square</span></span><br><span class="line">    <span class="comment">// bracket notation everywhere</span></span><br><span class="line">    fn = drinks[<span class="string">&#x27;default&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// called with &quot;dr pepper&quot;</span></span><br><span class="line"><span class="keyword">var</span> drink = getDrink(<span class="string">&#x27;dr pepper&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(drink); <span class="comment">// &#x27;Default item&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们可以简化上面的内容，if 并在表达式中 else 使用 or ||运算符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDrink</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> drinks = &#123;</span><br><span class="line">    coke: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Coke&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    pepsi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Pepsi&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    lemonade: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Lemonade&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Default item&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (drinks[type] || drinks[<span class="string">&#x27;default&#x27;</span>])();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会将两个对象查找包装在括号内( )，将它们视为表达式。然后调用表达式的结果。如果 drinks[type]在查找中未找到，则默认为 drinks[‘default’]，简单！<br>我们不具备总是 return 里面的函数或者，我们可以改变引用任何变量然后返回它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDrink</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> drink;</span><br><span class="line">  <span class="keyword">var</span> drinks = &#123;</span><br><span class="line">    coke: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      drink = <span class="string">&#x27;Coke&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    pepsi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      drink = <span class="string">&#x27;Pepsi&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    lemonade: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      drink = <span class="string">&#x27;Lemonade&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      drink = <span class="string">&#x27;Default item&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// invoke it</span></span><br><span class="line">  (drinks[type] || drinks[<span class="string">&#x27;default&#x27;</span>])();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return a String with chosen drink</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;The drink I chose was &#x27;</span> + drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> drink = getDrink(<span class="string">&#x27;coke&#x27;</span>);</span><br><span class="line"><span class="comment">// The drink I chose was Coke</span></span><br><span class="line"><span class="built_in">console</span>.log(drink);</span><br></pre></td></tr></table></figure>

<p>这些是非常基本的解决方案，而 Object 字面量包含一个 function 返回 a 的值 String，在您只需要 a 的情况下 String，可以将 a String 用作键的值-在某些情况下，该函数将包含逻辑，该逻辑将从该函数返回。如果您要混合使用函数和字符串，则始终可以使用函数来保存查找 type 和调用（如果是函数）会更容易-我们不想尝试调用 String。</p>
<h2 id="对象字面量“告吹”"><a href="#对象字面量“告吹”" class="headerlink" title="对象字面量“告吹”"></a>对象字面量“告吹”</h2><p>对于 switch 案例，我们可以让它们失败（这意味着一个以上的案例可以应用于特定的代码段）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="string">&#x27;coke&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> snack;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;coke&#x27;</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;pepsi&#x27;</span>:</span><br><span class="line">    snack = <span class="string">&#x27;Drink&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;cookies&#x27;</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;crisps&#x27;</span>:</span><br><span class="line">    snack = <span class="string">&#x27;Food&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    drink = <span class="string">&#x27;Unknown type!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(snack); <span class="comment">// &#x27;Drink&#x27;</span></span><br></pre></td></tr></table></figure>

<p>让我们 coke 和 pepsi“贯穿”以不添加 break 语句。为 Object Literals 执行此操作非常简单且更具说明性 - 并且不易出错。我们的代码突然变得更加结构化，可读性和可重用性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSnack</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> snack;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isDrink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (snack = <span class="string">&#x27;Drink&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isFood</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (snack = <span class="string">&#x27;Food&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> snacks = &#123;</span><br><span class="line">    coke: isDrink,</span><br><span class="line">    pepsi: isDrink,</span><br><span class="line">    cookies: isFood,</span><br><span class="line">    crisps: isFood</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> snacks[type]();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> snack = getSnack(<span class="string">&#x27;coke&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(snack); <span class="comment">// &#x27;Drink&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Object 键值是 JavaScript 中流动的一种更自然的控制，switch 有点陈旧和笨重，并且容易出现调试错误。对象更具可扩展性，可维护性，我们可以更好地测试它们。它们也是设计模式的一部分，在日常的其他编程任务中非常常用。对象键值可以包含函数以及任何其他对象类型，这使它们非常灵活！键值中的每个函数也都有函数作用域，因此我们可以从我们调用的父函数 getDrink 返回闭包（在这种情况下返回闭包）。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】滚动视差-CSS不在话下</title>
    <url>/posts/56953/</url>
    <content><![CDATA[<p>掘金链接：<a href="https://juejin.im/post/5b6d0756e51d4562b31ad23c">https://juejin.im/post/5b6d0756e51d4562b31ad23c</a></p>
<p>github 链接：<a href="https://github.com/chokcoco/iCSS/issues/37">https://github.com/chokcoco/iCSS/issues/37</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>一些有用的npm包</title>
    <url>/posts/44396/</url>
    <content><![CDATA[<h2 id="runjs"><a href="#runjs" class="headerlink" title="runjs"></a>runjs</h2><blockquote>
<p>已改名为 tasksfile ，<code>npm install tasksfile</code> 代替</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一个小型构件工具</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install runjs -D</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在根项目目录中创建 <code>runfile.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; run &#125; = <span class="built_in">require</span>(<span class="string">&#x27;runjs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">name = <span class="string">&#x27;Mysterious&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makedir</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  run(<span class="string">&#x27;mkdir somedir&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  hello,</span><br><span class="line">  makedir</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在你的终端中执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npx run hello Tommy</span></span><br><span class="line">Hello Tommy!</span><br><span class="line"><span class="meta">$</span><span class="bash"> npx run makedir</span></span><br><span class="line">mkdir somedir</span><br></pre></td></tr></table></figure>

<h2 id="chalk"><a href="#chalk" class="headerlink" title="chalk"></a>chalk</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>给 <code>终端</code> 字符串设置样式</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install chalk</span><br></pre></td></tr></table></figure>

<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(chalk.blue(<span class="string">&#x27;Hello world!&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>Connect 是一个可扩展的 HTTP 服务器框架，用于 node，使用称为中间件的“插件”。</p>
<h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install connect</span><br></pre></td></tr></table></figure>

<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var connect = require(&#x27;connect&#x27;);</span><br><span class="line">var http = require(&#x27;http&#x27;);</span><br><span class="line"></span><br><span class="line">var app = connect();</span><br><span class="line"></span><br><span class="line">// gzip/deflate outgoing responses</span><br><span class="line">var compression = require(&#x27;compression&#x27;);</span><br><span class="line">app.use(compression());</span><br><span class="line"></span><br><span class="line">// store session state in browser cookie</span><br><span class="line">var cookieSession = require(&#x27;cookie-session&#x27;);</span><br><span class="line">app.use(cookieSession(&#123;</span><br><span class="line">    keys: [&#x27;secret1&#x27;, &#x27;secret2&#x27;]</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">// parse urlencoded request bodies into req.body</span><br><span class="line">var bodyParser = require(&#x27;body-parser&#x27;);</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended: false&#125;));</span><br><span class="line"></span><br><span class="line">// respond to all requests</span><br><span class="line">app.use(function(req, res)&#123;</span><br><span class="line">  res.end(&#x27;Hello from Connect!\n&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//create node.js http server and listen on port</span><br><span class="line">http.createServer(app).listen(3000);</span><br></pre></td></tr></table></figure>

<h2 id="serve-static"><a href="#serve-static" class="headerlink" title="serve-static"></a>serve-static</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>一款静态资源管理器</p>
<h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install serve-static</span><br></pre></td></tr></table></figure>

<h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>),</span><br><span class="line">  url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>),</span><br><span class="line">  fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> serveStatic = <span class="built_in">require</span>(<span class="string">&#x27;serve-static&#x27;</span>),</span><br><span class="line">  <span class="comment">//finalhandler 是 serveStatic 的依赖，不需要特意安装。</span></span><br><span class="line">  finalhandler = <span class="built_in">require</span>(<span class="string">&#x27;finalhandler&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置静态资源服务 (&quot;要静态化的文件路径&quot;,&#123;默认主页的配置&#125;);</span></span><br><span class="line"><span class="keyword">var</span> serve = serveStatic(<span class="string">&#x27;public&#x27;</span>, &#123; <span class="attr">index</span>: [<span class="string">&#x27;index.html&#x27;</span>, <span class="string">&#x27;index.htm&#x27;</span>] &#125;);</span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//路由清单</span></span><br><span class="line">    <span class="keyword">if</span> (req.url == <span class="string">&#x27;/music&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">//也让其显示 根目录public 下的主页</span></span><br><span class="line">      fs.readFile(<span class="string">&#x27;./public/index.html&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          res.end(<span class="string">&#x27;没有此文件!&#x27;</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">        res.end(data.toString());</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//读取并呈递完毕之后,在路由中加上return,</span></span><br><span class="line">      <span class="comment">//否则下面的静态资源服务里面会一直寻找这个路由，</span></span><br><span class="line">      <span class="comment">//这个路由是虚拟出来的，因此不会呈递上面我们去读的文件</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用静态资源服务，一般放在中间件最下方，不至于遮蔽中间件的路由</span></span><br><span class="line">    serve(req, res, finalhandler(req, res));</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">8888</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;ok&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="mockjs"><a href="#mockjs" class="headerlink" title="mockjs"></a>mockjs</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>生成随机数据，拦截 Ajax 请求</p>
<h3 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install mockjs</span><br></pre></td></tr></table></figure>

<h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Mock</span></span><br><span class="line"><span class="keyword">var</span> Mock = <span class="built_in">require</span>(<span class="string">&#x27;mockjs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="comment">// 属性 list 的值是一个数组，其中含有 1 到 10 个元素</span></span><br><span class="line">  <span class="string">&#x27;list|1-10&#x27;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 属性 id 是一个自增数，起始值为 1，每次增 1</span></span><br><span class="line">      <span class="string">&#x27;id|+1&#x27;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>构建工具</category>
        <category>npm</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】高性能前端架构解决方案</title>
    <url>/posts/10518/</url>
    <content><![CDATA[<p>来源：<a href="https://mp.weixin.qq.com/s/C4izhX-vMnw_dpUZ1uDM0A">高性能前端架构解决方案</a></p>
<p>这篇文章介绍了一些使前端应用程序加载更快并提供良好用户体验的技术。</p>
<p>我们将研究前端的总体架构，如何首先加载必需的资源，并最大化资源缓存的概率。</p>
<p>无论你的页面是否需要成为客户端应用程序，还是如何优化应用程序的渲染时间，我都不会说太多后端如何传递资源。</p>
<a id="more"></a>

<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>我将把应用程序加载分为三个不同的阶段：</p>
<ul>
<li>初始渲染 – 用户看到任何东西之前需要多长时间？</li>
<li>应用程序加载 – 用户可以使用该应用程序需要多长时间？</li>
<li>下一页 – 导航到下一页需要多长时间？</li>
</ul>
<img src="/posts/10518/640-20200322202223114.png" class="" title="640-20200322202223114">

<h2 id="初始渲染"><a href="#初始渲染" class="headerlink" title="初始渲染"></a>初始渲染</h2><p>在浏览器的初始渲染之前，用户看不到任何东西。渲染页面至少需要加载 <code>HTML</code> 文件，但是大多数时候需要加载其他资源，例如 <code>CSS</code> 和 <code>JavaScript</code> 文件。一旦这些都加载完毕，浏览器就可以开始在屏幕上渲染。</p>
<p>在本文中，我将使用 <code>WebPageTest</code> 瀑布图。你网站的请求瀑布可能看起来像这样。</p>
<img src="/posts/10518/640-20200322202223159.png" class="" title="640-20200322202223159">

<p><code>HTML</code> 文档将加载一堆其他文件，并在这些文件加载后渲染页面。请注意， <code>CSS</code> 文件是并行加载的，因此每个其他请求不会增加明显的延迟。</p>
<p>（备注：<code>gov.uk</code> 启用了 <code>HTTP/2</code>，因此资产域可以重新使用与 <code>www.gov.uk</code> 的现有连接！我将在下面详细讨论服务器连接。）</p>
<h3 id="减少渲染阻塞的请求"><a href="#减少渲染阻塞的请求" class="headerlink" title="减少渲染阻塞的请求"></a>减少渲染阻塞的请求</h3><p><code>css</code> 和（默认情况下） <code>script</code> 文件会阻止其下方的任何内容渲染。</p>
<p>你可以通过以下几种方法来解决此问题：</p>
<ul>
<li>将脚本标签放在 <code>body</code> 标签的底部</li>
<li>使用 <code>async</code> 异步加载 <code>script</code></li>
<li>内联使用小型的 <code>JS</code> 或 <code>CSS</code> 代码段（如果需要同步加载）</li>
</ul>
<h3 id="避免顺序渲染阻塞请求链"><a href="#避免顺序渲染阻塞请求链" class="headerlink" title="避免顺序渲染阻塞请求链"></a>避免顺序渲染阻塞请求链</h3><p>让你的网站变慢的不一定是阻止渲染的请求数量。更重要的是每种资源的下载大小，以及浏览器发现需要加载资源的时间。</p>
<p>如果浏览器仅在另一个请求完成后才发现需要加载文件，则可以获取同步请求链。发生这种情况可能有多种原因：</p>
<ul>
<li><code>CSS</code> 中的 <code>@import</code> 规则</li>
<li><code>CSS</code> 文件中引用的 <code>Webfonts</code></li>
<li><code>JavaScript</code> 注入链接或脚本标签</li>
</ul>
<p>看一下这个例子：</p>
<img src="/posts/10518/640-20200322202223158.png" class="" title="640-20200322202223158">

<p>这个网站在它的某个 <code>CSS</code> 文件中使用 <code>@import</code> 加载 <code>Google Fonts</code>。这意味着浏览器需要一个接一个地发出这些请求：</p>
<ul>
<li>文件 <code>HTML</code></li>
<li>应用程序的 <code>CSS</code></li>
<li><code>Google</code> 字体 <code>CSS</code></li>
<li><code>Google Font Woff</code>文件（在瀑布图中未显示）</li>
</ul>
<p>要解决这个问题，首先需要将 <code>Google Fonts</code> 的 <code>CSS</code> 请求从 <code>@import</code> 移动到 <code>HTML</code> 中的 <code>link</code> 标记，这就切断了请求链条上的一个环节。</p>
<p>为了进一步加快速度，建议直接在 <code>HTML</code> 或 <code>CSS</code> 文件中内联 <code>Google Fonts CSS</code> 文件。</p>
<p>(记住，来自 <code>Google Fonts</code> 的 <code>CSS</code> 响应取决于用户代理。如果你用 <code>IE8</code> 发出请求，CSS 会引用一个 <code>EOT</code> 文件，<code>IE11</code> 会得到一个 <code>woff</code> 文件，而现在的浏览器会得到一个 <code>woff2</code> 文件。但是如果你不介意旧的浏览器使用系统字体，那么你可以复制粘贴 <code>CSS</code> 文件的内容。)</p>
<p>即使页面开始呈现后，用户仍可能无法对该页面执行任何操作，因为在加载字体之前，不会显示任何文本。可以通过 <code>font-display swap</code> 来避免这种情况，现在 <code>Google Fonts</code> 默认情况下已经开始支持。</p>
<p>有时，消除请求链是不可行的。在这些情况下，可以考虑使用 <code>preload</code> 或 <code>preconnect</code> 标记。例如，在实际的 <code>CSS</code> 请求发出之前，上面的网站可以连接到 <code>fonts.googleapis.com</code>。</p>
<h3 id="重复使用服务器连接以加快请求"><a href="#重复使用服务器连接以加快请求" class="headerlink" title="重复使用服务器连接以加快请求"></a>重复使用服务器连接以加快请求</h3><p>建立新的服务器连接通常需要在服务器的浏览器之间进行 3 次往返：</p>
<ul>
<li><code>DNS</code> 查询</li>
<li>建立 <code>TCP</code> 连接</li>
<li>建立 <code>SSL</code> 连接</li>
</ul>
<p>连接就绪后，至少需要再进行一次往返来发送请求并下载响应。</p>
<p>下面的瀑布显示连接已启动到四个不同的服务器：<code>hostgator.com，optimize.com，googletagmanager.com 和 googelapis.com</code>。</p>
<p>但是，对同一服务器的后续请求可以重新使用现有连接。因此，加载 <code>base.css</code>或 <code>index1.css</code> 的速度很快，因为它们也托管在 <code>hostgator.com</code> 上。</p>
<img src="/posts/10518/640-20200322202223164.png" class="" title="640-20200322202223164">

<h3 id="减小文件大小并使用-CDN"><a href="#减小文件大小并使用-CDN" class="headerlink" title="减小文件大小并使用 CDN"></a>减小文件大小并使用 CDN</h3><p>除了文件大小之外，还有两个其他因素会影响请求时间，这些因素都在你的控制范围内：资源大小和服务器位置。</p>
<p>向用户发送尽可能少的数据，并确保将其压缩（例如，使用 <code>brotli</code> 或 <code>gzip</code> ）。</p>
<p>内容交付网络在大量位置提供服务器，因此其中之一可能位于你的用户附近。用户可以连接到与其附近的 <code>CDN</code> 服务器，而不必连接到中央应用程序服务器。这意味着服务器的往返时间将大大缩短。这对于诸如 <code>CSS</code>，<code>JavaScript</code>和 <code>Image</code> 之类的静态资产特别方便，因为它们易于分发。</p>
<h3 id="使用-service-workers-跳过网络"><a href="#使用-service-workers-跳过网络" class="headerlink" title="使用 service workers 跳过网络"></a>使用 service workers 跳过网络</h3><p><code>service workers</code> 允许你在请求进入网络之前拦截它们。这意味着你可以实现瞬时首屏渲染!</p>
<p>当然，这只在你不需要网络发送响应时才有效。你需要已经缓存了响应，所以用户只有在第二次加载你的应用时才会受益。</p>
<p>下面的 <code>service workers</code> 缓存呈现页面所需的 HTML 和 CSS。当再次加载应用程序时，它会尝试为缓存的资源提供服务，如果资源不可用，则会返回到网络。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">self.addEventListener(<span class="string">&#x27;install&#x27;</span>, <span class="keyword">async</span> e =&gt; &#123;</span><br><span class="line">  caches.open(<span class="string">&#x27;v1&#x27;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.addAll([<span class="string">&#x27;/app&#x27;</span>, <span class="string">&#x27;/app.css&#x27;</span>]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">&#x27;fetch&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request).then(<span class="function"><span class="params">cachedResponse</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cachedResponse || fetch(event.request);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="应用加载"><a href="#应用加载" class="headerlink" title="应用加载"></a>应用加载</h2><p>好的，现在用户已经可以看到一些东西，然后他们在可以使用你的应用程序之前还需要什么？</p>
<ul>
<li>加载应用程序代码（JS 和 CSS）</li>
<li>加载页面的基本数据</li>
<li>加载其他数据和图像</li>
</ul>
<img src="/posts/10518/640-20200322202223220.png" class="" title="640-20200322202223220">

<p>请注意，不仅仅是延迟从网络加载数据会延迟渲染。加载代码后，浏览器将需要解析，编译和执行它。</p>
<h3 id="Bundle-split：仅加载必要的代码，并最大化缓存命中率"><a href="#Bundle-split：仅加载必要的代码，并最大化缓存命中率" class="headerlink" title="Bundle split：仅加载必要的代码，并最大化缓存命中率"></a>Bundle split：仅加载必要的代码，并最大化缓存命中率</h3><p><code>Bundle split</code> 允许只加载当前页面所需的代码，而不是加载整个应用程序。<code>Bundle split</code> 还意味着可以缓存其中的一部分，即使其他部分已经更改，需要重新加载。</p>
<p>通常，代码被分成三种不同类型的文件:</p>
<ul>
<li>网页本身专用代码</li>
<li>共享应用程序代码</li>
<li>很少更改的第三方模块（非常适合缓存！）</li>
</ul>
<p><code>Webpack</code> 可以使用 <code>optimization.splitChunks</code> 自动拆分共享代码以减少总下载量。确保启用运行时块，以使 <code>chunk</code> 哈希稳定，并从长期缓存中受益。</p>
<p>分离页面特定的代码不能自动完成，你需要识别可以单独加载的位。通常这是一个特定的路径或一组页面。使用动态导入来延迟加载代码。</p>
<p><code>Bundle split</code> 会导致更多的请求被发送来加载你的应用程序。但是只要请求是并行发送的，这就不是什么大问题，特别是当你的站点开启了 <code>HTTP/2</code> 服务的时候。你可以看到在这个瀑布的前三个请求:</p>
<img src="/posts/10518/640-20200322202223167.png" class="" title="640-20200322202223167">

<p>然而，这个瀑布图还显示了两个按顺序发出的请求。这些块只在这个页面中需要，并通过 <code>import()</code> 调用动态加载。</p>
<p>如果你知道需要这些块，你可以通过插入预加载链接标记来解决这个问题。</p>
<img src="/posts/10518/640-20200322203628249.png" class="" title="640-20200322203628249">

<p>但是，你会看到，与总页面加载时间相比，这样做的好处可能很小。</p>
<p>另外，使用预加载有时会适得其反，因为加载其他更重要的文件时可能会延迟。</p>
<h3 id="加载页面数据"><a href="#加载页面数据" class="headerlink" title="加载页面数据"></a>加载页面数据</h3><p>你的应用程序可能是用来显示一些数据的。下面是一些提示，你可以使用这些提示尽早加载数据并避免呈现延迟。</p>
<h4 id="在开始加载数据之前不要等待包"><a href="#在开始加载数据之前不要等待包" class="headerlink" title="在开始加载数据之前不要等待包"></a>在开始加载数据之前不要等待包</h4><p>这是一个顺序请求链的特殊情况:你加载应用程序包，然后代码请求页面数据。</p>
<p>有两种方法可以避免这种情况：</p>
<ul>
<li>将页面数据嵌入 HTML 文档中</li>
<li>通过文档中的内联脚本启动数据请求</li>
</ul>
<p>将数据嵌入 HTML 可以确保你的应用程序不必等待数据加载。这也降低了应用程序的复杂性，因为你不必处理加载状态。</p>
<p>但是，如果获取数据会大大延迟你的文档响应，那将不是一个好主意，因为这会延迟你的初始渲染。</p>
<p>在这种情况下，或者如果你通过服务工作者提供缓存的 HTML 文档，则可以将内联脚本嵌入到 HTML 中以加载此数据。你可以将其作为全局 <code>promise</code> 提供，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.userDataPromise = fetch(<span class="string">&#x27;/me&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>然后，如果数据准备就绪，你的应用程序可以立即开始渲染，或者等到准备就绪。</p>
<p>对于这两种技术，你都需要知道在应用开始呈现之前页面必须加载哪些数据。对于与用户相关的数据（用户名，通知 …），这往往很容易，但是对于特定于页面的内容，则比较棘手。考虑确定最重要的页面并为这些页面编写自定义逻辑。</p>
<h4 id="等待非必需数据时不要阻塞渲染"><a href="#等待非必需数据时不要阻塞渲染" class="headerlink" title="等待非必需数据时不要阻塞渲染"></a>等待非必需数据时不要阻塞渲染</h4><p>有时生成页面数据需要缓慢的复杂后端逻辑。在这些情况下，如果足以使你的应用程序具有功能性和交互性，则可以首先加载较简单的数据版本。</p>
<p>例如，分析工具可以在加载图表数据之前首先加载所有图表的列表。这使用户可以立即查找他们感兴趣的图表，还可以帮助将后端请求分散到不同的服务器上。</p>
<img src="/posts/10518/640-20200322202223217.png" class="" title="640-20200322202223217">

<h4 id="避免顺序数据请求链"><a href="#避免顺序数据请求链" class="headerlink" title="避免顺序数据请求链"></a>避免顺序数据请求链</h4><p>这可能与我先前关于在第二个请求中加载非必需数据的观点相冲突，但是如果每个完成的请求都不会导致向用户显示更多信息，则避免顺序请求链。</p>
<p>与其先发出关于用户登录身份的请求，然后再请求其所属团队的列表，不如在用户信息旁边返回团队列表。你可以使用 <code>GraphQL</code> ，但自定义用户呢? <code>includeTeams=true endpoint</code> 也很有用。</p>
<p>与其首先请求用户登录为谁，然后请求他们所属的团队列表，</p>
<h3 id="服务端端渲染"><a href="#服务端端渲染" class="headerlink" title="服务端端渲染"></a>服务端端渲染</h3><p>服务端端渲染意味着在服务器上预渲染你的应用程序，并使用整页 HTML 响应文档请求。这意味着客户端可以看到完全呈现的页面，而不必等待加载其他代码或数据！</p>
<p>由于服务器只是将静态 HTML 发送给客户端，因此你的应用尚无法进行交互。需要加载应用程序，它需要重新运行呈现逻辑，然后将必要的事件侦听器附加到 DOM。</p>
<p>如果看到非交互式内容很有价值，请使用服务器呈现。如果你能够将呈现的 HTML 缓存在服务器上并将其提供给所有用户而又不会延迟初始文档请求，那么它也将有所帮助。例如，如果你使用 <code>React</code> 来渲染博客文章，则服务器渲染非常合适。</p>
<h2 id="下一页"><a href="#下一页" class="headerlink" title="下一页"></a>下一页</h2><p>在某个时候，用户将与你的应用进行交互并转到下一页。打开初始页面后，你可以控制浏览器中发生的事情，因此你可以准备进行下一次交互。</p>
<h3 id="预取资源"><a href="#预取资源" class="headerlink" title="预取资源"></a>预取资源</h3><p>如果你预加载了下一页所需的代码，则可以消除用户启动导航时的延迟。使用 <code>prefetch</code> 标记，或 <code>webpackPrefetch</code> 用于动态导入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPrefetch: true, webpackChunkName: &quot;todo-list&quot; */</span> <span class="string">&#x27;./TodoList&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>注意你使用了多少用户数据和带宽，特别是当他们使用移动连接时。如果他们使用的是你网站的移动版本，或者他们启用了保存数据模式，你可以减少预加载。</p>
<p>对于用户最可能需要的应用程序部分，要有策略。</p>
<h3 id="重用已经加载的数据"><a href="#重用已经加载的数据" class="headerlink" title="重用已经加载的数据"></a>重用已经加载的数据</h3><p>在应用程序中本地缓存 <code>Ajax</code> 数据，并使用它来避免未来的请求。如果用户从团队列表导航到“编辑团队”页面，你可以通过重用已经获取的数据来立即进行转换。</p>
<p>请注意，如果你的实体经常被其他用户编辑，并且你下载的数据可能已经过期，那么这种方法将不起作用。在这些情况下，在获取最新数据时，请首先考虑以只读方式显示现有数据。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本文介绍了许多因素，这些因素可能会在加载过程的不同时刻使你的页面速度减慢。使用 <code>Chrome DevTools</code>，<code>WebPageTest</code>和<code>Lighthouse</code>之类的工具来确定其中哪些适用于你的应用程序。</p>
<p>实际上，你几乎不可能在所有方面进行优化。找出对用户有最大影响的因素，并专注于此。</p>
<p>我在写这篇文章时意识到的一件事是，我根深蒂固地相信，发出许多单独的请求对性能不利。过去，当每个请求都需要一个单独的连接时，Thas 就是这样，而浏览器每个域只允许几个连接。但是，使用 <code>HTTP/2</code> 和现代浏览器已不再是这种情况。</p>
<p>并且有强烈的理由支持拆分请求。它允许仅加载必要的资源，并可以更好地利用缓存的内容，因为仅需要重新加载已更改的文件。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>三栏布局方案(圣杯_双飞翼)</title>
    <url>/posts/10370/</url>
    <content><![CDATA[<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><h3 id="步骤一-HTML框架搭建-amp-初始化CSS"><a href="#步骤一-HTML框架搭建-amp-初始化CSS" class="headerlink" title="步骤一 - HTML框架搭建 &amp; 初始化CSS"></a>步骤一 - HTML框架搭建 &amp; 初始化CSS</h3><p>首先把基本框架搭起来（注意中间部分放最前面）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>我是中间<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>我是左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>我是右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>接下来是初始化样式。left, right宽度分别设置为100px和200px；然后设置container的 <code>padding-left: 100px</code> + <code>padding-right: 200px</code> 来占据两侧填充；center宽度设为100%，这样能够自适应剩下的宽度。再让所有子元素左浮动。代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">100px</span>; <span class="comment">/* 左边100， 右边200*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e1e1e1</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>; <span class="comment">/* 为了看效果，给个300px把高度撑起来 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.center</span>, <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>; <span class="comment">/* 占据父元素剩下的宽度*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的页面效果：</p>
<img src="/posts/10370/%E5%9C%A3%E6%9D%AFstep1.png" class="" title="圣杯step1">

<h3 id="步骤二-让left占据最左列"><a href="#步骤二-让left占据最左列" class="headerlink" title="步骤二 - 让left占据最左列"></a>步骤二 - 让left占据最左列</h3><p>为了让left能越过center，我们先给它设置一个 -100% 的左边距。这个100%是在container中的宽度，也就是center的宽度：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="comment">/*为了看left和center的重叠效果，暂时bgc设为半透明*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">204</span>,<span class="number">204</span>,.<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页面效果：</p>
<img src="/posts/10370/%E5%9C%A3%E6%9D%AFstep2.png" class="" title="圣杯step2">

<p>此时，我们已经让left从“第二行”升到了“第一行”，为了让它靠到最左侧，不与center重叠，可以给它设置相对定位，然后给个 <code>left: -100px</code> ，让它定位到container最左侧：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="comment">/* 设置相对定位 */</span> </span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="comment">/* 靠到最左侧 */</span></span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页面效果：</p>
<img src="/posts/10370/%E5%9C%A3%E6%9D%AFstep3.png" class="" title="圣杯step3">

<h3 id="步骤三-让right占据最右列"><a href="#步骤三-让right占据最右列" class="headerlink" title="步骤三 - 让right占据最右列"></a>步骤三 - 让right占据最右列</h3><p>定位好了left，也是时候让right呆在最右边来填充位置了，我们继续使用负margin：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: -<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页面效果：</p>
<img src="/posts/10370/%E5%9C%A3%E6%9D%AFstep4.png" class="" title="圣杯step4">

<h3 id="步骤四-给container设置min-width"><a href="#步骤四-给container设置min-width" class="headerlink" title="步骤四 - 给container设置min-width"></a>步骤四 - 给container设置min-width</h3><p>看起来已经实现了不是吗？但我们还差最后一步，给container设置一个 <code>min-width: 100px</code> （就是左列的宽度），否则当浏览器缩小到一定程度时，这个布局可能会被破坏。原因简单来讲就是：“由于设置了相对定位，所以当left原来的位置和right的位置产生重叠时，由于浮动的原因一行放不下就会换行”。所以布局就被打乱了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e1e1e1</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码-最终效果"><a href="#完整代码-最终效果" class="headerlink" title="完整代码 + 最终效果"></a>完整代码 + 最终效果</h3><p>这样，我们就实现了圣杯布局，完整代码和效果见下：</p>
<iframe height="265" scrolling="no" title="三栏布局 - 圣杯布局" src="https://codepen.io/JingW/embed/VRXYmz/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p>如果上面圣杯布局你已经理解并自己实践了一遍，那么这里的双飞翼布局你也应该不再话下。跟着我一起撸一遍代码吧。</p>
<h3 id="步骤一-HTML框架搭建-amp-初始化CSS-1"><a href="#步骤一-HTML框架搭建-amp-初始化CSS-1" class="headerlink" title="步骤一 - HTML框架搭建 &amp; 初始化CSS"></a>步骤一 - HTML框架搭建 &amp; 初始化CSS</h3><p>首先搭建html，仔细观察下方代码你会发现，双飞翼布局在html上面有一点和圣杯布局有差别，那就是双飞翼在center里又套了一个div。到后面你就会知道这样设置的目的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是中间<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>我是左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>我是右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后编写初始样式。left定宽100；right定宽200；left, right, center全部设置左浮动。其他例如设置颜色高度等等直接看下方代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e1e1e1</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.center</span>, <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/posts/10370/%E5%8F%8C%E9%A3%9E%E7%BF%BCstep1.png" class="" title="双飞翼step1">

<h3 id="步骤二-设置center为100-宽"><a href="#步骤二-设置center为100-宽" class="headerlink" title="步骤二 - 设置center为100%宽"></a>步骤二 - 设置center为100%宽</h3><p>将center的宽度设为100%，这样会把left，right“挤”到第二行：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/posts/10370/%E5%8F%8C%E9%A3%9E%E7%BF%BCstep2.png" class="" title="双飞翼step2">

<h3 id="步骤三-分别让left-right回到最左边和最右边"><a href="#步骤三-分别让left-right回到最左边和最右边" class="headerlink" title="步骤三 - 分别让left,right回到最左边和最右边"></a>步骤三 - 分别让left,right回到最左边和最右边</h3><p>接着，给left设置 <code>margin-left: -100%</code> 回到最左边，给right设置 <code>margin-left: -200px</code> 回到最右边。此时center和left,right都有重叠区域，为了看效果，设置了半透明背景颜色。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/posts/10370/%E5%8F%8C%E9%A3%9E%E7%BF%BCstep3.png" class="" title="双飞翼step3">

<h3 id="步骤四-给center的子div设置左右margin"><a href="#步骤四-给center的子div设置左右margin" class="headerlink" title="步骤四 - 给center的子div设置左右margin"></a>步骤四 - 给center的子div设置左右margin</h3><p>其实上面的效果图已经实现了三栏布局中间自适应。但有个问题是center左右部分区域会被遮挡，这个时候在步骤一提到的center子div的作用就体现出来了，我们可以给它设置一个左右的margin值，分别等于left的宽和right的宽，消除掉重叠的副作用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 左margin100，右margin200 */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/posts/10370/%E5%8F%8C%E9%A3%9E%E7%BF%BCstep4.png" class="" title="双飞翼step4">

<h3 id="步骤五-给container设置min-width"><a href="#步骤五-给container设置min-width" class="headerlink" title="步骤五 - 给container设置min-width"></a>步骤五 - 给container设置min-width</h3><p>最后，给container设置一个min-width，让container最小宽度不小于left宽+right宽</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e1e1e1</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大功告成~</p>
<h3 id="完整代码-最终效果-1"><a href="#完整代码-最终效果-1" class="headerlink" title="完整代码 + 最终效果"></a>完整代码 + 最终效果</h3><iframe height="265" scrolling="no" title="三栏布局 - 双飞翼布局" src="https://codepen.io/JingW/embed/wOmBoY/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>两栏布局方案汇总</title>
    <url>/posts/44541/</url>
    <content><![CDATA[<p>记录下常见的两栏布局方式。</p>
<h2 id="左边定宽，右边自适应"><a href="#左边定宽，右边自适应" class="headerlink" title="左边定宽，右边自适应"></a>左边定宽，右边自适应</h2><h3 id="模拟table"><a href="#模拟table" class="headerlink" title="模拟table"></a>模拟table</h3><p>父元素 <code>display: table</code> ，子元素左右 <code>table-cell</code> ，左边定宽。</p>
<iframe height="460" scrolling="no" title="两栏布局（左定右自适应）模拟table" src="https://codepen.io/JingW/embed/zbWYMO/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<a id="more"></a>

<h3 id="左浮-右Margin"><a href="#左浮-右Margin" class="headerlink" title="左浮 + 右Margin"></a>左浮 + 右Margin</h3><p>子元素的左边浮动脱标，右边设置 <code>margin-left: 左边元素宽度</code></p>
<iframe height="460" scrolling="no" title="两栏布局（左定右自适应）子元素绝对定位" src="https://codepen.io/JingW/embed/bZvGRY/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="左浮-右BFC"><a href="#左浮-右BFC" class="headerlink" title="左浮 + 右BFC"></a>左浮 + 右BFC</h3><p>子元素左边设置浮动+定宽，右边子元素设置 <code>overflow: hidden</code> 触发自身BFC</p>
<iframe height="460" scrolling="no" title="两栏布局（左定右自适应）左浮 + 右BFC" src="https://codepen.io/JingW/embed/rRdNYR/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="子绝父相"><a href="#子绝父相" class="headerlink" title="子绝父相"></a>子绝父相</h3><p>子绝父相，左边 <code>top, left: 0</code>，右边 <code>top, right: 0</code>，left等于左边宽度。</p>
<iframe height="460" scrolling="no" title="两栏布局（左定右自适应）子绝父相" src="https://codepen.io/JingW/embed/gEeONo/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>父元素 <code>display: flex</code> ，左边定宽，右边 <code>flex: 1</code>。</p>
<iframe height="460" scrolling="no" title="两栏布局（左定右自适应）flex" src="https://codepen.io/JingW/embed/bZvNGx/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Jekyll搭建GitHubPages博客</title>
    <url>/posts/63074/</url>
    <content><![CDATA[<h2 id="安装-Jekyll"><a href="#安装-Jekyll" class="headerlink" title="安装 Jekyll"></a>安装 Jekyll</h2><p>来源：<a href="https://jekyllrb.com/docs/installation/">https://jekyllrb.com/docs/installation/</a></p>
<h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>终端运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<p>安装 Ruby：</p>
<p>Jekyll 依赖 Ruby v2.5.0+，如果你的 macOS 版本为 Catalina 10.15 或以上，则不需要再手动安装，因为系统自带 Ruby 2.6.3 。</p>
<a id="more"></a>

<blockquote>
<p>查看本地 Ruby 版本：<code>ruby -v</code></p>
<p>如果你的版本低于 10.15 则需要下载或更新你的 Ruby</p>
<p>具体下载or更新方案可查看：<a href="https://jekyllrb.com/docs/installation/macos/#install-ruby">https://jekyllrb.com/docs/installation/macos/#install-ruby</a></p>
</blockquote>
<p>安装 Jekyll：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gem install --user-install bundler jekyll</span><br></pre></td></tr></table></figure>

<p>选择你要安装博客的目录下运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jekyll new 你博客名(随意，反正最后要全部移动到你的githubpages repo下)</span><br></pre></td></tr></table></figure>

<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>windows安装不再赘述，可查看官网文档安装：<a href="https://jekyllrb.com/docs/installation/windows/">https://jekyllrb.com/docs/installation/windows/</a></p>
<h2 id="安装-minimal-mistakes-jekyll-主题"><a href="#安装-minimal-mistakes-jekyll-主题" class="headerlink" title="安装 minimal-mistakes-jekyll 主题"></a>安装 minimal-mistakes-jekyll 主题</h2><p>github 链接：<a href="https://github.com/mmistakes/minimal-mistakes">https://github.com/mmistakes/minimal-mistakes</a></p>
<h3 id="编辑-Gemfile"><a href="#编辑-Gemfile" class="headerlink" title="编辑 Gemfile"></a>编辑 Gemfile</h3><p>替换你的 <code>Gemfile</code> 文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">source &quot;https://rubygems.org&quot;</span><br><span class="line"></span><br><span class="line"># Hello! This is where you manage which Jekyll version is used to run.</span><br><span class="line"># When you want to use a different version, change it below, save the</span><br><span class="line"># file and run `bundle install`. Run Jekyll with `bundle exec`, like so:</span><br><span class="line">#</span><br><span class="line">#     bundle exec jekyll serve</span><br><span class="line">#</span><br><span class="line"># This will help ensure the proper Jekyll version is running.</span><br><span class="line"># Happy Jekylling!</span><br><span class="line"></span><br><span class="line"># gem &quot;github-pages&quot;, group: :jekyll_plugins</span><br><span class="line"></span><br><span class="line"># To upgrade, run `bundle update`.</span><br><span class="line"></span><br><span class="line">gem &quot;github-pages&quot;, group: :jekyll_plugins</span><br><span class="line">gem &quot;minimal-mistakes-jekyll&quot;, :github =&gt; &quot;mmistakes/minimal-mistakes&quot;</span><br><span class="line"></span><br><span class="line"># The following plugins are automatically loaded by the theme-gem:</span><br><span class="line">#   gem &quot;jekyll-paginate&quot;</span><br><span class="line">#   gem &quot;jekyll-sitemap&quot;</span><br><span class="line">#   gem &quot;jekyll-gist&quot;</span><br><span class="line">#   gem &quot;jekyll-feed&quot;</span><br><span class="line">#   gem &quot;jekyll-include-cache&quot;</span><br><span class="line">#</span><br><span class="line"># If you have any other plugins, put them here!</span><br><span class="line">group :jekyll_plugins do</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>运行 <code>bundle install</code> 安装依赖。</p>
<h3 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置 _config.yml"></a>配置 _config.yml</h3><p>找到 <code>_config.yml</code> 文件并替换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Welcome to Jekyll!</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># This config file is meant for settings that affect your whole blog, values</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">which</span> you are expected to <span class="built_in">set</span> up once and rarely edit after that. If you find</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yourself editing this file very often, consider using Jekyll<span class="string">&#x27;s data files</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> feature <span class="keyword">for</span> the data you need to update frequently.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># For technical reasons, this file is *NOT* reloaded automatically when you use</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&#x27;bundle exec jekyll serve&#x27;</span>. If you change this file, please restart the server process.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># If you need help with YAML syntax, here are some quick references for you:</span></span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> https://learn-the-web.algonquindesign.ca/topics/markdown-yaml-cheat-sheet/<span class="comment">#yaml</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://learnxinyminutes.com/docs/yaml/</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Site settings</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> These are used to personalize your new site. If you look <span class="keyword">in</span> the HTML files,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> you will see them accessed via &#123;&#123; site.title &#125;&#125;, &#123;&#123; site.email &#125;&#125;, and so on.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You can create any custom variable you would like, and they will be accessible</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> the templates via &#123;&#123; site.myvariable &#125;&#125;.</span></span><br><span class="line"></span><br><span class="line">title: Your awesome title</span><br><span class="line">email: your-email@example.com</span><br><span class="line">description: &gt;- # this means to ignore newlines until &quot;baseurl:&quot;</span><br><span class="line">  Write an awesome description for your new site here. You can edit this</span><br><span class="line">  line in _config.yml. It will appear in your document head meta (for</span><br><span class="line">  Google search results) and in your feed.xml site description.</span><br><span class="line">baseurl: &quot;&quot; # the subpath of your site, e.g. /blog</span><br><span class="line">url: &quot;https://evestorm.github.io&quot; # the base hostname &amp; protocol for your site, e.g. http://example.com</span><br><span class="line">repository: &quot;&#123;github_username&#125;/&#123;github_username&#125;.github.io&quot; # 把 &#123;github_username&#125; 替换成你github的username</span><br><span class="line">twitter_username: jekyllrb</span><br><span class="line">github_username:  lance # 你的username，随便填</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Build settings</span></span><br><span class="line">theme: minimal-mistakes-jekyll</span><br><span class="line">plugins:</span><br><span class="line">  - jekyll-feed</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Exclude from processing.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The following items will not be processed, by default.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Any item listed under the `exclude:` key here will be automatically added to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the internal <span class="string">&quot;default list&quot;</span>.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Excluded items can be processed by explicitly listing the directories or</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> their entries<span class="string">&#x27; file path in the `include:` list.</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># exclude:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - .sass-cache/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - .jekyll-cache/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - gemfiles/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - Gemfile</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - Gemfile.lock</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - node_modules/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - vendor/bundle/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - vendor/cache/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - vendor/gems/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - vendor/ruby/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后执行 <code>bundle update</code>。</p>
<h3 id="替换和更改"><a href="#替换和更改" class="headerlink" title="替换和更改"></a>替换和更改</h3><ul>
<li><p>替换根目录下 <code>index.markdown</code> 为 <code>index.html</code>  ：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: home</span><br><span class="line">author_profile: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到 <code>_posts/0000-00-00-welcome-to-jekyll.md</code> 并替换 <code>layout: single</code></p>
</li>
<li><p>删除 <code>about.md</code> 文件</p>
</li>
</ul>
<p>最后执行： <code>bundle exec jekyll serve</code> 本地运行博客。</p>
]]></content>
      <categories>
        <category>教程</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo搭建个人博客</title>
    <url>/posts/43303/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>利用 <a href="https://hexo.io/zh-cn/">Hexo</a> 在 <a href="https://baike.baidu.com/item/github/10145341?fr=aladdin">GitHub</a> 上搭建个人博客。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>你的电脑需要安装下面两个应用程序：</p>
<ul>
<li>NodeJS <a href="http://www.runoob.com/nodejs/nodejs-install-setup.html">如何安装</a></li>
<li>Git <a href="http://www.runoob.com/git/git-install-setup.html">如何安装</a></li>
</ul>
<p>或者直接查看hexo的<a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85%E5%89%8D%E6%8F%90">官方文档</a>查看安装教程。</p>
<a id="more"></a>

<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><blockquote>
<p><a href="https://hexo.io/zh-cn/docs/">安装文档</a></p>
</blockquote>
<p>终端全局安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init 你的站点文件夹</span><br><span class="line">cd 你的站点文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>下方是三个常见命令，可以先执行前俩看看效果，最后一个部署命令待会再执行。</p>
<ul>
<li><code>hexo server -p 5000</code> 本地启动服务器，5000端口</li>
<li><code>hexo new &#39;你想要创建的文章名称&#39;</code> 创建文章</li>
<li><code>hexo clean &amp;&amp; hexo deploy</code> 部署网站</li>
</ul>
<h3 id="使用第三方主题"><a href="#使用第三方主题" class="headerlink" title="使用第三方主题"></a>使用第三方主题</h3><ul>
<li><a href="https://github.com/iissnan/hexo-theme-next">Next</a> 【推荐】</li>
<li><a href="https://github.com/litten/hexo-theme-yilia">Yilia</a></li>
</ul>
<h4 id="安装Next主题"><a href="#安装Next主题" class="headerlink" title="安装Next主题"></a>安装Next主题</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 你的站点目录</span><br><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="创建分类和标签"><a href="#创建分类和标签" class="headerlink" title="创建分类和标签"></a>创建分类和标签</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>

<p>p.s. 命名为 <code>categories</code> 原因是 <code>categories</code> 在next主题中是一个关键词对应着分类。</p>
<p>在主站根目录下,也就是你hexo的目录下找到 <code>/source/categories/index.md</code>，打开后的效果类似下方代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories  #本页标题</span><br><span class="line">date: 2018-03-13 23:02:50  #创建日期</span><br><span class="line">type: &quot;categories&quot; 	#分类属于</span><br><span class="line">comments: false  #如果有启用多说 或者 Disqus评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>接着在 themes 主题文件夹下找到 next 文件夹，修改 _config.yml 文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br></pre></td></tr></table></figure>

<p>然后在命令行输入添加文章命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &#39;你想要创建的文章名称&#39;</span><br></pre></td></tr></table></figure>

<p>根目录(主站目录下)/source/_posts/&lt;刚创建的文章名称&gt;.md，双击打开：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 2018-03-13 23:13:23</span><br><span class="line">tags: html    #属于哪个标签</span><br><span class="line">categories: interview   #属于哪个分类</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>打开命令行，进入博客所在文件夹。执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>成功后会有一个路径提示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO Created: ~/Documents/blog/source/tags/index.md</span><br></pre></td></tr></table></figure>

<p>找到对应的文件打开</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2018-03-14 00:02:05</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>添加type: “tags”到内容中，添加后是这样的：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-03-14 00:03:52</span><br><span class="line">type: &#x27;tags&#x27;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>打开你的文章页面：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: jQuery对表单的操作及更多应用</span><br><span class="line">date: 2019-03-14 00:03:55</span><br><span class="line">categories: 前端</span><br><span class="line">tags: jQuery  #如果想要多个标签可以 tags: [jQuery, 表格, 表单验证] or</span><br><span class="line"><span class="bullet">-</span> jQuery</span><br><span class="line"><span class="bullet">-</span> 表格</span><br><span class="line"><span class="bullet">-</span> 表单验证</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>p.s. 如果想要实现父子分类，也和标签一样的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- IDE</span><br><span class="line">- VSCode</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://hexo.io/zh-cn/docs/front-matter.html#%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE">分类和标签</a></p>
<h3 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h3><p>把头像放在站点根目录的 <code>source/uploads/</code> 下，然后在 <code>theme/next/_config.yml</code> 下修改配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/uploads/avatar.png</span></span><br></pre></td></tr></table></figure>

<h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><h4 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h4><p>在 <code>theme/next/_config.yml</code> 下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="comment">#about: /about/ || fa fa-user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || fa fa-tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || fa fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>

<h4 id="社交"><a href="#社交" class="headerlink" title="社交"></a>社交</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:yourname@gmail.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line">  <span class="attr">Weibo:</span> <span class="string">https://weibo.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-weibo</span></span><br><span class="line">  <span class="attr">Google:</span> <span class="string">https://plus.google.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-google</span></span><br><span class="line">  <span class="attr">Twitter:</span> <span class="string">https://twitter.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-twitter</span></span><br><span class="line">  <span class="attr">FB Page:</span> <span class="string">https://www.facebook.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-facebook</span></span><br><span class="line">  <span class="attr">StackOverflow:</span> <span class="string">https://stackoverflow.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-stack-overflow</span></span><br><span class="line">  <span class="attr">YouTube:</span> <span class="string">https://youtube.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-youtube</span></span><br><span class="line">  <span class="attr">Instagram:</span> <span class="string">https://instagram.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-instagram</span></span><br><span class="line">  <span class="attr">Skype:</span> <span class="string">skype:yourname?call|chat</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-skype</span></span><br></pre></td></tr></table></figure>

<h3 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h3><p>在文章想要截断的地方添加 <code>&lt;!-- more --&gt;</code> ，这样在文章列表中就会只展示到截断位置为止。</p>
<h2 id="第三方插件"><a href="#第三方插件" class="headerlink" title="第三方插件"></a>第三方插件</h2><h3 id="永久URL生成：hexo-abbrlink"><a href="#永久URL生成：hexo-abbrlink" class="headerlink" title="永久URL生成：hexo-abbrlink"></a>永久URL生成：hexo-abbrlink</h3><ul>
<li>用来生成每篇博客永久URL链接的</li>
<li>Repo: <a href="https://github.com/rozbo/hexo-abbrlink">https://github.com/rozbo/hexo-abbrlink</a></li>
<li>执行： <code>npm install hexo-abbrlink --save</code></li>
</ul>
<h3 id="部署到GitHub：hexo-deployer-git"><a href="#部署到GitHub：hexo-deployer-git" class="headerlink" title="部署到GitHub：hexo-deployer-git"></a>部署到GitHub：hexo-deployer-git</h3><ul>
<li>将本地博客部署到GitHub</li>
<li>Repo: <a href="https://hexo.io/zh-cn/docs/one-command-deployment">https://hexo.io/zh-cn/docs/one-command-deployment</a>)</li>
<li>执行： <code>npm install hexo-deployer-git --save</code></li>
</ul>
<p><strong>如何部署</strong></p>
<p>在 <code>_config.yml</code> 下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&quot;https://github.com/evestorm/evestorm.github.io&quot;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">&quot;gh-pages&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后在你的githubpages的repo下新建 <code>gh-pages</code> 分支，最后执行：<code>hexo clean &amp;&amp; hexo deploy</code> 即可部署。</p>
<h3 id="本地热更新：hexo-server"><a href="#本地热更新：hexo-server" class="headerlink" title="本地热更新：hexo-server"></a>本地热更新：hexo-server</h3><ul>
<li>服务器模块。在启动期间，Hexo 会监视文件变动并自动更新</li>
<li>Repo: <a href="https://github.com/hexojs/hexo-server">https://github.com/hexojs/hexo-server</a>)</li>
<li>执行： <code>npm install hexo-server –save</code></li>
</ul>
<h3 id="关键词搜索：LocalSearch"><a href="#关键词搜索：LocalSearch" class="headerlink" title="关键词搜索：LocalSearch"></a>关键词搜索：LocalSearch</h3><ul>
<li>本地搜索</li>
<li>Repo: <a href="https://github.com/theme-next/hexo-generator-searchdb">https://github.com/theme-next/hexo-generator-searchdb</a></li>
<li>执行：<code>npm install hexo-generator-searchdb --save</code></li>
</ul>
<p><strong>配置博客</strong></p>
<p>安装完成，编辑博客配置文件：<code>hexo/_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br></pre></td></tr></table></figure>

<p><strong>配置主题</strong></p>
<p>Next 主题自带搜索设置，编辑主题配置文件：<code>_config.yml</code></p>
<p>找到文件中 Local search 的相关配置，设为 <code>true</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>最后记得 hexo 重新部署。</p>
<h3 id="统计分析：busuanzi-count"><a href="#统计分析：busuanzi-count" class="headerlink" title="统计分析：busuanzi_count"></a>统计分析：busuanzi_count</h3><p>NexT 主题集成了不蒜子（busuanzi_count）统计功能，在 NexT 配置文件中找到关键词 <code>busuanzi_count:</code> ，把 enable 设置为 true</p>
<p>p.s. 除此之外，如果设置为true后仍然无效，且打开控制台显示js报错。有可能是不蒜子链接失效的原因，需要在Next主题配置文件位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">themes\next\layout\_third-party\analytics\busuanzi-counter.swig</span><br></pre></td></tr></table></figure>

<p>修改script链接为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="评论功能：ChangYan"><a href="#评论功能：ChangYan" class="headerlink" title="评论功能：ChangYan"></a>评论功能：ChangYan</h3><p>文档地址：<a href="https://theme-next.js.org/docs/third-party-services/comments.html#Changyan-China">https://theme-next.js.org/docs/third-party-services/comments.html#Changyan-China</a></p>
<ul>
<li><p>注册登录：<a href="https://changyan.kuaizhan.com/">https://changyan.kuaizhan.com/</a></p>
</li>
<li><p>获取 APP ID 和 APP KEY</p>
</li>
<li><p>设置 changyan enable: true:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># changyan</span></span><br><span class="line"><span class="attr">changyan:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span></span><br><span class="line">  <span class="attr">appkey:</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p><a href="https://blog.csdn.net/lewky_liu/article/details/81277337">Hexo瞎折腾系列(4) - 站点首页不显示文章全文</a></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// npm全局安装Hexo</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">// 新建Hexo项目</span><br><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">// 新建文章</span><br><span class="line">hexo new &#x27;文章名&#x27;</span><br><span class="line"></span><br><span class="line">// 启动服务器</span><br><span class="line">hexo server -p 5000</span><br><span class="line"></span><br><span class="line">// 生成静态文件</span><br><span class="line">hexo generate --watch</span><br><span class="line"></span><br><span class="line">// 部署</span><br><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>

<h2 id="相关配置及资源"><a href="#相关配置及资源" class="headerlink" title="相关配置及资源"></a>相关配置及资源</h2><ul>
<li><a href="https://juejin.im/post/5bcd2d395188255c3b7dc1db#heading-42">Hexo+NexT 打造一个炫酷博客</a></li>
<li><a href="https://me.idealli.com/post/e8d13fc.html">这应该是最全的hexo博客搭建以及next美化教程</a></li>
<li><a href="https://leancloud.cn/">LeanCloud</a></li>
<li><a href="https://eirunye.github.io/2018/09/15/Hexo%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2%E2%80%94%E6%89%93%E9%80%A0%E7%82%AB%E9%85%B7%E7%9A%84NexT%E4%B8%BB%E9%A2%98%E2%80%94%E9%AB%98%E7%BA%A7%E2%80%94%E5%9B%9B/">Hexo搭建GitHub博客—打造炫酷的NexT主题–高级(四)</a></li>
<li><a href="http://www.missfli.com/2018/06/19/github-hexo-next-08.html">Hexo NexT主题代码块添加复制功能</a></li>
<li><a href="https://ihaoming.top/archives/9a935f57.html">修改hexo博客next主题文章页面宽度</a></li>
<li><a href="https://hexo.io/zh-cn/docs/asset-folders.html">在Hexo中使用资源文件夹添加图片</a></li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>函数中的rest参数</title>
    <url>/posts/29820/</url>
    <content><![CDATA[<h2 id="什么是-REST-参数"><a href="#什么是-REST-参数" class="headerlink" title="什么是 REST 参数"></a>什么是 REST 参数</h2><p>REST参数翻译过来就是剩余参数，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters">MDN</a>上的定义是：</p>
<blockquote>
<p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组。</p>
</blockquote>
<a id="more"></a>

<h2 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.reduce(<span class="function">(<span class="params">previous, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> previous + current;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// expected output: 6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// expected output: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">multiplier, ...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.map(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> multiplier * element;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = multiply(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<h2 id="rest-参数和-arguments-对象的区别"><a href="#rest-参数和-arguments-对象的区别" class="headerlink" title="rest 参数和 arguments 对象的区别"></a>rest 参数和 arguments 对象的区别</h2><p>剩余参数和 <code>arguments</code>对象之间的区别主要有三个：</p>
<ul>
<li><p>剩余参数只包含那些没有对应形参的实参，而 <code>arguments</code> 对象包含了传给函数的所有实参。</p>
</li>
<li><p><code>arguments</code>对象不是一个真正的数组，而剩余参数是真正的 <code>Array</code>实例，也就是说你能够在它上面直接使用所有的数组方法，比如 <code>sort</code>，<code>map</code>，<code>forEach</code>或<code>pop</code>。</p>
</li>
<li><pre><code>arguments
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">对象还有一些附加的属性 （如</span><br><span class="line"></span><br></pre></td></tr></table></figure>
callee</code></pre>
<p>属性）。</p>
<ul>
<li>arguments.callee 属性包含当前正在执行的函数。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>前端vscode插件配置</title>
    <url>/posts/11039/</url>
    <content><![CDATA[<h3 id="外观配置"><a href="#外观配置" class="headerlink" title="外观配置"></a>外观配置</h3><ul>
<li><strong>主题</strong>：<a href="https://marketplace.visualstudio.com/items?itemName=chriseckenrode.vscode-chester-atom">Chester Atom</a></li>
<li><strong>图标</strong>：<a href="https://marketplace.visualstudio.com/items?itemName=emmanuelbeziat.vscode-great-icons">VSCode Great Icons</a></li>
<li><strong>字体</strong>：<a href="https://github.com/tonsky/FiraCode/wiki">Fira Code</a></li>
</ul>
<a id="more"></a>

<h4 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h4><img src="/posts/11039/163001_02d3ddb2_1203301.png" class="" title="UI-Show">


<h4 id="用户设置（User-Settings）"><a href="#用户设置（User-Settings）" class="headerlink" title="用户设置（User Settings）"></a>用户设置（User Settings）</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;editor.fontSize&quot;</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="attr">&quot;workbench.colorTheme&quot;</span>: <span class="string">&quot;Chester Atom&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;editor.fontFamily&quot;</span>: <span class="string">&quot;Fira Code&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;emmet.triggerExpansionOnTab&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;editor.fontLigatures&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="风格检查"><a href="#风格检查" class="headerlink" title="风格检查"></a>风格检查</h3><ul>
<li><strong><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">ESLint</a></strong></li>
<li><strong><a href="https://marketplace.visualstudio.com/items?itemName=shinnn.stylelint">StyleLint</a></strong></li>
<li><strong><a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint">MarkdownLint</a></strong></li>
<li><strong><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">Prettier</a></strong></li>
</ul>
<h3 id="编码效率"><a href="#编码效率" class="headerlink" title="编码效率"></a>编码效率</h3><h4 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h4><ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=abusaidm.html-snippets">HTML Snippets</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippets">Javascript (ES6) Code Snippets</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=nikhilkumar80.js-patterns-snippets">Javascript Patterns Snippets</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=joelday.docthis">Document This</a>，一键给代码中的类、函数加上注释，支持函数声明、函数表达式、箭头函数等；</li>
</ul>
<h4 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h4><ul>
<li><a href="https://link.juejin.im/?target=https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag">Auto Close Tag</a>，在打开标签并且键入 <code>&lt;/</code> 的时候，能自动补全要闭合的标签；</li>
<li><a href="https://link.juejin.im/?target=https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag">Auto Rename Tag</a>，在修改标签名时，能在你修改开始（结束）标签的时候修改对应的结束（开始）标签。</li>
<li><a href="https://link.juejin.im/?target=https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense">Path Intellisense</a>，文件路径补全，在你用任何方式引入文件系统中的路径时提供智能提示和自动完成。</li>
<li><a href="https://link.juejin.im/?target=https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense">NPM Intellisense</a>，NPM 依赖补全，在你引入任何 node_modules 里面的依赖包时提供智能提示和自动完成。</li>
<li><a href="https://link.juejin.im/?target=https://marketplace.visualstudio.com/items?itemName=Zignd.html-css-class-completion">IntelliSense for CSS class names</a>，CSS 类名补全，会自动扫描整个项目里面的 CSS 类名并在你输入类名时做智能提示。</li>
<li><a href="https://link.juejin.im/?target=https://emmet.io">Emmet</a>，VSCode 已经内置，官方介绍文档<a href="https://link.juejin.im/?target=https://code.visualstudio.com/docs/editor/emmet">参见</a>。</li>
</ul>
<h4 id="代码补全"><a href="#代码补全" class="headerlink" title="代码补全"></a>代码补全</h4><ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner">Code Runner</a><!-- [![Code Runner](前端vscode插件配置/162c15a64b468fd8.gif)](https://user-gold-cdn.xitu.io/2018/4/14/162c15a64b468fd8?imageslim) -->
<img src="/posts/11039/162c15a64b468fd8.gif" class="" title="Code-Runner">

</li>
</ul>
<h3 id="功能增强"><a href="#功能增强" class="headerlink" title="功能增强"></a>功能增强</h3><ul>
<li><a href="https://link.juejin.im/?target=https://marketplace.visualstudio.com/items?itemName=naumovs.color-highlight">Color Highlight</a>，识别代码中的颜色，包括各种颜色格式。</li>
<li><a href="https://link.juejin.im/?target=https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer">Bracket Pair Colorizer</a>，识别代码中的各种括号，并且标记上不同的颜色，方便你扫视到匹配的括号。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync">Settings Sync</a>，基于 Gist 实现 VSCode 用户配置、快捷键配置、已安装插件列表等的备份和恢复功能，配置过程有详细精确的操作步骤文档。生成的备份 Gist 默认是私密的，如果你想设置为共享的，也可以一键切换。</li>
</ul>
<h3 id="外观增强"><a href="#外观增强" class="headerlink" title="外观增强"></a>外观增强</h3><ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=wayou.vscode-todo-highlight">TODO Highlight</a><br>维护时间稍长的代码仓库免不了会有各种 TODO、FIXME、HACK 之类的标记，TODO Highlight 能够帮我们把这些关键词高亮出来，在你翻阅代码时非常醒目，就像是在大声提醒你尽快把他解决掉。支持自定义配置需要高亮的关键词，实际使用比较坑的地方是，TODO、FIXME 之类的后面必须加上冒号，否则无法高亮。<!-- [![TODO Highlight](前端vscode插件配置/1)](https://user-gold-cdn.xitu.io/2018/4/14/162c1592cecf92d8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) -->
<img src="/posts/11039/1.png" class="" title="TODO-Highlight"></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>去除图片上下左右间隙</title>
    <url>/posts/31251/</url>
    <content><![CDATA[<h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>当在定宽父容器下有多张图片顺序排列时，图片的上下左右之间都有间隙：</p>
<iframe height="265" scrolling="no" title="KEBmRP" src="https://codepen.io/JingW/embed/KEBmRP/?height=265&amp;theme-id=0&amp;default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<a id="more"></a>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul>
<li>左右：因为 img 是 inline-block 元素，元素代码之间有『换行（回车），空格，tab』时会产生左右间隙。</li>
<li>上下：行内元素默认与父容器基线对齐，而基线与父容器底部有一定间隙，所以上下图片间有间隙。</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>移除上下间隙：<ul>
<li>img本身设置 <code>display: block;</code></li>
<li>父元素设置 <code>font-size: 0;</code> （基线与字体大小有关，字体为零，基线间就没距离了）</li>
<li>img本身设置 <code>vertical-align: bottom;</code>（让inline-block 的 img 与每行的底部对齐）</li>
</ul>
</li>
<li>移除左右间距：<ul>
<li>行内元素间不要有换行，连成一行写消除间隙（阅读性差，不推荐）</li>
<li>第一行img结尾写上 <code>&lt;!--</code> ，第二行img开头跟上 <code>--&gt;</code> 。即利用注释消除间距</li>
<li>父元素 <code>font-size: 0</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>垂直居中方案汇总</title>
    <url>/posts/12733/</url>
    <content><![CDATA[<p>这里汇总了常见的元素居中方案。</p>
<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h3 id="行内元素水平居中"><a href="#行内元素水平居中" class="headerlink" title="行内元素水平居中"></a>行内元素水平居中</h3><p>核心：给父元素添加 <code>text-align: center</code></p>
<iframe height="265" scrolling="no" title="行内元素水平居中" src="https://codepen.io/JingW/embed/mvaNXw/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<a id="more"></a>

<h3 id="块级元素水平居中"><a href="#块级元素水平居中" class="headerlink" title="块级元素水平居中"></a>块级元素水平居中</h3><p>核心：子元素自身 <code>margin: 0 auto;</code></p>
<iframe height="291" scrolling="no" title="块元素水平居中" src="https://codepen.io/JingW/embed/moxbxb/?height=291&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="多个div水平居中"><a href="#多个div水平居中" class="headerlink" title="多个div水平居中"></a>多个div水平居中</h3><h4 id="传统方案"><a href="#传统方案" class="headerlink" title="传统方案"></a>传统方案</h4><p>核心：父元素设置 <code>text-align: center</code> ，子元素设置 <code>inline-block</code></p>
<iframe height="265" scrolling="no" title="多个div水平居中 - 传统方案" src="https://codepen.io/JingW/embed/KEoPGq/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h4 id="Flex方案"><a href="#Flex方案" class="headerlink" title="Flex方案"></a>Flex方案</h4><p>核心：父元素 <code>display: flex</code> + <code>justify-content: center</code> + <code>align-items: center</code></p>
<iframe height="265" scrolling="no" title="多个div水平居中-flex" src="https://codepen.io/JingW/embed/XGEroY/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><h3 id="table自带水平垂直居中"><a href="#table自带水平垂直居中" class="headerlink" title="table自带水平垂直居中"></a>table自带水平垂直居中</h3><p>核心：使用 <code>table&gt;tr&gt;td</code> 布局</p>
<iframe height="460" scrolling="no" title="div水平垂直居中 - table" src="https://codepen.io/JingW/embed/xBWxwe/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="模拟table"><a href="#模拟table" class="headerlink" title="模拟table"></a>模拟table</h3><p>核心：父元素 <code>display: table</code> ，子元素 <code>display: table-cell</code> + <code>vertical-align: middle</code></p>
<iframe height="460" scrolling="no" title="div水平垂直居中 - 模拟table" src="https://codepen.io/JingW/embed/aMYbZx/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="子绝父相-子元素-margin-auto"><a href="#子绝父相-子元素-margin-auto" class="headerlink" title="子绝父相 + 子元素 margin:auto"></a>子绝父相 + 子元素 margin:auto</h3><p>核心：子元素相对于父元素绝对定位，<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 都设为0，margi设为auto</p>
<iframe height="460" scrolling="no" title="div水平垂直居中 - 子绝父相 + Margin Auto" src="https://codepen.io/JingW/embed/PLRYrz/?height=460&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="子绝父相-负margin"><a href="#子绝父相-负margin" class="headerlink" title="子绝父相 + 负margin"></a>子绝父相 + 负margin</h3><p>核心：子元素相对于父元素绝对定位，<code>top</code>、<code>left</code>设为50%，margin相对自身宽/高一半</p>
<iframe height="460" scrolling="no" title="div水平垂直居中 - 子绝父相 + 负Margin" src="https://codepen.io/JingW/embed/oVqNvK/?height=460&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="子绝父相-translate"><a href="#子绝父相-translate" class="headerlink" title="子绝父相 + translate"></a>子绝父相 + translate</h3><p>核心：子元素相对于父元素绝对定位，<code>top</code>、<code>left</code>设为50%，此时子元素左上角在父元素中心，然后让子元素向左上角位移自身宽度的一半</p>
<iframe height="460" scrolling="no" title="div水平垂直居中 - 子绝父相 + translate" src="https://codepen.io/JingW/embed/EMExjr/?height=456&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<h3 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h3><p>父元素 <code>display: flex</code>，<code>justify-content</code> 和 <code>align-items</code> 都设为 center 实现垂直居中</p>
<iframe height="460" scrolling="no" title="div水平垂直居中 - flex" src="https://codepen.io/JingW/embed/rRdNyo/?height=265&amp;theme-id=0&amp;default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】大屏上的全屏页面的自适应适配方案</title>
    <url>/posts/61674/</url>
    <content><![CDATA[<p>转载自：<a href="https://www.njleonzhang.com/2018/08/15/flexible-pc-full-screen.html">https://www.njleonzhang.com/2018/08/15/flexible-pc-full-screen.html</a></p>
<p>通常来说PC端的页面并不像移动端页面那样对屏幕大小和分别率有那么强的依赖。一般的页面都是取屏幕中间的一块宽度(1280px), 两边留白, 高度随着内容的长度滚动。这样无论窗口怎么变化，页面都是可用的。比如，我们的这个页面. 然而也有少数的页面，天生就是要在 pc 端全屏显示的，其中最为典型的代表就是全屏的 dashboard 页面。比如：</p>
<p>当然，如果 dashboard 页面是内嵌在一些管理页面里的，通常是允许滚动的。</p>
<img src="/posts/61674/ba7c9abd-2f10-3890-cfed-f8c389248b53.png" class="" title="admin_dashboard">

<p>但是，如果 dashboard 是用于官方宣传，比如在电视机或者广告屏上的展示的时候，通常是不允许滚动条出现的。比如:</p>
<img src="/posts/61674/0349a840-ed31-06be-207c-e748883522b7.png" class="" title="天猫">

<a id="more"></a>

<blockquote>
<p>这种 dashboard 有个帅气的名字叫数据可视化。</p>
</blockquote>
<h2 id="通常的做法"><a href="#通常的做法" class="headerlink" title="通常的做法"></a>通常的做法</h2><p>为了实现全屏的这种 dashboard, 通常的做法就是要对宽度和高度都做百分比（网格）来实现了。但是这种方案的缺点在于:</p>
<ul>
<li>实现太麻烦。设计师给的设计稿通常是 px 为单位标注的，我们需要仔细的计算宽度和高度的比例，然后小心处理页面的布局。</li>
<li>难以处理屏幕宽高比与设计图不符时，带来的元素变形。所以最后展示的屏幕不能和设计稿的屏幕的宽高比差距太大。</li>
</ul>
<p>比如，下面这个简单的页面就是用百分比方案来做的。设计师给的图的比例为 16: 9。</p>
<img src="/posts/61674/16-9.png" class="" title="16:9">

<img src="/posts/61674/1-1.png" class="" title="1:1">

<p>当窗口比例是 16 : 9 的时候黄色的长方形显示符合设计，当窗口变成正方形的时候，黄色部分也跟着变方了，这必然会影响显示效果。</p>
<p>可以在浏览器中打开，改变窗口大小页面来体验这个<a href="https://quellingblade.github.io/postcss-px-to-rem/percent.html">百分比方案</a>。</p>
<h2 id="理想的效果"><a href="#理想的效果" class="headerlink" title="理想的效果"></a>理想的效果</h2><p>我心目中的理想效果可能是像下面这个页面一样，无论窗口怎么变，我们的内容都保持原来的比例，并尽量占满窗口（类似 background contain 的效果）。</p>
<ul>
<li>屏幕尺寸和设计稿比例(16:9)一致时，占满屏幕</li>
</ul>
<img src="/posts/61674/full-screen.png" class="" title="full-screen">

<ul>
<li>屏幕尺寸比设计图比例瘦时，上下留白，左右占满，并上下居中, 显示的比例保持16：9</li>
</ul>
<img src="/posts/61674/square.png" class="" title="square">

<ul>
<li>屏幕尺寸比设计图比例胖时，左右留白，上下占满，并左右居中, 显示的比例保持16：9</li>
</ul>
<img src="/posts/61674/600-300.png" class="" title="600:300">

<p>可以在浏览器中打开，改变窗口大小页面来体验这个<a href="https://quellingblade.github.io/postcss-px-to-rem/percent.html">flexible方案</a></p>
<h2 id="rem-方案"><a href="#rem-方案" class="headerlink" title="rem 方案"></a>rem 方案</h2><p>熟悉移动端的自适应方案的朋友对 rem 适应方案，肯定不陌生，最出名的就是阿里的 <a href="https://github.com/amfe/lib-flexible">lib-flexible</a> 方案。可能你已经猜到，本文的这个方案肯定也是基于 rem 的。</p>
<p>rem (font size of the root element), 是 css3 的引入的一个大小单位。即相对于根元素的 font-size 值的大小。所谓根元素在网页里一般就是 html. 举例说明：下例中，<code>html 的 font-size 大小</code>是 20px, 那么 1.4rem 和 2.4 rem 就分别代表着 28px 和 48px 了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123; <span class="attribute">font-size</span>: <span class="number">20px</span>; &#125;</span><br><span class="line"><span class="selector-tag">test1</span> &#123;</span><br><span class="line">  width: 1.4rem; //1.4 × 20px = 28px</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">test2</span> &#123;</span><br><span class="line">  height: 2.4rem; //2.4 × 20px = 48px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们的设计稿其尺寸为 1920 * 1280 px，并且实际运行这个网页的屏幕分别率也是 1920 * 1280. 那么，这网页就好做了。简单粗暴地，按图中的元素的尺寸和位置，直接利用绝对定位把所有元素撸出来就行了。比如，设计稿中有这样一个元素:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.doughnut</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这不刚介绍了 rem, 我们试着用 rem 为单位来写一下 <code>doughnut</code> 元素的 css。我们把页面的 html 元素的 font-size 设置为 1920 / 10 = 192 px. 那么 <code>doughnut</code> 这个元素就应该写作：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.doughnut</span> &#123;</span><br><span class="line">  top:  .781rem;     // 150 / 192 = 0.781</span><br><span class="line">  left: .156rem;     // 30  / 192 = 0.156</span><br><span class="line">  width: 2.083rem;   // 400 / 192 = 2.083</span><br><span class="line">  height: 1.563rem;  // 300 / 192 = 1.564</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>恩。。。。这不是有病么？算成 rem，然后设置一下 html 的 font-size 让浏览器再算回去？显摆自己的数学好么？23333。</p>
<p>注意上上面有一个假设，<strong>屏幕大小正好是 1920 * 1280</strong>。这个假设真的很假，根本不可能，一旦用了 px，那么一切长宽都死了。这时你再看一眼 rem，真实的长度为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">实际长度(px) = rootFontSize (html 的 font-size) * rem 长度</span><br></pre></td></tr></table></figure>

<p>那么这个实际长度必然有一下特点：</p>
<ul>
<li>所有长度的比例必然和设计图一致。</li>
<li>实际的显示长度完全由 <code>html 的 font-size</code> 值决定（线性关系）。</li>
</ul>
<p>我们来证明一下：</p>
<blockquote>
<p>设：设计稿上有任一1条线: A, A 的长度为 xx, <code>计算 rem 值的基准</code>为 zz<br>那么 css 里，A 的长度表示为 xzxz (rem)</p>
<p>设网页运行时的 html 的 font-size 值为 fsfs，</p>
<p>那么 A 的实际显示长度就分为 xfszxfsz (px)</p>
<p>所以：</p>
<ol>
<li>对于任意2条线，其实际长度的比例为 x1fszx1fsz ： x2fszx2fsz 就等于 他们在设计图上的比例 x1x1 : x2x2</li>
<li>对于任意一条线，xx 和 zz 是固定值，其实际值随着 fsfs 值线性关系变化的</li>
</ol>
</blockquote>
<p>我们取设计图的边框的4条线来分析, 那么<code>设计稿</code>，<code>真实显示（画布）</code>和 <code>显示窗口（全屏时，即为屏幕）</code>的关系如下图所示:</p>
<img src="/posts/61674/70ef9642-13d0-a15c-ff25-23feaef1029b.png" class="" title="70ef9642-13d0-a15c-ff25-23feaef1029b">

<ul>
<li>设计稿的宽高分别为 axax 和 ayay, 比例为 xx : yy.</li>
<li>实际显示的范围（我们称其为画布）比例和设计稿保持一致，所以可以设实际显示的画布的宽高为bx:bybx:by, 且所有线的实际显示长度是由 <code>html 的 font-size 值</code> fsfs 线性决定的。</li>
<li>屏幕的尺寸不确定，假设其宽度为 ww, 高度为 hh</li>
</ul>
<blockquote>
<p>小结一下，用了上面提到的 rem 来方案后，我们做出来的页面是一个<strong>和设计稿比例一致的</strong>，并且<strong>大小根据网页运行时的 html 的 font-size的值缩放</strong>的页面。</p>
</blockquote>
<p>既然页面的大小可以按<strong>html 的 font-size的值</strong>缩放，那么如果我希望<strong>画布的实际显示宽度</strong>始终和<strong>浏览器窗口宽度</strong>保持一致的话（即下图这样的状态），<strong>html 的 font-size的值</strong>应该如何设置呢？</p>
<img src="/posts/61674/19e45d16-534a-9ac3-578c-83bb3f01b45f.png" class="" title="19e45d16-534a-9ac3-578c-83bb3f01b45f">

<p>我们假设 <code>计算 rem 值的基准</code> 为设计稿宽度的 1q1q:</p>
<blockquote>
<p>假设，设计稿窗口宽为 axax，高为 ayay, 则<code>计算 rem 值的基准</code> zz 为 axqaxq</p>
<p>那么按上面的公式，浏览器中画布实际的<br>宽度为 axfsaxq=fsqaxfsaxq=fsq，<br>高度为 ayfsaxq=qyfsxayfsaxq=qyfsx</p>
<p>浏览器窗口的宽度 ww 要等于画布实际的宽度，即 w=fsqw=fsq，则 fs=wqfs=wq</p>
</blockquote>
<p>好的，从数学回到我们的工程中来，我们的设计稿尺寸是 1920 * 1280。我们取 qq 这个值为 10, 则 <code>计算 rem 值的基准</code> zz 为 axq=192010=192axq=192010=192. 然后我们把<strong>所有元素的长、宽、位置、字体大小等原来 <code>px</code> 单位都转换成 rem</strong>，网页加载后，我们<strong>用 js 去计算当前浏览器窗口的宽度，并设置 <code>html 的 font-size</code> fsfs 为<code>当前浏览器窗口的宽度</code> ww 的 1q1q，即 w10w10，这样我们就做出了一个100%宽度的、等比例缩放设计稿的页面</strong>了。</p>
<blockquote>
<p>通过这样的设置，我就得到了一个<strong>和设计稿比例一致的</strong>，<strong>宽度与窗口大小一致</strong>的页面。</p>
</blockquote>
<p>到此为止，就是现有 rem 方案的核心内容了。</p>
<p>说了半天，都是别人的方案，读者可能会问了，那博主你干了啥？</p>
<h2 id="我的方案"><a href="#我的方案" class="headerlink" title="我的方案"></a>我的方案</h2><p>回头想一下，我们要的是什么？现在这个方案，能满足我们的要求么？我们来逐条分析：</p>
<ul>
<li>屏幕（窗口）尺寸和设计稿比例(x:yx:y)一致时，占满屏幕</li>
</ul>
<img src="/posts/61674/327c8e32-cb68-0615-fa7f-b0bbec3dc4f1.png" class="" title="327c8e32-cb68-0615-fa7f-b0bbec3dc4f1">

<p>这种情况肯定没问题，屏幕和真实页面完美重合.</p>
<ul>
<li>屏幕（窗口）尺寸比设计图比例瘦时，上下留白，左右占满，并上下居中, 显示的比例保持(x:yx:y)</li>
</ul>
<img src="/posts/61674/19e45d16-534a-9ac3-578c-83bb3f01b45f(1).png" class="" title="19e45d16-534a-9ac3-578c-83bb3f01b45f(1)">

<p>这种情况也没问题，真实页面高度小于屏幕，然后页面内容上下居中就可以了。</p>
<ul>
<li>屏幕（窗口）尺寸比设计图比例胖时，左右留白，上下占满，并左右居中, 显示的比例保持(x:yx:y)</li>
</ul>
<img src="/posts/61674/c2b3b4d8-759c-14ce-2ffe-6ab2f59b15b4.png" class="" title="c2b3b4d8-759c-14ce-2ffe-6ab2f59b15b4">

<p>问题出现了，在这种场景下，页面的高度超出了屏幕的高度，这就会导致垂直滚动条了。这就是我的方案处理的地方了。在这种场景下，我们需要页面的高度缩小为屏幕的高度，当然为了保持比例页面的宽度等也要等比例缩小.换句话说我们要把所有的线的长度等比例缩小，缩小后画布的高度要等于屏幕的高度，即下图所示的状态:</p>
<img src="/posts/61674/d312b3ec-ded3-746f-9e59-7daa68811f30.png" class="" title="d312b3ec-ded3-746f-9e59-7daa68811f30">

<p>要等比例缩小所有的长度，那么操作 <code>html 的 font-size</code> fsfs 的值就能做到了。我们上面的分析中，我们已经计算了页面（画布）的真实高度</p>
<blockquote>
<p>那么按上面的公式，浏览器中页面（画布）的真实<br>高度为 ayfsaxq=qyfsx</p>
</blockquote>
<p>在此场景下，我们需要把画布真实高度值缩小到屏幕的高度,</p>
<blockquote>
<p>设窗口的高度为 hh,<br>设缩小比例为 ss, 则有 h=qyfsxsh=qyfsxs, 得 s=xhqyfss=xhqyfs<br>即我们需要在页面（画布）真实高度上 qyfsxqyfsx 乘上个缩小系数 xhqyfsxhqyfs，可以使 页面（画布）的真是高等于窗口的高度了<br>又因为 fs=wqfs=wq, 则这个缩小系数可变换为:<br>xhqywq=xhyw=xy/whxhqywq=xhyw=xy/wh, 即 设计稿宽高比窗口宽高比</p>
</blockquote>
<p>Bingo. 综上可知: 当窗口尺寸比设计图比例胖时，只要我们在原来 fsfs 值的基础上，乘上 设计稿宽高比窗口宽高比设计稿宽高比窗口宽高比 的缩小系数，就可以实现我们想要的效果了。</p>
<h2 id="工程应用"><a href="#工程应用" class="headerlink" title="工程应用"></a>工程应用</h2><p>好了，前面的理论，你看着头疼，我写着更头疼。终于到了喜闻乐见的运用环节了。</p>
<p>按照前面的一顿操作，应用这个方案，我们需要做2件事: （以设计稿的尺寸为 1920 * 1280 为例）</p>
<ol>
<li>在 css 表示长度的时候，用设计稿上的长度除以 192, 算得 rem 的值。</li>
<li>页面内写一段 js 代码，根据我们上面的公式去计算并设置 <code>html 元素的 font-size</code> 值。</li>
</ol>
<p>关于第1点：如果告诉你所有的长度你要自己算。。。可能这个方案马上就没人用了，因为真的要算死人。参照 <a href="https://github.com/amfe/lib-flexible">lib-flexible</a> 的方案，我写了一个 <a href="https://github.com/QuellingBlade/postcss-px-to-rem">post-css 插件</a>来帮助你做这个计算，效果就是你不用算了，图上是多少长度，你写多少就行了，这个 rem 的转换由<a href="https://github.com/QuellingBlade/postcss-px-to-rem">插件</a>完成。</p>
<p>关于第2点：这段 js 代码我已经为你写好了 <a href="https://github.com/QuellingBlade/lib-flexible-for-dashboard">lib-flexible-for-dashboard</a>, 直接嵌入你的 html 里就行。考虑到这段 js 代码，会计算 font-size 的值，这个值会决定所有的长度，所以这个值要优先计算出来，最好的方案就是把这段代码拷贝到 html 的 head 里去（这个操作被称为 inline）. 为了方便你使用webpack 和 npm 管理这个库，我们还为你准备了一个 <a href="https://github.com/QuellingBlade/html-webpack-inline-plugin">webpack 插件</a>，帮助你去做 inline.</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote>
<p>talk is cheap, show me the <a href="https://github.com/njleonzhang/flexible-pc-full-screen">code</a></p>
</blockquote>
<p>设计稿是这样的一个 1920 * 1280（16：9）的图:</p>
<img src="/posts/61674/562e47bd-abda-dae4-7765-68706b5a978e.png" class="" title="562e47bd-abda-dae4-7765-68706b5a978e">

<p>实现的[效果]在这：<a href="http://www.njleonzhang.com/flexible-pc-full-screen/">http://www.njleonzhang.com/flexible-pc-full-screen/</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我是站在巨人的肩膀上，针对全屏 pc 页面这一特别场景做出了一个个人比较满意的方案，希望能给有需要的朋友一些帮助。</p>
<p>相关项目：</p>
<ul>
<li><a href="https://github.com/njleonzhang/flexible-pc-full-screen">https://github.com/njleonzhang/flexible-pc-full-screen</a></li>
<li><a href="https://github.com/QuellingBlade/postcss-px-to-rem">https://github.com/QuellingBlade/postcss-px-to-rem</a></li>
<li><a href="https://github.com/QuellingBlade/lib-flexible-for-dashboard">https://github.com/QuellingBlade/lib-flexible-for-dashboard</a></li>
<li><a href="https://github.com/QuellingBlade/html-webpack-inline-plugin">https://github.com/QuellingBlade/html-webpack-inline-plugin</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>大屏</tag>
      </tags>
  </entry>
  <entry>
    <title>奇妙的-webkit-background-clip</title>
    <url>/posts/12897/</url>
    <content><![CDATA[<p>github 链接：<a href="https://github.com/chokcoco/iCSS/issues/14">https://github.com/chokcoco/iCSS/issues/14</a></p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><iframe height="1449" scrolling="no" title="existential gradient buttons" src="https://codepen.io/JingW/embed/gObGjww?height=1449&amp;theme-id=default&amp;default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 997.594px;"></iframe>

<p>原特效链接：<a href="https://codepen.io/cubeghost/pen/ByJGEN">A PEN BY alex baldwin</a></p>
<h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip">MDN - background-clip</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-image-slice">MDN - border-image-slice</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>如何清除浮动</title>
    <url>/posts/12906/</url>
    <content><![CDATA[<h2 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h2><p>其实浮动（e.g. <code>float: left;</code>）本质上是用来做文字混排的，但却被我们拿来做布局，这个时候虽然实现了某些效果，但也带来了不少副作用。</p>
<p>由于浮动元素不再占有原文档流的位置，所以它会对后续元素的排版带来影响（无视浮动元素，就当它不存在过）。因此我们很多时候要做的，就是消除浮动元素造成的影响。清除浮动的本质主要是为了解决父元素因为子元素浮动造成的内部高度为0的问题。</p>
<a id="more"></a>

<h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>清除浮动的核心css属性是 clear ，基本语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器: &#123;</span><br><span class="line">    <span class="attribute">clear</span>: 属性值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">属性值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">left</td>
<td align="left">不允许左侧有浮动元素（清除左侧浮动的影响）</td>
</tr>
<tr>
<td align="left">right</td>
<td align="left">不允许右侧有浮动元素（清除右侧浮动的影响）</td>
</tr>
<tr>
<td align="left">both</td>
<td align="left">同时清除左右两侧浮动的影响</td>
</tr>
</tbody></table>
<h2 id="清除浮动常见方案"><a href="#清除浮动常见方案" class="headerlink" title="清除浮动常见方案"></a>清除浮动常见方案</h2><h3 id="额外标记法"><a href="#额外标记法" class="headerlink" title="额外标记法"></a>额外标记法</h3><p>在浮动元素后面添加一个空标签，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>优点：通俗易懂，书写方便<br>缺点：加入了过多的没有实际含义的额外标签，结构化差。</p>
<h3 id="父元素添加overflow"><a href="#父元素添加overflow" class="headerlink" title="父元素添加overflow"></a>父元素添加overflow</h3><p>通过触发BFC达到清除浮动的效果。（p.s. 对bfc不了解可以看<a href="https://evestorm.github.io/posts/9722/">这篇</a>文章）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：代码简洁<br>缺点：超出的内容会被隐藏</p>
<h3 id="before和after双伪元素方案"><a href="#before和after双伪元素方案" class="headerlink" title="before和after双伪元素方案"></a>before和after双伪元素方案</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;  <span class="comment">/* 触发BFC清除浮动 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    <span class="attribute">*zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：代码简洁<br>缺点：IE6-7不支持:after，需要使用 <code>zoom: 1</code> 触发 <code>hasLayout</code></p>
<h3 id="使用after伪元素（我平常使用的）"><a href="#使用after伪元素（我平常使用的）" class="headerlink" title="使用after伪元素（我平常使用的）"></a>使用after伪元素（我平常使用的）</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;  </span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    <span class="attribute">*zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;   <span class="comment">/* IE6、7 专有 */</span></span><br></pre></td></tr></table></figure>

<p>使用方式：给浮动元素的父元素添加一个class类：<code>clearfix</code><br>优点：一次书写多处使用，并且符合闭合浮动思想，结构语义化正确<br>缺点：IE6-7不支持:after，需要使用 <code>zoom: 1</code> 触发 <code>hasLayout</code><br>注意：<code>content:&quot;.&quot;</code> 内容尽量不为空，可以跟一个小点，否则在firefox 7.0前的版本会生成空格</p>
<h2 id="after-和-after-的区别"><a href="#after-和-after-的区别" class="headerlink" title=":after 和 ::after 的区别"></a>:after 和 ::after 的区别</h2><p>:before、:after 在旧版本里是伪元素，CSS3的规范里 “:” 用来表示伪类，”::” 用来表示伪元素，但是在高版本浏览器下 :before、:after 会被自动识别为 ::before、::after ，这样做的目的是用来做兼容处理。</p>
<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>伪类对象，用来设置对象前的内容<br>:before 和 ::before 写法是等效的</p>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>:before 是 css2 的写法，::before 是 css3 的写法<br>:before 兼容性比 ::before要好</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>伪类元素必须要配合 content 属性一起使用，否则无效<br>伪类元素是css渲染层加入的，不能通过js来操作</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】如何在Mac上配置一个本地Web服务器</title>
    <url>/posts/28116/</url>
    <content><![CDATA[<p>来源：<a href="https://shannonchenchn.github.io/2018/10/22/How-do-you-set-up-a-local-web-server-on-Mac/">https://shannonchenchn.github.io/2018/10/22/How-do-you-set-up-a-local-web-server-on-Mac/</a></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>我们为什么需要服务器？<ul>
<li><ol>
<li>本地文件 VS. 远程文件</li>
</ol>
</li>
<li><ol>
<li>直接访问本地文件时存在的问题</li>
</ol>
</li>
</ul>
</li>
<li>方法一、启动 Mac 自带的 Apache 服务器</li>
<li>方法二：使用 Python 的 SimpleHTTPServer 模块启动服务器</li>
</ul>
<h3 id="我们为什么需要服务器？"><a href="#我们为什么需要服务器？" class="headerlink" title="我们为什么需要服务器？"></a>我们为什么需要服务器？</h3><h4 id="1-本地文件-VS-远程文件"><a href="#1-本地文件-VS-远程文件" class="headerlink" title="1. 本地文件 VS. 远程文件"></a>1. 本地文件 VS. 远程文件</h4><p>通常情况下，你可以通过在浏览器中直接打开或者通过一个 URL 来访问一个文件。</p>
<p>使用浏览器访问本地文件时，一般地址是 <code>file://</code> 开头的本地文件地址。<br>而访问远程文件时，一般地址是 <code>http://</code> 或者 <code>https://</code> 开头的地址，表示这个文件通过 http 协议访问的。</p>
<h4 id="2-直接访问本地文件时存在的问题"><a href="#2-直接访问本地文件时存在的问题" class="headerlink" title="2. 直接访问本地文件时存在的问题"></a>2. 直接访问本地文件时存在的问题</h4><p>在有些情况下，你打开一个本地的 html 文件时，会出现运行错误。</p>
<p>导致这些错误的原因主要有以下两个：<br>（1） 其中包含了异步请求。 如果你直接打开本地文件运行，一些浏览器（包括 Chrome）将不会运行其中的异步请求（请参阅 从服务器获取数据）。 这是因为安全限制而导致的（更多关于 Web 安全的信息，请参阅<a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/First_steps/Website_security">Website security</a>）。</p>
<p>比如，你直接在浏览器中打开含有如下内容的文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(request);</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 发送请求:</span></span></span><br><span class="line"><span class="javascript">      request.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;./data.json&#x27;</span>);</span></span><br><span class="line">      request.send();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML 测试页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>测试页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，你会在 console 中看到这样的错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">index.html:12 Failed to load file:///Users/ShannonChen/Desktop/Playground/nodejs_example/data.json: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.</span><br></pre></td></tr></table></figure>

<p>（2） 执行文件中的代码时需要通过执行一些附加逻辑（如 PHP 或 Python）才能获得结果，而不仅仅是直接访问一个文件。</p>
<p>比如，我登录了京东网站后，查看购物车页面时，需要服务器返回的是包含我的购物车数据的页面，这个时候，就需要服务端在接收到请求后，跟我的用户信息（一般是 cookie）来返回匹配的数据。</p>
<h3 id="方法一、启动-Mac-自带的-Apache-服务器"><a href="#方法一、启动-Mac-自带的-Apache-服务器" class="headerlink" title="方法一、启动 Mac 自带的 Apache 服务器"></a>方法一、启动 Mac 自带的 Apache 服务器</h3><ol>
<li>运行 Apache <code>$ sudo apachectl start</code></li>
<li>退出 Apache <code>$ sudo apachectl stop</code></li>
<li>把工程文件夹放到以下位置中 <code>/Library/WebServer/Documents</code></li>
<li>在浏览器中访问：在地址栏中输入地址 <code>http://localhost/工程文件夹名称/</code>，回车。</li>
</ol>
<p><strong>注意：</strong> 不再需要使用后一定要记得退出，否则会消耗电脑性能。</p>
<p>Q：如何修改 Apache 的默认端口？<br>A：首先，找到 Apache 的配置文件，位于 <code>/etc/apache2</code> 下的 <code>httpd.conf</code>。<br>然后，找到 <code>Listen 80</code> 那一行，修改成你想要的端口即可。</p>
<h3 id="方法二：借助-Mac-系统自带的-Python，使用其中的-SimpleHTTPServer-模块启动服务器"><a href="#方法二：借助-Mac-系统自带的-Python，使用其中的-SimpleHTTPServer-模块启动服务器" class="headerlink" title="方法二：借助 Mac 系统自带的 Python，使用其中的 SimpleHTTPServer 模块启动服务器"></a>方法二：借助 Mac 系统自带的 Python，使用其中的 SimpleHTTPServer 模块启动服务器</h3><ol>
<li><p>安装 Python，其实 Mac 系统就自带了 Python2.7。</p>
</li>
<li><p>通过 <code>cd &lt;your-working-dir&gt;</code> 进入到你的工作目录下，也就是你要让别人访问的文件所在的目录。</p>
</li>
<li><p>在工作目录下执行下面的命令后，就可以启动服务了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果你的 Python 版本是 3.X</span></span><br><span class="line">python3 -m http.server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果你的 Python 版本是 2.X</span></span><br><span class="line">python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认情况下，上面的操作将会在本地 Web 服务器上的端口 8000 上运行工作目录中的内容。您可以通过在浏览器中输入 URL <code>http://localhost:8000</code> 并回车，来访问此服务器。你会看到列出的目录的内容，点击就可以查看你想运行的 HTML 文件。</p>
</li>
</ol>
<p>Q：如何修改服务器的默认端口？<br>A：可以通过运行下面的命令来指定一个端口号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果你的 Python 版本是 3.X</span></span><br><span class="line">python -m http.server &lt;your-port&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果你的 Python 版本是 2.X</span></span><br><span class="line">python -m SimpleHTTPServer &lt;your-port&gt;</span><br></pre></td></tr></table></figure>

<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>方法二相比方法一来说，更简单、方便，也更灵活，而且还可以随时在终端上看到服务器的状态。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/set_up_a_local_testing_server">How do you set up a local testing server? - Learn web development | MDN</a>（推荐阅读）</li>
<li><a href="https://www.jianshu.com/p/d006a34a343f">Mac OS X 启用 Web 服务器</a></li>
<li><a href="http://www.jianshu.com/p/90d5fa728861">Mac 自带的本地服务器的使用</a></li>
<li><a href="https://blog.csdn.net/seafishyls/article/details/44546809">Mac OS 原来自带了 apache，基本用法总结</a></li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>如何解决0.1+0.2不等于0.3的问题</title>
    <url>/posts/21245/</url>
    <content><![CDATA[<h2 id="为何会出现此问题？"><a href="#为何会出现此问题？" class="headerlink" title="为何会出现此问题？"></a>为何会出现此问题？</h2><p>总结一句话：这是因为二进制模拟十进制进行运算时的精度问题。</p>
<p>具体可查看 <a href="https://juejin.im/post/5b90e00e6fb9a05cf9080dff">0.1 + 0.2 不等于 0.3？为什么 JavaScript 有这种“骚”操作？</a> 这篇掘金文章。</p>
<a id="more"></a>

<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><h3 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h3><p>第一种方法是利用 <code>Number.EPSILON</code> ，这个值无限接近于 0。0.1+0.2 的精度误差在这个值的范围内：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numbersEqual</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a-b)&lt;<span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">0.1</span>+<span class="number">0.2</span>， b=<span class="number">0.3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(numbersEqual(a,b));    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="内置函数-toFixed"><a href="#内置函数-toFixed" class="headerlink" title="内置函数 toFixed"></a>内置函数 toFixed</h3><p>利用 <code>parseFloat</code> + 内置函数 toFixed：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatNum</span>(<span class="params">num, fixed = <span class="number">10</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// a.toFixed(fixed) 先转为小数点10位的字符串 &quot;0.3000000000&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseFloat</span>(a.toFixed(fixed)); <span class="comment">// 然后通过parseFloat转为浮点数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(formatNum(a)); <span class="comment">//0.3</span></span><br></pre></td></tr></table></figure>

<h3 id="内置函数-toPrecision"><a href="#内置函数-toPrecision" class="headerlink" title="内置函数 toPrecision"></a>内置函数 toPrecision</h3><p>我平常用此函数来计算精度，具体可参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision">Number.prototype.toPrecision() | MDN</a>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内置函数toPrecision(中文：精确，精度)</span></span><br><span class="line"><span class="comment">// 参数是精度.比如5.1234，传2返回5.1，传1返回5；0.2+0.1传2返回0.30</span></span><br><span class="line">(<span class="number">0.1</span> + <span class="number">0.2</span>).toPrecision(<span class="number">10</span>) == <span class="number">0.3</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>字体侵权避坑指南</title>
    <url>/posts/9274/</url>
    <content><![CDATA[<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>本文摘录自：<a href="https://www.uisdc.com/avoiding-pits-in-font-copyright">https://www.uisdc.com/avoiding-pits-in-font-copyright</a></p>
<p><strong>初始设定：</strong>字体，微软雅黑。</p>
<p><strong>场景设定：</strong>因产品需要，客户希望在 windows 的客户端查看网站都能够和设计稿保持一致用微软雅黑。项目组给了两种前端解决方案：</p>
<ul>
<li>在 css 样式文件中：引用字体样式为微软雅黑。</li>
<li>在网站样式文件中，打包微软雅黑字体，客户打开网站会预加载微软雅黑字体。</li>
</ul>
<p>请问两种解决方案应该用哪一个？</p>
<a id="more"></a>

<p><strong>案例分析：</strong></p>
<p>应使用第一种方案，因为第一种方案，我们只是设定了如果载体有安装微软雅黑的字体的客户端，那网站显示字体，这个字体授权的控制单位在客户端那里。如果用第二种方案，我们预置了，不管任何客户端都加载微软雅黑字体，除非客户已经购买了微软雅黑所属的方正公司授权商用，否则即判定为字体侵权。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">font-family: &#x27;微软雅黑&#x27;;</span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;MyFont&#x27;</span>; <span class="comment">/* 字体名称 */</span></span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;微软雅黑.ttf&#x27;</span>); <span class="comment">/*字体源文件*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字体侵权情况"><a href="#字体侵权情况" class="headerlink" title="字体侵权情况"></a>字体侵权情况</h2><p>1 图片或视频中使用了版权字体。</p>
<ol start="2">
<li>网站本身引入了字体库文件（直接将整个字体库加载了，也就是说如果浏览者没有这个字体，则会下载这种）</li>
</ol>
]]></content>
      <categories>
        <category>设计</category>
        <category>平面</category>
      </categories>
      <tags>
        <tag>字体侵权</tag>
      </tags>
  </entry>
  <entry>
    <title>对HTML语义化的理解</title>
    <url>/posts/2906/</url>
    <content><![CDATA[<h2 id="对HTML语义化的理解"><a href="#对HTML语义化的理解" class="headerlink" title="对HTML语义化的理解"></a>对HTML语义化的理解</h2><p>核心：用正确的标签做正确的事情</p>
<ol>
<li>利与开发：方便代码的阅读和维护</li>
<li>利于SEO：方便爬虫根据 语义标签 确定 页面结构 和 关键字 的权重</li>
</ol>
<a id="more"></a>

<h2 id="常见语义化标签"><a href="#常见语义化标签" class="headerlink" title="常见语义化标签"></a>常见语义化标签</h2><p>一图胜千言：</p>
<img src="/posts/2906/f8442d9e-e30d-11e6-85aa-3e3fb75f9695.jpg" class="" title="语义化demo">


<p>元素细节：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/main">main</a> 存放每个页面独有的内容。每个页面上只能用一次 <code>&lt;main&gt;</code>，且直位于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body">``</a>中。最好不要把它嵌套进其它元素。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article">article</a> 包围的内容即一篇文章，与页面其它部分无关（比如一篇博文）。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section">section</a> 与 <code>&lt;article&gt;</code> 类似，但 <code>&lt;section&gt;</code> 更适用于组织页面使其按功能（比如迷你地图、一组文章标题和摘要）分块。一般的最佳用法是：以 <a href="https://developer.mozilla.org/en-US/Learn/HTML/Howto/Set_up_a_proper_title_hierarchy">标题</a> 作为开头；也可以把一篇 <code>&lt;article&gt;</code> 分成若干部分并分别置于不同的 <code>&lt;section&gt;</code> 中，也可以把一个区段 <code>&lt;section&gt;</code> 分成若干部分并分别置于不同的 <code>&lt;article&gt;</code> 中，取决于上下文。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/aside">aside</a> 包含一些间接信息（术语条目、作者简介、相关链接，等等）。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/header">header</a> 是简介形式的内容。如果它是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body">body</a> 的子元素，那么就是网站的全局页眉。如果它是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article">article</a> 或<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section">section</a> 的子元素，那么它是这些部分特有的页眉（此 <code>&lt;header&gt;</code> 非彼 <a href="https://developer.mozilla.org/zh-CN/docs/learn/HTML/Introduction_to_HTML/The_head_metadata_in_HTML#%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%A0%87%E9%A2%98">标题</a>）。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/nav">nav</a> 包含页面主导航功能。其中不应包含二级链接等内容。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/footer">footer</a> 包含了页面的页脚部分。</li>
</ul>
<p>来源：<a href="https://developer.mozilla.org/zh-CN/docs/learn/HTML/Introduction_to_HTML/%E6%96%87%E4%BB%B6%E5%92%8C%E7%BD%91%E7%AB%99%E7%BB%93%E6%9E%84">文档与网站架构</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>对this指向的判定</title>
    <url>/posts/33207/</url>
    <content><![CDATA[<h2 id="对-this-的理解"><a href="#对-this-的理解" class="headerlink" title="对 this 的理解"></a>对 this 的理解</h2><p>对于this指向的判定，时刻记住下面两点就好：</p>
<ul>
<li>普通函数的 this 指向是在函数的执行期间绑定的，换句话说 this 总是指向函数的<strong>直接</strong>调用者</li>
<li>箭头函数的 this 指向是在函数创建期间就绑定好了的，指向的是创建该箭头函数所在的作用域对象</li>
</ul>
<a id="more"></a>

<h2 id="普通函数中的this"><a href="#普通函数中的this" class="headerlink" title="普通函数中的this"></a>普通函数中的this</h2><p>这里直接引用 <a href="https://github.com/getify/You-Dont-Know-JS">You-Dont-Know-JS</a> 中对 this 的判定步骤：</p>
<ol>
<li>函数是通过 <code>new</code> 被调用的吗（<strong>new 绑定</strong>）？如果是，<code>this</code> 就是新构建的对象。<br><code>var bar = new foo()</code></li>
<li>函数是通过 <code>call</code> 或 <code>apply</code> 被调用（<strong>明确绑定</strong>），甚至是隐藏在 <code>bind</code> <em>硬绑定</em> 之中吗？如果是，<code>this</code> 就是那个被明确指定的对象。<br><code>var bar = foo.call( obj2 )</code></li>
<li>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（<strong>隐含绑定</strong>）？如果是，<code>this</code> 就是那个环境对象。<br><code>var bar = obj1.foo()</code></li>
<li>否则，使用默认的 <code>this</code>（<strong>默认绑定</strong>）。如果在 <code>strict mode</code> 下，就是 <code>undefined</code>，否则是 <code>global</code> 对象。<br><code>var bar = foo()</code></li>
</ol>
<h2 id="常见this指向"><a href="#常见this指向" class="headerlink" title="常见this指向"></a>常见this指向</h2><ul>
<li>普通函数中this ——&gt; window</li>
<li>构造函数中this ——&gt; new出来的实例对象</li>
<li>方法中的this ——&gt; 实例对象</li>
<li>原型中的方法中的this ——&gt; 实例对象</li>
<li>定时器中的this ——&gt; window</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>对闭包的理解</title>
    <url>/posts/29980/</url>
    <content><![CDATA[<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>我一直认为，MDN是前端学习的在线指南。只要有不懂的语法，或者不懂的概念，查找资料的首选就应该是它。虽然早些年做iOS开发的时候就就接触过闭包，但如今已经忘得一干二净，所以在想要了解闭包的时候，第一件事就是在MDN中搜索。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">其中</a>给到了一个闭包的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>;    <span class="comment">// name 是一个被 init 创建的局部变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123; <span class="comment">// displayName() 是内部函数,一个闭包</span></span><br><span class="line">        alert(name);         <span class="comment">// 使用了父函数中声明的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> displayName;      <span class="comment">// 返回 displayName 这个函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunc = makeFunc();</span><br><span class="line">myFunc(); <span class="comment">// 当执行myFunc时，其实调用了displayName，会弹窗显示&quot;Mozilla&quot;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>在上面这个例子中，一个函数套了一个函数，且这个内部函数使用到了外部函数中的变量，这个时候就形成了闭包。有什么用呢？其中一个用处就如上面代码所示，能够让 makeFunc 函数外面也能访问 name 这个局部变量。换句话说，闭包缓存了数据，延长了作用域链。</p>
<p>Kyle Simpson编写的<a href="https://github.com/getify/You-Dont-Know-JS">You-Dont-Know-JS</a>中对闭包的总结我觉得很精髓：</p>
<blockquote>
<p>闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。</p>
</blockquote>
<h2 id="闭包的特性"><a href="#闭包的特性" class="headerlink" title="闭包的特性"></a>闭包的特性</h2><ol>
<li>函数内再嵌套函数</li>
<li>内部函数可以引用外层的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ol>
<h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><h3 id="读取正确的值"><a href="#读取正确的值" class="headerlink" title="读取正确的值"></a>读取正确的值</h3><p>一个经典的例子，给 ul&gt;li 下面的每个 li 节点添加点击事件，让其弹出当前 li 元素的索引：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;testUL&quot;</span>&gt;</span><br><span class="line">    &lt;li&gt; index = <span class="number">0</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt; index = <span class="number">1</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt; index = <span class="number">2</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt; index = <span class="number">3</span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> nodes = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        nodes[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>运行上述代码后就会发现，每次打印的结果都显示为4，而不是真正的索引值。这是因为点击事件的匿名函数发生在for循环之后，而for循环执行完毕时 i 的值就为4，所以点谁都是同样的结果。那么这个时候就能通过<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">立即执行函数</a> + <strong>闭包</strong>的方法解决此问题：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> nodes = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i += <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">        nodes[i].onclick = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123; <span class="comment">// 1. IIFE创建一个函数作用域</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 4. 返回这个匿名函数，延长作用域链</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 3. 内部嵌套的匿名函数使用到了IIFE的参数i，形成闭包</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(i);</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">        &#125;)(i); <span class="comment">// 2. 给IIFE传递每次for循环的i</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个时候触发click事件，打印的值就是li元素的索引了。</p>
<h3 id="高级排他"><a href="#高级排他" class="headerlink" title="高级排他"></a>高级排他</h3><p>这个例子有点像上面的，现在我们要个需求：在一个 <code>ul li</code> 列表中，鼠标移入时高亮当前li标签，移除之前li标签的高亮状态。</p>
<p>常规写法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设给li添加active类可以让标签高亮</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> list = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">    <span class="comment">// 遍历每个标签</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> li = list[i]</span><br><span class="line">      li.onmouseover = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// mouseover触发后遍历整个列表，将所有标签class设为空</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; list.length; j++) &#123;</span><br><span class="line">          list[j].className = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后给当前li标签添加active</span></span><br><span class="line">        <span class="built_in">this</span>.className = <span class="string">&#x27;active&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码能够实现功能，然而一旦列表非常长性能就不高，所以可以利用闭包来缓存li标签的索引，使其与标签一一对应：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> list = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">  <span class="comment">// 记录上一次选中的li标签的对应索引</span></span><br><span class="line">  <span class="keyword">let</span> preActiveIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> li = list[i]</span><br><span class="line">      li.onmouseover = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 清除上次li标签的高亮</span></span><br><span class="line">        list[preActiveIndex].className = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">// 设置当前位高亮</span></span><br><span class="line">        <span class="built_in">this</span>.className = <span class="string">&#x27;active&#x27;</span></span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        preActiveIndex = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h3><p>在团队开发中，为了避免命名冲突通常不同成员会把自己的代码单独封装起来，最后return一个对象出去，挂载到window上。这样其他人也可以使用，而且能在一定程度上避免命名冲突：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">w</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> money = <span class="number">1000</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    money *= <span class="number">10</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;赚了一笔钱，总资产：&quot;</span> + money + <span class="string">&quot;元&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    money--</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;花了一笔钱，总资产：&quot;</span> + money + <span class="string">&quot;元&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向外暴露对象</span></span><br><span class="line">  w.myTools = &#123;</span><br><span class="line">    get,</span><br><span class="line">    set</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>

<h3 id="函数节流防抖"><a href="#函数节流防抖" class="headerlink" title="函数节流防抖"></a>函数节流防抖</h3><p>在日常开发中，我们也经常用到函数节流与防抖，通常我们会将它们封装为函数，这样可以在需要的地方直接调用使用，还不会污染全局：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>防抖节流<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 函数防抖 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> timer = <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ctx = <span class="built_in">this</span>,</span></span><br><span class="line"><span class="javascript">            args = <span class="built_in">arguments</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (timer) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">window</span>.clearTimeout(timer)</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">          fn.apply(ctx, args)</span><br><span class="line"><span class="javascript">          timer = <span class="literal">null</span></span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">// 搜索框做函数防抖避免用户高频输入内容</span></span></span><br><span class="line"><span class="javascript">    input.addEventListener(<span class="string">&#x27;input&#x27;</span>, debounce(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.target.value)</span></span><br><span class="line">    &#125;, 500))</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 函数节流 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> canUse = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ctx = <span class="built_in">this</span>,</span></span><br><span class="line"><span class="javascript">            args = <span class="built_in">arguments</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (canUse) &#123;</span></span><br><span class="line">          fn.apply(ctx, args)</span><br><span class="line"><span class="javascript">          canUse = <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            canUse = <span class="literal">true</span></span></span><br><span class="line">          &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">// 对于像onresize这样的高频事件，可以使用函数节流让其回调函数中的代码隔一段时间再次执行</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onresize = throttle(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      input.value = <span class="built_in">Math</span>.random() * <span class="number">100</span></span></span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>其实闭包并不会造成内存泄漏，现在的垃圾回收机制已经很成熟了。但早期的IE（ie4-ie6）版本里，对宿主对象（也就是document对象）采用是引用计数的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">垃圾回收机制</a>，闭包导致内存泄漏的一个原因就是这个算法的一个缺陷。循环引用会导致没法回收，这个循环引用只限定于有宿主对象参与的循环引用，而js对象之间即使形成循环引用，也不会产生内存泄漏，因为对js对象的回收算法不是计数的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closure</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;oDiv&#x27;</span>);<span class="comment">//oDiv用完之后一直驻留在内存中</span></span><br><span class="line">    oDiv.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">&#x27;oDiv.innerHTML&#x27;</span>);<span class="comment">//这里用oDiv导致内存泄露</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码创建了一个作为 div 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。</span></span><br><span class="line"><span class="comment">// 由于匿名函数保存了一个对closure()的活动对象的引用，因此就会导致无法减少 div 的引用数。</span></span><br><span class="line"><span class="comment">// 只要匿名函数存在，element 的引用数至少也是1，因此它所占用的内存就永远不会被回收</span></span><br><span class="line"></span><br><span class="line">closure();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后应将oDiv解除引用来避免内存泄露</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closure</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;oDiv&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> test = oDiv.innerHTML;</span><br><span class="line">    oDiv.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(test);</span><br><span class="line">    &#125;;</span><br><span class="line">    oDiv = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解决办法: 把 oDiv.innerHTML 的一个副本保存在一个变量中，</span></span><br><span class="line"><span class="comment">// 从而消除闭包中该变量的循环引用,同时将 oDiv 变量设为null。</span></span><br></pre></td></tr></table></figure>

<p>所以我们要保持良好的编程习惯，在使用完闭包后记得释放内存：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">9999999999999</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn1()</span><br><span class="line">f() <span class="comment">// 调用完后没有释放，arr就会一直在内存中占着，导致内存泄漏</span></span><br><span class="line"><span class="comment">// 记得释放</span></span><br><span class="line">f = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法</title>
    <url>/posts/59937/</url>
    <content><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是一种交换排序，基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><img src="/posts/59937/%E5%86%92%E6%B3%A1.gif" class="" title="冒泡">

<a id="more"></a>

<p>———— 动图来自《菜鸟教程》</p>
<p>说明：绿色表示当前正在比较的两个相邻元素；橘黄色表示已排完序的元素，不再参与后续的比较</p>
<h3 id="代码实现（JS）"><a href="#代码实现（JS）" class="headerlink" title="代码实现（JS）"></a>代码实现（JS）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myBubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123; <span class="comment">// 趟数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123; <span class="comment">// 当前趟要比较的次数</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">// 相邻元素两两比较</span></span><br><span class="line">                temp = arr[j];              <span class="comment">// 元素交换</span></span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码与图片配合食用更加~</p>
<img src="/posts/59937/%E5%86%92%E6%B3%A12.png" class="" title="冒泡2">

<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第2步，直到所有元素均排序完毕。</li>
</ol>
<h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><img src="/posts/59937/%E9%80%89%E6%8B%A9.gif" class="" title="选择">

<h3 id="代码实现（JS）-1"><a href="#代码实现（JS）-1" class="headerlink" title="代码实现（JS）"></a>代码实现（JS）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySelectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;       <span class="comment">// 第 i 轮选择</span></span><br><span class="line">        minIndex = i;                         <span class="comment">// 每轮开始假设起始元素为最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;   <span class="comment">// 遍历剩余未排序元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">// 寻找最小的数</span></span><br><span class="line">                minIndex = j;                 <span class="comment">// 将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];                         <span class="comment">// 交换起始元素与真正的最小值</span></span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配图：</p>
<img src="/posts/59937/%E9%80%89%E6%8B%A92.png" class="" title="选择2">

<hr>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的原理应该是最容易理解的，因为只要你打过扑克牌就应该能秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h3 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ol>
<h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><img src="/posts/59937/%E6%8F%92%E5%85%A5.gif" class="" title="插入">

<h3 id="代码实现（JS）-2"><a href="#代码实现（JS）-2" class="headerlink" title="代码实现（JS）"></a>代码实现（JS）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInsertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> insertItem; <span class="comment">// 要插入的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组的第二个元素开始循环将数组中的元素插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        insertItem = arr[i]; <span class="comment">// 设置数组中的第2个元素为第一次遍历要插入的数据</span></span><br><span class="line">        <span class="keyword">var</span> j = i - <span class="number">1</span>;       <span class="comment">// 已排序好数组的最后一个元素的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将已排好序的元素从最后一个往前依次与待插入元素比较，</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; insertItem &lt; arr[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果要插入的元素小于第j个元素,就将第j个元素向后移动</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直到要插入的元素不小于第j个元素,将insertNote插入到数组中</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = insertItem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例如for循环中 i 等于 2 时，已排序完毕的元素为[3,44]，进入for循环</span></span><br><span class="line">    <span class="comment">// 待插入元素为 arr[2]，也就是38;</span></span><br><span class="line">    <span class="comment">// j=i-1也就是2-1等于1</span></span><br><span class="line">    <span class="comment">// while循环比较，待插入元素38是小于arr[j]（j=1）44 的 =&gt; 条件成立</span></span><br><span class="line">        <span class="comment">// arr[j+1]要等于arr[j] =&gt; arr[2]要等于arr[1] =&gt; arr[2]=44 =&gt; 此刻数组前三个元素：[3,44,44]</span></span><br><span class="line">        <span class="comment">// j-- =&gt; j=1-1也就是0</span></span><br><span class="line">    <span class="comment">// 再来一轮while比较，待插入元素38现在不小于arr[j] 也就是arr[0]的3，所以直接退出while循环</span></span><br><span class="line">    <span class="comment">// arr[j+1]=insertItem =&gt; arr[1]=38 =&gt; 数组前三排序完毕：[3,38,44]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序也是一种插入排序，它是简单插入排序的一个改进版，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。本文会以图解的方式详细介绍希尔排序的基本思想及其代码实现。</p>
<p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h3 id="算法步骤-示例"><a href="#算法步骤-示例" class="headerlink" title="算法步骤(示例)"></a>算法步骤(示例)</h3><p>在此我们选择增量 <code>gap=数组长度length/2</code>，缩小增量继续以 <code>gap = gap/2</code> 的方式，这种增量选择我们可以用一个序列来表示：<code>&#123;n/2,(n/2)/2...1&#125;</code>，称为增量序列。当然，希尔排序的增量序列有很多种，这里采用的是比较常用的一种作为示例：</p>
<img src="/posts/59937/%E5%B8%8C%E5%B0%94.png" class="" title="希尔排序">

<p>在上面这幅图中：</p>
<p>初始时，有一个大小为 10 的无序序列。</p>
<p>在第一趟排序中，我们设 gap1 = 10 / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。接下来，按照直接插入排序的方法对每个组进行排序。</p>
<p>在第二趟排序中，我们把上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。按照直接插入排序的方法对每个组进行排序。</p>
<p>在第三趟排序中，再次把 gap 缩小一半，即gap3 = gap2 / 2 = 1。 这样相隔距离为 1 的元素组成一组，即只有一组。按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。</p>
<p><strong>注意</strong>：图中有两个相等数值的元素 5 和 5 。我们可以清楚的看到，在排序过程中，两个元素位置交换了。<br>所以，希尔排序是不稳定的算法。</p>
<h3 id="代码演示（JS）"><a href="#代码演示（JS）" class="headerlink" title="代码演示（JS）"></a>代码演示（JS）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myShellSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gap = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span> &lt;= gap) &#123;</span><br><span class="line">        <span class="comment">// 把距离为 gap 的元素编为一个组，扫描所有组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> temp = arr[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对距离为 gap 的元素组进行排序</span></span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j]; j = j - gap) &#123;</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`gap = <span class="subst">$&#123;gap&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">        gap = <span class="built_in">Math</span>.floor(gap / <span class="number">2</span>); <span class="comment">// 减小增量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略（分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p>
<img src="/posts/59937/%E5%BD%92%E5%B9%B6.png" class="" title="分而治之">

<p>可以看到这种结构很像一棵完全二叉树，下面的归并排序代码将会采用递归去实现（你也可采用迭代的方式去实现）。<strong>分</strong>阶段可以理解为就是递归拆分子序列的过程，递归深度为logn。</p>
<h3 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤 3 直到某一指针达到序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
<h3 id="图片演示"><a href="#图片演示" class="headerlink" title="图片演示"></a>图片演示</h3><img src="/posts/59937/%E5%BD%92%E5%B9%B62.png" class="" title="归并排序">

<p>图片来自博客<a href="https://www.cnblogs.com/chengxiao/p/6194356.html">《图解排序算法之归并排序》</a></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123; <span class="comment">// 采用自上而下的递归方法</span></span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>), <span class="comment">// 将未排序数组拆分成两半分而治之</span></span><br><span class="line">        left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">      	<span class="comment">// 两边的起始元素相互比较，始终将小的一方的头元素弹出，并push到准备好的容器result中</span></span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的元素均比另一部分记录的元素小，继而再分别对这两部分记录递归的进行同样的排序操作。</p>
<h3 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>把数组中第一个元素当做一个基准值，称为“基准”（Pivot）</li>
</ol>
<img src="/posts/59937/%E5%BF%AB%E6%8E%92.png" class="" title="快排">

<ol>
<li>重新排序数列，把所有比基准值小的元素摆放在基准前面，所有比基准值大元素摆放在基准后面。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
</ol>
<img src="/posts/59937/%E5%BF%AB%E6%8E%922.png" class="" title="快排2">

<img src="/posts/59937/%E5%BF%AB%E6%8E%923.png" class="" title="快排3">

<ol>
<li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
</ol>
<img src="/posts/59937/%E5%BF%AB%E6%8E%924.png" class="" title="快排4">

<h3 id="分区（Partition）思路"><a href="#分区（Partition）思路" class="headerlink" title="分区（Partition）思路"></a>分区（Partition）思路</h3><p>首先把未排序数组的第一个（最左边）元素设置为基准，把它的位置叫做 <code>l</code> ：</p>
<img src="/posts/59937/%E5%BF%AB%E6%8E%925.png" class="" title="快排5">

<p>然后依次向后查看所有元素，在查看过程中，不断的调整后面元素的位置，使得后面的元素分为两部分，一部分都小于 v ；一部分都大于 v 。</p>
<p>我们用 <code>j</code> 来不断记录这两部分的分割线位置。而 e 就是我们要判断的下一个元素，用索引 <code>i</code> 来表示，<code>i</code> 会遍历每一个元素，来看该如何调整这个元素。</p>
<p>在下图中，我们用 <code>arr[l+1 ... j]</code> 来表示小于 v 的橙色部分，用 <code>arr[j+1 ... i-1]</code> 来表示大于 v 的紫色部分。</p>
<img src="/posts/59937/%E5%BF%AB%E6%8E%926.png" class="" title="快排6">

<p>接下来就要看如何来调整下一个元素 e 的位置。分情况讨论：</p>
<p><strong>当 e 大于 v 时</strong>，我们直接让 e 融入大于 v 的部分，并让 <code>i++</code></p>
<img src="/posts/59937/%E5%BF%AB%E6%8E%927.png" class="" title="快排7">

<img src="/posts/59937/%E5%BF%AB%E6%8E%928.png" class="" title="快排8">


<p><strong>当 e 小于 v 时</strong>，我们让 e 和大于 v 部分的第一个元素交换位置。</p>
<img src="/posts/59937/%E5%BF%AB%E6%8E%929.png" class="" title="快排9">

<img src="/posts/59937/%E5%BF%AB%E6%8E%9210.png" class="" title="快排10">

<p>把 e 融入到小于 v 的部分。此时就需要让分隔线的索引位置 <code>j++</code> ，相应的，索引 <code>i</code> 的位置也要 <code>i++</code> 以便查看下一个元素。</p>
<img src="/posts/59937/%E5%BF%AB%E6%8E%9211.png" class="" title="快排11">

<img src="/posts/59937/%E5%BF%AB%E6%8E%9212.png" class="" title="快排12">

<p>以这样的步骤我们就能遍历完整个数组，如下图所示</p>
<img src="/posts/59937/%E5%BF%AB%E6%8E%9213.png" class="" title="快排13">


<p>现在还差最后一个步骤，那就是把基准值 v ，与小于 v 部分的最后一个元素交换位置。此刻 v 左边都小于它，v 右边都大于它，而 <code>j</code> 指向的就是基准值所在的位置。这样我们就完成了分区（Partition）操作。</p>
<img src="/posts/59937/%E5%BF%AB%E6%8E%9214.png" class="" title="快排14">

<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length,</span><br><span class="line">        partitionIndex,         <span class="comment">// 分区索引</span></span><br><span class="line">        left = <span class="keyword">typeof</span> left != <span class="string">&#x27;number&#x27;</span> ? <span class="number">0</span> : left,</span><br><span class="line">        right = <span class="keyword">typeof</span> right != <span class="string">&#x27;number&#x27;</span> ? len - <span class="number">1</span> : right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过分区找到分隔点，再分别快排左右两部分</span></span><br><span class="line">    partitionIndex = partition(arr, left, right);</span><br><span class="line">    quickSort(arr, left, partitionIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, partitionIndex + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123; <span class="comment">// 分区操作</span></span><br><span class="line">    <span class="keyword">var</span> v = left,   <span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">        j = left;  <span class="comment">// arr[l+1...j] ; arr[j+1...i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = j + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[v]) &#123; <span class="comment">// 当前要判断元素 小于 基准元素时</span></span><br><span class="line">            j++; <span class="comment">// 分隔点右移</span></span><br><span class="line">            swap(arr, i, j);   <span class="comment">// 让 当前元素 与大于 v 部分的第一个元素交换位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此处不用写 else ，因为当大于基准元素时，直接i++就好，</span></span><br><span class="line">        <span class="comment">// 而i++，for循环已经帮我们做了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环完毕后，交换基准值和小于v部分的最后一个元素的位置</span></span><br><span class="line">    swap(arr, v, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(quickSort(arr, <span class="number">0</span>, arr.length));</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h3 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入数组 Count 的第 i 项；</li>
<li>对所有的计数累加（从 Count 中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素 i 放在新数组的第 Count(i) 项，每放一个元素就将 Count(i) 减去1。</li>
</ol>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length,</span><br><span class="line">        Result = [],</span><br><span class="line">        Count = [],</span><br><span class="line">        min = max = arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最大最小值,并将arr数置入Count数组中,统计出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        min = min &lt;= arr[i] ? min : arr[i];</span><br><span class="line">        max = max &gt;= arr[i] ? max : arr[i];</span><br><span class="line">        Count[arr[i]] = Count[arr[i]] ? Count[arr[i]] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最小值-&gt;最大值,将计数逐项相加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = min; j &lt; max; j++) &#123;</span><br><span class="line">        Count[j + <span class="number">1</span>] = (Count[j + <span class="number">1</span>] || <span class="number">0</span>) + (Count[j] || <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Count中,下标为arr数值,数据为arr数值出现次数;反向填充数据进入Result数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k = len - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">        <span class="comment">// Result[位置] = arr数据</span></span><br><span class="line">        Result[Count[arr[k]] - <span class="number">1</span>] = arr[k];</span><br><span class="line">        <span class="comment">// 减少Count数组中保存的计数</span></span><br><span class="line">        Count[arr[k]]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(countingSort(arr));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>【转载】常见正则表达式合集</title>
    <url>/posts/40424/</url>
    <content><![CDATA[<p>转载来源：<a href="http://obkoro1.com/web_accumulate/codeBlack/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%94%B6%E9%9B%86.html#%E5%B8%B8%E8%A7%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%90%88%E9%9B%86">常见正则表达式合集</a></p>
<p>为了避免用户胡乱输入就通过验证，很多时候我们都会采用正则表达式来验证一下用户输入的信息是否符合规范。这部分的内容基本上是在网上收集来的，这里跟大家一起分享一下，有需要的可以记在自己的有道云笔记里面。</p>
<a id="more"></a>

<h3 id="如何验证？"><a href="#如何验证？" class="headerlink" title="如何验证？"></a>如何验证？</h3><p>验证的方式当然是很多了，这里推荐采用<a href="http://www.w3school.com.cn/js/jsref_test_regexp.asp">test()</a>方法来验证。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isTrue = RegExpObject.test(string);<span class="comment">// RegExpObject为正则 string是要检测的字符串</span></span><br><span class="line"><span class="comment">// 如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false。</span></span><br><span class="line"><span class="keyword">if</span> (isTrue)&#123;</span><br><span class="line">    <span class="comment">//验证成功 do something</span></span><br><span class="line">&#125;elseP&#123;</span><br><span class="line">    <span class="comment">//验证失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="身份证号码正则表达式："><a href="#身份证号码正则表达式：" class="headerlink" title="身份证号码正则表达式："></a>身份证号码正则表达式：</h3><p>第一代身份证只有 15 位数，第二代身份证有 18 位数，各位按照需求来选择表达式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二代身份证号码正则</span></span><br><span class="line"><span class="keyword">let</span> isTrue = <span class="regexp">/^[1-9]\d&#123;5&#125;(18|19|20)\d&#123;2&#125;((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$/</span>;</span><br><span class="line"><span class="comment">//第一代身份证正则表达式(15位)</span></span><br><span class="line"><span class="keyword">let</span> isTrue = <span class="regexp">/^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$/</span>;</span><br></pre></td></tr></table></figure>

<h3 id="手机号码正则表达式："><a href="#手机号码正则表达式：" class="headerlink" title="手机号码正则表达式："></a>手机号码正则表达式：</h3><p>时间截止为：2018 年 1 月 11 日</p>
<ul>
<li>移动号段：134 135 136 137 138 139 147 148 150 151 152 157 158 159 172 178 182 183 184 187 188 198</li>
<li>联通号段：130 131 132 145 146 155 156 166 171 175 176 185 186</li>
<li>电信号段：133 149 153 173 174 177 180 181 189 199</li>
<li>虚拟运营商：170</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isTrue = <span class="regexp">/^(13[0-9]|14[5-9]|15[012356789]|166|17[0-8]|18[0-9]|19[8-9])[0-9]&#123;8&#125;$/</span>;</span><br></pre></td></tr></table></figure>

<h3 id="邮箱正则表达式："><a href="#邮箱正则表达式：" class="headerlink" title="邮箱正则表达式："></a>邮箱正则表达式：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isTrue = <span class="regexp">/^([A-Za-z0-9_\-\.\u4e00-\u9fa5])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]&#123;2,8&#125;)$/</span>;</span><br></pre></td></tr></table></figure>

<h3 id="用户名正则"><a href="#用户名正则" class="headerlink" title="用户名正则:"></a>用户名正则:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户名正则，4到16位（字母，数字，下划线，减号）</span></span><br><span class="line"><span class="keyword">let</span> isTrue = <span class="regexp">/^[a-zA-Z0-9_-]&#123;4,16&#125;$/</span>;</span><br></pre></td></tr></table></figure>

<h3 id="密码正则"><a href="#密码正则" class="headerlink" title="密码正则:"></a>密码正则:</h3><p>密码正则，以字母开头，长度在 6~18 之间，只能包含字母、数字和下划线</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isTrue =^[a-zA-Z]\w&#123;<span class="number">5</span>,<span class="number">17</span>&#125;$;</span><br></pre></td></tr></table></figure>

<p>强密码正则，最少 6 位，包括至少 1 个大写字母，1 个小写字母，1 个数字，1 个特殊字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isTrue = <span class="regexp">/^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/</span>;</span><br></pre></td></tr></table></figure>

<h3 id="QQ-号码正则"><a href="#QQ-号码正则" class="headerlink" title="QQ 号码正则:"></a>QQ 号码正则:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isTrue = <span class="regexp">/^[1-9][0-9]&#123;4,10&#125;$/</span>;</span><br></pre></td></tr></table></figure>

<h3 id="微信号码正则"><a href="#微信号码正则" class="headerlink" title="微信号码正则:"></a>微信号码正则:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//微信号正则，6至20位，以字母开头，字母，数字，减号，下划线</span></span><br><span class="line"><span class="keyword">let</span> isTrue = <span class="regexp">/^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$/</span>;</span><br></pre></td></tr></table></figure>

<h3 id="特殊字符检测正则"><a href="#特殊字符检测正则" class="headerlink" title="特殊字符检测正则:"></a>特殊字符检测正则:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isTrue = <span class="regexp">/[&quot;&#x27;&lt;&gt;%;)(&amp;+]+-!！@#$~/</span>;</span><br></pre></td></tr></table></figure>

<h3 id="域名正则"><a href="#域名正则" class="headerlink" title="域名正则:"></a>域名正则:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isTrue=[a-zA-Z0-<span class="number">9</span>][-a-zA-Z0-<span class="number">9</span>]&#123;<span class="number">0</span>,<span class="number">62</span>&#125;(<span class="regexp">/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/</span>.?;</span><br></pre></td></tr></table></figure>

<h3 id="车牌号码正则"><a href="#车牌号码正则" class="headerlink" title="车牌号码正则:"></a>车牌号码正则:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isTrue = <span class="regexp">/^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]&#123;1&#125;[A-Z]&#123;1&#125;[A-Z0-9]&#123;4&#125;[A-Z0-9挂学警港澳]&#123;1&#125;$/</span>;</span><br></pre></td></tr></table></figure>

<h3 id="包含中文正则"><a href="#包含中文正则" class="headerlink" title="包含中文正则:"></a>包含中文正则:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isTrue = <span class="regexp">/[\u4E00-\u9FA5]/</span>;</span><br><span class="line"><span class="comment">//这个可以用于验证用户的真实姓名。</span></span><br></pre></td></tr></table></figure>

<h3 id="护照正则"><a href="#护照正则" class="headerlink" title="护照正则:"></a>护照正则:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isTrue = <span class="regexp">/^(P\d&#123;7&#125;|G\d&#123;7,8&#125;|TH\d&#123;7,8&#125;|S\d&#123;7,8&#125;|A\d&#123;7,8&#125;|L\d&#123;7,8&#125;|\d&#123;9&#125;|D\d+|1[4,5]\d&#123;7&#125;)$/</span>;</span><br></pre></td></tr></table></figure>

<h3 id="固定电话正则："><a href="#固定电话正则：" class="headerlink" title="固定电话正则："></a>固定电话正则：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isTrue=(\(\d&#123;<span class="number">3</span>,<span class="number">4</span>&#125;\)|\d&#123;<span class="number">3</span>,<span class="number">4</span>&#125;-|\s)?\d&#123;<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="IP-地址正则"><a href="#IP-地址正则" class="headerlink" title="IP 地址正则:"></a>IP 地址正则:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isTrue=\d+\.\d+\.\d+\.\d+;</span><br></pre></td></tr></table></figure>

<h3 id="邮政编码正则"><a href="#邮政编码正则" class="headerlink" title="邮政编码正则:"></a>邮政编码正则:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isTrue=[<span class="number">1</span>-<span class="number">9</span>]&#123;<span class="number">1</span>&#125;(\d+)&#123;<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="经纬度正则"><a href="#经纬度正则" class="headerlink" title="经纬度正则:"></a>经纬度正则:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//经度正则</span></span><br><span class="line"><span class="keyword">let</span> isTrue = <span class="regexp">/^(\-|\+)?(((\d|[1-9]\d|1[0-7]\d|0&#123;1,3&#125;)\.\d&#123;0,6&#125;)|(\d|[1-9]\d|1[0-7]\d|0&#123;1,3&#125;)|180\.0&#123;0,6&#125;|180)$/</span>;</span><br><span class="line"><span class="comment">//纬度正则</span></span><br><span class="line"><span class="keyword">let</span> isTrue = <span class="regexp">/^(\-|\+)?([0-8]?\d&#123;1&#125;\.\d&#123;0,6&#125;|90\.0&#123;0,6&#125;|[0-8]?\d&#123;1&#125;|90)$/</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>正则</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的遍历方法</title>
    <url>/posts/64478/</url>
    <content><![CDATA[<p>下面是总结的数组遍历的常见方法</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><ul>
<li>标准for循环</li>
<li>forEach((当前值, 当前索引, 当前数组) =&gt; {…}, [, 绑定的this])`<ul>
<li>无法中途退出循环，只能用 return 退出本次回调，进行下一次回调</li>
<li>它总是返回 undefined 值，即使你 return 了一个值</li>
</ul>
</li>
<li>for…in（不推荐）会把继承链的对象属性都会遍历一遍，而且数组遍历不一定按次序<ul>
<li>for-in 循环返回的是所有能通过对象访问的、可枚举的属性</li>
</ul>
</li>
<li>for (variable of iterable)（ES6）可迭代Array，Map，Set，String等（迭代的是值value）<ul>
<li>在 for..of 中如果遍历中途要退出，可以使用 break 退出循环</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h2><ul>
<li><p>map (不改变原数组) 会给原数组中的每个元素都按顺序调用一次 callback 函数</p>
</li>
<li><p>reduce (不改变原数组) 数组中的前项和后项做某种计算,并累计最终值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="comment">// arr.reduce(function(total, currentValue, currentIndex, arr), initialValue)</span></span><br><span class="line"><span class="comment">// callback 参数</span></span><br><span class="line"><span class="comment">// (累积器, 当前元素, 当前元素索引, 当前数组)</span></span><br><span class="line"><span class="comment">// initialValue:指定第一次回调 的第一个参数</span></span><br><span class="line"><span class="keyword">var</span> wallets = [<span class="number">4</span>, <span class="number">7.8</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> totalMoney = wallets.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">countedMoney, curMoney</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> countedMoney + curMoney;</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>filter (不改变原数组)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> morearr = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number &gt; <span class="number">3</span></span><br><span class="line">&#125;) <span class="comment">// [4,5,6]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>every (不改变原数组) 测试数组的所有元素是否都通过了指定函数的测试</p>
<ul>
<li>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测</li>
<li>如果所有元素都满足条件，则返回 true</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> result = arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>some (不改变原数组) 测试是否至少有一个元素通过 callback 中的条件。对于放在空数组上的任何条件，此方法返回 false</p>
<ul>
<li>如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测</li>
<li>如果没有满足条件的元素，则返回false</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// some(callback, thisArg)</span></span><br><span class="line"><span class="comment">// callback:</span></span><br><span class="line"><span class="comment">//    (当前元素, 当前索引, 调用some的数组)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> result = arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">item,index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">&#125;) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ul>
<li><p>find() &amp; findIndex() 根据条件找到数组成员</p>
<ul>
<li>find 定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回 undefined</li>
<li>findIndex 定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">let</span> new_array = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisArg</span>)</span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">new_array</span> = <span class="title">arr</span>.<span class="title">findIndex</span>(<span class="params"><span class="keyword">function</span>(currentValue, index, arr), thisArg</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 这两个方法都可以识别<span class="title">NaN</span>,弥补了<span class="title">indexOf</span>的不足</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">find</span></span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">a</span> = [1, 4, -5, 10].<span class="title">find</span>(<span class="params">(n) =&gt; n &lt; <span class="number">0</span></span>)</span>; <span class="comment">// 返回元素-5</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>,<span class="literal">NaN</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, n));  <span class="comment">// 返回元素NaN</span></span><br><span class="line"><span class="comment">// findIndex</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].findIndex(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// 返回索引2</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>,<span class="literal">NaN</span>].findIndex(<span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, n));  <span class="comment">// 返回索引4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>keys() &amp; values() &amp; entries() 遍历键名、遍历键值、遍历键名+键值</p>
<ul>
<li>三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">array.keys()   array.values()   array.entries()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>有序表查找之二分查找</title>
    <url>/posts/39853/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>二分查找又名折半查找。它的前提是所操作的数据集是一个有序的数据集。它的基本思想是：开始时，先找出有序集合中间的那个元素。如果此元素比要查找的元素大，就接着在较小的一个半区进行查找；反之，如果此元素比要找的元素小，就在较大的一个半区进行查找。在每个更小的数据集中重复这个查找过程，直到找到要查找的元素或者数据集不能再分割。</p>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/posts/39853/1556938076685-7ebcf60f-aaf7-4f4c-ba78-0f4d7b9a3099.png" class="" title="二分查找">

<a id="more"></a>

<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>二分查找可以应用于任何类型的数据，但前提是这些数据是按某种规则进行排序的。这使得它在处理那些频繁插入和删除操作的数据集时不太高效。因为执行完插入和删除操作后，无法保证数据集的有序性，在查找前还得先维护一个有序数据集，从而导致查找过程代价太高。此外，元素必须存储在连续的空间中。</p>
<p>因此，当待搜索的集合是相对静态的数据集时，此时使用二分查找是最好的选择。</p>
<h2 id="代码示例（JS）"><a href="#代码示例（JS）" class="headerlink" title="代码示例（JS）"></a>代码示例（JS）</h2><blockquote>
<p>非递归实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">33</span>, <span class="number">46</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">77</span>, <span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binary_search</span>(<span class="params">arr, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> min = <span class="number">0</span>,</span><br><span class="line">        max = arr.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (min &lt;= max) &#123;</span><br><span class="line">        <span class="keyword">var</span> mid = <span class="built_in">parseInt</span>((min + max) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target === arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; arr[mid]) &#123;</span><br><span class="line">            min = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(binary_search(arr, <span class="number">33</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>递归实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">33</span>, <span class="number">46</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">77</span>, <span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binary_search</span>(<span class="params">arr, min, max, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (min &gt; max) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mid = <span class="built_in">parseInt</span>((min + max) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target === arr[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; arr[mid]) &#123;</span><br><span class="line">        min = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> binary_search(arr, min, max, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> binary_search(arr, min, max, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(binary_search(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">33</span>));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>用JS实现翻转二叉树</title>
    <url>/posts/50491/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>翻转二叉树就是把二叉树每一层的左右顺序颠倒过来。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote>
<p>输入</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>如果根节点不为空，那么将左右子结点交换，然后将左右子结点进行递归调用。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Sequelize框架入门</title>
    <url>/posts/1183/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平常写前端项目时，为了更方便的获取“真实”的动态数据，也会新建几个数据库表来作支撑。但每每需要用Node搭建后端服务时，数据库的查询真的让人头疼，难倒不难，就是特别繁琐，即使封装了个查询sql用工具模块，在遇到稍复杂的查询语句时还是得写完整SQL。</p>
<p>我又是个比较懒的人，在经历了几次痛苦折磨后，我开始google有没有谁帮我们解决了数据库表字段与对象之间的关系映射。也就是我们通常所说的 <a href="https://baike.baidu.com/item/ORM/3583252?fr=aladdin">ORM</a> 。经过几番搜索，我找到了 <a href="http://docs.sequelizejs.com/">Sequelize</a> 框架。在了解它之前，我们先简单介绍下什么是 <code>ORM</code> ：（我知道不少人是不会点击上面链接查看详情的 :)）</p>
<a id="more"></a>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>ORM 全称 Object Relational Mapping，翻译成中文就是 <code>对象关系映射</code> 。是对 SQL 查询语句的封装，让我们可以用面向对象的方式操作数据库，来更加优雅的生成安全、可维护的 SQL 代码。说白了，就是通过对象来映射和操作数据库。</p>
<h3 id="Sequelize"><a href="#Sequelize" class="headerlink" title="Sequelize"></a>Sequelize</h3><p>而今天的主角 <code>Sequelize</code> 则是一个基于 promise 的 Node.js 异步ORM框架。它能够支持多种数据库，包含但不限于 PostgreSQL, MySQL 和 MSSQL 。</p>
<blockquote>
<p>官网地址：<a href="http://docs.sequelizejs.com/">http://docs.sequelizejs.com/</a><br>github：<a href="https://github.com/sequelize/sequelize">https://github.com/sequelize/sequelize</a></p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><p>在本地新建文件夹，例如 <code>sequelize-demo</code> ，然后在项目根目录下运行命令行命名 <code>npm init -y</code>。运行完该命令后项目tree如下：</p>
<img src="/posts/1183/npminit-y.png" class="" title="npminit-y">

<p>接着使用 npm 安装 <code>sequelize</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i sequelize</span><br></pre></td></tr></table></figure>



<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>完成上述步骤以后，我们在根目录下新建一个 <code>app.js</code> 文件来使用 <code>sequelize</code> ，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入 sequelize</span></span><br><span class="line"><span class="keyword">const</span> Sequelize = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建 sequelize 实例</span></span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(<span class="string">&#x27;数据库名称&#x27;</span>, <span class="string">&#x27;数据库用户名&#x27;</span>, <span class="string">&#x27;数据库密码&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 其他的数据库连接配置</span></span><br><span class="line">    host: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="comment">// 主机，默认 localhost</span></span><br><span class="line">    port: <span class="number">8889</span>,        <span class="comment">// 端口，默认 3306</span></span><br><span class="line">    dialect: <span class="string">&#x27;mysql&#x27;</span>,  <span class="comment">// 数据库类型， 默认 mysql 【必填】</span></span><br><span class="line">    timezone: <span class="string">&#x27;+08:00&#x27;</span> <span class="comment">// 时区，默认会根据系统当前所在时区进行设置，格式：&#x27;+08:00&#x27; 或字符串格式 &#x27;Asia/Shanghai&#x27; 参考：http://php.net/manual/zh/timezones.php 【使用场景：一般情况下默认配置就好，但如果服务器在美国，但想存储中国时区，就需要明确指定 &#x27;+08:00&#x27; 了】</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试数据库的连接（返回的是一个Promise，记得 catch 捕获错误）</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sequelize.authenticate();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据库连接成功!&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;连接失败&#x27;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时你可以尝试运行 <code>app.js</code> 文件，即在根目录下运行 <code>node app.js</code> 命令。正常情况下你会收到报错信息，类似这样：</p>
<img src="/posts/1183/error-mysql2.png" class="" title="mysql2">

<p>意思是你需要安装 <code>mysql2</code> ，这是因为 <code>sequelize</code> 虽然依赖了 <code>mysql2</code> ，但却没有内置安装。所以接下来你得在项目根目录下运行如下代码来安装 <code>mysql2</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i mysql2</span><br></pre></td></tr></table></figure>



<p>安装完毕后再次运行 <code>app.js</code> ，就能连接数据库成功了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node app.js</span><br><span class="line">Executing (default): SELECT 1+1 AS result</span><br><span class="line">数据库连接成功!</span><br></pre></td></tr></table></figure>



<h3 id="定义模型（Model）"><a href="#定义模型（Model）" class="headerlink" title="定义模型（Model）"></a>定义模型（Model）</h3><blockquote>
<p>所谓模型，就是用来描述数据库表字段信息的对象，每一个模型对象表示数据库中的一个表，后续对数据库的操作都是用过对应的模型对象来完成的。</p>
</blockquote>
<p>接下来我们就要定义数据的模型了。在此之前，你还需要做一些准备工作。以我为例，我在数据库中新建了一个 <code>users</code> 表，表字段和类型如下：</p>
<img src="/posts/1183/table-property.png" class="" title="表字段">

<p>然后定义出对应此表的数据模型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义模型（用对象的方式来描述数据库中的表）</span></span><br><span class="line"><span class="keyword">const</span> UserModel = sequelize.define(<span class="string">&#x27;User&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 描述表中对应的字段信息</span></span><br><span class="line">    id: &#123; <span class="comment">// 每一个字段的信息</span></span><br><span class="line">        type: Sequelize.INTEGER(<span class="number">11</span>), <span class="comment">// 字段类型</span></span><br><span class="line">        allowNull: <span class="literal">false</span>,            <span class="comment">// 不允许为空</span></span><br><span class="line">        autoIncrement: <span class="literal">true</span>,         <span class="comment">// id自增长</span></span><br><span class="line">        primaryKey: <span class="literal">true</span>,            <span class="comment">// 设为主键</span></span><br><span class="line">    &#125;,</span><br><span class="line">    username: &#123;</span><br><span class="line">        type: Sequelize.STRING(<span class="number">50</span>),</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">        defaultValue: <span class="string">&#x27;&#x27;</span>,            <span class="comment">// 设置字段默认值</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        type: Sequelize.TINYINT(<span class="number">3</span>),</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    gender: &#123;</span><br><span class="line">        type: Sequelize.ENUM([<span class="string">&#x27;men&#x27;</span>, <span class="string">&#x27;women&#x27;</span>, <span class="string">&#x27;other&#x27;</span>]), <span class="comment">// 这是个枚举类型字段，表示性别只能为“男”，“女”，“保密”中的其中一个，传入 ENUM 中的可以是逗号隔开的字符串，也可以是个数组：ENUM([&#x27;men&#x27;, &#x27;women&#x27;]) or ENUM(&#x27;men&#x27;, &#x27;women&#x27;, &#x27;other&#x27;)</span></span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">        defaultValue: <span class="string">&#x27;men&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;, &#123; <span class="comment">// 用来设置字段以外的其他信息</span></span><br><span class="line">    timestamps: <span class="literal">false</span>, <span class="comment">// 是否给每条记录添加 createAt 和 updateAt 字段，并在添加新数据和更新数据的时候自动设置这两个字段的值，默认为 true</span></span><br><span class="line">    tableName: <span class="string">&#x27;users&#x27;</span>, <span class="comment">// 该模型映射的真实表名</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong>在定义模型时，字段名称可以和数据库表中的字段名称不相同，但如果你想另起一个别名，则需要在字段信息设置中加入 <code>field</code> 来关联真正的表字段名称。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">userName: &#123; <span class="comment">// &lt;-- 你起的别名</span></span><br><span class="line">    type: Sequelize.STRING(<span class="number">50</span>),</span><br><span class="line">    allowNull: <span class="literal">false</span>,</span><br><span class="line">    field: <span class="string">&#x27;username&#x27;</span>, <span class="comment">// 关联数据库表中真正的字段名</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><p>完成表模型的定义以后，我们就可以通过 <code>findAll</code> 来查询表数据了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询 users 表中所有数据</span></span><br><span class="line">UserModel.findAll().then(<span class="function"><span class="params">users</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回的 users 是个数组</span></span><br><span class="line">    users.forEach(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 循环的每个 user 都是个 Model 实例</span></span><br><span class="line">        <span class="comment">// 该 Model 实例包含 get 方法，我们能通过它获取 username</span></span><br><span class="line">        <span class="built_in">console</span>.log(user.get(<span class="string">&#x27;username&#x27;</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>写完上面代码后，再次运行 <code>app.js</code> ，你就应该能够查询到数据了~<br>p.s. 查询之前别忘了在数据库中插入一些数据。</p>
<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>除了查询全部数据，我们还可以使用 <code>where</code> 查询指定的数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这次不用 .then 形式，而采用 async + await</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 查找 username 为 &#x27;李元芳&#x27; 的唯一数据</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> UserModel.findOne(&#123;</span><br><span class="line">        where: &#123;</span><br><span class="line">            username: <span class="string">&#x27;李元芳&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.dir(res);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<p>而类似大于小于这样的查询会稍显麻烦一点。例如我们来编写查询 users 表中年龄大于某个值的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 查找满足 age &gt; 24 的所有数据</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> UserModel.findAll(&#123;</span><br><span class="line">        where: &#123;</span><br><span class="line">            age: &#123;</span><br><span class="line">                [Sequelize.Op.gt]: <span class="number">24</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 打印出符合条件的用户的 username</span></span><br><span class="line">    <span class="built_in">console</span>.dir(res.map(<span class="function"><span class="params">r</span> =&gt;</span> r.get(<span class="string">&#x27;username&#x27;</span>)));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<h4 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h4><p>除了单一条件查询，我们还可以通过嵌套 or 或 and 运算符的集合来生成复杂条件语句。例如我们来查询 <code>年龄小于25 或者 性别为男</code> 的所有数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; Op &#125; = Sequelize;</span><br><span class="line">    <span class="comment">// 查找满足 age &lt; 25 或 gender = &#x27;men&#x27; 的所有数据</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> UserModel.findAll(&#123;</span><br><span class="line">        where: &#123;</span><br><span class="line">            [Op.or]: [</span><br><span class="line">                &#123;</span><br><span class="line">                    age: &#123;</span><br><span class="line">                        [Sequelize.Op.lt]: <span class="number">25</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    gender: <span class="string">&#x27;men&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 打印出符合条件的用户的 username</span></span><br><span class="line">    <span class="built_in">console</span>.dir(res.map(<span class="function"><span class="params">r</span> =&gt;</span> r.get(<span class="string">&#x27;username&#x27;</span>)));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<p>从上面几组查询语句我们可以看出，<code>where</code> 通常用 <code>attribute: value</code> 键值对获取一个对象，其中 <code>value</code> 可以是匹配等式的<strong>数据</strong>或其他运算符的<strong>键值对象</strong>。更多查询语法可在下方链接查询：</p>
<ul>
<li><a href="http://docs.sequelizejs.com/manual/querying.html">Sequelize - Querying</a></li>
<li><a href="https://demopark.github.io/sequelize-docs-Zh-CN/querying.html">Sequelize - Querying（中文文档）</a></li>
</ul>
<h4 id="查询限制-limit-offset"><a href="#查询限制-limit-offset" class="headerlink" title="查询限制 limit, offset"></a>查询限制 limit, offset</h4><p>我们还能限制查询的数量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 只从表中查询两条数据</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> UserModel.findAll(&#123;</span><br><span class="line">        limit: <span class="number">2</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res.map(<span class="function"><span class="params">r</span> =&gt;</span> r.get(<span class="string">&#x27;username&#x27;</span>)));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<p>跳过前2条数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> UserModel.findAll(&#123;</span><br><span class="line">        offset: <span class="number">2</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res.map(<span class="function"><span class="params">r</span> =&gt;</span> r.get(<span class="string">&#x27;username&#x27;</span>)));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<p>跳过前2条数据并获取3条：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> UserModel.findAll(&#123;</span><br><span class="line">        offset: <span class="number">2</span>,</span><br><span class="line">        limit: <span class="number">3</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res.map(<span class="function"><span class="params">r</span> =&gt;</span> r.get(<span class="string">&#x27;username&#x27;</span>)));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<h4 id="查询排序"><a href="#查询排序" class="headerlink" title="查询排序"></a>查询排序</h4><p>我们还可以将查询数据进行排序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 查询的结果按年龄高到低排序</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> UserModel.findAll(&#123;</span><br><span class="line">        order: [</span><br><span class="line">            [<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;desc&#x27;</span>]</span><br><span class="line">        ]</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res.map(<span class="function"><span class="params">r</span> =&gt;</span> r.get(<span class="string">&#x27;username&#x27;</span>)));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<h4 id="查询记录"><a href="#查询记录" class="headerlink" title="查询记录"></a>查询记录</h4><p>有些时候我们可能只是想单纯的查询数据表中有多少条数据，这时可以用 <code>count()</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 查询 users 表中有多少条数据</span></span><br><span class="line">  <span class="keyword">let</span> count = <span class="keyword">await</span> UserModel.count();</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 `findAndCountAll()` 方法在数据库中搜索多条记录，它能返回给我们**数据和总计数**：</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 查询 users 表中的前两条数据，并返回 users 表中总记录数</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> UserModel.findAndCountAll(&#123;</span><br><span class="line">        limit: <span class="number">2</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<p>查询结果的格式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    count: 总记录数,</span><br><span class="line">    rows: [ </span><br><span class="line">        &#123;第一条记录&#125;, &#123;第二条记录&#125;, ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个方法对我们为前端提供分页功能很方便，count是符合条件的总记录数，而rows中可以是当前页数下的记录数。</p>
<h3 id="数据增加"><a href="#数据增加" class="headerlink" title="数据增加"></a>数据增加</h3><p>既然能查，当然就能往数据库插入数据，在 <code>sequelize</code> 中，插入数据可以用 <code>build</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一条数据（除了build外，还可以通过 new UserModel(&#123;&#125;) 的形式创建一条记录）</span></span><br><span class="line"><span class="keyword">let</span> wangwu = UserModel.build(&#123;</span><br><span class="line">    username: <span class="string">&#x27;王五&#x27;</span>,</span><br><span class="line">    age: <span class="number">22</span>,</span><br><span class="line">    gender: <span class="string">&#x27;men&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// **注意：** 通过 new 或 build 出来的对象不会立即同步到数据库中，</span></span><br><span class="line"><span class="comment">// 需要使用后续的一些方法（例如 save ）来同步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你还可以修改这条数据</span></span><br><span class="line">wangwu.set(<span class="string">&#x27;age&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后别忘了保存才能成功插入数据</span></span><br><span class="line">wangwu.save();</span><br></pre></td></tr></table></figure>


<p>如果运行后没报错，去数据库刷新表吧，数据已经成功的插入到 <code>users</code> 表了~</p>
<h3 id="数据修改"><a href="#数据修改" class="headerlink" title="数据修改"></a>数据修改</h3><p>实际开发中修改数据是再平常不过的了，比如修改一篇博客，更新自己的个人信息… 在 <code>sequelize</code> 中，我们这样修改数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询id为2的用户数据</span></span><br><span class="line">UserModel.findByPk(<span class="number">2</span>).then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 查询到以后修改其 age 字段为 99</span></span><br><span class="line">    user.set(<span class="string">&#x27;age&#x27;</span>, <span class="number">99</span>);</span><br><span class="line">    <span class="comment">// 修改后别忘了保存</span></span><br><span class="line">    user.save();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong> 在 Sequelize v5 版本以前，通过id查询数据的方法名为 <code>findById</code> ，从 v5 版本开始，更改为 <code>findByPk</code> 。其实想一下这样非常合理，以前的 <code>findById</code> 太主观了，要知道不一定每个表的主键都为 id ，所以更改为 <code>findByPk</code> 后，表示通过<strong>主键（Pk -&gt; PrimaryKey）</strong>查找，<code>sequelize</code> 会自动通过你在创建表模型时定义的主键字段查找。例如我们一开始在定义 <code>User</code> 模型时，就给 <code>id</code> 字段添加了 <code>primaryKey: true,</code> 属性。</p>
<p>除了 set + update 来更新数据以外，还可以使用 <code>update()</code> 方法做相同的事情：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 先查询</span></span><br><span class="line">    <span class="keyword">let</span> xiaohong = <span class="keyword">await</span> UserModel.findByPk(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// update方法相当于 set + save</span></span><br><span class="line">    <span class="keyword">await</span> xiaohong.update(&#123;</span><br><span class="line">        age: <span class="number">22</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<h3 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h3><p>如果想要删除一条数据，可以使用 <code>destroy</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 先查询</span></span><br><span class="line">    <span class="keyword">let</span> wangwu = <span class="keyword">await</span> UserModel.findByPk(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 对查询到的数据进行删除</span></span><br><span class="line">    wangwu.destroy();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Sequelize = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(<span class="string">&quot;miaov&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// 其他的数据库连接配置</span></span><br><span class="line">  host: <span class="string">&quot;127.0.0.1&quot;</span>, <span class="comment">// 主机</span></span><br><span class="line">  port: <span class="number">8889</span>, <span class="comment">// 端口</span></span><br><span class="line">  dialect: <span class="string">&quot;mysql&quot;</span> <span class="comment">// 数据库类型</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试连接</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sequelize.authenticate();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据库连接成功!&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;连接失败&#x27;</span>);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义模型（用对象的方式来描述数据库中的表）</span></span><br><span class="line"><span class="keyword">const</span> UserModel = sequelize.define(<span class="string">&#x27;User&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 定义字段</span></span><br><span class="line">    id: &#123; <span class="comment">// 对字段属性的定义</span></span><br><span class="line">        type: Sequelize.INTEGER(<span class="number">11</span>), <span class="comment">// 字段类型</span></span><br><span class="line">        allowNull: <span class="literal">false</span>,            <span class="comment">// 不允许为空</span></span><br><span class="line">        autoIncrement: <span class="literal">true</span>,         <span class="comment">// id自增长</span></span><br><span class="line">        primaryKey: <span class="literal">true</span>,            <span class="comment">// 设为主键</span></span><br><span class="line">    &#125;,</span><br><span class="line">    username: &#123;</span><br><span class="line">        type: Sequelize.STRING(<span class="number">50</span>),</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">        defaultValue: <span class="string">&#x27;&#x27;</span>,            <span class="comment">// 设置字段默认值</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        type: Sequelize.TINYINT(<span class="number">3</span>),</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    gender: &#123;</span><br><span class="line">        type: Sequelize.ENUM([<span class="string">&#x27;men&#x27;</span>, <span class="string">&#x27;women&#x27;</span>, <span class="string">&#x27;other&#x27;</span>]),</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">        defaultValue: <span class="string">&#x27;men&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;, &#123; <span class="comment">// 用来设置字段以外的其他信息</span></span><br><span class="line">    timestamps: <span class="literal">false</span>,  <span class="comment">// 是否给每条记录添加 createAt 和 updateAt 字段，并在添加新数据和更新数据的时候自动设置这两个字段的值，默认为 true</span></span><br><span class="line">    tableName: <span class="string">&#x27;users&#x27;</span>, <span class="comment">// 该模型映射的真实表名</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了方便学习，使用一个函数包裹一组代码</span></span><br><span class="line"><span class="comment">// 这样代码就不会运行了，从而避免干扰其他代码的执行</span></span><br><span class="line"><span class="comment">// 如果想要此函数中代码执行，添加 `()` 就好</span></span><br><span class="line"><span class="comment">// (function()&#123;...&#125;)();  &lt;-- 加上括号</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 查询 users 表中所有数据</span></span><br><span class="line">    UserModel.findAll().then(<span class="function"><span class="params">users</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 返回的 users 是个数组</span></span><br><span class="line">        users.forEach(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 循环的每个 user 都是个 Model 实例</span></span><br><span class="line">            <span class="comment">// 该 Model 实例包含 get 方法，我们能通过它获取 username</span></span><br><span class="line">            <span class="built_in">console</span>.log(user.get(<span class="string">&#x27;username&#x27;</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 新建一条数据（除了build外，还可以通过 new UserModel() 的形式创建一条记录）</span></span><br><span class="line">    <span class="keyword">let</span> liyuanfang = UserModel.build(&#123;</span><br><span class="line">        username: <span class="string">&#x27;李元芳&#x27;</span>,</span><br><span class="line">        age: <span class="number">09</span>,</span><br><span class="line">        gender: <span class="string">&#x27;men&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 修改数据</span></span><br><span class="line">    liyuanfang.set(<span class="string">&#x27;age&#x27;</span>, <span class="number">25</span>);</span><br><span class="line">    <span class="comment">// 别忘了保存</span></span><br><span class="line">    <span class="keyword">await</span> liyuanfang.save();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 查询id为2的用户数据</span></span><br><span class="line">    UserModel.findByPk(<span class="number">2</span>).then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 查询到以后修改其 age 字段为 99</span></span><br><span class="line">        user.set(<span class="string">&#x27;age&#x27;</span>, <span class="number">99</span>);</span><br><span class="line">        <span class="comment">// 修改后别忘了保存</span></span><br><span class="line">        user.save();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 先查询</span></span><br><span class="line">    <span class="keyword">let</span> xiaohong = <span class="keyword">await</span> UserModel.findByPk(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// update方法相当于 set + save</span></span><br><span class="line">    <span class="keyword">await</span> xiaohong.update(&#123;</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 先查询</span></span><br><span class="line">    <span class="keyword">let</span> wangwu = <span class="keyword">await</span> UserModel.findByPk(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 对查询到的数据进行删除</span></span><br><span class="line">    wangwu.destroy();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 查找 username 为 &#x27;李元芳&#x27; 的唯一数据</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> UserModel.findOne(&#123;</span><br><span class="line">        where: &#123;</span><br><span class="line">            username: <span class="string">&#x27;李元芳&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.dir(res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 查找满足 age &gt; 24 的所有数据</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> UserModel.findAll(&#123;</span><br><span class="line">        where: &#123;</span><br><span class="line">            age: &#123;</span><br><span class="line">                [Sequelize.Op.gt]: <span class="number">24</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 打印出符合条件的用户的 username</span></span><br><span class="line">    <span class="built_in">console</span>.dir(res.map(<span class="function"><span class="params">r</span> =&gt;</span> r.get(<span class="string">&#x27;username&#x27;</span>)));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; Op &#125; = Sequelize;</span><br><span class="line">    <span class="comment">// 查找满足 age &lt; 25 或 gender = &#x27;men&#x27; 的所有数据</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> UserModel.findAll(&#123;</span><br><span class="line">        where: &#123;</span><br><span class="line">            [Op.or]: [</span><br><span class="line">                &#123;</span><br><span class="line">                    age: &#123;</span><br><span class="line">                        [Sequelize.Op.lt]: <span class="number">25</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    gender: <span class="string">&#x27;men&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 打印出符合条件的用户的 username</span></span><br><span class="line">    <span class="built_in">console</span>.dir(res.map(<span class="function"><span class="params">r</span> =&gt;</span> r.get(<span class="string">&#x27;username&#x27;</span>)));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 只从表中查询两条数据</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> UserModel.findAll(&#123;</span><br><span class="line">        limit: <span class="number">2</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res.map(<span class="function"><span class="params">r</span> =&gt;</span> r.get(<span class="string">&#x27;username&#x27;</span>)));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 跳过前2条数据</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> UserModel.findAll(&#123;</span><br><span class="line">        offset: <span class="number">2</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res.map(<span class="function"><span class="params">r</span> =&gt;</span> r.get(<span class="string">&#x27;username&#x27;</span>)));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 跳过前2条数据并获取3条</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> UserModel.findAll(&#123;</span><br><span class="line">        offset: <span class="number">2</span>,</span><br><span class="line">        limit: <span class="number">3</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res.map(<span class="function"><span class="params">r</span> =&gt;</span> r.get(<span class="string">&#x27;username&#x27;</span>)));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 查询的结果按年龄高到低排序</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> UserModel.findAll(&#123;</span><br><span class="line">        order: [</span><br><span class="line">            [<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;desc&#x27;</span>]</span><br><span class="line">        ]</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res.map(<span class="function"><span class="params">r</span> =&gt;</span> r.get(<span class="string">&#x27;username&#x27;</span>)));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 查询的结果按年龄高到低排序</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="keyword">await</span> UserModel.count();</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 查询 users 表中的前两条数据，并返回 users 表中总记录数</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> UserModel.findAndCountAll(&#123;</span><br><span class="line">        limit: <span class="number">2</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>安装的 sequelize 和 mysql2 的版本为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;mysql2&quot;</span>: <span class="string">&quot;^1.6.5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sequelize&quot;</span>: <span class="string">&quot;^5.3.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><a href="http://docs.sequelizejs.com/">Sequelize Docs</a></li>
<li><a href="https://demopark.github.io/sequelize-docs-Zh-CN/">Sequelize Docs 中文版</a></li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Sequelize</tag>
      </tags>
  </entry>
  <entry>
    <title>基于sequelize的数据库迁移</title>
    <url>/posts/16051/</url>
    <content><![CDATA[<h2 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h2><p>有时候我们也希望能够跟踪数据库的更改，像 git 一样在各个不同时期的数据库状态之间进行切换。或者能通过一套工具将数据库迁移到本机，让我们在家也能进行测试开发，而不用依赖公司的测试环境。这些特性，作为今天的主角 <code>sequelize-cli</code> 都能提供给我们。</p>
<blockquote>
<p>npm链接请 <a href="https://www.npmjs.com/package/sequelize-cli">点击这里</a>。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先创建项目，项目名随意，创建完毕后cd到项目根目录，老规矩命令行 <code>npm init -y</code> 创建 <code>package.json</code> ，然后输入安装一步到位：<code>npm i sequelize mysql2 sequelize-cli</code> 。</p>
<a id="more"></a>

<p><strong>注意：</strong> <code>sequelize-cli</code> 依赖 <code>sequelize</code>，<code>sequelize</code> 依赖 <code>mysql2</code></p>
<p>安装完毕后我们可以测试下是否可用，根目录命令行输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./node_modules/.bin/sequelize</span><br></pre></td></tr></table></figure>

<p>看见命令行输出类似下方提示代表安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sequelize [命令]</span><br><span class="line"></span><br><span class="line">命令：</span><br><span class="line">  sequelize db:migrate                        Run pending migrations</span><br><span class="line">  sequelize db:migrate:schema:timestamps:add  Update migration table to have timestamps</span><br><span class="line">  sequelize db:migrate:status                 List the status of all migrations</span><br><span class="line">  sequelize db:migrate:undo                   Reverts a migration</span><br><span class="line">  sequelize db:migrate:undo:all               Revert all migrations ran</span><br><span class="line">  sequelize db:seed                           Run specified seeder</span><br><span class="line">  sequelize db:seed:undo                      Deletes data from the database</span><br><span class="line">  sequelize db:seed:all                       Run every seeder</span><br><span class="line">  sequelize db:seed:undo:all                  Deletes data from the database</span><br><span class="line">  sequelize db:create                         Create database specified by configuration</span><br><span class="line">  sequelize db:drop                           Drop database specified by configuration</span><br><span class="line">  sequelize init                              Initializes project</span><br><span class="line">  sequelize init:config                       Initializes configuration</span><br><span class="line">  sequelize init:migrations                   Initializes migrations</span><br><span class="line">  sequelize init:models                       Initializes models</span><br><span class="line">  sequelize init:seeders                      Initializes seeders</span><br><span class="line">  sequelize migration:generate                Generates a new migration file     [aliases: migration:create]</span><br><span class="line">  sequelize model:generate                    Generates a model and its migration    [aliases: model:create]</span><br><span class="line">  sequelize seed:generate                     Generates a new seed file               [aliases: seed:create]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  --help     显示帮助信息                                                                             [布尔]</span><br><span class="line">  --version  显示版本号                                                                               [布尔]</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>目前我们项目的树形结构为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── node_modules</span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>

<p>接着根目录命令行输入 <code>./node_modules/.bin/sequelize init</code> 来初始化 sequelize 项目，该命令会帮我们创建如下目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── config              # 包含数据库的配置文件</span><br><span class="line">├── migrations          # 包含所有迁移文件（e.g. 数据库、表的创建，字段的增加）跟数据库结构有关的操作都存放在这里</span><br><span class="line">├── models              # 包含项目中的所有模型（e.g. Users, Message）</span><br><span class="line">├── node_modules</span><br><span class="line">├── seeders             # 包含所有种子文件（e.g. 表中的数据）</span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>



<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>首先我们来看下 <code>config</code> 目录下的 <code>config.json</code> 文件。它里面包含了数据库的的基本配置，默认分为 <code>development（开发）</code> 、<code>test（测试）</code> 和 <code>production（生产）</code> 环境。当然你也可以删除或新增环境，比如新增一个在家编写代码所使用的 <code>home</code> 环境。</p>
<h3 id="db-create"><a href="#db-create" class="headerlink" title="db:create"></a>db:create</h3><p><code>sequelize-cli</code> 默认读取 <code>development</code> 模式下的数据库配置来创建数据库，所以接下来就用它来配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;development&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>, <span class="comment">// 数据库用户名</span></span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;root&quot;</span>, <span class="comment">// 数据库密码</span></span><br><span class="line">    <span class="string">&quot;database&quot;</span>: <span class="string">&quot;database_development&quot;</span>, <span class="comment">// 需要创建的数据库名</span></span><br><span class="line">    <span class="string">&quot;host&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>, <span class="comment">// 主机</span></span><br><span class="line">    <span class="string">&quot;port&quot;</span>: <span class="number">8889</span>,       <span class="comment">// 端口号</span></span><br><span class="line">    <span class="string">&quot;dialect&quot;</span>: <span class="string">&quot;mysql&quot;</span>  <span class="comment">// 使用的数据库类型</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<p>配置完毕后在根目录下的命令行输入 <code>./node_modules/.bin/sequelize db:create</code><br>。当你看到如下输出就代表创建数据库成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Loaded configuration file &quot;config/config.json&quot;.</span><br><span class="line">Using environment &quot;development&quot;.</span><br><span class="line">Database sw_sequelize_development created.</span><br></pre></td></tr></table></figure>



<h3 id="db-drop"><a href="#db-drop" class="headerlink" title="db:drop"></a>db:drop</h3><p>能添加就能删除，我们可以键入 <code>./node_modules/.bin/sequelize db:drop</code> 命令来删除数据库。当你看到命令行输出下面内容就代表删除成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Loaded configuration file &quot;config/config.json&quot;.</span><br><span class="line">Using environment &quot;development&quot;.</span><br><span class="line">Database sw_sequelize_development dropped.</span><br></pre></td></tr></table></figure>



<h3 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h3><p>前面已经说了，<code>sequelize-cli</code> 默认读取 <code>development</code> 模式下的数据库配置。那如果我现在想切到 <code>test</code> 模式下该怎么办呢？</p>
<h4 id="变更环境变量"><a href="#变更环境变量" class="headerlink" title="变更环境变量"></a>变更环境变量</h4><p>首先得切换服务器环境变量，MacOS下（其他系统切换命令见下方链接）使用 <code>export NODE_ENV=test</code> 来切换到 <code>test</code> 模式，然后使用 <code>echo $NODE_ENV</code> 查看是否已经切换成功，接着就可以再次执行 <code>./node_modules/.bin/sequelize db:create</code> 命令，创建 <code>test</code> 模式下的数据库了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> NODE_ENV=<span class="built_in">test</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$NODE_ENV</span></span></span><br><span class="line">test</span><br><span class="line"></span><br><span class="line">./node_modules/.bin/sequelize db:create</span><br><span class="line"></span><br><span class="line">Sequelize CLI [Node: 9.0.0, CLI: 5.4.0, ORM: 5.3.3]</span><br><span class="line"></span><br><span class="line">Loaded configuration file &quot;config/config.json&quot;.</span><br><span class="line">Using environment &quot;test&quot;.</span><br><span class="line">Database sw_sequelize_test created.</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="http://sorex.cnblogs.com/p/6200940.html">各系统下NodeJS环境变量修改</a></p>
</blockquote>
<h4 id="还原环境变量"><a href="#还原环境变量" class="headerlink" title="还原环境变量"></a>还原环境变量</h4><p>如果想回到默认的 <code>development</code> 模式，MacOS下直接键入命令 <code>export NODE_ENV=</code> 就OK啦。</p>
<h2 id="models"><a href="#models" class="headerlink" title="models"></a>models</h2><h3 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h3><p>我们通过 <code>model:generate</code> 或者 <code>model:create</code> 来创建模型文件，它一共需要两个参数，分别是：</p>
<ul>
<li>–name: 模型名称（必须）</li>
<li>–attributes: 字段列表（必须）</li>
</ul>
<p>回到我们的项目，在根目录执行下面命令来创建一个 User 模型文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./node_modules/.bin/sequelize model:create --name User --attributes username:STRING</span><br></pre></td></tr></table></figure>

<p>执行完毕后命令行会有类似下方输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Sequelize CLI [Node: 9.0.0, CLI: 5.4.0, ORM: 5.3.3]</span><br><span class="line"></span><br><span class="line">New model was created at .../你的项目名/models/user.js .</span><br><span class="line">New migration was created at .../你的项目名/migrations/20190316035632-User.js</span><br></pre></td></tr></table></figure>



<p>所以 <code>model:create</code> 命令执行后帮我们创建了两个文件，一个是用来定义 User 模型的文件 user.js :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">sequelize, DataTypes</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> User = sequelize.define(<span class="string">&#x27;User&#x27;</span>, &#123;</span><br><span class="line">    username: DataTypes.STRING</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">  User.associate = <span class="function"><span class="keyword">function</span>(<span class="params">models</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// associations can be defined here</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> User;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>一个是 <code>migrations</code> 迁移文件夹下的 <code>用来创建 User 表</code> 的文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  up: <span class="function">(<span class="params">queryInterface, Sequelize</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//   创建名为 Users 的数据表</span></span><br><span class="line">    <span class="keyword">return</span> queryInterface.createTable(<span class="string">&#x27;Users&#x27;</span>, &#123;</span><br><span class="line">      id: &#123;</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">        autoIncrement: <span class="literal">true</span>,</span><br><span class="line">        primaryKey: <span class="literal">true</span>,</span><br><span class="line">        type: Sequelize.INTEGER</span><br><span class="line">      &#125;,</span><br><span class="line">      username: &#123;</span><br><span class="line">        type: Sequelize.STRING</span><br><span class="line">      &#125;,</span><br><span class="line">      createdAt: &#123;</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">        type: Sequelize.DATE</span><br><span class="line">      &#125;,</span><br><span class="line">      updatedAt: &#123;</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">        type: Sequelize.DATE</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  down: <span class="function">(<span class="params">queryInterface, Sequelize</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> queryInterface.dropTable(<span class="string">&#x27;Users&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>其中 <code>models</code> 文件夹下文件，例如生成的 <code>user.js</code> 模型文件是给程序用的；<code>migrations</code> 和 <code>seeders</code> 文件夹下的文件是个 <code>cli</code> 用的。</p>
<p>总结下来，<code>model:create</code> 命令帮我们做了两件事情：</p>
<ul>
<li>创建 User 模型</li>
<li>创建跟模型对应的 Users 数据表文件，方便用此文件在数据库中创建 Users 表</li>
</ul>
<h2 id="migrations"><a href="#migrations" class="headerlink" title="migrations"></a>migrations</h2><p>刚刚我们已经创建了一个 User 模型和用来创建 Users 表的脚本执行文件。下面就可以开始执行迁移了。首先我们重温何为执行迁移：</p>
<blockquote>
<p>所谓迁移，就是对数据库进行结构的创建、升级（修改）等操作</p>
</blockquote>
<h3 id="执行迁移"><a href="#执行迁移" class="headerlink" title="执行迁移"></a>执行迁移</h3><h4 id="db-migrate"><a href="#db-migrate" class="headerlink" title="db:migrate"></a>db:migrate</h4><p>执行迁移的命令为 <code>db:migrate</code>，我们直接在项目根目录下运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./node_modules/.bin/sequelize db:migrate</span><br></pre></td></tr></table></figure>

<p>（如果在此之前你运行过 db:drop 命令来删除数据库，记得再重新执行一次 db:create，否则会导致创建表失败）。执行成功的输出类似下面文字：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Sequelize CLI [Node: 9.0.0, CLI: 5.4.0, ORM: 5.3.3]</span><br><span class="line"></span><br><span class="line">Loaded configuration file &quot;config/config.json&quot;.</span><br><span class="line">Using environment &quot;development&quot;.</span><br><span class="line">== 20190316035632-create-user: migrating =======</span><br><span class="line">== 20190316035632-create-user: migrated (0.047s)</span><br></pre></td></tr></table></figure>

<p>此时刷新下你的本地数据库，就会发现之前空空如也的数据库中多了个 <code>users</code> 表和 <code>sequelizemeta</code> 表：</p>
<img src="/posts/16051/create-users.png" class="" title="create-users">

<p><code>users</code> 表被创建出来我们能理解，重点说一下这个 <code>sequelizemeta</code> 表，其实它是用来记录已经被执行过的迁移脚本的，避免我们重复执行已经执行过的脚本。</p>
<h4 id="db-migrate-status"><a href="#db-migrate-status" class="headerlink" title="db:migrate:status"></a>db:migrate:status</h4><p>我们可以通过 <code>db:migrate:status</code> 命令来查看当前迁移脚本的执行状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./node_modules/.bin/sequelize db:migrate:status</span><br></pre></td></tr></table></figure>

<p>执行完毕后的打印结果为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Loaded configuration file &quot;config/config.json&quot;.</span><br><span class="line">Using environment &quot;development&quot;.</span><br><span class="line">up 20190316035632-create-user.js</span><br></pre></td></tr></table></figure>

<p>这个 up ，表示我们已经执行该脚本。此时我们可以删掉 <code>sequelizemeta</code> 表中的记录，然后再次执行 <code>db:migrate:status</code> ，会发现输出的 <code>up</code> 已变为 <code>down</code> ，表示我们从未执行过该脚本。由此可知 <code>db:migrate:status</code> 会通过 <code>sequelizemeta</code> 表中的记录来判断脚本是否被执行过。而当我们已经执行过某些脚本后再次执行 <code>db:migrate</code> ，那些已经执行过的脚本就不会再次重复执行了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Loaded configuration file &quot;config/config.json&quot;.</span><br><span class="line">Using environment &quot;development&quot;.</span><br><span class="line">No migrations were executed, database schema was already up to date.</span><br></pre></td></tr></table></figure>

<h4 id="db-migrate-undo"><a href="#db-migrate-undo" class="headerlink" title="db:migrate:undo"></a>db:migrate:undo</h4><p>除了上面的新增数据表操作，我们还可以进行撤销操作。执行 <code>./node_modules/.bin/sequelize db:migrate:status</code> 命令后 <code>sequelize-cli</code> 会帮我们撤销掉上一次（最近一次）的迁移操作，比如我们的 <code>sequelizemeta</code><br>表中记录了两条迁移操作（假设创建了 user 和 message 表）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">20190316035632</span>-create-user.js</span><br><span class="line"><span class="number">20190316035921</span>-create-message.js</span><br></pre></td></tr></table></figure>

<p>那么执行 <code>undo</code> 后就会把最近的一次迁移，也就是 <code>*-message.js</code> 从表中移除，并且在数据库中删除 <code>message</code> 表。而这个删除操作，其实是执行了迁移文件下对应表的删除代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">down: <span class="function">(<span class="params">queryInterface, Sequelize</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> queryInterface.dropTable(<span class="string">&#x27;Messages&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="db-migrate-undo-all"><a href="#db-migrate-undo-all" class="headerlink" title="db:migrate:undo:all"></a>db:migrate:undo:all</h4><p>当执行 <code>./node_modules/.bin/sequelize db:migrate:undo:all</code> 命令后，能帮我们撤销所有的迁移操作。</p>
<h4 id="db-migrate-undo-–name"><a href="#db-migrate-undo-–name" class="headerlink" title="db:migrate:undo: –name"></a>db:migrate:undo: –name</h4><p>此命令能帮我们撤销具体指定的迁移脚本，例如执行下面命令会撤销名称为 <code>20190316035632-create-user</code> 的脚本操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./node_modules/.bin/sequelize db:migrate:undo --name 20190316035632-create-user</span><br></pre></td></tr></table></figure>



<p>执行完毕后再来刷新我们的数据库，就会发现 <code>user</code> 表已被删除，只留下了 <code>message</code> 表。</p>
<h3 id="字段添加与删除"><a href="#字段添加与删除" class="headerlink" title="字段添加与删除"></a>字段添加与删除</h3><p>随着业务的增长，我们很有可能需要扩充数据表的字段。例如我们需要给 <code>user</code> 表添加一个 <code>username</code> 字段，那么我们就可以键入以下命令来创建一个 <code>migration</code> :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./node_modules/.bin/sequelize migration:create --name UserAddAge</span><br></pre></td></tr></table></figure>

<p>执行完上述操作后我们能在 <code>migrations</code> 文件夹中看到新创建的 <code>UserAddAge</code> 文件，打开后代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  up: <span class="function">(<span class="params">queryInterface, Sequelize</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Add altering commands here.</span></span><br><span class="line"><span class="comment">      Return a promise to correctly handle asynchronicity.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Example:</span></span><br><span class="line"><span class="comment">      return queryInterface.createTable(&#x27;users&#x27;, &#123; id: Sequelize.INTEGER &#125;);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  down: <span class="function">(<span class="params">queryInterface, Sequelize</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Add reverting commands here.</span></span><br><span class="line"><span class="comment">      Return a promise to correctly handle asynchronicity.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Example:</span></span><br><span class="line"><span class="comment">      return queryInterface.dropTable(&#x27;users&#x27;);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>我们要做的，就是在 <code>up</code> 和 <code>down</code> 方法中填入数据库操作逻辑的代码，<code>up</code> 方法中有注释作提示，让我们返回一个类型为 <code>Promise</code> 的对象，还给出了示例。因为我们要给数据表添加字段，所以使用 <code>addColumn</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> queryInterface.addColumn(</span><br><span class="line">    <span class="string">&#x27;users&#x27;</span>,                        <span class="comment">// 被添加字段的表名称</span></span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>,                          <span class="comment">// 需要添加的字段名称</span></span><br><span class="line">    &#123;</span><br><span class="line">        type: Sequelize.TINYINT,</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">        defaultValue: <span class="number">0</span>,</span><br><span class="line">    &#125;,                              <span class="comment">// 字段属性</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样我们就可以给 <code>user</code> 表添加上 <code>age</code> 字段了。</p>
<p>p.s. 之所以代码中填写 <code>users</code> ，是因为 <code>sequelize-cli</code> 帮我们创建表是会自动给表名称加 <code>s</code> 。</p>
<hr>
<p>能添加就能删除，删除操作我们在 <code>down</code> 方法中编写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> queryInterface.removeColumn(</span><br><span class="line">    <span class="string">&#x27;users&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>UserAddAge.js</code> 文件完整代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  up: <span class="function">(<span class="params">queryInterface, Sequelize</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Add altering commands here.</span></span><br><span class="line"><span class="comment">      Return a promise to correctly handle asynchronicity.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Example:</span></span><br><span class="line"><span class="comment">      return queryInterface.createTable(&#x27;users&#x27;, &#123; id: Sequelize.INTEGER &#125;);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> queryInterface.addColumn(</span><br><span class="line">      <span class="string">&#x27;users&#x27;</span>, </span><br><span class="line">      <span class="string">&#x27;age&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        type: Sequelize.TINYINT,</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">        defaultValue: <span class="number">0</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  down: <span class="function">(<span class="params">queryInterface, Sequelize</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Add reverting commands here.</span></span><br><span class="line"><span class="comment">      Return a promise to correctly handle asynchronicity.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Example:</span></span><br><span class="line"><span class="comment">      return queryInterface.dropTable(&#x27;users&#x27;);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> queryInterface.removeColumn(</span><br><span class="line">      <span class="string">&#x27;users&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;age&#x27;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>编写完毕后我们运行 <code>./node_modules/.bin/sequelize db:migrate</code> 来重新执行一遍所有迁移，刷新 <code>user</code> 表后就能看见新增字段 <code>age</code> 了。</p>
<p>最后你还可以执行 <code>./node_modules/.bin/sequelize db:migrate:undo</code> 来确认 <code>down</code> 方法正常工作，从而让 <code>user</code> 表删除刚刚添加的 <code>age</code> 字段。</p>
<p>文档参考：<a href="http://docs.sequelizejs.com/class/lib/query-interface.js~QueryInterface.html">更多 QueryInterface 操作</a></p>
<h2 id="seeders"><a href="#seeders" class="headerlink" title="seeders"></a>seeders</h2><p>除了数据库结构的添加修改删除操作以外，我们通常还会给各种表批量添加一些假数据。这个时候就要用到 seeders 里的种子文件了。比方说现在要给 <code>user</code> 表批量添加一些数据，则可以执行下面代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./node_modules/.bin/sequelize seed:create --name userTest</span><br></pre></td></tr></table></figure>



<p>执行完毕后你会发现在 <code>seeders</code> 文件夹下多了一个类似 <code>20190316090425-userTest.js</code> 的文件。</p>
<h3 id="批量添加"><a href="#批量添加" class="headerlink" title="批量添加"></a>批量添加</h3><p>我们可以在里面编写代码让 <code>cli</code> 帮助我们批量添加数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  up: <span class="function">(<span class="params">queryInterface, Sequelize</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Add altering commands here.</span></span><br><span class="line"><span class="comment">      Return a promise to correctly handle asynchronicity.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Example:</span></span><br><span class="line"><span class="comment">      return queryInterface.bulkInsert(&#x27;People&#x27;, [&#123;</span></span><br><span class="line"><span class="comment">        name: &#x27;John Doe&#x27;,</span></span><br><span class="line"><span class="comment">        isBetaMember: false</span></span><br><span class="line"><span class="comment">      &#125;], &#123;&#125;);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">      <span class="keyword">return</span> queryInterface.bulkInsert(<span class="string">&#x27;users&#x27;</span>, [</span><br><span class="line">        &#123;</span><br><span class="line">          username: <span class="string">&#x27;狄仁杰&#x27;</span>,</span><br><span class="line">          age: <span class="number">56</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          username: <span class="string">&#x27;李元芳&#x27;</span>,</span><br><span class="line">          age: <span class="number">27</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  down: <span class="function">(<span class="params">queryInterface, Sequelize</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Add reverting commands here.</span></span><br><span class="line"><span class="comment">      Return a promise to correctly handle asynchronicity.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Example:</span></span><br><span class="line"><span class="comment">      return queryInterface.bulkDelete(&#x27;People&#x27;, null, &#123;&#125;);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> queryInterface.bulkDelete(<span class="string">&#x27;users&#x27;</span>, <span class="literal">null</span>, &#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>种子文件的执行方式有两种：</p>
<ul>
<li><code>db:seed 种子文件名</code> 来运行指定种子文件</li>
<li><code>db:seed:all</code> 来运行所有种子文件</li>
</ul>
<p>知道执行方法后我们来运行下面命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./node_modules/.bin/sequelize db:seed:all</span><br></pre></td></tr></table></figure>

<p>执行成功后刷新我们的 <code>user</code> 表，就会发现数据已经被批量添加进去了。</p>
<h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><p>命令行输入并执行： <code>./node_modules/.bin/sequelize db:seed:undo:all</code> 便可以批量删除刚刚添加进 <code>user</code> 表中的数据。</p>
<h3 id="记录种子数据的存储"><a href="#记录种子数据的存储" class="headerlink" title="记录种子数据的存储"></a>记录种子数据的存储</h3><p>我们知道 <code>migrations</code> 迁移是会被记录的（数据库的 <code>sequelizemeta</code> 表中），但默认情况下，种子数据的存储不会被记录下来。但官方同样提供了 <a href="http://docs.sequelizejs.com/manual/migrations.html#seed-storage">方法</a> 来记录种子数据的存储。我们可以通过在配置文件中使用 <code>seederStorage</code> 来记录存储：</p>
<h4 id="JSON记录"><a href="#JSON记录" class="headerlink" title="JSON记录"></a>JSON记录</h4><blockquote>
<p>config/config.json</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;development&quot;: &#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;seederStorage&quot;: &quot;json&quot;, // 存储类型</span><br><span class="line">    &quot;seederStoragePath&quot;: &quot;userTestData.json&quot; // 存储路径（当前项目根目录下）</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>p.s. 上方注释在 copy 到自己项目时需要删除，否则报错。</p>
<p>接着我们执行 <code>./node_modules/.bin/sequelize db:seed:undo:all</code> 先删除数据表中数据，然后再执行 <code>./node_modules/.bin/sequelize db:seed:all</code> 重新添加一次种子数据。你就会发现项目根目录下多出来了一个叫做 <code>userTestData.json</code> 的文件，里面记录了已经执行过的种子文件名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">&quot;20190316090425-userTest.js&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h4 id="sequelize记录"><a href="#sequelize记录" class="headerlink" title="sequelize记录"></a>sequelize记录</h4><p>p.s. 如果你已经用上面json记录的方式记录过种子文件的存储，再想要尝试用sequelize玩一遍的话，首先得执行一遍 <code>./node_modules/.bin/sequelize db:seed:undo:all</code> 哦。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;development&quot;: &#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;seederStorage&quot;: &quot;sequelize&quot;, // 存储类型</span><br><span class="line">    &quot;seederStoragePath&quot;: &quot;userTestData.json&quot;, // 存储路径（当前项目根目录下）</span><br><span class="line">    &quot;seederStorageTableName&quot;: &quot;userTestData&quot; // 存储的表名</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>编写完上述代码后你可以执行下面命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./node_modules/.bin/sequelize db:seed:all</span><br></pre></td></tr></table></figure>

<p>执行完毕后刷新数据库，就能在数据库中发现 <code>userTestData</code> 表，里面记录了已经执行完毕的种子文件 <code>20190316090425-userTest.js</code></p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>安装的 sequelize 和 mysql2 的版本为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;sequelize&quot;: &quot;^5.3.3&quot;,</span><br><span class="line">    &quot;sequelize-cli&quot;: &quot;^5.4.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><a href="http://docs.sequelizejs.com/class/lib/query-interface.js~QueryInterface.html">QueryInterface 操作</a></li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Sequelize</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;大话数据结构&gt;笔记</title>
    <url>/posts/51696/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前对算法和数据结构没有一个系统的学习，从今天开始抽空啃啃书吧。就从这本程杰老师的《大话数据结构》起步。</p>
<p>p.s. 原笔记是存放在幕布上的，文字版看着不舒服可以 <a href="https://mubu.com/doc/bnO4e_64Ti">点击这里</a> 看思维导图版。</p>
<a id="more"></a>

<ul>
<li><p>数据结构绪论</p>
<ul>
<li>基本概念和术语<ul>
<li>数据<ul>
<li>定义：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的集合符号。</li>
<li>总结：数据即符号，必备条件：<ul>
<li>可以输入到计算机中</li>
<li>能被计算机程序处理</li>
</ul>
</li>
<li>举例：<ul>
<li>MP3是声音数据</li>
<li>图片是图像数据</li>
</ul>
</li>
<li>#数据对象<ul>
<li>定义：是性质相同的数据元素的集合，是数据的子集</li>
<li>举例：<ul>
<li>人（都有姓名、生日等相同的数据项）</li>
</ul>
</li>
<li>#数据元素<ul>
<li>定义：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被成为记录。</li>
<li>举例：<ul>
<li>人类中的人</li>
<li>畜类中的牛马羊</li>
</ul>
</li>
<li>#数据项<ul>
<li>定义：一个数据元素可以由若干个数据项组成</li>
<li>举例：<ul>
<li>人的姓名、年龄、性别</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数据结构<ul>
<li>定义：是相互之间存在一种或多种特定关系的数据元素的集合</li>
<li>#逻辑结构<ul>
<li>定义：指数据对象中数据元素之间的相互关系</li>
<li>类型<ul>
<li>#集合结构<ul>
<li>同属于一个集合的数据元素<ul>
<li><img src="/posts/51696/e754fe1c-d4ec-4359-bb69-876f4ef61bc9-3051986.jpg" class="" title="e754fe1c-d4ec-4359-bb69-876f4ef61bc9-3051986"></li>
</ul>
</li>
</ul>
</li>
<li>#线性结构<ul>
<li>数据元素之间是一对一的关系<ul>
<li><img src="/posts/51696/5a4b6a6e-dff2-4608-96bc-77a924fac8fa-3051986.jpg" class="" title="5a4b6a6e-dff2-4608-96bc-77a924fac8fa-3051986"></li>
</ul>
</li>
</ul>
</li>
<li>#树形结构<ul>
<li>数据元素之间存在一对多的层次关系<ul>
<li><img src="/posts/51696/7f8cad6a-31f2-40e8-9193-47d0e8a52b41-3051986.jpg" class="" title="7f8cad6a-31f2-40e8-9193-47d0e8a52b41-3051986"></li>
</ul>
</li>
</ul>
</li>
<li>#图形结构<ul>
<li>数据元素是多对多的关系<ul>
<li><img src="/posts/51696/c0f99e81-3222-4fe4-8575-04e5e924cd49-3051986.jpg" class="" title="c0f99e81-3222-4fe4-8575-04e5e924cd49-3051986"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>用示意图表示数据逻辑结构时的注意点：<ul>
<li>每个数据元素是一个结点，用圆圈表示</li>
<li>元素之间的逻辑关系用连线表示，如果此关系是有方向的，那么用箭头连线表示</li>
</ul>
</li>
</ul>
</li>
<li>#物理结构<ul>
<li>定义：是指数据的逻辑结构在计算机中的存储形式</li>
<li>#顺序存储结构<ul>
<li>定义：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的<ul>
<li><img src="/posts/51696/b9a920bc-1728-4c8c-b0dd-c4b34c11e9e4-3051986.jpg" class="" title="b9a920bc-1728-4c8c-b0dd-c4b34c11e9e4-3051986"></li>
</ul>
</li>
</ul>
</li>
<li>#链式存储结构<ul>
<li>定义：是把数据元素存放在任意的存储单元里，这组存储单元可以使连续的，也可以是不连续的。<ul>
<li><img src="/posts/51696/0987f1e7-fdea-4404-bce6-c377ed05532d-3051986.jpg" class="" title="0987f1e7-fdea-4404-bce6-c377ed05532d-3051986"></li>
</ul>
</li>
<li>注意：数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>算法</p>
<ul>
<li>基本特性：输入、输出、有穷性、确定性和可行性</li>
<li>设计要求：正确性、可读性、健壮性、高效和低存储量</li>
<li>度量方法：事后统计（不科学、不准确）、事前分析估算 ✅</li>
<li>时间复杂度<ul>
<li>概念<ul>
<li>计算公式：T(n) = O(f(n))<ul>
<li>T(n)： 语句总的执行次数</li>
<li>n： 问题规模</li>
<li>f(n)： 问题规模 n 的某个函数</li>
</ul>
</li>
<li>表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同</li>
</ul>
</li>
<li>大O记法<ul>
<li>定义：用大写O()来体现时间复杂度，简称为大O记法</li>
<li>推导大O阶方法：<ul>
<li>\1. 用常数 1 取代运行时间中的所有加法常数</li>
<li>\2. 在修改后的运行次数函数中，只保留最高阶项</li>
<li>\3. 如果最高阶项存在且不是 1，则去除与这个项相乘的常数</li>
<li>\4. 得到的结果就是大 O 阶</li>
</ul>
</li>
</ul>
</li>
<li>常数阶<ul>
<li>举例：高斯算法<ul>
<li><img src="/posts/51696/e2affafd-97aa-4ee5-a37f-07bf1a7150d7-3051986.jpg" class="" title="e2affafd-97aa-4ee5-a37f-07bf1a7150d7-3051986"></li>
<li>此算法运行次数函数是 f(n)=3</li>
<li>推导：把常数项 3 改为 1 =&gt; 它没有最高阶 =&gt; 复杂度：O(1)</li>
</ul>
</li>
</ul>
</li>
<li>线性阶<ul>
<li><img src="/posts/51696/69be2ab0-b14f-4f40-976c-0f3ed54b2ffd-3051986.jpg" class="" title="69be2ab0-b14f-4f40-976c-0f3ed54b2ffd-3051986"></li>
<li>推导：循环体中代码需要执行 n 次 =&gt; 复杂度：O(n)</li>
</ul>
</li>
<li>对数阶<ul>
<li><img src="/posts/51696/972276a7-aeac-4f91-8337-a26f1e93dd8a-3051986.jpg" class="" title="972276a7-aeac-4f91-8337-a26f1e93dd8a-3051986"></li>
<li>推导：每次 count 乘以 2 后，就距离 n 更近一分。换句话说，有多少个 2 相乘后大于 n，则会退出循环。由 2^x=n 得到 x=log(2)n。所以此循环复杂度：O(logn)</li>
</ul>
</li>
<li>平方阶<ul>
<li>举例1<ul>
<li><img src="/posts/51696/7b6c8e16-5c79-4ef3-b066-95eace17bf19-3051986.jpg" class="" title="7b6c8e16-5c79-4ef3-b066-95eace17bf19-3051986"></li>
<li>推导：两层循环，每层循环 n 次 =&gt; 复杂度：O(n^2)</li>
<li>如果把外层 n 改为 m，则复杂度：O(m✘n)</li>
</ul>
</li>
<li>举例2<ul>
<li><img src="/posts/51696/3f60f9ca-4e93-4cf5-b69c-dbc8e189892d-3051986.jpg" class="" title="3f60f9ca-4e93-4cf5-b69c-dbc8e189892d-3051986"></li>
<li>复杂度：O(n^2)</li>
</ul>
</li>
</ul>
</li>
<li>常见时间复杂度<ul>
<li><img src="/posts/51696/f30d6524-ce51-470e-9f30-f624a72b6131-3051986.jpg" class="" title="f30d6524-ce51-470e-9f30-f624a72b6131-3051986"></li>
<li>常见时间复杂度所耗费的时间从小到大：<ul>
<li><img src="/posts/51696/621fb24b-7010-4e37-a761-0f178a4c0091-3051986.jpg" class="" title="621fb24b-7010-4e37-a761-0f178a4c0091-3051986"></li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>概念<ul>
<li>计算公式：S(n) = O(f(n))<ul>
<li>S(n)：计算算法所耗的存储空间</li>
<li>n： 问题规模</li>
<li>f(n)： 问题规模 n 所占存储空间的函数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>当不用限定词地使用“复杂度”时，指的都是时间复杂度</li>
<li>心得<ul>
<li>明白算法的时间复杂度估算很重要，不要以“CPU越来越快，不用考虑算法优劣”为借口。愚公移山固然可敬，但发明炸药和推土机更加实在和聪明</li>
</ul>
</li>
</ul>
</li>
<li><p>线性表</p>
<ul>
<li>定义：零个或多个数据元素的有限序列<ul>
<li>关键点：<ul>
<li>是一个<em>有顺序</em>的序列</li>
<li>若元素存在多个，则第一个无前驱，最后一个无后继，中间部分都有且只有一个前驱和后继</li>
<li>线性表是有限的</li>
</ul>
</li>
</ul>
</li>
<li>举例：<ul>
<li>幼儿园小朋友按次序排队，各自都知道他前面人是谁，方便清点人数，知道谁不在</li>
<li>一年的星座列表</li>
</ul>
</li>
<li>顺序存储结构<ul>
<li>定义：用一段地址连续的存储单元一次存储线性表的数据元素<ul>
<li><img src="/posts/51696/0da7720c-5c75-4a5c-ad5a-1323aa7dc388-3051986.jpg" class="" title="0da7720c-5c75-4a5c-ad5a-1323aa7dc388-3051986"></li>
</ul>
</li>
<li>三个重要属性：<ul>
<li>存储空间的起始位置</li>
<li>线性表的最大存储容量</li>
<li>线性表的当前长度</li>
</ul>
</li>
<li>数据长度与线性表长度区别<ul>
<li>数据长度：（例如一个数组的长度）是存放线性表的存储空间的长度，一般不变</li>
<li>线性表长度：是线性表中数据元素的个数，随着插入与删除，这个量是可变的</li>
<li>在任意时刻，线性表长度应该 小于等于 数据长度</li>
</ul>
</li>
<li>时间复杂度：<ul>
<li>插入或删除最后一个元素为 O(1)</li>
<li>插入或删除第一个元素为O(n)</li>
</ul>
</li>
<li>优缺点<ul>
<li>优点：<ul>
<li>无需为了表示表中元素之间的逻辑关系而增加额外的存储空间</li>
<li>可以快速地存取表中任意位置的元素</li>
</ul>
</li>
<li>缺点：<ul>
<li>插入和删除操作需要移动大量元素</li>
<li>当线性表长度变化较大时，难以确定存储空间的容量</li>
<li>造成存储空间的“碎片”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>链式存储结构<ul>
<li>定义：是把数据元素存放在任意的存储单元里，这组存储单元可以使连续的，也可以是不连续的。<ul>
<li><img src="/posts/51696/90e595e5-f1a5-4c67-a6e3-d27a59d629b6-3051986.jpg" class="" title="90e595e5-f1a5-4c67-a6e3-d27a59d629b6-3051986"></li>
</ul>
</li>
<li>与顺序结构不同，在链式结构中，除了要存储数据信息外，还要存储它后继元素的存储地址</li>
<li>单链表<ul>
<li>定义：一个链式结构的，每个结点中只包含一个指针域的链表叫做单链表<ul>
<li><img src="/posts/51696/43f9bf59-0141-4902-80b2-1ee623ce6bc9-3051986.jpg" class="" title="43f9bf59-0141-4902-80b2-1ee623ce6bc9-3051986"></li>
</ul>
</li>
<li>单链表结构与顺序存储结构的优缺点<ul>
<li>对比：<ul>
<li>存储分配方式：<ul>
<li>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素</li>
<li>单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</li>
</ul>
</li>
<li>时间性能：<ul>
<li>查找：<ul>
<li>顺序存储结构 O(1)</li>
<li>单链表 O(n)</li>
</ul>
</li>
<li>插入与删除：<ul>
<li>顺序存储结构需要移动表长一半的元素，时间为 O(n)</li>
<li>单链表在找出某位置的指针后，插入和删除时间仅为 O(1)</li>
</ul>
</li>
<li>空间性能：<ul>
<li>顺序存储结构需要预分配存储空间，分大了浪费，分小了容易溢出</li>
<li>单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>结论：<ul>
<li>若线性表需要频繁查找，很少进行插入和删除操作，宜采用顺序存储结构</li>
<li>若需要频繁插入和删除，宜采用单链表结构</li>
<li>当线性表中的元素个数变化较大或根本不知道多大时，宜采用单链表结构，这样不用考虑存储空间的大小问题。</li>
<li>若事先知道大致长度，比如一年12个月，一周7天，宜采用顺序存储结构</li>
</ul>
</li>
<li>实际应用：<ul>
<li>用户注册的个人信息，除了注册时插入数据外，绝大多数情况都是读取，所以宜采用顺序存储结构</li>
<li>游戏中玩家的武器装备列表，随着游戏推进，玩家可能随时增加或删除，所以宜采用单链表结构</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>静态链表<ul>
<li>背景：有些编程高级语言（e.g. Basic, Fortran）没有指针，这样链表结构就没法实现。</li>
<li>解决方案：用数组来代替指针，来描述单链表</li>
<li>实现：让数组元素都由两个数据域组成，data和cur。data用来存储数据元素，cur（游标）相当于单链表中的next指针，存放该元素的后继在数组中的下标。</li>
<li>定义：这种用数组描述的链表叫做静态链表。这种描述方法起名为游标实现法。<ul>
<li><img src="/posts/51696/bcbf36b2-6c2b-49a8-a3bc-08ecb8935a01-3051986.jpg" class="" title="bcbf36b2-6c2b-49a8-a3bc-08ecb8935a01-3051986"></li>
</ul>
</li>
<li>举例：<ul>
<li>将 “甲乙丙丁戊己庚”存入静态链表：<ul>
<li><img src="/posts/51696/60412d31-4595-4bee-a252-ccdcac7e333a-3051986.jpg" class="" title="60412d31-4595-4bee-a252-ccdcac7e333a-3051986"></li>
</ul>
</li>
<li>优缺点：<ul>
<li>优点：<ul>
<li>再插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。</li>
</ul>
</li>
<li>缺点：<ul>
<li>没有解决连续存储分配带来的表长难以确定的问题</li>
<li>失去了顺序存储结构随机存储的特性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>循环链表<ul>
<li>定义：将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。</li>
</ul>
</li>
<li>双向链表<ul>
<li>定义：双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>栈与队列</p>
<ul>
<li><p>栈</p>
<ul>
<li>定义：栈是限定仅在表尾进行插入和删除操作的线性表</li>
<li>描述：我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈又称为后进先出（Last In First Out）的线性表，简称 LIFO 结构。</li>
<li>举例：浏览器的前进后退，Photoshop 的前进撤销。</li>
<li>栈的顺序存储结构<ul>
<li>操作：<ul>
<li>栈的插入操作（push 压），叫作进栈，也称压栈、入栈。类似子弹入弹夹。<ul>
<li><img src="/posts/51696/8f921c05-7deb-4104-96cb-f293de081246-3051986.jpg" class="" title="8f921c05-7deb-4104-96cb-f293de081246-3051986"></li>
</ul>
</li>
<li>栈的删除操作（pop 弹），叫作出栈，也称弹栈。类似子弹出夹。<ul>
<li><img src="/posts/51696/6e22676a-6c14-446d-b330-2c459da99634-3051986.jpg" class="" title="6e22676a-6c14-446d-b330-2c459da99634-3051986"></li>
</ul>
</li>
</ul>
</li>
<li>两栈共享空间<ul>
<li>理解：两个相同类型的栈，为它们各自开辟了数组空间，极有可能第一个栈满，再进栈就溢出了，而另一个栈还有很多存储空间空闲。所以我们完全可以用一个数组来存储两个栈。<ul>
<li><img src="/posts/51696/55e0d735-25b7-4c18-8a8f-624eaa16cd8d-3051986.jpg" class="" title="55e0d735-25b7-4c18-8a8f-624eaa16cd8d-3051986"></li>
</ul>
</li>
<li>做法：数组的两个端点，让一个栈的栈底为数组的始端（下标0），另一个栈为栈的末端（n-1）。两栈如果增加元素，就是两端向中间延伸。</li>
<li>关键思路：<ul>
<li>\1. 两个top是数组两端的栈顶指针，只要它俩不见面，两个栈就都可以一直使用。</li>
<li>\2. 栈1为空时，就是top1等于-1时；当top2等于n时，即是栈2为空时。</li>
<li>\3. 何时栈满：top1等于n-1时栈1满；top2等于0时，栈2满，所以推导出，top1+1==top2为栈满</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>栈的链式存储结构<ul>
<li>栈顶存放位置：<ul>
<li>由于单链表有头指针，而栈顶指针也是必须的，所以把它俩合二为一，将栈顶放在单链表的头部。</li>
</ul>
</li>
<li>不需要头结点：<ul>
<li>都已经有了栈顶在头部，所以单链表的头结点也失去了意义，所以不需要头结点。</li>
</ul>
</li>
<li>示意图：<ul>
<li><img src="/posts/51696/aa59ece6-46d3-42de-8ccf-302713f41f0a-3051986.jpg" class="" title="aa59ece6-46d3-42de-8ccf-302713f41f0a-3051986"></li>
</ul>
</li>
</ul>
</li>
<li>栈的应用<ul>
<li>#递归</li>
<li>#四则运算表达式求值</li>
</ul>
</li>
</ul>
</li>
<li><p>队列</p>
<ul>
<li><p>定义：队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表</p>
</li>
<li><p>描述：队列是一种先进先出（First In First Out）的线性表，简称 FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p>
</li>
<li><p>举例：键盘的输入，记事本上的输出。</p>
</li>
<li><p>队列的顺序存储结构</p>
<ul>
<li><p>缺点：</p>
<ul>
<li><p>由于从队头出，导致后面元素都得向前移动，时间复杂度 O(n)</p>
<img src="/posts/51696/ce01c75c-c53a-49c7-b4b4-0e2fb3e4bfa6-3051986.jpg" class="" title="ce01c75c-c53a-49c7-b4b4-0e2fb3e4bfa6-3051986">
</li>
</ul>
</li>
<li><p>解决：</p>
<ul>
<li>循环队列<ul>
<li>让头尾相接</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>队列的链式存储结构</p>
</li>
<li><p>顺序存储和链式存储的选择</p>
<ul>
<li>可以确定队列长度最大值时，建议循环队列</li>
<li>无法预估队列长度时，使用链队列</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>串</p>
<ul>
<li>定义：是由零个或多个字符组成的有限序列，又名字符串</li>
<li>算法<ul>
<li>朴素的模式匹配算法<ul>
<li>从头开始依次往后比较【不推荐】</li>
</ul>
</li>
<li>KMP模式匹配算法</li>
</ul>
</li>
</ul>
</li>
<li><p>数</p>
<ul>
<li><p>定义：</p>
<ul>
<li>树是 n(n&gt;=0) 个结点的有限集。n=0 时称为空树。在任意一棵非空树中：<ul>
<li>\1. 有且仅有一个特定的称为根（Root）的结点</li>
<li>\2. 当 n &gt; 1 时，其余结点可分为 m(m &gt; 0) 个互不相交的有限集 T1、T2 … 、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）</li>
</ul>
</li>
<li><img src="/posts/51696/aea04c1e-15b7-4692-8504-7d049e7ea05e-3051986.jpg" class="" title="aea04c1e-15b7-4692-8504-7d049e7ea05e-3051986">
</li>
</ul>
</li>
<li><p>结点分类</p>
<ul>
<li>定义：结点拥有的子树数称为结点的度。度为 0 的结点称为叶结点或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根结点外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。下面树结点的度的最大值是结点 D 的度，为 3，所以树的度也为 3 。<ul>
<li><img src="/posts/51696/e31ad7c9-0003-435a-bf98-3c7c03764720-3051986.jpg" class="" title="e31ad7c9-0003-435a-bf98-3c7c03764720-3051986">
</li>
</ul>
</li>
</ul>
</li>
<li><p>结点间关系</p>
<ul>
<li><img src="/posts/51696/63d4fff0-5e45-428e-a32c-14b972b93e2b-3051986.jpg" class="" title="63d4fff0-5e45-428e-a32c-14b972b93e2b-3051986">
</li>
</ul>
</li>
<li><p>树的其他相关概念</p>
<ul>
<li><p>结点的层次</p>
<ul>
<li><p>从根开始定义起，根为第一层。</p>
<ul>
<li><p>树中结点的最大层次称为树的深度或高度，下图树深度为 4</p>
<img src="/posts/51696/5fd0623d-6956-447b-9125-48a3eaf0a977-3051986.jpg" class="" title="5fd0623d-6956-447b-9125-48a3eaf0a977-3051986">
</li>
</ul>
</li>
</ul>
</li>
<li><p>树与线性表结构的对比</p>
<ul>
<li><img src="/posts/51696/a277b277-b5ef-4306-b89b-477e49fa9bf7-3051986.jpg" class="" title="a277b277-b5ef-4306-b89b-477e49fa9bf7-3051986">
</li>
</ul>
</li>
<li><p>阿萨德</p>
</li>
</ul>
</li>
<li><p>二叉树</p>
<ul>
<li><p>定义：二叉树是 n(n&gt;=0)个结点的有限集合，该集合或为空集（称为空二叉树），或由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。</p>
<ul>
<li><img src="/posts/51696/1d2f3500-70e1-4aed-adbb-4007c27125af-3051986.jpg" class="" title="1d2f3500-70e1-4aed-adbb-4007c27125af-3051986">
</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>每个结点最多有两棵子树</li>
<li>左子树和右子树是有顺序的，次序不能任意颠倒</li>
<li>即使树中某结点只有一棵树，也要区分左右子树</li>
</ul>
</li>
<li><p>特殊二叉树</p>
<ul>
<li><p>#斜树</p>
<ul>
<li>定义：<ul>
<li>所有结点都在左子树的二叉树叫左斜树<ul>
<li><img src="/posts/51696/34668592-d9a6-4e01-b13c-1eec6b8fca42-3051986.jpg" class="" title="34668592-d9a6-4e01-b13c-1eec6b8fca42-3051986"></li>
</ul>
</li>
<li>所有结点都在右子树的二叉树叫右斜树<ul>
<li><img src="/posts/51696/3e52b0f5-6d81-43bd-8e35-33b203ccd3af-3051986.jpg" class="" title="3e52b0f5-6d81-43bd-8e35-33b203ccd3af-3051986"></li>
</ul>
</li>
</ul>
</li>
<li>这种特殊树和线性表结构一样，所以线性表结构可以理解为是树的一种特殊形式</li>
</ul>
</li>
<li><p>#满二叉树</p>
<ul>
<li><img src="/posts/51696/e13bdddf-2d7b-4f94-b17f-b539f7200efa-3051986.jpg" class="" title="e13bdddf-2d7b-4f94-b17f-b539f7200efa-3051986">
</li>
</ul>
</li>
<li><p>#完全二叉树</p>
<ul>
<li><p>定义：对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i (i &lt;= i &lt;= n) 的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中的位置完全相同，则这课二叉树称为完全二叉树。</p>
<ul>
<li><img src="/posts/51696/d0842d6b-122e-48c2-91f1-9ce55d73028e-3051986.jpg" class="" title="d0842d6b-122e-48c2-91f1-9ce55d73028e-3051986">
</li>
</ul>
</li>
<li><p>如何判定：在看树时，心中默默给每个结点按照满<em>二叉树</em>的结构<em>逐层顺序</em>编号，如果编号出现空挡，就说明不是完全二叉树，否则就是。</p>
<ul>
<li><p>下面几个都不是：</p>
<ul>
<li><p>9跟11之间有空挡</p>
<img src="/posts/51696/d055bd00-8c52-4da4-983e-baf9c1d65abe-3051986.jpg" class="" title="d055bd00-8c52-4da4-983e-baf9c1d65abe-3051986">
</li>
<li><p>5跟8，9之间有空挡</p>
<img src="/posts/51696/821f0e91-4700-495e-a657-a372965a7027-3051986.jpg" class="" title="821f0e91-4700-495e-a657-a372965a7027-3051986">
</li>
<li><p>9跟12之间有空挡</p>
<img src="/posts/51696/130be6af-5ac2-403e-a196-60a3534664eb-3051986.jpg" class="" title="130be6af-5ac2-403e-a196-60a3534664eb-3051986">
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>存储结构</p>
<ul>
<li>二叉树顺序存储结构（适用于完全二叉树）</li>
<li>二叉链表</li>
</ul>
</li>
<li><p>遍历二叉树</p>
<ul>
<li><p>#二叉树遍历方法</p>
<ul>
<li><p>前序遍历</p>
<ul>
<li><p>遍历顺序：ABDGHCEIF</p>
<img src="/posts/51696/bcef9e8a-1e6a-4f9e-97ac-d0aa5d29d6ce-3051986.jpg" class="" title="bcef9e8a-1e6a-4f9e-97ac-d0aa5d29d6ce-3051986">
</li>
</ul>
</li>
<li><p>中序遍历</p>
<ul>
<li><p>遍历顺序：GDHBAEICF</p>
<img src="/posts/51696/53c8f72e-58fb-4c13-8ee6-110c000a497c-3051986.jpg" class="" title="53c8f72e-58fb-4c13-8ee6-110c000a497c-3051986">
</li>
</ul>
</li>
<li><p>后序遍历</p>
<ul>
<li><p>遍历顺序：GHDBIEFCA</p>
<img src="/posts/51696/76154ad4-d5f9-4db5-a8f7-06c0e36b29de-3051986.jpg" class="" title="76154ad4-d5f9-4db5-a8f7-06c0e36b29de-3051986">
</li>
</ul>
</li>
<li><p>层序遍历</p>
<ul>
<li><p>遍历顺序：ABCDEFGHI</p>
<img src="/posts/51696/ca020d5e-541d-47d2-b72f-fdaf25b5fba1-3051986.jpg" class="" title="ca020d5e-541d-47d2-b72f-fdaf25b5fba1-3051986">
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>图</p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用webpack4</title>
    <url>/posts/47462/</url>
    <content><![CDATA[<h2 id="为什么要使用-webpack"><a href="#为什么要使用-webpack" class="headerlink" title="为什么要使用 webpack"></a>为什么要使用 webpack</h2><h3 id="网页中引用的常见静态资源"><a href="#网页中引用的常见静态资源" class="headerlink" title="网页中引用的常见静态资源"></a>网页中引用的常见静态资源</h3><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">静态资源</th>
</tr>
</thead>
<tbody><tr>
<td align="left">JS</td>
<td align="left">.js .jsx .coffee .ts（TypeScript 类 C# 语言）</td>
</tr>
<tr>
<td align="left">CSS</td>
<td align="left">.css .less .sass .scss</td>
</tr>
<tr>
<td align="left">Images</td>
<td align="left">.jpg .png .gif .bmp .svg</td>
</tr>
<tr>
<td align="left">字体文件（Fonts）</td>
<td align="left">.svg .ttf .eot .woff .woff2</td>
</tr>
<tr>
<td align="left">模板文件</td>
<td align="left">.ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】</td>
</tr>
</tbody></table>
<a id="more"></a>

<h3 id="引入过多静态资源有什么问题？"><a href="#引入过多静态资源有什么问题？" class="headerlink" title="引入过多静态资源有什么问题？"></a>引入过多静态资源有什么问题？</h3><ol>
<li>网页加载速度慢， 因此我们要发起很多的二次请求</li>
<li>还要处理错综复杂的依赖关系</li>
</ol>
<h3 id="如何解决上述两个问题"><a href="#如何解决上述两个问题" class="headerlink" title="如何解决上述两个问题"></a>如何解决上述两个问题</h3><ol>
<li>合并、压缩、精灵图、图片的 Base64 编码</li>
<li>可以使用 requireJS、也可以使用 webpack 来解决各个包之间的复杂依赖关系</li>
</ol>
<h3 id="如何完美实现上述的2种解决方案"><a href="#如何完美实现上述的2种解决方案" class="headerlink" title="如何完美实现上述的2种解决方案"></a>如何完美实现上述的2种解决方案</h3><ol>
<li>使用 Gulp， 基于 task 任务</li>
<li>使用 webpack， 基于整个项目进行构建<ul>
<li>借助于 webpack 这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能</li>
</ul>
</li>
</ol>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>webpack 是基于 Node.js 开发出来的一个前端项目打包工具。</p>
<h2 id="安装-amp-初步使用"><a href="#安装-amp-初步使用" class="headerlink" title="安装 &amp; 初步使用"></a>安装 &amp; 初步使用</h2><ol>
<li><p>如果第一次安装，需要全局安装 『 webpack &amp;&amp; webpack-cli 』:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g webpack webpack-cli</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建文件夹</span></span><br><span class="line">mkdir webpack4-demo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入</span></span><br><span class="line">cd webpack4-demo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化</span></span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>以下面的目录结构创建文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── package.json</span><br><span class="line">└── src</span><br><span class="line">    ├── css</span><br><span class="line">    │   └── index.css</span><br><span class="line">    ├── images</span><br><span class="line">    │   └── temp.png</span><br><span class="line">    ├── index.html</span><br><span class="line">    ├── js</span><br><span class="line">    │   ├── a.js</span><br><span class="line">    │   ├── b.js</span><br><span class="line">    │   └── index.js</span><br><span class="line">    └── main.js</span><br></pre></td></tr></table></figure>

<blockquote>
<p>index.css</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">   <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">0.05</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>index.html</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>js/a.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">   <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;我是 a 模块，现在被初始化了&quot;</span>)</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="function"><span class="title">binit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      b.init()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br></pre></td></tr></table></figure>

<blockquote>
<p>js/b.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">   <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;我是 b 模块，现在被初始化了&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> b</span><br></pre></td></tr></table></figure>

<blockquote>
<p>js/index.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> index = &#123;</span><br><span class="line">   <span class="comment">// init后执行隔行变色的代码</span></span><br><span class="line">   <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 设置偶数行背景色，索引从0开始，0是偶数</span></span><br><span class="line">      $(<span class="string">&#x27;#list li:even&#x27;</span>).css(<span class="string">&#x27;backgroundColor&#x27;</span>, <span class="string">&#x27;lightblue&#x27;</span>)</span><br><span class="line">      <span class="comment">// 设置奇数行背景色</span></span><br><span class="line">      $(<span class="string">&#x27;#list li:odd&#x27;</span>).css(<span class="string">&#x27;backgroundColor&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> index</span><br></pre></td></tr></table></figure>

<blockquote>
<p>main.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./js/a&#x27;</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./js/b&#x27;</span></span><br><span class="line"><span class="keyword">import</span> index <span class="keyword">from</span> <span class="string">&#x27;./js/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./css/index.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;入口函数 main 被调用了&#x27;</span>)</span><br><span class="line">   a.init()</span><br><span class="line">   a.binit()</span><br><span class="line">   b.init()</span><br><span class="line">   index.init()</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
</li>
<li><p>项目根文件夹下执行命令 <code>npm i webpack webpack-cli -D</code></p>
</li>
<li><p>使用 <code>npm i jquery</code> 安装 jQuery 类库</p>
</li>
<li><p>直接在页面上引用 <code>main.js</code> 会报错，因为浏览器不认识 <code>import $ from &#39;jquery&#39;</code> 这种JS语法，需要使用 webpack 进行处理，webpack 默认会把这种高级的语法转换为低级的浏览器能识别的语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 直接引入会报错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 <code>webpack 入口文件路径 模式</code> 运行 <code>main.js</code> 入口文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">webpack src/main.js --mode development # 开发环境</span><br><span class="line">或者</span><br><span class="line">webpack src/main.js --mode production  # 生产环境</span><br></pre></td></tr></table></figure>
</li>
<li><p>不过每次都要输入这个命令，非常麻烦，我们可以在<code>package.json</code>的<code>scripts</code>中加入两个指令成员：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;dev&quot;: &quot;webpack src/main.js --mode development&quot;,</span><br><span class="line">   &quot;build&quot;: &quot;webpack src/main.js --mode production&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>以后只需要在命令行执行 <code>npm run dev</code> 便相当于执行 <code>webpack --mode development</code> ，执行 <code>npm run build</code> 便相当于执行 <code>webpack --mode production</code>。</p>
</li>
</ol>
<h2 id="使用配置文件简化打包命令"><a href="#使用配置文件简化打包命令" class="headerlink" title="使用配置文件简化打包命令"></a>使用配置文件简化打包命令</h2><ol>
<li><p>在项目根目录中创建 <code>webpack.config.js</code></p>
</li>
<li><p>由于运行 webpack 命令的时候，webpack 需要指定入口文件和输出文件的路径，所以我们需要在 <code>webpack.config.js</code> 中配置这两个路径：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入处理路径的模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出一个配置对象，将来 webpack 在启动的时候，</span></span><br><span class="line"><span class="comment">// 会默认来查找 webpack.config.js ，</span></span><br><span class="line"><span class="comment">// 并读取这个文件中导出的配置对象，来进行打包处理</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   <span class="comment">// 配置入口文件，表示要使用 webpack 打包哪个文件</span></span><br><span class="line">   <span class="comment">// 若不配置 webpack 将自动查找 src 目录下的 index.js 文件</span></span><br><span class="line">   entry: &#123;</span><br><span class="line">      main: path.join(__dirname, <span class="string">&#x27;./src/main.js&#x27;</span>)</span><br><span class="line">   &#125;,</span><br><span class="line">   output: &#123;</span><br><span class="line">      filename: <span class="string">&quot;[name].bundle.[hash].js&quot;</span>, <span class="comment">//输出文件名，[name]表示入口文件js名，[hash]会在后面生成随机hash值</span></span><br><span class="line">      path: path.join(__dirname, <span class="string">&quot;./dist&quot;</span>) <span class="comment">//输出文件路径</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于此时已经配置了入口文件，<code>package.json</code> 中的脚本命令就可简化为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack --mode development&quot;,</span><br><span class="line">&quot;build&quot;: &quot;webpack --mode production&quot;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="实现-webpack-实时打包构建"><a href="#实现-webpack-实时打包构建" class="headerlink" title="实现 webpack 实时打包构建"></a>实现 webpack 实时打包构建</h2><p>webpack 提供了一个可选的本地开发服务器，这个本地服务器基于 node.js 构建，它是一个单独的插件，叫做 <code>webpack-dev-server</code> ，在 webpack 中进行配置之前需要单独安装它作为项目依赖。</p>
<p>devServer 作为 webpack 配置选项中的一项，以下是它的一些配置选项:</p>
<ul>
<li><code>contentBase</code> ：设置服务器所读取文件的目录，当前我们设置为”./dist”</li>
<li><code>port</code> ：设置端口号，如果省略，默认为<code>8080</code></li>
<li><code>inline</code> ：设置为<code>true</code>，当源文件改变时会自动刷新页面</li>
<li><code>historyApiFallback</code> ：设置为<code>true</code>，所有的跳转将指向<code>index.html</code></li>
</ul>
<ol>
<li><p>由于每次重新修改代码之后，都需要手动运行 webpack 打包的命令，比较麻烦，所以使用 <code>webpack-dev-server</code> 来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。</p>
</li>
<li><p>运行 <code>npm i webpack-dev-server -D</code> 安装到开发依赖</p>
</li>
<li><p>安装完成之后，修改之前在 <code>package.json</code> 中添加的 dev 指令：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server --mode development&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行指令 <code>npm run dev</code> ，发现可以进行实时打包，但是 dist 目录下并没有生成 <code>main.bundle.js</code> 文件，这是因为 <code>webpack-dev-server</code> 将打包好的文件放在了内存中。</p>
<ul>
<li><p>把 <code>bundle.js</code> 放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快</p>
</li>
<li><p>这个时候访问 webpack-dev-server 启动的 <code>http://localhost:8080/</code> 网站，发现是一个文件夹的面板，需要点击到 src 目录下，才能打开我们的 index 首页，此时引用不到 <code>main.bundle.js</code> 文件，需要修改 index.html 中 script 的 src 属性为:<code>&lt;script src=&quot;../main.bundle.js&quot;&gt;&lt;/script&gt;</code></p>
</li>
<li><p>为了能在访问 <code>http://localhost:8080/</code> 的时候直接访问到 index 首页，可以使用 <code>--contentBase src</code> 指令来修改dev指令，指定启动的根目录：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server --mode development --contentBase src&quot;,</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="插件（Plugins）"><a href="#插件（Plugins）" class="headerlink" title="插件（Plugins）"></a>插件（Plugins）</h2><p>插件（Plugins）是用来拓展 webpack 功能的，它们会在整个构建过程中生效，执行相关的任务。<br>Loaders 和 Plugins 常常被弄混，但是它们其实是完全不同的东西，可以这么来说，loaders 是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。</p>
<h3 id="使用-html-webpack-plugin-插件配置启动页面"><a href="#使用-html-webpack-plugin-插件配置启动页面" class="headerlink" title="使用 html-webpack-plugin 插件配置启动页面"></a>使用 <code>html-webpack-plugin</code> 插件配置启动页面</h3><p>由于使用 <code>--contentBase</code> 指令的过程比较繁琐，需要指定启动的目录，同时还需要修改 index.html 中 script 标签的 src 属性，所以推荐使用 <code>html-webpack-plugin</code> 插件配置启动页面。</p>
<ol>
<li><p>运行 <code>npm i html-webpack-plugin -D</code> 安装到开发依赖</p>
</li>
<li><p>修改 <code>webpack.config.js</code> 配置文件如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入处理路径的模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入自动生成HTMl文件的插件</span></span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出一个配置对象，将来 webpack 在启动的时候，</span></span><br><span class="line"><span class="comment">// 会默认来查找 webpack.config.js ，</span></span><br><span class="line"><span class="comment">// 并读取这个文件中导出的配置对象，来进行打包处理</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 配置入口文件，表示要使用 webpack 打包哪个文件</span></span><br><span class="line">    <span class="comment">// 若不配置 webpack 将自动查找 src 目录下的 index.js 文件</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: path.join(__dirname, <span class="string">&#x27;./src/main.js&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&quot;[name].bundle.js&quot;</span>, <span class="comment">//输出文件名，[name]表示入口文件js名</span></span><br><span class="line">        path: path.join(__dirname, <span class="string">&quot;./dist&quot;</span>) <span class="comment">//输出文件路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [ <span class="comment">// 添加plugins节点配置插件</span></span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            template: path.join(__dirname, <span class="string">&#x27;./src/index.html&#x27;</span>), <span class="comment">//模板路径</span></span><br><span class="line">            filename: <span class="string">&#x27;index.html&#x27;</span>, <span class="comment">//自动生成的HTML文件的名称</span></span><br><span class="line">            minify: &#123; <span class="comment">// 压缩HTML文件</span></span><br><span class="line">               removeComments: <span class="literal">true</span>, <span class="comment">// 移除HTML中的注释</span></span><br><span class="line">               collapseWhitespace: <span class="literal">true</span>, <span class="comment">// 删除空白符与换行符</span></span><br><span class="line">               minifyCSS: <span class="literal">true</span> <span class="comment">// 压缩内联css</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>撤销 <code>package.json</code> 中 <code>script</code> 节点中的 dev 指令为：<br><code>dev&quot;: &quot;webpack-dev-server --mode development&quot;</code></p>
</li>
<li><p>将 index.html 中 script 标签注释掉，因为 <code>html-webpack-plugin</code> 插件会自动把 main.bundle.js 注入到 index.html 页面中。</p>
</li>
</ol>
<h3 id="实现自动打开浏览器、热更新和配置浏览器的默认端口号"><a href="#实现自动打开浏览器、热更新和配置浏览器的默认端口号" class="headerlink" title="实现自动打开浏览器、热更新和配置浏览器的默认端口号"></a>实现自动打开浏览器、热更新和配置浏览器的默认端口号</h3><h4 id="方式1："><a href="#方式1：" class="headerlink" title="方式1："></a>方式1：</h4><p>修改 <code>package.json</code> 的 script 节点如下，其中 <code>--open</code> 表示自动打开浏览器， <code>--port 4321</code> 表示打开的端口号为 4321 ，<code>--hot</code> 表示启用浏览器热更新：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server --open --port 4321 --hot  --mode development&quot;,</span><br></pre></td></tr></table></figure>

<h4 id="方式2：-个人推荐"><a href="#方式2：-个人推荐" class="headerlink" title="方式2：(个人推荐)"></a>方式2：(个人推荐)</h4><ol>
<li><p>修改 <code>webpack.config.js</code> 文件，新增 <code>devServer</code> 节点如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">     inline: <span class="literal">true</span>, <span class="comment">//打包后加入一个 websocket 客户端</span></span><br><span class="line">     hot: <span class="literal">true</span>, <span class="comment">// 启用热更新 的 第1步</span></span><br><span class="line">     open: <span class="literal">true</span>, <span class="comment">// 自动打开浏览器</span></span><br><span class="line">     contentBase: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>), <span class="comment">// 指定托管的根目录，不注释的话，无法访问 src 以外的资源，比如 node_modules</span></span><br><span class="line">     host: <span class="string">&#x27;localhost&#x27;</span>, <span class="comment">// 主机地址</span></span><br><span class="line">     port: <span class="number">4321</span>, <span class="comment">// 设置启动时候的运行端口</span></span><br><span class="line">     compress: <span class="literal">true</span> <span class="comment">// 开发服务器是否启动gzip等压缩</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>在头部引入 <code>webpack</code> 模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启用热更新的 第2步</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>plugins</code> 节点下新增：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启用热更新的第 3 步</span></span><br><span class="line"><span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h2><p>loaders 是 webpack 最强大的功能之一，通过不同的 loader ，webpack 有能力调用外部的脚本或工具，实现对不同格式的文件的处理，例如把 <code>scss</code> 转为 <code>css</code> ，将 ES6 、ES7 等语法转化为当前浏览器能识别的语法，将 JSX 转化为 js 等多项功能。</p>
<p>loaders 需要单独安装并且需要在 <code>webpack.config.js</code> 中的 <code>modules</code> 配置项下进行配置，Loaders的配置包括以下几方面：</p>
<ul>
<li><code>test</code>：一个用以匹配 loaders 所处理文件的拓展名的正则表达式（必须）</li>
<li><code>loader</code>：loader的名称（必须）</li>
<li><code>include/exclude</code>：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；</li>
<li><code>options</code>：为loaders提供额外的设置选项（可选）</li>
</ul>
<h3 id="打包-css-文件"><a href="#打包-css-文件" class="headerlink" title="打包 css 文件"></a>打包 css 文件</h3><ol>
<li><p>运行<code>npm i style-loader css-loader --D</code></p>
</li>
<li><p>修改 <code>webpack.config.js</code> 这个配置文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123; <span class="comment">// 用来配置第三方loader模块的</span></span><br><span class="line">    rules: [ <span class="comment">// 文件的匹配规则</span></span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">        &#125; <span class="comment">//处理css文件的规则</span></span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：<code>use</code> 表示使用哪些模块来处理 <code>test</code> 所匹配到的文件；<code>use</code> 中相关 loader 模块的调用顺序是从后向前调用的。</p>
</li>
</ol>
<h3 id="打包-less-文件"><a href="#打包-less-文件" class="headerlink" title="打包 less 文件"></a>打包 less 文件</h3><ol>
<li><p>如果你习惯使用 less ，可以执行命令 <code>npm i less-loader less -D</code> 来安装 less-loader 。</p>
</li>
<li><p>修改 <code>webpack.config.js</code> 配置文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">&#125;, <span class="comment">//配置处理 .less 文件的第三方 loader 规则</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="打包-sass-文件"><a href="#打包-sass-文件" class="headerlink" title="打包 sass 文件"></a>打包 sass 文件</h3><ol>
<li><p>例如我平常习惯用 scss，所以会安装 sass-loader ：执行命令 <code>npm i sass-loader node-sass --D</code></p>
</li>
<li><p>在 <code>webpack.config.js</code> 中添加处理 sass 文件的 loader 模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">   use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 配置处理 .scss 文件的 第三方 loader 规则（npm i sass-loader后还需要 npm i node-sass，否则编译报错）</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="处理-css-中的图片路径"><a href="#处理-css-中的图片路径" class="headerlink" title="处理 css 中的图片路径"></a>处理 css 中的图片路径</h3><blockquote>
<p>预备工作：</p>
<ol>
<li>在 src/css/index.css 文件中给 body 添加：background-image: url(“../images/temp.png”);</li>
<li>此时保存会编译报错，因为 webpack 无法处理 css 中的路径（此案例中为——图片资源）</li>
</ol>
</blockquote>
<ol>
<li><p>运行 <code>npm i url-loader file-loader --D</code></p>
</li>
<li><p>在 <code>webpack.config.js</code> 中添加处理 url 路径的 loader 模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(jpg|png|bmp|gif|jpeg)$/</span>,</span><br><span class="line">    use:[&#123;</span><br><span class="line">       loader:<span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">       options:&#123;</span><br><span class="line">          outputPath:<span class="string">&#x27;images/&#x27;</span>,<span class="comment">//输出到images文件夹</span></span><br><span class="line">          <span class="comment">//是把小于500B的文件打成 Base64 的格式，写入JS</span></span><br><span class="line">          <span class="comment">// 如果不小于，url-loader 就会使用 file-loader 处理图片</span></span><br><span class="line">          <span class="comment">// 所以必须安装file-loader</span></span><br><span class="line">          limit:<span class="number">500</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;, <span class="comment">// 配置图片路径</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="处理-Bootstrap-字体的加载"><a href="#处理-Bootstrap-字体的加载" class="headerlink" title="处理 Bootstrap 字体的加载"></a>处理 Bootstrap 字体的加载</h3><p>**重要(更新)**：webpack4后的 bootstrap 字体加载已经不能使用下面该方法，如何使用可以参考这篇博客：<a href="https://blog.csdn.net/hyt941026/article/details/82870466">webpack 4.X版本的简单使用(处理js/css/less/scss/url(图片)/字体文件)</a></p>
<blockquote>
<p>预备工作：</p>
<p>index.html 写入</p>
<p>来展示字体图片</p>
<p>main.js 导入 import ‘bootstrap/dist/css/bootstrap.css’</p>
<p>此时报错</p>
</blockquote>
<p>在 <code>webpack.config.js</code> 中添加处理字体文件的 loader 模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(ttf|eot|svg|woff|woff2)$/</span>,</span><br><span class="line">    use: <span class="string">&#x27;url-loader&#x27;</span></span><br><span class="line">&#125;, <span class="comment">// 处理 字体文件的 loader</span></span><br></pre></td></tr></table></figure>

<h3 id="提取css文件（插件！）"><a href="#提取css文件（插件！）" class="headerlink" title="提取css文件（插件！）"></a>提取css文件（插件！）</h3><p>先安装 mini-css-extract-plugin 包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure>

<p>然后在 <code>webpack.config.js</code> 中修改对css文件处理的配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提取css</span></span><br><span class="line"><span class="keyword">var</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>)</span><br><span class="line"></span><br><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            process.env.NODE_ENV === <span class="string">&#x27;development&#x27;</span> ? <span class="string">&#x27;style-loader&#x27;</span> : MiniCssExtractPlugin.loader,</span><br><span class="line">            <span class="string">&#x27;css-loader&#x27;</span>] <span class="comment">//处理css</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        filename: <span class="string">&#x27;style.css&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="添加浏览器css前缀"><a href="#添加浏览器css前缀" class="headerlink" title="添加浏览器css前缀"></a>添加浏览器css前缀</h3><p>首先下载 loader ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i postcss-loader autoprefixer -D</span><br></pre></td></tr></table></figure>

<p>然后根目录添加 <code>postcss.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: &#123;</span><br><span class="line">        <span class="string">&#x27;autoprefixer&#x27;</span>: &#123;</span><br><span class="line">            browsers: <span class="string">&#x27;last 5 version&#x27;</span> <span class="comment">// 代表意思为每个主流浏览器的最后5个版本</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在 <code>webpack.config.js</code> 中添加配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            process.env.NODE_ENV === <span class="string">&#x27;development&#x27;</span> ? <span class="string">&#x27;style-loader&#x27;</span> : MiniCssExtractPlugin.loader,</span><br><span class="line">            &#123;</span><br><span class="line">                loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    importLoaders: <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;postcss-loader&quot;</span></span><br><span class="line">        ] <span class="comment">//处理css</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="使用-babel-处理高级-JS-语法"><a href="#使用-babel-处理高级-JS-语法" class="headerlink" title="使用 babel 处理高级 JS 语法"></a>使用 babel 处理高级 JS 语法</h3><ol>
<li><p>在 main.js 文件中添加 ES6 代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class 关键字，是ES6中提供的新语法，是用来 实现 ES6 中面向对象编程的方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 static 关键字，可以定义静态属性</span></span><br><span class="line">    <span class="comment">// 所谓的静态属性，就是 可以直接通过 类名， 直接访问的属性</span></span><br><span class="line">    <span class="comment">// 实例属性： 只能通过类的实例，来访问的属性，叫做实例属性</span></span><br><span class="line">    <span class="keyword">static</span> info = &#123;</span><br><span class="line">        name: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">        age: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问 Person 类身上的  info 静态属性</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.info)</span><br><span class="line"><span class="comment">// 在 webpack 中，默认只能处理 一部分 ES6 的新语法，一些更高级的ES6语法或者 ES7 语法，webpack 是处理不了的；这时候，就需要 借助于第三方的 loader，来帮助webpack 处理这些高级的语法，当第三方loader 把 高级语法转为 低级的语法之后，会把结果交给 webpack 去打包到 bundle.js 中</span></span><br><span class="line"><span class="comment">// 通过 Babel ，可以帮我们将 高级的语法转换为 低级的语法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行如下两套命令，安装两套包，去安装 Babel 相关的loader功能：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 【相当于转换工具】</span><br><span class="line">npm i -D @babel/core babel-loader @babel/plugin-transform-runtime @babel/runtime @babel/plugin-proposal-class-properties</span><br><span class="line">// 【相当于字典】</span><br><span class="line">npm i -D @babel/preset-env</span><br><span class="line"></span><br><span class="line">// =====&gt; 「转换工具」根据「字典」将 es6 转换</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开 webpack 的配置文件，在 module 节点下的 rules 数组中，添加一个新的匹配规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    use: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">&#125; <span class="comment">// 配置 Babel 来转换高级的ES语法</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.2</p>
<p>注意： 在配置 babel 的 loader 规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉：原因有俩：</p>
<p>2.2.1</p>
<p>如果 不排除 node_modules， 则Babel 会把 node_modules 中所有的 第三方 JS 文件，都打包编译，这样，会非常消耗CPU，同时，打包速度非常慢；</p>
<p>2.2.2</p>
<p>哪怕，最终，Babel 把 所有 node_modules 中的JS转换完毕了，但是，项目也无法正常运行！</p>
</blockquote>
</li>
<li><p>在项目的根目录中，新建一个叫做 <code>.babelrc</code> 的 Babel 配置文件，这个配置文件，属于 JSON 格式，所以，在写 <code>.babelrc</code> 配置的时候，必须符合 JSON 语法规范： 不能写注释，字符串必须用双引号：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">        [<span class="string">&quot;@babel/preset-env&quot;</span>, &#123;</span><br><span class="line">            <span class="string">&quot;modules&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;targets&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;browsers&quot;</span>: [<span class="string">&quot;&gt; 1%&quot;</span>, <span class="string">&quot;last 2 versions&quot;</span>, <span class="string">&quot;not ie &lt;= 8&quot;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span></span><br><span class="line">        &#125;]</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="webpack-config-js配置遇到Error-Cannot-find-module-‘-babel-core’问题"><a href="#webpack-config-js配置遇到Error-Cannot-find-module-‘-babel-core’问题" class="headerlink" title="webpack.config.js配置遇到Error: Cannot find module ‘@babel/core’问题"></a><a href="https://www.cnblogs.com/soyxiaobi/p/9554565.html">webpack.config.js配置遇到Error: Cannot find module ‘@babel/core’问题</a></h4><blockquote>
<p><strong>官方默认babel-loader | babel 对应的版本需要一致: 即babel-loader需要搭配最新版本babel</strong></p>
</blockquote>
<p>两种解决方案:</p>
<ol>
<li>回退低版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -D babel-loader@7 babel-core babel-preset-env</span><br></pre></td></tr></table></figure>

<ol>
<li>更新到最高版本:</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -D babel-loader @babel/core @babel/preset-env webpack</span><br></pre></td></tr></table></figure>

<h2 id="压缩和优化css文件"><a href="#压缩和优化css文件" class="headerlink" title="压缩和优化css文件"></a>压缩和优化css文件</h2><p>下载 <code>optimize-css-assets-webpack-plugin</code> 插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i optimize-css-assets-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p>在 <code>webpack.config.js</code> 中引入插件并添加配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 压缩css</span></span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;</span><br><span class="line">        assetNameRegExp: <span class="regexp">/\.css$/g</span>, <span class="comment">//一个正则表达式，指示应优化/最小化的资产的名称。提供的正则表达式针对配置中ExtractTextPlugin实例导出的文件的文件名运行，而不是源CSS文件的文件名。默认为/\.css$/g</span></span><br><span class="line">        cssProcessor: <span class="built_in">require</span>(<span class="string">&#x27;cssnano&#x27;</span>), <span class="comment">//用于优化\最小化CSS的CSS处理器，默认为cssnano</span></span><br><span class="line">        cssProcessorOptions: &#123;</span><br><span class="line">            safe: <span class="literal">true</span>,</span><br><span class="line">            discardComments: &#123;</span><br><span class="line">                removeAll: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="comment">//传递给cssProcessor的选项，默认为&#123;&#125;</span></span><br><span class="line">        canPrint: <span class="literal">true</span> <span class="comment">//一个布尔值，指示插件是否可以将消息打印到控制台，默认为true</span></span><br><span class="line">    &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="压缩和优化js文件"><a href="#压缩和优化js文件" class="headerlink" title="压缩和优化js文件"></a>压缩和优化js文件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add webpack-parallel-uglify-plugin -D</span><br><span class="line"><span class="keyword">const</span> WebpackParallelUglifyPlugin = <span class="built_in">require</span>(<span class="string">&#x27;webpack-parallel-uglify-plugin&#x27;</span>)</span><br><span class="line">plugins: [</span><br><span class="line"><span class="keyword">new</span> WebpackParallelUglifyPlugin(&#123;</span><br><span class="line">      uglifyJS: &#123;</span><br><span class="line">        output: &#123;</span><br><span class="line">          beautify: <span class="literal">false</span>, <span class="comment">//不需要格式化</span></span><br><span class="line">          comments: <span class="literal">false</span> <span class="comment">//不保留注释</span></span><br><span class="line">        &#125;,</span><br><span class="line">        compress: &#123;</span><br><span class="line">          warnings: <span class="literal">false</span>, <span class="comment">// 在UglifyJs删除没有用到的代码时不输出警告</span></span><br><span class="line">          drop_console: <span class="literal">true</span>, <span class="comment">// 删除所有的 `console` 语句，可以兼容ie浏览器</span></span><br><span class="line">          collapse_vars: <span class="literal">true</span>, <span class="comment">// 内嵌定义了但是只用到一次的变量</span></span><br><span class="line">          reduce_vars: <span class="literal">true</span> <span class="comment">// 提取出出现多次但是没有定义成变量去引用的静态值</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="提取公共文件"><a href="#提取公共文件" class="headerlink" title="提取公共文件"></a>提取公共文件</h2><p>我们可看到 <code>src/js/a.js</code> 和 <code>src/main.js</code> 都引入了 <code>src/js/b.js</code> 文件，为什么要提取公共代码，简单来说，就是减少代码冗余，提高加载速度。和之前的 webpack 配置不一样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//之前配置</span></span><br><span class="line"><span class="comment">// new webpack.optimize.SplitChunksPlugin(&#123;</span></span><br><span class="line"><span class="comment">//     name: &#x27;common&#x27;, // 如果还要提取公共代码,在新建一个实例</span></span><br><span class="line"><span class="comment">//     minChunks: 2, //重复两次之后就提取出来</span></span><br><span class="line"><span class="comment">//     chunks: [&#x27;index&#x27;, &#x27;a&#x27;] // 指定提取范围</span></span><br><span class="line"><span class="comment">// &#125;),</span></span><br><span class="line"><span class="comment">//现在配置</span></span><br><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">        cacheGroups: &#123;</span><br><span class="line">            commons: &#123;  <span class="comment">// 抽离自己写的公共代码</span></span><br><span class="line">                chunks: <span class="string">&quot;initial&quot;</span>,</span><br><span class="line">                name: <span class="string">&quot;common&quot;</span>, <span class="comment">// 打包后的文件名，任意命名</span></span><br><span class="line">                minChunks: <span class="number">2</span>,<span class="comment">//最小引用2次</span></span><br><span class="line">                minSize: <span class="number">0</span> <span class="comment">// 只要超出0字节就生成一个新包</span></span><br><span class="line">            &#125;,</span><br><span class="line">            vendor: &#123;   <span class="comment">// 抽离第三方插件</span></span><br><span class="line">                test: <span class="regexp">/node_modules/</span>,   <span class="comment">// 指定是node_modules下的第三方包</span></span><br><span class="line">                chunks: <span class="string">&#x27;initial&#x27;</span>,</span><br><span class="line">                name: <span class="string">&#x27;vendor&#x27;</span>,  <span class="comment">// 打包后的文件名，任意命名</span></span><br><span class="line">                <span class="comment">// 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包</span></span><br><span class="line">                priority: <span class="number">10</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="Source-Maps-调试配置"><a href="#Source-Maps-调试配置" class="headerlink" title="Source Maps 调试配置"></a>Source Maps 调试配置</h2><p>作为开发，代码调试当然少不了，那么问题来了，经过打包后的文件，你是不容易找到出错的地方的，<code>Source Map</code>就是用来解决这个问题的。</p>
<p>通过如下配置，我们会在打包时生成对应于打包文件的 <code>.map</code> 文件，使得编译后的代码可读性更高，更易于调试。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    devtool: <span class="string">&#x27;source-map&#x27;</span> <span class="comment">// 会生成对于调试的完整的.map文件，但同时也会减慢打包速度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置好后，我们再次运行 <code>npm run build</code> 进行打包，这时我们会发现在 <code>dist</code> 文件夹中多出了一个 <code>bundle.js.map</code></p>
<p>如果我们的代码有 bug ，在浏览器的调试工具中会提示错误出现的位置，这就是 <code>devtool: &#39;source-map&#39;</code> 配置项的作用。</p>
<h2 id="开发环境-VS-生产环境"><a href="#开发环境-VS-生产环境" class="headerlink" title="开发环境 VS 生产环境"></a>开发环境 VS 生产环境</h2><h3 id="npm-run-dev"><a href="#npm-run-dev" class="headerlink" title="npm run dev"></a>npm run dev</h3><p><strong>npm run dev</strong> 是我们开发环境下打包的文件，当然由于 devServer 帮我们把文件放到内存中了，所以并不会输出打包后的 dist 文件夹。</p>
<h3 id="npm-run-build"><a href="#npm-run-build" class="headerlink" title="npm run build"></a>npm run build</h3><p>通过 <strong>npm run build</strong> 之后会生成一个dist目录文件夹，里面有我们打包后的文件。</p>
<h2 id="清理-dist文件夹-CleanwebpackPlugin"><a href="#清理-dist文件夹-CleanwebpackPlugin" class="headerlink" title="清理/dist文件夹(CleanwebpackPlugin)"></a>清理<code>/dist</code>文件夹(CleanwebpackPlugin)</h2><p>你可能已经注意到，在我们删掉 <code>/dist</code> 文件夹之前，由于前面的代码示例遗留，导致我们的 <code>/dist</code> 文件夹比较杂乱。<code>webpack</code> 会生成文件，然后将这些文件放置在 <code>/dist</code> 文件夹中，但是 <code>webpack</code> 无法追踪到哪些文件是实际在项目中用到的。</p>
<p>通常，在每次构建前清理 <code>/dist</code> 文件夹，是比较推荐的做法，因此只会生成用到的文件，这时候就用到 <code>CleanWebpackPlugin</code> 插件了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i clean-webpack-plugin -D</span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>); <span class="comment">// 引入CleanWebpackPlugin插件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    plugins: [</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),  <span class="comment">// 以前括号里面要传入数组([dist])来指定要删除的目录，新版 CleanWebpackPlugin 不需要传任何参数了</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插件的使用方法都是一样的，首先引入，然后new一个实例，实例可传入参数。</p>
<p>现在我们运行 <code>npm run build</code> 后就会发现，webpack 会先将 <code>/dist</code> 文件夹删除，然后再生产新的 <code>/dist</code> 文件夹。</p>
<h2 id="webpack4-x-相关资源"><a href="#webpack4-x-相关资源" class="headerlink" title="webpack4.x 相关资源"></a>webpack4.x 相关资源</h2><ul>
<li><strong><a href="https://www.cnblogs.com/BetterMan-/p/9867642.html">webpack4.x最详细入门讲解</a></strong></li>
<li><a href="https://segmentfault.com/a/1190000018866232">从基础到实战 手摸手带你掌握新版Webpack4.0详解 教你看文档</a></li>
</ul>
<h2 id="webpack3-与-webpack4-使用差异"><a href="#webpack3-与-webpack4-使用差异" class="headerlink" title="webpack3 与 webpack4 使用差异"></a>webpack3 与 webpack4 使用差异</h2><ul>
<li><a href="https://blog.csdn.net/u012443286/article/details/79504289">webpack4.x开发环境配置</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云云服务器ECS购买与使用（笔记）</title>
    <url>/posts/40394/</url>
    <content><![CDATA[<h2 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h2><p>进入阿里云下拉菜单选择 ecs ：</p>
<img src="/posts/40394/ecs_config.png" class="" title="ecs_config">

<p>我购买的配置如下：</p>
<img src="/posts/40394/ecs_config.png" class="" title="ecs_config">

<p>购买后实例就运行了，远程连接后安装一系列包和软件：</p>
<h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><p><a href="https://www.cnblogs.com/87hbteo/p/7802104.html">阿里云服务器 ECS LAMP 环境安装（Ubuntu）</a><br><a href="https://blog.csdn.net/KascLiyuan/article/details/73438093">阿里云 ECS 云服务器外网 IP 无法访问</a></p>
<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p><a href="https://jingyan.baidu.com/article/48b558e3f25e6d7f38c09aec.html">阿里云如何解析域名</a></p>
<a id="more"></a>

<h2 id="Github-Page-自定义域名"><a href="#Github-Page-自定义域名" class="headerlink" title="Github Page 自定义域名"></a>Github Page 自定义域名</h2><ul>
<li><a href="https://www.jianshu.com/p/8ac6c7c037c5">创建 Github Page 并设置自定义域名</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/github-pages-basics/cname-file.html">添加 CNAME 文件到你的存储库中</a></li>
</ul>
<h2 id="Ubuntu-安装-nodejs"><a href="#Ubuntu-安装-nodejs" class="headerlink" title="Ubuntu 安装 nodejs"></a>Ubuntu 安装 nodejs</h2><ul>
<li><a href="https://evestorm.github.io/posts/58410/%E9%98%BF%E9%87%8C%E4%BA%91Ubuntu%E6%90%AD%E5%BB%BANodeJs%E7%8E%AF%E5%A2%83">https://blog.5udou.cn/blog/A-Li-Yun-UbuntuDa-Jian-NodeJsHuan-Jing-75</a></li>
</ul>
<h2 id="ubuntu-图形界面下无法用-root-登录解决办法"><a href="#ubuntu-图形界面下无法用-root-登录解决办法" class="headerlink" title="ubuntu 图形界面下无法用 root 登录解决办法"></a>ubuntu 图形界面下无法用 root 登录解决办法</h2><p>先按照 <a href="https://www.linuxidc.com/Linux/2017-01/139094.htm">这个教程</a> 走，但最后不重启。然后转到 <a href="https://blog.csdn.net/qq_39591507/article/details/81288644">这个教程</a>，执行第三步，也就是下面这段：</p>
<blockquote>
<p>进入/etc/pam.d 文件夹下，修改 gdm-autologin 和 gdm-passwd 文件内容(首先修改文件权限，参考步骤 2 的操作)</p>
<p>gdm-autologin 文件注释掉 auth required pam_success_if.so user!=root quiet_success 这一行</p>
<p>gdm-passwd 文件注释掉 auth required pam_success_if.so user!=root quiet_success 这一行</p>
</blockquote>
<p>做完后重启然后点击登录其他用户，输入 root 和密码 root（这个密码在上面第一个教程中已经自己设置了）就好。</p>
<h2 id="安装-LAMP-环境"><a href="#安装-LAMP-环境" class="headerlink" title="安装 LAMP 环境"></a>安装 LAMP 环境</h2><p><a href="https://blog.csdn.net/qq_27366789/article/details/81990291">在 ubuntu16.04 中一键创建 LAMP 环境</a></p>
<h3 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h3><ul>
<li>退出 mysql 命令行：<code>exit</code></li>
<li>vi 编辑文件 按下 i 表示编辑 按下 esc 退出编辑模式 按下 <code>:wq</code> 保存退出</li>
</ul>
<h3 id="mysql-操作"><a href="#mysql-操作" class="headerlink" title="mysql 操作"></a>mysql 操作</h3><p>登录 mysql -u root -p</p>
<p>-u 表示选择登陆的用户名， -p 表示登陆的用户密码，现在是 mysql 数据库是没有密码的，Enter password:处直接回车，就能够进入 mysql 数据库。</p>
<h4 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h4><p><a href="https://blog.csdn.net/hewenjing8168/article/details/80821447">ubuntu 下 mysql 数据库的导入导出</a></p>
<h2 id="安装-图形化-mysql-workbench"><a href="#安装-图形化-mysql-workbench" class="headerlink" title="安装 图形化 mysql-workbench"></a>安装 图形化 mysql-workbench</h2><p><a href="https://blog.csdn.net/qq_37638061/article/details/80246799">安装 mysql 服务，及安装图形化管理界面</a></p>
<h2 id="打开-mysql-图形化后无法连接数据库"><a href="#打开-mysql-图形化后无法连接数据库" class="headerlink" title="打开 mysql 图形化后无法连接数据库"></a>打开 mysql 图形化后无法连接数据库</h2><p><a href="https://blog.csdn.net/chexiansheng/article/details/89193955">Unbuntu 下 Mysql 连接 MysqlWorkBench 出现错误</a></p>
<h2 id="在-ubuntu-下搭建-ftp-服务器"><a href="#在-ubuntu-下搭建-ftp-服务器" class="headerlink" title="在 ubuntu 下搭建 ftp 服务器"></a>在 ubuntu 下搭建 ftp 服务器</h2><ul>
<li><a href="https://www.howtoing.com/how-to-set-up-vsftpd-for-a-user-s-directory-on-ubuntu-18-04">如何在 Ubuntu 18.04 上为用户目录设置 vsftpd</a><br>执行完上面操作后，会发现下面两个问题，按方法调整就好：</li>
<li><a href="https://blog.51cto.com/zhkao/1758125">使用 FileZilla FTP 下载时提示“不安全的服务器，不支持 FTPover TLS”,和“服务器不支持非 ASCII 字符”</a></li>
<li><a href="https://blog.csdn.net/wbryfl/article/details/82729189">ftp 连接错误——服务器发回了不可路由的地址。使用服务器地址代替。</a></li>
</ul>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>FTP 是文件传输协议的缩写，是一种曾经广泛用于在客户端和服务器之间移动文件的网络协议。 它已被更快，更安全，更方便的文件传输方式所取代。 许多休闲互联网用户希望通过<code>https</code>直接从他们的网络浏览器下载，命令行用户更有可能使用安全协议，如<code>scp</code>或<a href="https://www.howtoing.com/how-to-use-sftp-to-securely-transfer-files-with-a-remote-server/">SFTP</a> 。</p>
<p>FTP 仍然用于支持具有特定需求的遗留应用程序和工作流。 如果您可以选择使用哪种协议，请考虑探索更现代的选项。 但是，当您确实需要 FTP 时，vsftpd 是一个很好的选择。 vsftpd 针对安全性，性能和稳定性进行了优化，可以很好地防范其他 FTP 服务器中存在的许多安全问题，并且是许多 Linux 发行版的默认设置。</p>
<p>在本教程中，您将配置 vsftpd 以允许用户使用具有 SSL / TLS 保护的登录凭据的 FTP 将文件上载到其主目录。</p>
<h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>要学习本教程，您需要：</p>
<ul>
<li><strong>Ubuntu 18.04 服务器和具有 sudo 权限的非 root 用户</strong> ：您可以在<a href="https://www.howtoing.com/initial-server-setup-with-ubuntu-18-04/">使用 Ubuntu 18.04</a>指南的<a href="https://www.howtoing.com/initial-server-setup-with-ubuntu-18-04/">初始服务器设置中</a>了解有关如何使用这些权限设置用户的更多信息。</li>
</ul>
<h3 id="第-1-步-安装-vsftpd"><a href="#第-1-步-安装-vsftpd" class="headerlink" title="第 1 步 - 安装 vsftpd"></a>第 1 步 - 安装 vsftpd</h3><p>让我们首先更新我们的包列表并安装<code>vsftpd</code>守护进程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install vsftpd</span><br></pre></td></tr></table></figure>

<p>安装完成后，让我们复制配置文件，这样我们就可以从空白配置开始，将原件保存为备份：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/vsftpd.conf /etc/vsftpd.conf.orig</span><br></pre></td></tr></table></figure>

<p>通过备份配置，我们已准备好配置防火墙。</p>
<h3 id="第-2-步-打开防火墙"><a href="#第-2-步-打开防火墙" class="headerlink" title="第 2 步 - 打开防火墙"></a>第 2 步 - 打开防火墙</h3><p><strong>注意：</strong> 最后我们还得打开 80 和 8080 端口！！！</p>
<p>让我们检查防火墙状态以查看它是否已启用。 如果是，我们将确保允许 FTP 流量，因此防火墙规则不会阻止我们的测试。</p>
<p>检查防火墙状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure>

<p>在这种情况下，只允许 SSH 通过：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">OutputStatus: active</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">OpenSSH                    ALLOW       Anywhere</span><br><span class="line">OpenSSH (v6)               ALLOW       Anywhere (v6)</span><br></pre></td></tr></table></figure>

<p>您可能有其他规则或根本没有防火墙规则。 由于在这种情况下只允许 SSH 流量，因此我们需要为 FTP 流量添加规则。</p>
<p>让我们打开端口<code>20</code>和<code>21</code>用于 FTP，端口<code>990</code>用于启用 TLS，端口<code>40000-50000</code>用于我们计划在配置文件中设置的被动端口范围：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 20/tcp</span><br><span class="line">sudo ufw allow 21/tcp</span><br><span class="line">sudo ufw allow 990/tcp</span><br><span class="line">sudo ufw allow 40000:50000/tcp</span><br><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure>

<p>我们的防火墙规则现在应如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">OutputStatus: active</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">OpenSSH                    ALLOW       Anywhere</span><br><span class="line">990/tcp                    ALLOW       Anywhere</span><br><span class="line">20/tcp                     ALLOW       Anywhere</span><br><span class="line">21/tcp                     ALLOW       Anywhere</span><br><span class="line">40000:50000/tcp            ALLOW       Anywhere</span><br><span class="line">OpenSSH (v6)               ALLOW       Anywhere (v6)</span><br><span class="line">20/tcp (v6)                ALLOW       Anywhere (v6)</span><br><span class="line">21/tcp (v6)                ALLOW       Anywhere (v6)</span><br><span class="line">990/tcp (v6)               ALLOW       Anywhere (v6)</span><br><span class="line">40000:50000/tcp (v6)       ALLOW       Anywhere (v6)</span><br></pre></td></tr></table></figure>

<p>p.s. 如何删除一个 rule：<code>sudo ufw delete allow 80/tcp</code></p>
<p>安装了<code>vsftpd</code>并打开了必要的端口后，我们继续创建一个专用的 FTP 用户。</p>
<h3 id="第-3-步-准备用户目录"><a href="#第-3-步-准备用户目录" class="headerlink" title="第 3 步 - 准备用户目录"></a>第 3 步 - 准备用户目录</h3><p>我们将创建一个专用的 FTP 用户，但您可能已经有一个需要 FTP 访问的用户。 我们将注意保留现有用户对以下说明中的数据的访问权限。 即便如此，我们建议您在配置和测试设置之前先与新用户联系。</p>
<p>首先，添加一个测试用户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo adduser sammy</span><br></pre></td></tr></table></figure>

<p>出现提示时分配密码。 随意通过其他提示按<code>ENTER</code> 。</p>
<p>当用户被限制在特定目录时，FTP 通常更安全。 <code>vsftpd</code>用<a href="https://www.howtoing.com/how-to-configure-chroot-environments-for-testing-on-an-ubuntu-12-04-vps/#what-is-a-chroot-environment"><code>chroot</code></a> jails 完成了这个。 为本地用户启用<code>chroot</code> ，默认情况下它们仅限于其主目录。 但是，由于<code>vsftpd</code>保护目录的方式，用户不能写入。 这对于只应通过 FTP 连接的新用户来说很好，但如果现有用户也具有 shell 访问权限，则可能需要写入其主文件夹。</p>
<p>在这个例子中，不是从主目录中删除写权限，而是创建一个<code>ftp</code>目录作为<code>chroot</code>和一个可写<code>files</code>目录来保存实际文件。</p>
<p>创建<code>ftp</code>文件夹：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir /home/sammy/ftp</span><br></pre></td></tr></table></figure>

<p>设置所有权：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chown nobody:nogroup /home/sammy/ftp</span><br></pre></td></tr></table></figure>

<p>删除写权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod a-w /home/sammy/ftp</span><br></pre></td></tr></table></figure>

<p>验证权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ls -la /home/sammy/ftp</span><br><span class="line">Outputtotal 8</span><br><span class="line">4 dr-xr-xr-x  2 nobody nogroup 4096 Aug 24 21:29 .</span><br><span class="line">4 drwxr-xr-x  3 sammy  sammy   4096 Aug 24 21:29 ..</span><br></pre></td></tr></table></figure>

<p>接下来，让我们创建文件上传目录并为用户分配所有权：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir /home/sammy/ftp/files</span><br><span class="line">sudo chown sammy:sammy /home/sammy/ftp/files</span><br></pre></td></tr></table></figure>

<p>对<code>ftp</code>目录的权限检查应返回以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ls -la /home/sammy/ftp</span><br><span class="line">Outputtotal 12</span><br><span class="line">dr-xr-xr-x 3 nobody nogroup 4096 Aug 26 14:01 .</span><br><span class="line">drwxr-xr-x 3 sammy  sammy   4096 Aug 26 13:59 ..</span><br><span class="line">drwxr-xr-x 2 sammy  sammy   4096 Aug 26 14:01 files</span><br></pre></td></tr></table></figure>

<p>最后，让我们添加一个<code>test.txt</code>文件，以便在测试时使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;vsftpd test file&quot; | sudo tee /home/sammy/ftp/files/test.txt</span><br></pre></td></tr></table></figure>

<p>现在我们已经保护了<code>ftp</code>目录并允许用户访问<code>files</code>目录，让我们修改我们的配置。</p>
<h3 id="第-4-步-配置-FTP-访问"><a href="#第-4-步-配置-FTP-访问" class="headerlink" title="第 4 步 - 配置 FTP 访问"></a>第 4 步 - 配置 FTP 访问</h3><p>我们计划允许具有本地 shell 帐户的单个用户与 FTP 连接。 这两个关键设置已在<code>vsftpd.conf</code>设置。 首先打开配置文件，验证配置中的设置是否与以下设置相匹配：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/vsftpd.conf</span><br></pre></td></tr></table></figure>

<p>/etc/vsftpd.conf 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line"><span class="meta">#</span><span class="bash"> Allow anonymous FTP? (Disabled by default).</span></span><br><span class="line">anonymous_enable=NO</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Uncomment this to allow local users to log in.</span></span></span><br><span class="line">local_enable=YES</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<p>接下来，让我们通过取消注释<code>write_enable</code>设置来允许用户上传文件：</p>
<p>/etc/vsftpd.conf 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line">write_enable=YES</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<p>我们还将取消注释<code>chroot</code>以防止 FTP 连接的用户访问目录树之外的任何文件或命令：</p>
<p>/etc/vsftpd.conf 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line">chroot_local_user=YES</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<p>我们还添加一个<code>user_sub_token</code>以在<code>local_root directory</code>路径中插入用户名，这样我们的配置将适用于此用户和任何其他未来用户。 在文件中的任何位置添加这些设置：</p>
<p>/etc/vsftpd.conf 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line">user_sub_token=$USER</span><br><span class="line">local_root=/home/$USER/ftp</span><br></pre></td></tr></table></figure>

<p>我们还限制了可用于被动 FTP 的端口范围，以确保有足够的连接可用：</p>
<p>/etc/vsftpd.conf 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line">pasv_min_port=40000</span><br><span class="line">pasv_max_port=50000</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>在第 2 步中，我们打开了我们在此处为被动端口范围设置的端口。 如果更改值，请务必更新防火墙设置。</p>
<p>要根据具体情况允许 FTP 访问，让我们设置配置，以便用户只有在明确添加到列表时才能访问，而不是默认情况下：</p>
<p>/etc/vsftpd.conf 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line">userlist_enable=YES</span><br><span class="line">userlist_file=/etc/vsftpd.userlist</span><br><span class="line">userlist_deny=NO</span><br></pre></td></tr></table></figure>

<p><code>userlist_deny</code>切换逻辑：当它设置为<code>YES</code> ，列表中的用户被拒绝 FTP 访问。 当它设置为<code>NO</code> ，只允许列表中的用户访问。</p>
<p>完成更改后，保存文件并退出编辑器。</p>
<p>最后，让我们将用户添加到<code>/etc/vsftpd.userlist</code> 。 使用<code>-a</code>标志追加到文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;sammy&quot; | sudo tee -a /etc/vsftpd.userlist</span><br></pre></td></tr></table></figure>

<p>检查它是否按预期添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/vsftpd.userlist</span><br><span class="line">Outputsammy</span><br></pre></td></tr></table></figure>

<p>重新启动守护程序以加载配置更改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart vsftpd</span><br></pre></td></tr></table></figure>

<p>配置到位后，我们继续测试 FTP 访问。</p>
<h3 id="第-5-步-测试-FTP-访问"><a href="#第-5-步-测试-FTP-访问" class="headerlink" title="第 5 步 - 测试 FTP 访问"></a>第 5 步 - 测试 FTP 访问</h3><p>我们已将服务器配置为仅允许用户<code>sammy</code>通过 FTP 连接。 让我们确保它按预期工作。</p>
<p><strong>匿名用户应该无法连接</strong> ：我们已禁用匿名访问。 让我们通过尝试匿名连接来测试它。 如果我们的配置设置正确，则应拒绝匿名用户的权限。 请务必将<code>203.0.113.0</code>替换为服务器的公共 IP 地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ftp -p 203.0.113.0</span><br><span class="line">OutputConnected to 203.0.113.0.</span><br><span class="line">220 (vsFTPd 3.0.3)</span><br><span class="line">Name (203.0.113.0:default): anonymous</span><br><span class="line">530 Permission denied.</span><br><span class="line">ftp: Login failed.</span><br><span class="line"><span class="meta">ftp&gt;</span></span><br></pre></td></tr></table></figure>

<p>关闭连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bye</span><br></pre></td></tr></table></figure>

<p><strong>除了 sammy 之外的用户应该无法连接</strong> ：接下来，让我们尝试连接我们的 sudo 用户。 他们也应该被拒绝访问，并且应该在他们被允许输入密码之前发生：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ftp -p 203.0.113.0</span><br><span class="line">OutputConnected to 203.0.113.0.</span><br><span class="line">220 (vsFTPd 3.0.3)</span><br><span class="line">Name (203.0.113.0:default): sudo_user</span><br><span class="line">530 Permission denied.</span><br><span class="line">ftp: Login failed.</span><br><span class="line"><span class="meta">ftp&gt;</span></span><br></pre></td></tr></table></figure>

<p>关闭连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bye</span><br></pre></td></tr></table></figure>

<p><strong>用户 sammy 应该能够连接，读取和写入文件</strong> ：让我们确保我们的指定用户可以连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ftp -p 203.0.113.0</span><br><span class="line">OutputConnected to 203.0.113.0.</span><br><span class="line">220 (vsFTPd 3.0.3)</span><br><span class="line">Name (203.0.113.0:default): sammy</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password: your_user&#x27;s_password</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system type is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line"><span class="meta">ftp&gt;</span></span><br></pre></td></tr></table></figure>

<p>让我们切换到<code>files</code>目录并使用<code>get</code>命令将我们之前创建的测试文件传输到本地机器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd files</span><br><span class="line">get test.txt</span><br><span class="line">Output227 Entering Passive Mode (203,0,113,0,169,12).</span><br><span class="line">150 Opening BINARY mode data connection for test.txt (16 bytes).</span><br><span class="line">226 Transfer complete.</span><br><span class="line">16 bytes received in 0.0101 seconds (1588 bytes/s)</span><br><span class="line"><span class="meta">ftp&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下来，让我们使用新名称上传文件以测试写入权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">put test.txt upload.txt</span><br><span class="line">Output227 Entering Passive Mode (203,0,113,0,164,71).</span><br><span class="line">150 Ok to send data.</span><br><span class="line">226 Transfer complete.</span><br><span class="line">16 bytes sent in 0.000894 seconds (17897 bytes/s)</span><br></pre></td></tr></table></figure>

<p>关闭连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bye</span><br></pre></td></tr></table></figure>

<p>现在我们已经测试了我们的配置，让我们采取措施进一步保护我们的服务器。</p>
<h3 id="第-6-步-保护交易"><a href="#第-6-步-保护交易" class="headerlink" title="第 6 步 - 保护交易"></a>第 6 步 - 保护交易</h3><p>由于 FTP 不会加密传输中的任何数据，包括用户凭据，因此我们将启用 TLS / SSL 来提供加密。 第一步是创建用于<code>vsftpd</code>的 SSL 证书。</p>
<p>让我们使用<code>openssl</code>创建一个新证书，并使用<code>-days</code>标志使其有效一年。 在同一个命令中，我们将添加一个私有的 2048 位 RSA 密钥。 通过将<code>-keyout</code>和<code>-out</code>标志都设置为相同的值，私钥和证书将位于同一文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/vsftpd.pem -out /etc/ssl/private/vsftpd.pem</span><br></pre></td></tr></table></figure>

<p>系统将提示您提供证书的地址信息。 将您自己的信息替换为以下突出显示的值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">OutputGenerating a 2048 bit RSA private key</span><br><span class="line">............................................................................+++</span><br><span class="line">...........+++</span><br><span class="line">writing new private key to &#x27;/etc/ssl/private/vsftpd.pem&#x27;</span><br><span class="line">-----</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter &#x27;.&#x27;, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [AU]:US</span><br><span class="line">State or Province Name (full name) [Some-State]:NY</span><br><span class="line">Locality Name (eg, city) []:New York City</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:DigitalOcean</span><br><span class="line">Organizational Unit Name (eg, section) []:</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []: your_server_ip</span><br><span class="line">Email Address []:</span><br></pre></td></tr></table></figure>

<p>有关证书标志的更多详细信息，请参阅<a href="https://www.howtoing.com/openssl-essentials-working-with-ssl-certificates-private-keys-and-csrs/">OpenSSL Essentials：使用 SSL 证书，私钥和 CSR</a></p>
<p>创建证书后，再次打开<code>vsftpd</code>配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/vsftpd.conf</span><br></pre></td></tr></table></figure>

<p>在文件的底部，您将看到以<code>rsa_</code>开头的两行。 评论它们，看起来像这样：</p>
<p>/etc/vsftpd.conf 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line"><span class="meta">#</span><span class="bash"> rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key</span></span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<p>在它们下面，添加以下指向我们刚刚创建的证书和私钥的行：</p>
<p>/etc/vsftpd.conf 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line">rsa_cert_file=/etc/ssl/private/vsftpd.pem</span><br><span class="line">rsa_private_key_file=/etc/ssl/private/vsftpd.pem</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<p>之后，我们将强制使用 SSL，这将阻止无法处理 TLS 的客户端连接。 这对于确保所有流量都已加密是必要的，但它可能会强制您的 FTP 用户更改客户端。 将<code>ssl_enable</code>更改为<code>YES</code> ：</p>
<p>/etc/vsftpd.conf 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line">ssl_enable=YES</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<p>之后，添加以下行以显式拒绝 SSL 上的匿名连接，并要求 SSL 进行数据传输和登录：</p>
<p>/etc/vsftpd.conf 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line">allow_anon_ssl=NO</span><br><span class="line">force_local_data_ssl=YES</span><br><span class="line">force_local_logins_ssl=YES</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<p>在此之后，通过添加以下行将服务器配置为使用 TLS（SSL 的首选后继者）：</p>
<p>/etc/vsftpd.conf 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line">ssl_tlsv1=YES</span><br><span class="line">ssl_sslv2=NO</span><br><span class="line">ssl_sslv3=NO</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<p>最后，我们将添加两个选项。 首先，我们不会要求重用 SSL，因为它可能会破坏许多 FTP 客户端。 我们将需要“高”加密密码套件，目前这意味着密钥长度等于或大于 128 位：</p>
<p>/etc/vsftpd.conf 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line">require_ssl_reuse=NO</span><br><span class="line">ssl_ciphers=HIGH</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<p>完成的文件部分应如下所示：</p>
<p>/etc/vsftpd.conf 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This option specifies the location of the RSA certificate to use <span class="keyword">for</span> SSL</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> encrypted connections.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem</span></span><br><span class="line"><span class="meta">#</span><span class="bash">rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key</span></span><br><span class="line">rsa_cert_file=/etc/ssl/private/vsftpd.pem</span><br><span class="line">rsa_private_key_file=/etc/ssl/private/vsftpd.pem</span><br><span class="line">ssl_enable=YES</span><br><span class="line">allow_anon_ssl=NO</span><br><span class="line">force_local_data_ssl=YES</span><br><span class="line">force_local_logins_ssl=YES</span><br><span class="line">ssl_tlsv1=YES</span><br><span class="line">ssl_sslv2=NO</span><br><span class="line">ssl_sslv3=NO</span><br></pre></td></tr></table></figure>

<p>完成后，保存并关闭文件。</p>
<p>重新启动服务器以使更改生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart vsftpd</span><br></pre></td></tr></table></figure>

<p>此时，我们将无法再使用不安全的命令行客户端进行连接。 如果我们尝试过，我们会看到类似的东西：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ftp -p 203.0.113.0</span><br><span class="line">Connected to 203.0.113.0.</span><br><span class="line">220 (vsFTPd 3.0.3)</span><br><span class="line">Name (203.0.113.0:default): sammy</span><br><span class="line">530 Non-anonymous sessions must use encryption.</span><br><span class="line">ftp: Login failed.</span><br><span class="line">421 Service not available, remote server has closed connection</span><br><span class="line"><span class="meta">ftp&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下来，让我们验证我们是否可以使用支持 TLS 的客户端进行连接。</p>
<h3 id="第-7-步-使用-FileZilla-测试-TLS"><a href="#第-7-步-使用-FileZilla-测试-TLS" class="headerlink" title="第 7 步 - 使用 FileZilla 测试 TLS"></a>第 7 步 - 使用 FileZilla 测试 TLS</h3><p>大多数现代 FTP 客户端都可以配置为使用 TLS 加密。 我们将演示如何与<a href="https://filezilla-project.org/">FileZilla</a>连接，因为它支持跨平台。 请参阅其他客户的文档。</p>
<p>首次打开 FileZilla 时，在主页上方找到站点管理器图标，这是最上一行最左侧的图标。 点击它：</p>
<img src="/posts/40394/filezilla_site_manager_vsftpd_18_04.png" class="" title="filezilla_site_manager_vsftpd_18_04">

<p>将打开一个新窗口。 单击右下角的“ <strong>新建站点”</strong>按钮：</p>
<img src="/posts/40394/new-site.png" class="" title="new-site">

<p>在“ <strong>我的网站”</strong>下，将出现一个带有“ <strong>新网站</strong> ”字样的新图标。 您可以立即命名或稍后返回并使用“ <strong>重命名”</strong>按钮。</p>
<p>使用名称或 IP 地址填写<strong>主机</strong>字段。 在“ <strong>加密”</strong>下拉菜单下，选择“ <strong>要求显式 FTP over TLS”</strong> 。</p>
<p>对于<strong>登录类型</strong> ，选择<strong>询问密码</strong> 。 在“ <strong>用户”</strong>字段中填写您的 FTP 用户：</p>


<p>单击界面底部的“连接”。 系统将要求您输入用户密码：</p>
<img src="/posts/40394/user-pass.png" class="" title="密码对话">

<p>单击<strong>确定</strong>以进行连接。 您现在应该使用 TLS / SSL 加密与您的服务器连接。</p>
<p>成功后，您将看到一个如下所示的服务器证书：</p>
<img src="/posts/40394/filezilla_certificate_vsftpd_three.png" class="" title="filezilla_certificate_vsftpd_three">

<p>当您接受证书后，双击<code>files</code>夹并将<code>upload.txt</code>拖到左侧以确认您能够下载文件：</p>
<p><a href="https://www.howtoing.com/wp-content/uploads/articles/vsftpd_18_04/vsftpd_images/filezilla_file_test_vsftpd_18_04.png"><img src="%E9%98%BF%E9%87%8C%E4%BA%91%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS%E8%B4%AD%E4%B9%B0%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/filezilla_file_test_vsftpd_18_04.png" alt="下载test.txt"></a></p>
<img src="/posts/40394/filezilla_file_test_vsftpd_18_04.png" class="" title="下载test.txt">

<p>完成后，右键单击本地副本，将其重命名为<code>upload-tls.txt</code>并将其拖回服务器以确认您可以上传文件：</p>
<img src="/posts/40394/filezilla_file_upload_vsftpd_18_04.png" class="" title="重命名和上传">

<p>您现在已确认可以安全地成功传输启用了 SSL / TLS 的文件。</p>
<h3 id="第-8-步-禁用-Shell-访问（可选）"><a href="#第-8-步-禁用-Shell-访问（可选）" class="headerlink" title="第 8 步 - 禁用 Shell 访问（可选）"></a>第 8 步 - 禁用 Shell 访问（可选）</h3><p>如果由于客户端要求而无法使用 TLS，则可以通过禁用 FTP 用户以任何其他方式登录的方式来获得一些安全性。 防止它的一种相对简单的方法是创建一个自定义 shell。 这不会提供任何加密，但会限制受感染帐户对 FTP 可访问的文件的访问。</p>
<p>首先，在<code>bin</code>目录中打开一个名为<code>ftponly</code>的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /bin/ftponly</span><br></pre></td></tr></table></figure>

<p>添加一条消息，告诉用户他们无法登录的原因：</p>
<p>/斌/ ftponly</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">echo &quot;This account is limited to FTP access only.&quot;</span><br></pre></td></tr></table></figure>

<p>保存文件并退出编辑器。</p>
<p>更改权限以使文件可执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod a+x /bin/ftponly</span><br></pre></td></tr></table></figure>

<p>打开有效 shell 列表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/shells</span><br></pre></td></tr></table></figure>

<p>在底部添加：</p>
<p>/ etc / shells 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line">/bin/ftponly</span><br></pre></td></tr></table></figure>

<p>使用以下命令更新用户的 shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo usermod sammy -s /bin/ftponly</span><br></pre></td></tr></table></figure>

<p>现在尝试以<code>sammy</code>身份登录您的服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh sammy@your_server_ip</span><br></pre></td></tr></table></figure>

<p>你应该看到类似的东西：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">OutputThis account is limited to FTP access only.</span><br><span class="line">Connection to 203.0.113.0 closed.</span><br></pre></td></tr></table></figure>

<p>这确认用户不能再<code>ssh</code>到服务器并且仅限于 FTP 访问。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在本教程中，我们介绍了为具有本地帐户的用户设置 FTP。 如果您需要使用外部身份验证源，您可能需要了解<code>vsftpd</code>对虚拟用户的支持。 这通过使用 PAM（可插入身份验证模块）提供了丰富的选项，如果您管理其他系统（如 LDAP 或 Kerberos）中的用户，这是一个不错的选择。</p>
<h3 id="执行完上面操作后的问题解决"><a href="#执行完上面操作后的问题解决" class="headerlink" title="执行完上面操作后的问题解决"></a>执行完上面操作后的问题解决</h3><h4 id="使用-FileZilla-FTP-下载时提示“不安全的服务器，不支持-FTPover-TLS”-和“服务器不支持非-ASCII-字符”"><a href="#使用-FileZilla-FTP-下载时提示“不安全的服务器，不支持-FTPover-TLS”-和“服务器不支持非-ASCII-字符”" class="headerlink" title="使用 FileZilla FTP 下载时提示“不安全的服务器，不支持 FTPover TLS”,和“服务器不支持非 ASCII 字符”"></a>使用 FileZilla FTP 下载时提示“不安全的服务器，不支持 FTPover TLS”,和“服务器不支持非 ASCII 字符”</h4><p>1、提示“不安全的服务器，不支持 FTPover TLS</p>
<p>解决方法：在站点管理器中，加密方式选择：</p>


<p>2、提示“服务器不支持非 ASCII 字符”</p>
<p>解决方法：在站点管理器中字符集选择：自定义字符集：GBK</p>
<img src="/posts/40394/wKiom1b6SWvwBjm7AAA9pZvVBTE386.png" class="" title="wKiom1b6SWvwBjm7AAA9pZvVBTE386">

<p>OK,正常了</p>
<h4 id="ftp-连接错误——服务器发回了不可路由的地址。使用服务器地址代替。"><a href="#ftp-连接错误——服务器发回了不可路由的地址。使用服务器地址代替。" class="headerlink" title="ftp 连接错误——服务器发回了不可路由的地址。使用服务器地址代替。"></a>ftp 连接错误——服务器发回了不可路由的地址。使用服务器地址代替。</h4><p>设置 filezilla 客户端的连接参数</p>
<ol>
<li>选中某一连接项</li>
<li>高级——加密——只使用普通 ftp</li>
<li>传输设置——传输模式——主动</li>
<li>重新连接</li>
</ol>
<h2 id="ubuntu-下-Apache-虚拟站点配置"><a href="#ubuntu-下-Apache-虚拟站点配置" class="headerlink" title="ubuntu 下 Apache 虚拟站点配置"></a>ubuntu 下 Apache 虚拟站点配置</h2><p><a href="https://www.linuxidc.com/Linux/2017-05/143590.htm">https://www.linuxidc.com/Linux/2017-05/143590.htm</a></p>
<h2 id="apache-配置二级域名"><a href="#apache-配置二级域名" class="headerlink" title="apache 配置二级域名"></a>apache 配置二级域名</h2><p>[apache2 服务器 mod_rewrite 模块 开启方法<a href="https://www.cnblogs.com/wwufengg/articles/apache2-mod_rewrite.html">linux, ubuntu]</a></p>
<p>开启重写，p.s. 上面教程中说要把 <code>/etc/apache2/sites-enabled/000-default</code> 中的 <code>AllowOverride None 修改为： AllowOverride All</code> ，然而我的 Apache2 是新版（2.4），所以得转到 <code>/etc/apache2/</code> 。将名为 <code>apache2.conf</code> 的文件中的 <a href="http://www.kbase101.com/question/9571.html">下面代码从 NONE 改为 ALL</a> ：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Directory</span> /<span class="attr">var</span>/<span class="attr">www</span>/&gt;</span></span><br><span class="line">    Options Indexes FollowSymLinks</span><br><span class="line">    AllowOverride All</span><br><span class="line">    Require all granted</span><br><span class="line"><span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>目标二级域名：mall.evelance.cn</p>
<p>阿里云控制台配置：在阿里云的控制台中找到域名管理，然后选择顶级域名 evelance.cn 后面的“解析”字样。在新打开的页面中我们可以看到一个提供域名解析的界面，选择解析类型为 A 类解析，然后输入 mall（我们想要的二级域名的头），然后在地址里面输入我们刚才查看到的 ECS 的公网 ip，然后点击确认，之后我们的解析就会生效了。</p>
<p>ubuntu 服务器配置：</p>
<p>进入 /etc/apache2/site-available/ ，复制默认的虚拟主机配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp 000-default.conf mall.evelance.cn.conf</span><br></pre></td></tr></table></figure>

<p>修改配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> *<span class="attr">:80</span>&gt;</span></span><br><span class="line">    ServerAdmin xxx@qq.com</span><br><span class="line">    ServerName mall.evelance.com</span><br><span class="line">    DocumentRoot /home/www/mall</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Directory</span> &quot;/<span class="attr">home</span>/<span class="attr">www</span>/<span class="attr">mall</span>&quot;&gt;</span></span><br><span class="line">        Options FollowSymLinks</span><br><span class="line">        AllowOverride All</span><br><span class="line">        #Require all denied</span><br><span class="line">        Require all granted</span><br><span class="line">    <span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</span><br><span class="line">    CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 sites-enabled 目录下建立符号链接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/apache2/sites-enabled</span><br><span class="line"><span class="meta">#</span><span class="bash">建立对应的软链接</span></span><br><span class="line">sudo ln -s /etc/apache2/sites-available/mall.evelance.cn.conf /etc/apache2/sites-enabled/mall.evelance.cn.conf</span><br></pre></td></tr></table></figure>

<p>在对应目录放入项目代码：</p>
<p>把项目文件放进 /home/www/mall 中，并赋予文件夹权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod -R 777 /home/www/mall</span><br></pre></td></tr></table></figure>

<p>激活配置，重启 apache：</p>
<p>返回上级目录 <code>cd ../site-enable/</code>，输入 <code>cd sites-available/</code></p>
<p>输入 <code>a2ensite mall.evelance.cn.conf</code> ，如果提示已经激活过了，输入下面代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a2dissite mall.evelance.cn.conf</span><br><span class="line">service apache2 reload</span><br><span class="line">a2ensite mall.evelance.cn.conf</span><br><span class="line">service apache2 reload</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/carolcoral/article/details/77857264">ECS 简单配置多个二级域名</a></li>
</ul>
<h3 id="域名解析-1"><a href="#域名解析-1" class="headerlink" title="域名解析"></a>域名解析</h3><p>登录阿里云，进入控制台，选择云解析 DNS。选择右侧的解析管理，进行二级域名的添加：</p>
<ul>
<li>记录类型：A</li>
<li>主机记录：[mall].evelance.cn</li>
<li>解析线路：默认</li>
<li>记录值：你的公共 IP</li>
<li>TTL：10 分钟</li>
</ul>
<p>参考：<a href="https://blog.csdn.net/wangjia55/article/details/81127647">阿里云添加二级域名的操作</a></p>
<h3 id="支持-https"><a href="#支持-https" class="headerlink" title="支持 https"></a>支持 https</h3><ol>
<li><a href="https://www.cnblogs.com/lxf1117/p/6650647.html">在阿里云里申请免费 Https 证书 SSL</a></li>
<li><a href="https://yq.aliyun.com/articles/697838">ubuntu apache2 配置安装 ssl 证书</a></li>
<li><a href="https://www.cnblogs.com/wpl-php/p/10287125.html">阿里云 Ubuntu16.04 apache2 ssl 证书下载与安装（必须有域名）</a></li>
<li>完成上述配置后，别忘了让防火墙允许 443 端口。<code>sudo ufw allow 443/tcp</code></li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
</search>
